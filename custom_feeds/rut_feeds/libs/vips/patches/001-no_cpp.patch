diff -u --recursive --new-file vips-7.38.5-vanilla/configure.ac vips-7.38.5/configure.ac
--- vips-7.38.5-vanilla/configure.ac	2014-07-17 23:48:36.205794473 -0400
+++ vips-7.38.5/configure.ac	2014-07-17 23:49:32.773792981 -0400
@@ -184,7 +184,6 @@
 AC_PROG_AWK
 AC_PROG_CC
 AC_PROG_CC_STDC
-AC_PROG_CXX
 AC_C_CONST
 AC_C_RESTRICT
 AC_PROG_RANLIB
@@ -192,19 +191,6 @@
 AC_PROG_LN_S
 AM_WITH_DMALLOC
 
-# vips_PROG_CXX_WORKS
-# Check whether the C++ compiler works.
-AC_DEFUN([vips_PROG_CXX_WORKS],
-  [AC_REQUIRE([AC_PROG_CXX])dnl
-   AC_CACHE_CHECK([whether the C++ compiler works],
-   [vips_cv_prog_cxx_works],
-   [AC_LANG_PUSH([C++])
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
-                   [vips_cv_prog_cxx_works=yes],
-                   [vips_cv_prog_cxx_works=no])
-    AC_LANG_POP([C++])])
-])
-
 # option to build without C++
 # handy for some embedded applications
 # also, including C++ source causes link problems on some
@@ -212,22 +198,8 @@
 AC_ARG_ENABLE(cxx, 
   AS_HELP_STRING([--enable-cxx], [build C++ components (default: test)]))
 
-if test x"$enable_cxx" != x"no"; then
-  vips_PROG_CXX_WORKS
-  if test x"$vips_cv_prog_cxx_works" = x"yes"; then 
-    AC_DEFINE(ENABLE_CXX,1,[build C++ components])
-    AM_CONDITIONAL(ENABLE_CXX, true)
-    # need -lstdc++ for (eg.) the C++ format loaders
-    # this gets added to vips.pc to help mingw and friends link programs
-    # using libvips
-    VIPS_CXX_LIBS="-lstdc++"
-    enable_cxx=yes
-  fi
-fi
-
 if test x"$enable_cxx" != x"yes"; then
   AM_CONDITIONAL(ENABLE_CXX, false)
-  VIPS_CXX_LIBS=""
   enable_cxx=no
 fi
 
@@ -688,7 +660,6 @@
 AC_SUBST(VIPS_CFLAGS)
 AC_SUBST(VIPS_INCLUDES)
 AC_SUBST(VIPS_LIBS)
-AC_SUBST(VIPS_CXX_LIBS)
 AC_SUBST(PACKAGES_USED)
 
 AC_OUTPUT([
@@ -700,7 +671,6 @@
 	libvips/include/vips/Makefile 
 	libvips/Makefile 
 	libvips/arithmetic/Makefile 
-	libvips/cimg/Makefile 
 	libvips/colour/Makefile 
 	libvips/conversion/Makefile 
 	libvips/convolution/Makefile 
@@ -715,9 +685,6 @@
 	libvips/create/Makefile 
 	libvips/resample/Makefile 
 	libvips/video/Makefile 
-	libvipsCC/include/Makefile 
-	libvipsCC/include/vips/Makefile 
-	libvipsCC/Makefile 
 	tools/Makefile 
 	tools/batch_crop 
 	tools/batch_image_convert 
@@ -725,7 +692,6 @@
 	tools/light_correct 
 	tools/shrink_width 
 	swig/Makefile 
-	swig/vipsCC/Makefile 
 	swig/python/setup.py 
 	man/Makefile
 	doc/Makefile
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/cimg/cimg.cpp vips-7.38.5/libvips/cimg/cimg.cpp
--- vips-7.38.5-vanilla/libvips/cimg/cimg.cpp	2014-07-17 23:48:36.231794473 -0400
+++ vips-7.38.5/libvips/cimg/cimg.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,300 +0,0 @@
-/* Pass VIPS images through CImg
- *
- * JC, 15/10/07
- * 29/4/10
- * 	- oop, should be smalltile, probably
- * 	- tiny cleanups
- * 	- gtkdoc
- */
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <vips/vips.h>
-#include <vips/internal.h>
-
-/* CImg needs to call pthread directly, this is the preproc magic they
- * prefer.
- */
-#if defined(sun)         || defined(__sun)      || defined(linux)       || defined(__linux) \
- || defined(__linux__)   || defined(__CYGWIN__) || defined(BSD)         || defined(__FreeBSD__) \
- || defined(__OPENBSD__) || defined(__MACOSX__) || defined(__APPLE__)   || defined(sgi) \
- || defined(__sgi)
-  #include <pthread.h>
-#endif
-
-#include "CImg.h"
-using namespace cimg_library;
-
-/* Save params here.
- */
-struct Greyc {
-	IMAGE *in;
-	IMAGE *out;
-	IMAGE *mask;
-	IMAGE **arry;
-
-        int iterations;
-	float amplitude; 
-	float sharpness; 
-	float anisotropy;
-	float alpha; 
-	float sigma; 
-	float dl; 
-	float da; 
-	float gauss_prec; 
-	int interpolation; 
-	bool fast_approx;
-};
-
-// copy part of a vips region into a cimg
-template<typename T> static CImg<T> *
-vips_to_cimg( REGION *in, Rect *area )
-{
-	IMAGE *im = in->im;
-	CImg<T> *img = new CImg<T>( area->width, area->height, 1, im->Bands );
-
-	for( int y = 0; y < area->height; y++ ) {
-		T *p = (T *) IM_REGION_ADDR( in, area->left, area->top + y );
-
-		for( int x = 0; x < area->width; x++ ) {
-			for( int z = 0; z < im->Bands; z++ )
-				(*img)( x, y, z ) = p[z];
-
-			p += im->Bands;
-		}
-	}
-
-	return( img );
-}
-
-// write a CImg to a vips region
-// fill out->valid, img has pixels in img_rect
-template<typename T> static void 
-cimg_to_vips( CImg<T> *img, Rect *img_rect, REGION *out )
-{
-	IMAGE *im = out->im;
-	Rect *valid = &out->valid;
-
-	g_assert( im_rect_includesrect( img_rect, valid ) );
-	
-	int x_off = valid->left - img_rect->left;
-	int y_off = valid->top - img_rect->top;
-
-	for( int y = 0; y < valid->height; y++ ) {
-		T *p = (T *) IM_REGION_ADDR( out, valid->left, valid->top + y );
-
-		for( int x = 0; x < valid->width; x++ ) {
-			for( int z = 0; z < im->Bands; z++ )
-				p[z] = static_cast<T>( (*img)( 
-					x + x_off, y + y_off, z ) );
-
-			p += im->Bands;
-		}
-	}
-}
-
-template<typename T> static int
-greyc_gen( REGION *out, REGION **in, IMAGE **arry, Greyc *greyc )
-{
-	static const float gfact = (sizeof( T ) == 2) ? 1.0 / 256 : 1.0;
-	static const int tile_border = 4;
-
-	Rect *ir = &out->valid;
-	Rect need;
-	Rect image;
-
-	CImg<T> *img;
-	CImg<unsigned char> *msk;
-
-	need = *ir;
-	im_rect_marginadjust( &need, tile_border );
-	image.left = 0;
-	image.top = 0;
-	image.width = in[0]->im->Xsize;
-	image.height = in[0]->im->Ysize;
-	im_rect_intersectrect( &need, &image, &need );
-	if( im_prepare( in[0], &need ) )
-		return( -1 );
-	if( in[1] && im_prepare( in[1], &need ) )
-		return( -1 );
-
-	img = NULL;
-	msk = NULL;
-
-	try {
-		img = vips_to_cimg<T>( in[0], &need );
-		if( in[1] )
-			msk = vips_to_cimg<unsigned char>( in[1], &need );
-		else
-			// empty mask
-			msk = new CImg<unsigned char>();
-
-		for( int i = 0; i < greyc->iterations; i++ ) 
-			img->blur_anisotropic( *msk,
-				greyc->amplitude, greyc->sharpness, 
-				greyc->anisotropy,
-				greyc->alpha, greyc->sigma, greyc->dl, 
-				greyc->da, greyc->gauss_prec, 
-				greyc->interpolation, greyc->fast_approx, 
-				gfact );
-
-		cimg_to_vips<T>( img, &need, out );
-	}
-	catch( CImgException e ) { 
-		if( img )
-			delete( img );
-		if( msk )
-			delete( msk );
-
-		im_error( "GREYCstoration", "%s", e.message );
-
-		return( -1 );
-	}
-
-	if( img )
-		delete( img );
-	if( msk )
-		delete( msk );
-
-	return( 0 );
-}
-
-// Hmm, strange double-cast needed
-typedef int (*generate_fn)( REGION *out, REGION **in, 
-	IMAGE **im, Greyc *greyc );
-
-// as a plain C function
-/**
- * im_greyc_mask:
- * @in: input image 
- * @out: output image
- * @mask: input mask 
- * @iterations: number of iterations to perform (eg. 1)
- * @amplitude: scaling factor (eg. 40)
- * @sharpness: degree of sharpening to apply (eg. 0.9)
- * @anisotropy: how much to blur along lines (eg. 0.15)
- * @alpha: blur by this much before calculating geometry (eg. 0.6)
- * @sigma: blur geometry by this much (eg. 1.1)
- * @dl: spatial integration step (eg. 0.8)
- * @da: angular integration step (eg. 30)
- * @gauss_prec: precision (eg. 2)
- * @interpolation: interpolation (eg. 0 for nearest-neighbour)
- *
- * This operation calls the blur_anisotropic() method of the CImag image
- * processing library. It is handy for denoising images and for upscaling.
- *
- * See also: im_conv().
- *
- * Returns: 0 on success, -1 on error
- */
-int
-im_greyc_mask( IMAGE *in, IMAGE *out, IMAGE *mask,
-        int iterations,
-	float amplitude, float sharpness, float anisotropy,
-	float alpha, float sigma, 
-	float dl, float da, float gauss_prec, 
-	int interpolation, int fast_approx )
-{
-	IMAGE **arry;
-	Greyc *greyc;
-
-	if( im_piocheck( in, out ) ||
-		im_check_uncoded( "im_greyc_mask", in ) ||
-		im_check_u8or16orf( "im_greyc_mask", in ) )
-		return( -1 );
-	if( mask ) {
-		if( im_pincheck( mask ) ||
-			im_check_uncoded( "im_greyc_mask", mask ) ||
-			im_check_size_same( "im_greyc_mask", in, mask ) ||
-			im_check_format( "im_greyc_mask", 
-				mask, IM_BANDFMT_UCHAR ) )
-			return( -1 );
-	}
-	if( im_cp_desc( out, in ) ||
-		!(arry = im_allocate_input_array( out, in, mask, NULL )) ||
-		!(greyc = IM_NEW( out, Greyc )) ||
-		im_demand_hint( out, IM_SMALLTILE, in, NULL ) )
-		return( -1 );
-
-	greyc->in = in;
-	greyc->out = out;
-	greyc->mask = mask;
-	greyc->arry = arry;
-	greyc->iterations = iterations;
-	greyc->amplitude = amplitude;
-	greyc->sharpness = sharpness;
-	greyc->anisotropy = anisotropy;
-	greyc->alpha = alpha;
-	greyc->sigma = sigma;
-	greyc->dl = dl;
-	greyc->da = da;
-	greyc->gauss_prec = gauss_prec;
-	greyc->interpolation = interpolation;
-	greyc->fast_approx = fast_approx;
-
-	switch( in->BandFmt ) {
-	case IM_BANDFMT_UCHAR:
-	        if( im_generate( out, 
-			im_start_many, 
-			// double-cast to give g++ enough context to expand the
-			// template correctly
-			(im_generate_fn) (
-				(generate_fn) greyc_gen<unsigned char>),
-			im_stop_many, arry, greyc ) )
-			return( -1 );
-		break;
-
-	case IM_BANDFMT_USHORT:
-	        if( im_generate( out, 
-			im_start_many, 
-			(im_generate_fn) (
-				(generate_fn) greyc_gen<unsigned short>),
-			im_stop_many, arry, greyc ) )
-			return( -1 );
-		break;
-
-	case IM_BANDFMT_FLOAT:
-	        if( im_generate( out, 
-			im_start_many, 
-			(im_generate_fn) (
-				(generate_fn) greyc_gen<float>),
-			im_stop_many, arry, greyc ) )
-			return( -1 );
-		break;
-
-	default:
-		g_assert( 0 );
-	}
-
-	return( 0 );
-}
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/cimg/cimg_dispatch.c vips-7.38.5/libvips/cimg/cimg_dispatch.c
--- vips-7.38.5-vanilla/libvips/cimg/cimg_dispatch.c	2014-07-17 23:48:36.230794473 -0400
+++ vips-7.38.5/libvips/cimg/cimg_dispatch.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,171 +0,0 @@
-/* Function dispatch tables for cimg wrappers.
- */
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <stdio.h>
-
-#include <vips/vips.h>
-
-/** 
- * SECTION: cimg_funcs
- * @short_description: expose operations from the CImg library, mostly noise
- * removal
- * @stability: Stable
- * @include: vips/vips.h
- *
- * The GREYCstoration filter.
- */
-
-static int
-greyc_vec( im_object *argv )
-{
-        IMAGE *src = (IMAGE *) argv[0];
-        IMAGE *dst = (IMAGE *) argv[1];
-
-        int iterations = *((int *) argv[2]); 
-	double amplitude = *((double *) argv[3]);   
-	double sharpness = *((double *) argv[4]); 
-	double anisotropy = *((double *) argv[5]); 
-	double alpha = *((double *) argv[6]); 
-	double sigma = *((double *) argv[7]);
-	double dl = *((double *) argv[8]); 
-	double da = *((double *) argv[9]); 
-	double gauss_prec = *((double *) argv[10]); 
-	int interpolation = *((int *) argv[11]); 
-	int fast_approx = *((int *) argv[12]); 
-
-        if( im_greyc_mask( src, dst, NULL,
-		iterations,
-		amplitude, sharpness, anisotropy,
-		alpha, sigma, 
-		dl, da, gauss_prec, 
-		interpolation, fast_approx ) )
-		return( -1 );
-
-        return( 0 );
-}
-
-static im_arg_desc greyc_arg_types[] = {
-        IM_INPUT_IMAGE( "src" ),
-        IM_OUTPUT_IMAGE( "dst" ),
-        IM_INPUT_INT( "iterations" ),
-	IM_INPUT_DOUBLE( "amplitude" ),
-	IM_INPUT_DOUBLE( "sharpness" ),
-	IM_INPUT_DOUBLE( "anisotropy" ),
-	IM_INPUT_DOUBLE( "alpha" ),
-	IM_INPUT_DOUBLE( "sigma" ),
-	IM_INPUT_DOUBLE( "dl" ),
-	IM_INPUT_DOUBLE( "da" ),
-	IM_INPUT_DOUBLE( "gauss_prec" ),
-	IM_INPUT_INT( "interpolation" ),
-	IM_INPUT_INT( "fast_approx" )
-};
-
-static im_function greyc_desc = {
-        "im_greyc", 			/* Name */
-        "noise-removing filter",      	/* Description */
-        (im_fn_flags) (IM_FN_TRANSFORM | IM_FN_PIO),/* Flags */
-        greyc_vec,           		/* Dispatch function */
-        IM_NUMBER( greyc_arg_types ),	/* Size of arg list */
-        greyc_arg_types       		/* Arg list */
-};
-
-static int
-greyc_mask_vec( im_object *argv )
-{
-        IMAGE *src = (IMAGE *) argv[0];
-        IMAGE *dst = (IMAGE *) argv[1];
-        IMAGE *mask = (IMAGE *) argv[2];
-
-        int iterations = *((int *) argv[3]); 
-	double amplitude = *((double *) argv[4]);   
-	double sharpness = *((double *) argv[5]); 
-	double anisotropy = *((double *) argv[6]); 
-	double alpha = *((double *) argv[7]); 
-	double sigma = *((double *) argv[8]);
-	double dl = *((double *) argv[9]); 
-	double da = *((double *) argv[10]); 
-	double gauss_prec = *((double *) argv[11]); 
-	int interpolation = *((int *) argv[12]); 
-	int fast_approx = *((int *) argv[13]); 
-
-        if( im_greyc_mask( src, dst, mask,
-		iterations,
-		amplitude, sharpness, anisotropy,
-		alpha, sigma, 
-		dl, da, gauss_prec, 
-		interpolation, fast_approx ) )
-		return( -1 );
-
-        return( 0 );
-}
-
-static im_arg_desc greyc_mask_arg_types[] = {
-        IM_INPUT_IMAGE( "src" ),
-        IM_OUTPUT_IMAGE( "dst" ),
-        IM_INPUT_IMAGE( "mask" ),
-        IM_INPUT_INT( "iterations" ),
-	IM_INPUT_DOUBLE( "amplitude" ),
-	IM_INPUT_DOUBLE( "sharpness" ),
-	IM_INPUT_DOUBLE( "anisotropy" ),
-	IM_INPUT_DOUBLE( "alpha" ),
-	IM_INPUT_DOUBLE( "sigma" ),
-	IM_INPUT_DOUBLE( "dl" ),
-	IM_INPUT_DOUBLE( "da" ),
-	IM_INPUT_DOUBLE( "gauss_prec" ),
-	IM_INPUT_INT( "interpolation" ),
-	IM_INPUT_INT( "fast_approx" )
-};
-
-static im_function greyc_mask_desc = {
-        "im_greyc_mask",     		/* Name */
-        "noise-removing filter, with a mask", /* Description */
-        (im_fn_flags) (IM_FN_TRANSFORM | IM_FN_PIO),/* Flags */
-        greyc_mask_vec,           	/* Dispatch function */
-        IM_NUMBER( greyc_mask_arg_types ),/* Size of arg list */
-        greyc_mask_arg_types       	/* Arg list */
-};
-
-static im_function *function_list[] = {
-	&greyc_desc,
-	&greyc_mask_desc
-};
-
-/* Package of functions.
- */
-im_package im__cimg = {
-	"cimg",
-	IM_NUMBER( function_list ),
-	function_list
-};
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/cimg/CImg.h vips-7.38.5/libvips/cimg/CImg.h
--- vips-7.38.5-vanilla/libvips/cimg/CImg.h	2014-07-17 23:48:36.230794473 -0400
+++ vips-7.38.5/libvips/cimg/CImg.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,22228 +0,0 @@
-/*
- #
- #  File        : CImg.h
- #
- #  Description : The C++ Template Image Processing Library
- #                ( http://cimg.sourceforge.net )
- #
- #  Copyright   : David Tschumperle
- #                ( http://www.greyc.ensicaen.fr/~dtschump/ )
- #
- #  License     : CeCILL-C
- #
- #  This software is governed by the CeCILL-C license under French law and
- #  abiding by the rules of distribution of free software.  You can  use,
- #  modify and or redistribute the software under the terms of the CeCILL-C
- #  license as circulated by CEA, CNRS and INRIA at the following URL
- #  "http://www.cecill.info".
- #
- #  As a counterpart to the access to the source code and  rights to copy,
- #  modify and redistribute granted by the license, users are provided only
- #  with a limited warranty  and the software's author,  the holder of the
- #  economic rights,  and the successive licensors  have only  limited
- #  liability.
- #
- #  In this respect, the user's attention is drawn to the risks associated
- #  with loading,  using,  modifying and/or developing or reproducing the
- #  software by the user in light of its specific status of free software,
- #  that may mean  that it is complicated to manipulate,  and  that  also
- #  therefore means  that it is reserved for developers  and  experienced
- #  professionals having in-depth computer knowledge. Users are therefore
- #  encouraged to load and test the software's suitability as regards their
- #  requirements in conditions enabling the security of their systems and/or
- #  data to be ensured and,  more generally, to use and operate it in the
- #  same conditions as regards security.
- #
- #  The fact that you are presently reading this means that you have had
- #  knowledge of the CeCILL-C license and that you accept its terms.
- #
- */
-#ifndef cimg_version
-#define cimg_version 1.20
-
-// Detect Microsoft VC++ 6.0 compiler to get some workarounds afterwards.
-#if defined(_MSC_VER) && _MSC_VER<1300
-#define cimg_use_visualcpp6
-#endif
-
-// Avoid strange 'deprecated' warning messages with Visual C++ .NET.
-#if defined(_MSC_VER) && _MSC_VER>=1300
-#define _CRT_SECURE_NO_DEPRECATE 1
-#define _CRT_NONSTDC_NO_DEPRECATE 1
-#endif
-
-// Standard C++ includes.
-#include <cstdio>
-#include <cstdlib>
-#include <cstdarg>
-#include <cstring>
-#include <cmath>
-#include <ctime>
-
-// Overcome VisualC++ 6.0 compilers namespace 'std::' bug.
-#ifdef cimg_use_visualcpp6
-#define std
-#endif
-
-/*
- #
- # Set CImg configuration flags.
- #
- # If compilation flags are not adapted to your system,
- # you may override their values, before including
- # the header file "CImg.h" (use the #define directive).
- #
- */
-
-// Try to detect the current system and set value of 'cimg_OS'.
-#ifndef cimg_OS
-#if defined(sun)         || defined(__sun)      || defined(linux)       || defined(__linux) \
- || defined(__linux__)   || defined(__CYGWIN__) || defined(BSD)         || defined(__FreeBSD__) \
- || defined(__OPENBSD__) || defined(__MACOSX__) || defined(__APPLE__)   || defined(sgi) \
- || defined(__sgi)
-// Unix-like (Linux, Solaris, BSD, MacOSX, Irix,...).
-#define cimg_OS            1
-#ifndef cimg_display_type
-#define cimg_display_type  1
-#endif
-#ifndef cimg_color_terminal
-#define cimg_color_terminal
-#endif
-#elif defined(_WIN32) || defined(__WIN32__)
-// Windows.
-#define cimg_OS            2
-#ifndef cimg_display_type
-#define cimg_display_type  2
-#endif
-#else
-// Unknown configuration : ask for minimal dependencies (no display).
-#define cimg_OS            0
-#ifndef cimg_display_type
-#define cimg_display_type  0
-#endif
-#endif
-#endif
-
-// Debug configuration.
-//
-// Set 'cimg_debug' to : 0 to remove debug messages (exceptions are still thrown anyway).
-//                       1 to display debug messages on standard error output (console).
-//                       2 to display debug messages with modal windows (default behavior).
-//                       3 to do as 2 + add extra memory access warnings (may slow down the code)
-#ifndef cimg_debug
-#define cimg_debug         2
-#endif
-
-// Allow compatibility with older CImg versions.
-//
-// Define 'cimg_strict' to avoid keeping the compatibility with older code
-#ifndef cimg_strict
-#define CImgl CImgList
-#define cimgl_map cimglist_for
-#define cimglist_map cimglist_for
-#define cimg_map cimg_for
-#define cimg_mapoff cimg_foroff
-#define cimg_mapX cimg_forX
-#define cimg_mapY cimg_forY
-#define cimg_mapZ cimg_forZ
-#define cimg_mapV cimg_forV
-#define cimg_mapXY cimg_forXY
-#define cimg_mapXZ cimg_forXZ
-#define cimg_mapXV cimg_forXV
-#define cimg_mapYZ cimg_forYZ
-#define cimg_mapYV cimg_forYV
-#define cimg_mapZV cimg_forZV
-#define cimg_mapXYZ cimg_forXYZ
-#define cimg_mapXYV cimg_forXYV
-#define cimg_mapXZV cimg_forXZV
-#define cimg_mapYZV cimg_forYZV
-#define cimg_mapXYZV cimg_forXYZV
-#define cimg_imapX cimg_for_insideX
-#define cimg_imapY cimg_for_insideY
-#define cimg_imapZ cimg_for_insideZ
-#define cimg_imapV cimg_for_insideV
-#define cimg_imapXY cimg_for_insideXY
-#define cimg_imapXYZ cimg_for_insideXYZ
-#define cimg_bmapX cimg_for_borderX
-#define cimg_bmapY cimg_for_borderY
-#define cimg_bmapZ cimg_for_borderZ
-#define cimg_bmapV cimg_for_borderV
-#define cimg_bmapXY cimg_for_borderXY
-#define cimg_bmapXYZ cimg_for_borderXYZ
-#define cimg_2mapX cimg_for2X
-#define cimg_2mapY cimg_for2Y
-#define cimg_2mapZ cimg_for2Z
-#define cimg_2mapXY cimg_for2XY
-#define cimg_2mapXZ cimg_for2XZ
-#define cimg_2mapYZ cimg_for2YZ
-#define cimg_2mapXYZ cimg_for2XYZ
-#define cimg_3mapX cimg_for3X
-#define cimg_3mapY cimg_for3Y
-#define cimg_3mapZ cimg_for3Z
-#define cimg_3mapXY cimg_for3XY
-#define cimg_3mapXZ cimg_for3XZ
-#define cimg_3mapYZ cimg_for3YZ
-#define cimg_3mapXYZ cimg_for3XYZ
-#define cimg_4mapX cimg_for4X
-#define cimg_4mapY cimg_for4Y
-#define cimg_4mapZ cimg_for4Z
-#define cimg_4mapXY cimg_for4XY
-#define cimg_4mapXZ cimg_for4XZ
-#define cimg_4mapYZ cimg_for4YZ
-#define cimg_4mapXYZ cimg_for4XYZ
-#define cimg_5mapX cimg_for5X
-#define cimg_5mapY cimg_for5Y
-#define cimg_5mapZ cimg_for5Z
-#define cimg_5mapXY cimg_for5XY
-#define cimg_5mapXZ cimg_for5XZ
-#define cimg_5mapYZ cimg_for5YZ
-#define cimg_5mapXYZ cimg_for5XYZ
-#define cimg_map2x2x1 cimg_for2x2
-#define cimg_map3x3x1 cimg_for3x3
-#define cimg_map4x4x1 cimg_for4x4
-#define cimg_map5x5x1 cimg_for5x5
-#define cimg_map2x2 cimg_for2x2
-#define cimg_map3x3 cimg_for3x3
-#define cimg_map4x4 cimg_for4x4
-#define cimg_map5x5 cimg_for5x5
-#define cimg_map3x3x3 cimg_for3x3x3
-#define cimg_map2x2x2 cimg_for2x2x2
-#define CImg_2x2x1 CImg_2x2
-#define CImg_3x3x1 CImg_3x3
-#define CImg_4x4x1 CImg_4x4
-#define CImg_5x5x1 CImg_5x5
-#define scroll translate
-#define cimg_convert_path cimg_imagemagick_path
-#define load_convert load_imagemagick
-#define save_convert save_imagemagick
-#endif
-
-// Architecture-dependent includes.
-#if cimg_OS==1
-#include <sys/time.h>
-#include <unistd.h>
-#elif cimg_OS==2
-#include <windows.h>
-// Discard unuseful macros in windows.h
-// to allow compilation with VC++ 6.0.
-#ifdef min
-#undef min
-#undef max
-#undef abs
-#endif
-#endif
-// Display-dependent includes.
-#if cimg_display_type==1
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-#include <X11/keysym.h>
-#include <pthread.h>
-#ifdef cimg_use_xshm
-#include <sys/ipc.h>
-#include <sys/shm.h>
-#include <X11/extensions/XShm.h>
-#endif
-#ifdef cimg_use_xrandr
-#include <X11/extensions/Xrandr.h>
-#endif
-#endif
-
-// Configuration for native PNG and JPEG support
-//
-// Define 'cimg_use_png', 'cimg_use_jpeg' or 'cimg_use_tiff' to enable native PNG, JPEG or TIFF files support.
-// This requires you link your code with the zlib/png, jpeg or tiff libraries.
-// Without these libraries, PNG,JPEG and TIFF support will be done by the Image Magick's 'convert' tool,
-// or byt the GraphicsMagick 'gm' tool if installed
-// (this is the case on most unix plateforms).
-#ifdef cimg_use_png
-extern "C" {
-#include "png.h"
-}
-#endif
-#ifdef cimg_use_jpeg
-extern "C" {
-#include "jpeglib.h"
-}
-#endif
-#ifdef cimg_use_tiff
-extern "C" {
-#include "tiffio.h"
-}
-#endif
-#ifdef cimg_use_magick
-#include "Magick++.h"
-#endif
-#ifdef cimg_use_fftw3
-extern "C" {
-#include "fftw3.h"
-}
-#endif
-
-/*
- #
- #
- # Define some useful macros. Macros of the CImg Library are prefixed by 'cimg_'
- # Documented macros below may be safely used in your own code
- # (particularly useful for option parsing, image loops and neighborhoods).
- #
- #
- */
-
-// Macros used to describe the program usage, and retrieve command line arguments
-// (See corresponding module 'Retrieving command line arguments' in the generated documentation).
-#define cimg_usage(usage) cimg_library::cimg::option((char*)0,argc,argv,(char*)0,usage)
-#define cimg_help(str)    cimg_library::cimg::option((char*)0,argc,argv,str,(char*)0)
-#define cimg_option(name,defaut,usage) cimg_library::cimg::option(name,argc,argv,defaut,usage)
-
-// Macros used for neighborhood definitions and manipulations.
-// (see module 'Using Image Loops' in the generated documentation).
-#define CImg_2(I,T)   T   I##cc,I##nc=0
-#define CImg_2x2(I,T) T   I##cc,I##nc=0,I##cn,I##nn=0
-#define CImg_3(I,T)   T   I##pp,I##cp,I##np=0
-#define CImg_3x3(I,T) T   I##pp,I##cp,I##np=0,I##pc,I##cc,I##nc=0,I##pn,I##cn,I##nn=0
-#define CImg_4(I,T)   T   I##pp,I##cp,I##np=0,I##ap=0
-#define CImg_4x4(I,T) T   I##pp,I##cp,I##np=0,I##ap=0, \
-                          I##pc,I##cc,I##nc=0,I##ac=0, \
-                          I##pn,I##cn,I##nn=0,I##an=0, \
-                          I##pa,I##ca,I##na=0,I##aa=0
-#define CImg_5(I,T)   T   I##bb,I##pb,I##cb,I##nb=0,I##ab=0
-#define CImg_5x5(I,T) T   I##bb,I##pb,I##cb,I##nb=0,I##ab=0, \
-                          I##bp,I##pp,I##cp,I##np=0,I##ap=0, \
-                          I##bc,I##pc,I##cc,I##nc=0,I##ac=0, \
-                          I##bn,I##pn,I##cn,I##nn=0,I##an=0, \
-                          I##ba,I##pa,I##ca,I##na=0,I##aa=0
-#define CImg_2x2x2(I,T) T I##ccc,I##ncc=0,I##cnc,I##nnc=0, \
-                          I##ccn,I##ncn=0,I##cnn,I##nnn=0
-#define CImg_3x3x3(I,T) T I##ppp,I##cpp,I##npp=0,I##pcp,I##ccp,I##ncp=0,I##pnp,I##cnp,I##nnp=0, \
-                          I##ppc,I##cpc,I##npc=0,I##pcc,I##ccc,I##ncc=0,I##pnc,I##cnc,I##nnc=0, \
-                          I##ppn,I##cpn,I##npn=0,I##pcn,I##ccn,I##ncn=0,I##pnn,I##cnn,I##nnn=0
-
-#define CImg_2x2_ref(I,T,tab)   T &I##cc=(tab)[0],&I##nc=(tab)[1],&I##cn=(tab)[2],&I##nn=(tab)[3]
-#define CImg_3x3_ref(I,T,tab)   T &I##pp=(tab)[0],&I##cp=(tab)[1],&I##np=(tab)[2], \
-                                  &I##pc=(tab)[3],&I##cc=(tab)[4],&I##nc=(tab)[5], \
-                                  &I##pn=(tab)[6],&I##cn=(tab)[7],&I##nn=(tab)[8]
-#define CImg_4x4_ref(I,T,tab)   T &I##pp=(tab)[0],&I##cp=(tab)[1],&I##np=(tab)[2],&I##ap=(tab)[3], \
-                                  &I##pc=(tab)[4],&I##cc=(tab)[5],&I##nc=(tab)[6],&I##ap=(tab)[7], \
-                                  &I##pn=(tab)[8],&I##cn=(tab)[9],&I##nn=(tab)[10],&I##aa=(tab)[11], \
-                                  &I##pa=(tab)[12],&I##ca=(tab)[13],&I##na=(tab)[14],&I##aa=(tab)[15]
-#define CImg_5x5_ref(I,T,tab)   T &I##bb=(tab)[0],&I##pb=(tab)[1],&I##cb=(tab)[2],&I##nb=(tab)[3],&I##ab=(tab)[4], \
-                                  &I##bp=(tab)[5],&I##pp=(tab)[6],&I##cp=(tab)[7],&I##np=(tab)[8],&I##ap=(tab)[9], \
-                                  &I##bc=(tab)[10],&I##pc=(tab)[11],&I##cc=(tab)[12],&I##nc=(tab)[13],&I##ac=(tab)[14], \
-                                  &I##bn=(tab)[15],&I##pn=(tab)[16],&I##cn=(tab)[17],&I##nn=(tab)[18],&I##an=(tab)[19], \
-                                  &I##ba=(tab)[20],&I##pa=(tab)[21],&I##ca=(tab)[22],&I##na=(tab)[23],&I##aa=(tab)[24]
-#define CImg_2x2x2_ref(I,T,tab) T &I##ccc=(tab)[0],&I##ncc=(tab)[1],&I##cnc=(tab)[2],&I##nnc=(tab)[3], \
-                                  &I##ccn=(tab)[4],&I##ncn=(tab)[5],&I##cnn=(tab)[6],&I##nnn=(tab)[7]
-#define CImg_3x3x3_ref(I,T,tab) T &I##ppp=(tab)[0],&I##cpp=(tab)[1],&I##npp=(tab)[2], \
-                                  &I##pcp=(tab)[3],&I##ccp=(tab)[4],&I##ncp=(tab)[5], \
-                                  &I##pnp=(tab)[6],&I##cnp=(tab)[7],&I##nnp=(tab)[8], \
-                                  &I##ppc=(tab)[9],&I##cpc=(tab)[10],&I##npc=(tab)[11], \
-                                  &I##pcc=(tab)[12],&I##ccc=(tab)[13],&I##ncc=(tab)[14], \
-                                  &I##pnc=(tab)[15],&I##cnc=(tab)[16],&I##nnc=(tab)[17], \
-                                  &I##ppn=(tab)[18],&I##cpn=(tab)[19],&I##npn=(tab)[20], \
-                                  &I##pcn=(tab)[21],&I##ccn=(tab)[22],&I##ncn=(tab)[23], \
-                                  &I##pnn=(tab)[24],&I##cnn=(tab)[25],&I##nnn=(tab)[26]
-
-#define cimg_copy2x2(J,I)   I##cc=J##cc, I##nc=J##nc, I##cn=J##cn, I##nn=J##nn
-#define cimg_copy3x3(J,I)   I##pp=J##pp, I##cp=J##cp, I##np=J##np, \
-                            I##pc=J##pc, I##cc=J##cc, I##nc=J##nc, \
-                            I##pn=J##pn, I##cn=J##cn, I##nn=J##nn
-#define cimg_copy5x5(J,I)   I##bb=J##bb, I##pb=J##pb, I##cb=J##cb, I##nb=J##nb, I##ab=J##ab, \
-                            I##bp=J##bp, I##pp=J##pp, I##cp=J##cp, I##np=J##np, I##ap=J##ap, \
-                            I##bc=J##bc, I##pc=J##pc, I##cc=J##cc, I##nc=J##nc, I##ac=J##ac, \
-                            I##bn=J##bn, I##pn=J##pn, I##cn=J##cn, I##nn=J##nn, I##an=J##an, \
-                            I##ba=J##ba, I##pa=J##pa, I##ca=J##ca, I##na=J##na, I##aa=J##aa
-
-#define cimg_squaresum2x2(I)   ( I##cc*I##cc + I##nc*I##nc + I##cn*I##cn + I##nn*I##nn )
-#define cimg_squaresum3x3(I)   ( I##pp*I##pp + I##cp*I##cp + I##np*I##np + \
-                                 I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + \
-                                 I##pn*I##pn + I##cn*I##cn + I##nn*I##nn )
-#define cimg_squaresum4x4(I)   ( I##pp*I##pp + I##cp*I##cp + I##np*I##np + I##ap*I##ap + \
-                                 I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + I##ac*I##ac + \
-                                 I##pn*I##pn + I##cn*I##cn + I##nn*I##nn + I##an*I##an + \
-                                 I##pa*I##pa + I##ca*I##ca + I##na*I##na + I##aa*I##aa )
-#define cimg_squaresum5x5(I)   ( I##bb*I##bb + I##pb*I##pb + I##cb*I##cb + I##nb*I##nb + I##ab*I##ab + \
-                                 I##bp*I##bp + I##pp*I##pp + I##cp*I##cp + I##np*I##np + I##ap*I##ap + \
-                                 I##bc*I##bc + I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + I##ac*I##ac + \
-                                 I##bn*I##bn + I##pn*I##pn + I##cn*I##cn + I##nn*I##nn + I##an*I##an + \
-                                 I##ba*I##ba + I##pa*I##pa + I##ca*I##ca + I##na*I##na + I##aa*I##aa )
-#define cimg_squaresum2x2x2(I) ( I##ccc*I##ccc + I##ncc*I##ncc + I##cnc*I##cnc + I##nnc*I##nnc + \
-                                 I##ccn*I##ccn + I##ncn*I##ncn + I##cnn*I##cnn + I##nnn*I##nnn )
-#define cimg_squaresum3x3x3(I) ( I##ppp*I##ppp + I##cpp*I##cpp + I##npp*I##npp + \
-                                 I##pcp*I##pcp + I##ccp*I##ccp + I##ncp*I##ncp + \
-                                 I##pnp*I##pnp + I##cnp*I##cnp + I##nnp*I##nnp + \
-                                 I##ppc*I##ppc + I##cpc*I##cpc + I##npc*I##npc + \
-                                 I##pcc*I##pcc + I##ccc*I##ccc + I##ncc*I##ncc + \
-                                 I##pnc*I##pnc + I##cnc*I##cnc + I##nnc*I##nnc + \
-                                 I##ppn*I##ppn + I##cpn*I##cpn + I##npn*I##npn + \
-                                 I##pcn*I##pcn + I##ccn*I##ccn + I##ncn*I##ncn + \
-                                 I##pnn*I##pnn + I##cnn*I##cnn + I##nnn*I##nnn )
-
-#define cimg_corr2x2(I,m)   ( I##cc*(m)(0,0)+I##nc*(m)(1,0)+I##cn*(m)(0,1)+I##nn*(m)(1,1) )
-#define cimg_corr3x3(I,m)   ( I##pp*(m)(0,0)+I##cp*(m)(1,0)+I##np*(m)(2,0) + \
-                              I##pc*(m)(0,1)+I##cc*(m)(1,1)+I##nc*(m)(2,1) + \
-                              I##pn*(m)(0,2)+I##cn*(m)(1,2)+I##nn*(m)(2,2) )
-#define cimg_corr4x4(I,m)   ( I##pp*(m)(0,0)+I##cp*(m)(1,0)+I##np*(m)(2,0)+I##ap*(m)(3,0) + \
-                              I##pc*(m)(0,1)+I##cc*(m)(1,1)+I##nc*(m)(2,1)+I##ac*(m)(3,1) + \
-                              I##pn*(m)(0,2)+I##cn*(m)(1,2)+I##nn*(m)(2,2)+I##an*(m)(3,2) + \
-                              I##pa*(m)(0,3)+I##ca*(m)(1,3)+I##na*(m)(2,3)+I##aa*(m)(3,3) )
-#define cimg_corr5x5(I,m)   ( I##bb*(m)(0,0)+I##pb*(m)(1,0)+I##cb*(m)(2,0)+I##nb*(m)(3,0)+I##ab*(m)(4,0) + \
-                              I##bp*(m)(0,1)+I##pp*(m)(1,1)+I##cp*(m)(2,1)+I##np*(m)(3,1)+I##ap*(m)(4,1) + \
-                              I##bc*(m)(0,2)+I##pc*(m)(1,2)+I##cc*(m)(2,2)+I##nc*(m)(3,2)+I##ac*(m)(4,2) + \
-                              I##bn*(m)(0,3)+I##pn*(m)(1,3)+I##cn*(m)(2,3)+I##nn*(m)(3,3)+I##an*(m)(4,3) + \
-                              I##ba*(m)(0,4)+I##pa*(m)(1,4)+I##ca*(m)(2,4)+I##na*(m)(3,4)+I##aa*(m)(4,4) )
-#define cimg_corr2x2x2(I,m) ( I##ccc*(m)(0,0,0)+I##ncc*(m)(1,0,0)+I##cnc*(m)(0,1,0)+I##nnc*(m)(1,1,0) + \
-                              I##ccn*(m)(0,0,1)+I##ncn*(m)(1,0,1)+I##cnn*(m)(0,1,1)+I##nnn*(m)(1,1,1) )
-#define cimg_corr3x3x3(I,m) ( I##ppp*(m)(0,0,0)+I##cpp*(m)(1,0,0)+I##npp*(m)(2,0,0) + \
-                              I##pcp*(m)(0,1,0)+I##ccp*(m)(1,1,0)+I##ncp*(m)(2,1,0) + \
-                              I##pnp*(m)(0,2,0)+I##cnp*(m)(1,2,0)+I##nnp*(m)(2,2,0) + \
-                              I##ppc*(m)(0,0,1)+I##cpc*(m)(1,0,1)+I##npc*(m)(2,0,1) + \
-                              I##pcc*(m)(0,1,1)+I##ccc*(m)(1,1,1)+I##ncc*(m)(2,1,1) + \
-                              I##pnc*(m)(0,2,1)+I##cnc*(m)(1,2,1)+I##nnc*(m)(2,2,1) + \
-                              I##ppn*(m)(0,0,2)+I##cpn*(m)(1,0,2)+I##npn*(m)(2,0,2) + \
-                              I##pcn*(m)(0,1,2)+I##ccn*(m)(1,1,2)+I##ncn*(m)(2,1,2) + \
-                              I##pnn*(m)(0,2,2)+I##cnn*(m)(1,2,2)+I##nnn*(m)(2,2,2) )
-
-#define cimg_conv2x2(I,m)   ( I##cc*(m)(1,1)+I##nc*(m)(0,1)+I##cn*(m)(1,0)+I##nn*(m)(0,0) )
-#define cimg_conv3x3(I,m)   ( I##pp*(m)(2,2)+I##cp*(m)(1,2)+I##np*(m)(0,2) + \
-                              I##pc*(m)(2,1)+I##cc*(m)(1,1)+I##nc*(m)(0,1) + \
-                              I##pn*(m)(2,0)+I##cn*(m)(1,0)+I##nn*(m)(0,0) )
-#define cimg_conv4x4(I,m)   ( I##pp*(m)(3,3)+I##cp*(m)(2,3)+I##np*(m)(1,3)+I##ap*(m)(0,3) + \
-                              I##pc*(m)(3,2)+I##cc*(m)(2,2)+I##nc*(m)(1,2)+I##ac*(m)(0,2) + \
-                              I##pn*(m)(3,1)+I##cn*(m)(2,1)+I##nn*(m)(1,1)+I##an*(m)(0,1) + \
-                              I##pa*(m)(3,0)+I##ca*(m)(2,0)+I##na*(m)(1,0)+I##aa*(m)(0,0) )
-#define cimg_conv5x5(I,m)   ( I##bb*(m)(4,4)+I##pb*(m)(3,4)+I##cb*(m)(2,4)+I##nb*(m)(1,4)+I##ab*(m)(0,4) + \
-                              I##bp*(m)(4,3)+I##pp*(m)(3,3)+I##cp*(m)(2,3)+I##np*(m)(1,3)+I##ap*(m)(0,3) + \
-                              I##bc*(m)(4,2)+I##pc*(m)(3,2)+I##cc*(m)(2,2)+I##nc*(m)(1,2)+I##ac*(m)(0,2) + \
-                              I##bn*(m)(4,1)+I##pn*(m)(3,1)+I##cn*(m)(2,1)+I##nn*(m)(1,1)+I##an*(m)(0,1) + \
-                              I##ba*(m)(4,0)+I##pa*(m)(3,0)+I##ca*(m)(2,0)+I##na*(m)(1,0)+I##aa*(m)(0,0) )
-#define cimg_conv2x2x2(I,m) ( I##ccc*(m)(1,1,1)+I##ncc*(m)(0,1,1)+I##cnc*(m)(1,0,1)+I##nnc*(m)(0,0,1) + \
-                              I##ccn*(m)(1,1,0)+I##ncn*(m)(0,1,0)+I##cnn*(m)(1,0,0)+I##nnn*(m)(0,0,0) )
-#define cimg_conv3x3x3(I,m) ( I##ppp*(m)(2,2,2)+I##cpp*(m)(1,2,2)+I##npp*(m)(0,2,2) + \
-                              I##pcp*(m)(2,1,2)+I##ccp*(m)(1,1,2)+I##ncp*(m)(0,1,2) + \
-                              I##pnp*(m)(2,0,2)+I##cnp*(m)(1,0,2)+I##nnp*(m)(0,0,2) + \
-                              I##ppc*(m)(2,2,1)+I##cpc*(m)(1,2,1)+I##npc*(m)(0,2,1) + \
-                              I##pcc*(m)(2,1,1)+I##ccc*(m)(1,1,1)+I##ncc*(m)(0,1,1) + \
-                              I##pnc*(m)(2,0,1)+I##cnc*(m)(1,0,1)+I##nnc*(m)(0,0,1) + \
-                              I##ppn*(m)(2,2,0)+I##cpn*(m)(1,2,0)+I##npn*(m)(0,2,0) + \
-                              I##pcn*(m)(2,1,0)+I##ccn*(m)(1,1,0)+I##ncn*(m)(0,1,0) + \
-                              I##pnn*(m)(2,0,0)+I##cnn*(m)(1,0,0)+I##nnn*(m)(0,0,0) )
-
-#define cimg_get2x2(img,x,y,z,v,I) \
-   I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), \
-   I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v)
-#define cimg_get3x3(img,x,y,z,v,I) \
-  I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), \
-  I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), \
-  I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v)
-#define cimg_get4x4(img,x,y,z,v,I) \
-  I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), I##ap=(img)(_a##x,_p##y,z,v), \
-  I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), I##ac=(img)(_a##x,    y,z,v), \
-  I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v), I##an=(img)(_a##x,_n##y,z,v), \
-  I##pa=(img)(_p##x,_a##y,z,v), I##ca=(img)(x,_a##y,z,v), I##na=(img)(_n##x,_a##y,z,v), I##aa=(img)(_a##x,_a##y,z,v)
-#define cimg_get5x5(img,x,y,z,v,I) \
-  I##bb=(img)(_b##x,_b##y,z,v), I##pb=(img)(_p##x,_b##y,z,v), I##cb=(img)(x,_b##y,z,v), I##nb=(img)(_n##x,_b##y,z,v), I##ab=(img)(_a##x,_b##y,z,v), \
-  I##bp=(img)(_b##x,_p##y,z,v), I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), I##ap=(img)(_a##x,_p##y,z,v), \
-  I##bc=(img)(_b##x,    y,z,v), I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), I##ac=(img)(_a##x,    y,z,v), \
-  I##bn=(img)(_b##x,_n##y,z,v), I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v), I##an=(img)(_a##x,_n##y,z,v), \
-  I##ba=(img)(_b##x,_a##y,z,v), I##pa=(img)(_p##x,_a##y,z,v), I##ca=(img)(x,_a##y,z,v), I##na=(img)(_n##x,_a##y,z,v), I##aa=(img)(_a##x,_a##y,z,v)
-#define cimg_get2x2x2(img,x,y,z,v,I) \
-  I##ccc=(img)(x,y,    z,v), I##ncc=(img)(_n##x,y,    z,v), I##cnc=(img)(x,_n##y,    z,v), I##nnc=(img)(_n##x,_n##y,    z,v), \
-  I##ccc=(img)(x,y,_n##z,v), I##ncc=(img)(_n##x,y,_n##z,v), I##cnc=(img)(x,_n##y,_n##z,v), I##nnc=(img)(_n##x,_n##y,_n##z,v)
-#define cimg_get3x3x3(img,x,y,z,v,I) \
-  I##ppp=(img)(_p##x,_p##y,_p##z,v), I##cpp=(img)(x,_p##y,_p##z,v), I##npp=(img)(_n##x,_p##y,_p##z,v), \
-  I##pcp=(img)(_p##x,    y,_p##z,v), I##ccp=(img)(x,    y,_p##z,v), I##ncp=(img)(_n##x,    y,_p##z,v), \
-  I##pnp=(img)(_p##x,_n##y,_p##z,v), I##cnp=(img)(x,_n##y,_p##z,v), I##nnp=(img)(_n##x,_n##y,_p##z,v), \
-  I##ppc=(img)(_p##x,_p##y,    z,v), I##cpc=(img)(x,_p##y,    z,v), I##npc=(img)(_n##x,_p##y,    z,v), \
-  I##pcc=(img)(_p##x,    y,    z,v), I##ccc=(img)(x,    y,    z,v), I##ncc=(img)(_n##x,    y,    z,v), \
-  I##pnc=(img)(_p##x,_n##y,    z,v), I##cnc=(img)(x,_n##y,    z,v), I##nnc=(img)(_n##x,_n##y,    z,v), \
-  I##ppn=(img)(_p##x,_p##y,_n##z,v), I##cpn=(img)(x,_p##y,_n##z,v), I##npn=(img)(_n##x,_p##y,_n##z,v), \
-  I##pcn=(img)(_p##x,    y,_n##z,v), I##ccn=(img)(x,    y,_n##z,v), I##ncn=(img)(_n##x,    y,_n##z,v), \
-  I##pnn=(img)(_p##x,_n##y,_n##z,v), I##cnn=(img)(x,_n##y,_n##z,v), I##nnn=(img)(_n##x,_n##y,_n##z,v)
-
-// Macros used to define special image loops.
-// (see module 'Using Image Loops' in the generated documentation).
-#define cimg_for(img,ptr,T_ptr)   for (T_ptr *ptr=(img).data+(img).size(); (ptr--)>(img).data; )
-#define cimglist_for(list,l)      for (unsigned int l=0; l<(list).size; l++)
-#define cimglist_apply(list,fn)   cimglist_for(list,__##fn) (list)[__##fn].fn
-#define cimg_foroff(img,off)      for (unsigned int off=0; off<(img).size(); off++)
-#define cimg_forX(img,x)          for (int x=0; x<(int)((img).width); x++)
-#define cimg_forY(img,y)          for (int y=0; y<(int)((img).height);y++)
-#define cimg_forZ(img,z)          for (int z=0; z<(int)((img).depth); z++)
-#define cimg_forV(img,v)          for (int v=0; v<(int)((img).dim);   v++)
-#define cimg_forXY(img,x,y)       cimg_forY(img,y) cimg_forX(img,x)
-#define cimg_forXZ(img,x,z)       cimg_forZ(img,z) cimg_forX(img,x)
-#define cimg_forYZ(img,y,z)       cimg_forZ(img,z) cimg_forY(img,y)
-#define cimg_forXV(img,x,v)       cimg_forV(img,v) cimg_forX(img,x)
-#define cimg_forYV(img,y,v)       cimg_forV(img,v) cimg_forY(img,y)
-#define cimg_forZV(img,z,v)       cimg_forV(img,v) cimg_forZ(img,z)
-#define cimg_forXYZ(img,x,y,z)    cimg_forZ(img,z) cimg_forXY(img,x,y)
-#define cimg_forXYV(img,x,y,v)    cimg_forV(img,v) cimg_forXY(img,x,y)
-#define cimg_forXZV(img,x,z,v)    cimg_forV(img,v) cimg_forXZ(img,x,z)
-#define cimg_forYZV(img,y,z,v)    cimg_forV(img,v) cimg_forYZ(img,y,z)
-#define cimg_forXYZV(img,x,y,z,v) cimg_forV(img,v) cimg_forXYZ(img,x,y,z)
-#define cimg_for_insideX(img,x,n)       for (int x=(n); x<(int)((img).width-(n)); x++)
-#define cimg_for_insideY(img,y,n)       for (int y=(n); y<(int)((img).height-(n)); y++)
-#define cimg_for_insideZ(img,z,n)       for (int z=(n); z<(int)((img).depth-(n)); z++)
-#define cimg_for_insideV(img,v,n)       for (int v=(n); v<(int)((img).dim-(n)); v++)
-#define cimg_for_insideXY(img,x,y,n)    cimg_for_insideY(img,y,n) cimg_for_insideX(img,x,n)
-#define cimg_for_insideXYZ(img,x,y,z,n) cimg_for_insideZ(img,z,n) cimg_for_insideXY(img,x,y,n)
-#define cimg_for_borderX(img,x,n)       for (int x=0; x<(int)((img).width);  x==(n)-1?(x=(img).width-(n)): x++)
-#define cimg_for_borderY(img,y,n)       for (int y=0; y<(int)((img).height); y==(n)-1?(x=(img).height-(n)):y++)
-#define cimg_for_borderZ(img,z,n)       for (int z=0; z<(int)((img).depth);  z==(n)-1?(x=(img).depth-(n)): z++)
-#define cimg_for_borderV(img,v,n)       for (int v=0; v<(int)((img).dim);    v==(n)-1?(x=(img).dim-(n)):   v++)
-#define cimg_for_borderXY(img,x,y,n)    cimg_forY(img,y) for (int x=0; x<(int)((img).width); (y<(n) || y>=(int)((img).height)-(n))?x++: \
-                                                          ((x<(n)-1 || x>=(int)((img).width)-(n))?x++:(x=(img).width-(n))))
-#define cimg_for_borderXYZ(img,x,y,z,n) cimg_forYZ(img,y,z) for (int x=0; x<(int)((img).width); (y<(n) || y>=(int)((img).height)-(n) || z<(n) || z>=(int)((img).depth)-(n))?x++: \
-                                                             ((x<(n)-1 || x>=(int)((img).width)-(n))?x++:(x=(img).width-(n))))
-#define cimg_for2X(img,x)         for (int x=0,_n##x=1; _n##x<(int)((img).width)   || x==--_n##x; x++, _n##x++)
-#define cimg_for2Y(img,y)         for (int y=0,_n##y=1; _n##y<(int)((img).height)  || y==--_n##y; y++, _n##y++)
-#define cimg_for2Z(img,z)         for (int z=0,_n##z=1; _n##z<(int)((img).depth)   || z==--_n##z; z++, _n##z++)
-#define cimg_for2XY(img,x,y)      cimg_for2Y(img,y) cimg_for2X(img,x)
-#define cimg_for2XZ(img,x,z)      cimg_for2Z(img,z) cimg_for2X(img,x)
-#define cimg_for2YZ(img,y,z)      cimg_for2Z(img,z) cimg_for2Y(img,y)
-#define cimg_for2XYZ(img,x,y,z)   cimg_for2Z(img,z) cimg_for2XY(img,x,y)
-#define cimg_for3X(img,x)         for (int x=0,_p##x=0,_n##x=1; _n##x<(int)((img).width)  || x==--_n##x;  _p##x=x++,_n##x++)
-#define cimg_for3Y(img,y)         for (int y=0,_p##y=0,_n##y=1; _n##y<(int)((img).height) || y==--_n##y;  _p##y=y++,_n##y++)
-#define cimg_for3Z(img,z)         for (int z=0,_p##z=0,_n##z=1; _n##z<(int)((img).depth)  || z==--_n##z;  _p##z=z++,_n##z++)
-#define cimg_for3XY(img,x,y)      cimg_for3Y(img,y) cimg_for3X(img,x)
-#define cimg_for3XZ(img,x,z)      cimg_for3Z(img,z) cimg_for3X(img,x)
-#define cimg_for3YZ(img,y,z)      cimg_for3Z(img,z) cimg_for3Y(img,y)
-#define cimg_for3XYZ(img,x,y,z)   cimg_for3Z(img,z) cimg_for3XY(img,x,y)
-#define cimg_for4X(img,x)         for (int _p##x=0,x=0,_n##x=1,_a##x=2; \
-                                       _a##x<(int)((img).width)  || _n##x==--_a##x || x==(_a##x=--_n##x); \
-                                       _p##x=x++,_n##x++,_a##x++)
-#define cimg_for4Y(img,y)         for (int _p##y=0,y=0,_n##y=1,_a##y=2; \
-                                       _a##y<(int)((img).height) || _n##y==--_a##y || y==(_a##y=--_n##y); \
-                                       _p##y=y++,_n##y++,_a##y++)
-#define cimg_for4Z(img,z)         for (int _p##z=0,z=0,_n##z=1,_a##z=2; \
-                                       _a##z<(int)((img).depth)  || _n##z==--_a##z || z==(_a##z=--_n##z); \
-                                       _p##z=z++,_n##z++,_a##z++)
-#define cimg_for4XY(img,x,y)      cimg_for4Y(img,y) cimg_for4X(img,x)
-#define cimg_for4XZ(img,x,z)      cimg_for4Z(img,z) cimg_for4X(img,x)
-#define cimg_for4YZ(img,y,z)      cimg_for4Z(img,z) cimg_for4Y(img,y)
-#define cimg_for4XYZ(img,x,y,z)   cimg_for4Z(img,z) cimg_for4XY(img,x,y)
-#define cimg_for5X(img,x)         for (int _b##x=0,_p##x=0,x=0,_n##x=1,_a##x=2; \
-                                       _a##x<(int)((img).width)  || _n##x==--_a##x || x==(_a##x=--_n##x); \
-                                       _b##x=_p##x,_p##x=x++,_n##x++,_a##x++)
-#define cimg_for5Y(img,y)         for (int _b##y=0,_p##y=0,y=0,_n##y=1,_a##y=2; \
-                                       _a##y<(int)((img).height) || _n##y==--_a##y || y==(_a##y=--_n##y); \
-                                       _b##y=_p##y,_p##y=y++,_n##y++,_a##y++)
-#define cimg_for5Z(img,z)         for (int _b##z=0,_p##z=0,z=0,_n##z=1,_a##z=2; \
-                                       _a##z<(int)((img).depth)  || _n##z==--_a##z || z==(_a##z=--_n##z); \
-                                       _b##z=_p##z,_p##z=z++,_n##z++,_a##z++)
-#define cimg_for5XY(img,x,y)      cimg_for5Y(img,y) cimg_for5X(img,x)
-#define cimg_for5XZ(img,x,z)      cimg_for5Z(img,z) cimg_for5X(img,x)
-#define cimg_for5YZ(img,y,z)      cimg_for5Z(img,z) cimg_for5Y(img,y)
-#define cimg_for5XYZ(img,x,y,z)   cimg_for5Z(img,z) cimg_for5XY(img,x,y)
-
-#define cimg_for2x2(img,x,y,z,v,I) cimg_for2Y(img,y) \
-       for (int _n##x=1, x=(int)((I##cc=(img)(0,    y,z,v)), \
-                                 (I##cn=(img)(0,_n##y,z,v)), \
-                                 0); \
-            (_n##x<(int)((img).width) && ((I##nc=(img)(_n##x,    y,z,v)), \
-                                          (I##nn=(img)(_n##x,_n##y,z,v)), \
-                                          1)) || x==--_n##x; \
-            I##cc=I##nc, I##cn=I##nn, \
-            x++,_n##x++ )
-
-#define cimg_for3x3(img,x,y,z,v,I) cimg_for3Y(img,y) \
-       for (int _n##x=1, _p##x=(int)((I##cp=I##pp=(img)(0,_p##y,z,v)), \
-                                     (I##cc=I##pc=(img)(0,  y,z,v)), \
-                                     (I##cn=I##pn=(img)(0,_n##y,z,v))), \
-                                     x=_p##x=0; \
-            (_n##x<(int)((img).width) && ((I##np=(img)(_n##x,_p##y,z,v)), \
-                                          (I##nc=(img)(_n##x,    y,z,v)), \
-                                          (I##nn=(img)(_n##x,_n##y,z,v)), \
-                                          1)) || x==--_n##x; \
-              I##pp=I##cp, I##pc=I##cc, I##pn=I##cn, \
-              I##cp=I##np, I##cc=I##nc, I##cn=I##nn, \
-              _p##x=x++,_n##x++ )
-
-
-#define cimg_for4x4(img,x,y,z,v,I) cimg_for4Y(img,y) \
-       for (int _a##x=2, _n##x=1, x=(int)((I##cp=I##pp=(img)(0,_p##y,z,v)), \
-                                          (I##cc=I##pc=(img)(0,    y,z,v)), \
-                                          (I##cn=I##pn=(img)(0,_n##y,z,v)), \
-                                          (I##ca=I##pa=(img)(0,_a##y,z,v)), \
-                                          (I##np=(img)(_n##x,_p##y,z,v)), \
-                                          (I##nc=(img)(_n##x,    y,z,v)), \
-                                          (I##nn=(img)(_n##x,_n##y,z,v)), \
-                                          (I##na=(img)(_n##x,_a##y,z,v)), \
-                                          0), _p##x=0; \
-            (_a##x<(int)((img).width) && ((I##ap=(img)(_a##x,_p##y,z,v)), \
-                                          (I##ac=(img)(_a##x,    y,z,v)), \
-                                          (I##an=(img)(_a##x,_n##y,z,v)), \
-                                          (I##aa=(img)(_a##x,_a##y,z,v)), \
-                                          1)) || _n##x==--_a##x || x==(_a##x=--_n##x); \
-              I##pp=I##cp, I##pc=I##cc, I##pn=I##cn, I##pa=I##ca, \
-              I##cp=I##np, I##cc=I##nc, I##cn=I##nn, I##ca=I##na, \
-              I##np=I##ap, I##nc=I##ac, I##nn=I##an, I##na=I##aa, \
-              _p##x=x++, _n##x++, _a##x++ )
-
-#define cimg_for5x5(img,x,y,z,v,I) cimg_for5Y(img,y) \
-       for (int _a##x=2, _n##x=1, _b##x=(int)((I##cb=I##pb=I##bb=(img)(0,_b##y,z,v)), \
-                                              (I##cp=I##pp=I##bp=(img)(0,_p##y,z,v)), \
-                                              (I##cc=I##pc=I##bc=(img)(0,    y,z,v)), \
-                                              (I##cn=I##pn=I##bn=(img)(0,_n##y,z,v)), \
-                                              (I##ca=I##pa=I##ba=(img)(0,_a##y,z,v)), \
-                                              (I##nb=(img)(_n##x,_b##y,z,v)), \
-                                              (I##np=(img)(_n##x,_p##y,z,v)), \
-                                              (I##nc=(img)(_n##x,   y,z,v)), \
-                                              (I##nn=(img)(_n##x,_n##y,z,v)), \
-                                              (I##na=(img)(_n##x,_a##y,z,v))), \
-                                              x=0, _p##x=_b##x=0; \
-            (_a##x<(int)((img).width) && ((I##ab=(img)(_a##x,_b##y,z,v)), \
-                                          (I##ap=(img)(_a##x,_p##y,z,v)), \
-                                          (I##ac=(img)(_a##x,    y,z,v)), \
-                                          (I##an=(img)(_a##x,_n##y,z,v)), \
-                                          (I##aa=(img)(_a##x,_a##y,z,v)), \
-                                          1)) || _n##x==--_a##x || x==(_a##x=--_n##x); \
-              I##bb=I##pb, I##bp=I##pp, I##bc=I##pc, I##bn=I##pn, I##ba=I##pa, \
-              I##pb=I##cb, I##pp=I##cp, I##pc=I##cc, I##pn=I##cn, I##pa=I##ca, \
-              I##cb=I##nb, I##cp=I##np, I##cc=I##nc, I##cn=I##nn, I##ca=I##na, \
-              I##nb=I##ab, I##np=I##ap, I##nc=I##ac, I##nn=I##an, I##na=I##aa, \
-              _b##x=_p##x, _p##x=x++, _n##x++, _a##x++ )
-
-#define cimg_for2x2x2(img,x,y,z,v,I) cimg_for2YZ(img,y,z) \
-       for (int _n##x=1, x=(int)((I##ccc=(img)(0,    y,    z,v)), \
-                                 (I##cnc=(img)(0,_n##y,    z,v)), \
-                                 (I##ccn=(img)(0,    y,_n##z,v)), \
-                                 (I##cnn=(img)(0,_n##y,_n##z,v)), \
-                                 0); \
-            (_n##x<(int)((img).width) && ((I##ncc=(img)(_n##x,    y,    z,v)), \
-                                          (I##nnc=(img)(_n##x,_n##y,    z,v)), \
-                                          (I##ncn=(img)(_n##x,    y,_n##z,v)), \
-                                          (I##nnn=(img)(_n##x,_n##y,_n##z,v)), \
-                                          1)) || x==--_n##x; \
-              I##ccc=I##ncc, I##cnc=I##nnc, \
-              I##ccn=I##ncn, I##cnn=I##nnn, \
-              x++, _n##x++ )
-
-#define cimg_for3x3x3(img,x,y,z,v,I) cimg_for3YZ(img,y,z) \
-       for (int _n##x=1, _p##x=(int)((I##cpp=I##ppp=(img)(0,_p##y,_p##z,v)), \
-                                     (I##ccp=I##pcp=(img)(0,    y,_p##z,v)), \
-                                     (I##cnp=I##pnp=(img)(0,_n##y,_p##z,v)), \
-                                     (I##cpc=I##ppc=(img)(0,_p##y,    z,v)), \
-                                     (I##ccc=I##pcc=(img)(0,    y,    z,v)), \
-                                     (I##cnc=I##pnc=(img)(0,_n##y,    z,v)), \
-                                     (I##cpn=I##ppn=(img)(0,_p##y,_n##z,v)), \
-                                     (I##ccn=I##pcn=(img)(0,    y,_n##z,v)), \
-                                     (I##cnn=I##pnn=(img)(0,_n##y,_n##z,v))),\
-                                     x=_p##x=0; \
-            (_n##x<(int)((img).width) && ((I##npp=(img)(_n##x,_p##y,_p##z,v)), \
-                                          (I##ncp=(img)(_n##x,    y,_p##z,v)), \
-                                          (I##nnp=(img)(_n##x,_n##y,_p##z,v)), \
-                                          (I##npc=(img)(_n##x,_p##y,    z,v)), \
-                                          (I##ncc=(img)(_n##x,    y,    z,v)), \
-                                          (I##nnc=(img)(_n##x,_n##y,    z,v)), \
-                                          (I##npn=(img)(_n##x,_p##y,_n##z,v)), \
-                                          (I##ncn=(img)(_n##x,    y,_n##z,v)), \
-                                          (I##nnn=(img)(_n##x,_n##y,_n##z,v)), \
-                                          1)) || x==--_n##x; \
-              I##ppp=I##cpp, I##pcp=I##ccp, I##pnp=I##cnp, \
-              I##cpp=I##npp, I##ccp=I##ncp, I##cnp=I##nnp, \
-              I##ppc=I##cpc, I##pcc=I##ccc, I##pnc=I##cnc, \
-              I##cpc=I##npc, I##ccc=I##ncc, I##cnc=I##nnc, \
-              I##ppn=I##cpn, I##pcn=I##ccn, I##pnn=I##cnn, \
-              I##cpn=I##npn, I##ccn=I##ncn, I##cnn=I##nnn, \
-              _p##x=x++, _n##x++ )
-
-/*
- #------------------------------------------------
- #
- #
- #  Definition of the cimg_library:: namespace
- #
- #
- #------------------------------------------------
- */
-
-//! Namespace that encompasses all classes and functions of the %CImg library.
-/**
-   This namespace is defined to avoid class names collisions that could happen
-   with the include of other C++ header files. Anyway, it should not happen
-   very often and you may start most of your programs with
-   \code
-   #include "CImg.h"
-   using namespace cimg_library;
-   \endcode
-   to simplify the declaration of %CImg Library objects variables afterwards.
-**/
-
-namespace cimg_library {
-
-  // Define the CImg classes.
-  template<typename T=float> struct CImg;
-  template<typename T=float> struct CImgList;
-  struct CImgStats;
-  struct CImgDisplay;
-  struct CImgException;
-
-  namespace cimg {
-
-    // The bodies of the functions below are defined afterwards
-    inline void info();
-
-    inline unsigned int& exception_mode();
-
-    inline int dialog(const char *title,const char *msg,const char *button1_txt="OK",
-                      const char *button2_txt=0,const char *button3_txt=0,
-                      const char *button4_txt=0,const char *button5_txt=0,
-                      const char *button6_txt=0,const bool centering = false);
-
-    template<typename tfunc, typename tp, typename tf>
-    inline void marching_cubes(const tfunc& func, const float isovalue,
-                               const float x0,const float y0,const float z0,
-                               const float x1,const float y1,const float z1,
-                               const float resx,const float resy,const float resz,
-                               CImgList<tp>& points, CImgList<tf>& primitives,
-                               const bool invert_faces = false);
-
-    template<typename tfunc, typename tp, typename tf>
-    inline void marching_squares(const tfunc& func, const float isovalue,
-                                 const float x0,const float y0,
-                                 const float x1,const float y1,
-                                 const float resx,const float resy,
-                                 CImgList<tp>& points, CImgList<tf>& primitives);
-  }
-
-  /*
-   #----------------------------------------------
-   #
-   #
-   # Definition of the CImgException structures
-   #
-   #
-   #----------------------------------------------
-   */
-
-  // Never use the following macro in your own code !
-#define cimg_exception_err(etype,disp_flag) \
-  if (cimg::exception_mode()>=1) { \
-    std::va_list ap; \
-    va_start(ap,format); \
-    std::vsprintf(message,format,ap); \
-    va_end(ap); \
-    if (cimg::exception_mode()>=2 && disp_flag) { \
-      try { cimg::dialog(etype,message,"Abort"); } \
-      catch (CImgException&) { std::fprintf(stderr,"\n# %s :\n%s\n\n",etype,message); } \
-    } else std::fprintf(stderr,"\n# %s :\n%s\n\n",etype,message); \
-  } \
-  if (cimg::exception_mode()>=3) cimg_library::cimg::info(); \
-
-  //! Class which is thrown when an error occured during a %CImg library function call.
-  /**
-
-      \section ex1 Overview
-
-      CImgException is the base class of %CImg exceptions.
-      Exceptions are thrown by the %CImg Library when an error occured in a %CImg library function call.
-      CImgException is seldom thrown itself. Children classes that specify the kind of error encountered
-      are generally used instead. These sub-classes are :
-
-      - \b CImgInstanceException : Thrown when the instance associated to the called %CImg function is not
-      correctly defined. Generally, this exception is thrown when one tries to process \a empty images. The example
-      below will throw a \a CImgInstanceException.
-      \code
-      CImg<float> img;        // Construct an empty image.
-      img.blur(10);           // Try to blur the image.
-      \endcode
-
-      - \b CImgArgumentException : Thrown when one of the arguments given to the called %CImg function is not correct.
-      Generally, this exception is thrown when arguments passed to the function are outside an admissible range of values.
-      The example below will throw a \a CImgArgumentException.
-      \code
-      CImg<float> img(100,100,1,3);   // Define a 100x100 color image with float pixels.
-      img = 0;                     // Try to fill pixels from the 0 pointer (invalid argument to operator=() ).
-      \endcode
-
-      - \b CImgIOException : Thrown when an error occured when trying to load or save image files.
-      The example below will throw a \a CImgIOException.
-      \code
-      CImg<float> img("file_doesnt_exist.jpg");    // Try to load a file that doesn't exist.
-      \endcode
-
-      - \b CImgDisplayException : Thrown when an error occured when trying to display an image in a window.
-      This exception is thrown when image display request cannot be satisfied.
-
-      The parent class CImgException may be thrown itself when errors that cannot be classified in one of
-      the above type occur. It is recommended not to throw CImgExceptions yourself, since there are normally
-      reserved to %CImg Library functions.
-      \b CImgInstanceException, \b CImgArgumentException, \b CImgIOException and \b CImgDisplayException are simple
-      subclasses of CImgException and are thus not detailled more in this reference documentation.
-
-      \section ex2 Exception handling
-
-      When an error occurs, the %CImg Library first displays the error in a modal window.
-      Then, it throws an instance of the corresponding exception class, generally leading the program to stop
-      (this is the default behavior).
-      You can bypass this default behavior by handling the exceptions yourself,
-      using a code block <tt>try { ... } catch() { ... }</tt>.
-      In this case, you can avoid the apparition of the modal window, by
-      defining the environment variable <tt>cimg_debug</tt> to 0 before including the %CImg header file.
-      The example below shows how to cleanly handle %CImg Library exceptions :
-      \code
-      #define cimg_debug 0     // Disable modal window in CImg exceptions.
-      #define "CImg.h"
-      int main() {
-        try {
-          ...; // Here, do what you want.
-        }
-        catch (CImgInstanceException &e) {
-          std::fprintf(stderr,"CImg Library Error : %s",e.message);  // Display your own error message
-          ...                                                        // Do what you want now.
-        }
-      }
-      \endcode
-  **/
-  struct CImgException {
-    char message[1024]; //!< Message associated with the error that thrown the exception.
-    CImgException() { message[0]='\0'; }
-    CImgException(const char *format,...) { cimg_exception_err("CImgException",true); }
-  };
-
-  // The \ref CImgInstanceException class is used to throw an exception related
-  // to a non suitable instance encountered in a library function call.
-  struct CImgInstanceException : CImgException {
-    CImgInstanceException(const char *format,...) { cimg_exception_err("CImgInstanceException",true); }
-  };
-
-  // The \ref CImgArgumentException class is used to throw an exception related
-  // to invalid arguments encountered in a library function call.
-  struct CImgArgumentException : CImgException {
-    CImgArgumentException(const char *format,...) { cimg_exception_err("CImgArgumentException",true); }
-  };
-
-  // The \ref CImgIOException class is used to throw an exception related
-  // to Input/Output file problems encountered in a library function call.
-  struct CImgIOException : CImgException {
-    CImgIOException(const char *format,...) { cimg_exception_err("CImgIOException",true); }
-  };
-
-  // The CImgDisplayException class is used to throw an exception related to display problems
-  // encountered in a library function call.
-  struct CImgDisplayException : CImgException {
-    CImgDisplayException(const char *format,...) { cimg_exception_err("CImgDisplayException",false); }
-  };
-
-  /*
-   #-------------------------------------
-   #
-   #
-   # Definition of the namespace 'cimg'
-   #
-   #
-   #-------------------------------------
-   */
-
-  //! Namespace that encompasses \a low-level functions and variables of the %CImg Library.
-  /**
-     Most of the functions and variables within this namespace are used by the library for low-level processing.
-     Nevertheless, documented variables and functions of this namespace may be used safely in your own source code.
-
-     \warning Never write <tt>using namespace cimg_library::cimg;</tt> in your source code, since a lot of functions of the
-     <tt>cimg::</tt> namespace have prototypes similar to standard C functions defined in the global namespace <tt>::</tt>.
-  **/
-  namespace cimg {
-
-    // Define the trait that will be used to determine the best data type to work with.
-    // Considered types are : bool, uchar, char, short, ushort, int, uint, long, ulong, float and double.
-    // Two rules applies there :
-    // - largest of two integer types is an integer type.
-    // - largest of integer/float type is a float type.
-    template<typename T,typename t> struct largest          { typedef t type; };
-    template<> struct largest<unsigned char,bool>           { typedef unsigned char type; };
-    template<> struct largest<unsigned char,char>           { typedef short type; };
-    template<> struct largest<char,bool>                    { typedef char type; };
-    template<> struct largest<char,unsigned char>           { typedef short type; };
-    template<> struct largest<char,unsigned short>          { typedef int type; };
-    template<> struct largest<char,unsigned int>            { typedef unsigned int type; };
-    template<> struct largest<char,unsigned long>           { typedef unsigned long type; };
-    template<> struct largest<unsigned short,bool>          { typedef unsigned short type; };
-    template<> struct largest<unsigned short,unsigned char> { typedef unsigned short type; };
-    template<> struct largest<unsigned short,char>          { typedef int type; };
-    template<> struct largest<unsigned short,short>         { typedef int type; };
-    template<> struct largest<short,bool>                   { typedef short type; };
-    template<> struct largest<short,unsigned char>          { typedef short type; };
-    template<> struct largest<short,char>                   { typedef short type; };
-    template<> struct largest<short,unsigned short>         { typedef int type; };
-    template<> struct largest<short,unsigned int>           { typedef unsigned int type; };
-    template<> struct largest<short,unsigned long>          { typedef unsigned long type; };
-    template<> struct largest<unsigned int,bool>            { typedef unsigned int type; };
-    template<> struct largest<unsigned int,unsigned char>   { typedef unsigned int type; };
-    template<> struct largest<unsigned int,char>            { typedef unsigned int type; };
-    template<> struct largest<unsigned int,unsigned short>  { typedef unsigned int type; };
-    template<> struct largest<unsigned int,short>           { typedef unsigned int type; };
-    template<> struct largest<unsigned int,int>             { typedef unsigned int type; };
-    template<> struct largest<int,bool>                     { typedef int type; };
-    template<> struct largest<int,unsigned char>            { typedef int type; };
-    template<> struct largest<int,char>                     { typedef int type; };
-    template<> struct largest<int,unsigned short>           { typedef int type; };
-    template<> struct largest<int,short>                    { typedef int type; };
-    template<> struct largest<int,unsigned int>             { typedef unsigned int type; };
-    template<> struct largest<int,unsigned long>            { typedef unsigned long type; };
-    template<> struct largest<float,bool>                   { typedef float type; };
-    template<> struct largest<float,unsigned char>          { typedef float type; };
-    template<> struct largest<float,char>                   { typedef float type; };
-    template<> struct largest<float,unsigned short>         { typedef float type; };
-    template<> struct largest<float,short>                  { typedef float type; };
-    template<> struct largest<float,unsigned int>           { typedef float type; };
-    template<> struct largest<float,int>                    { typedef float type; };
-    template<> struct largest<float,unsigned long>          { typedef float type; };
-    template<> struct largest<float,long>                   { typedef float type; };
-    template<> struct largest<double,bool>                  { typedef double type; };
-    template<> struct largest<double,unsigned char>         { typedef double type; };
-    template<> struct largest<double,char>                  { typedef double type; };
-    template<> struct largest<double,unsigned short>        { typedef double type; };
-    template<> struct largest<double,short>                 { typedef double type; };
-    template<> struct largest<double,unsigned int>          { typedef double type; };
-    template<> struct largest<double,int>                   { typedef double type; };
-    template<> struct largest<double,unsigned long>         { typedef double type; };
-    template<> struct largest<double,long>                  { typedef double type; };
-    template<> struct largest<double,float>                 { typedef double type; };
-
-    template<typename T> struct type {
-      static T min()  { return (T)-1>0?(T)0:(T)-1<<(8*sizeof(T)-1); }
-      static T max()  { return (T)-1>0?(T)-1:~((T)-1<<(8*sizeof(T)-1)); }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "unknown"; return s; }
-    };
-    template<> struct type<bool> {
-      static bool min() { return false; }
-      static bool max() { return true; }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "bool"; return s; }
-    };
-    template<> struct type<unsigned char> {
-      static unsigned char min() { return 0; }
-      static unsigned char max() { return (unsigned char)~0U; }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "unsigned char"; return s; }
-    };
-    template<> struct type<char> {
-      static char min() { return (char)-1<<(8*sizeof(char)-1); }
-      static char max() { return ~((char)-1<<(8*sizeof(char)-1)); }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "char"; return s; }
-    };
-    template<> struct type<unsigned short> {
-      static unsigned short min() { return 0; }
-      static unsigned short max() { return (unsigned short)~0U; }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "unsigned short"; return s; }
-    };
-    template<> struct type<short> {
-      static short min() { return (short)-1<<(8*sizeof(short)-1); }
-      static short max() { return ~((short)-1<<(8*sizeof(short)-1)); }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "short"; return s; }
-    };
-    template<> struct type<unsigned int> {
-      static unsigned int min() { return 0; }
-      static unsigned int max() { return (unsigned int)~0U; }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "unsigned int"; return s; }
-    };
-    template<> struct type<int> {
-      static int min() { return (int)-1<<(8*sizeof(int)-1); }
-      static int max() { return ~((int)-1<<(8*sizeof(int)-1)); }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "int"; return s; }
-    };
-    template<> struct type<unsigned long> {
-      static unsigned long min() { return 0; }
-      static unsigned long max() { return (unsigned long)~0UL; }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "unsigned long"; return s; }
-    };
-    template<> struct type<long> {
-      static long min() { return (long)-1<<(8*sizeof(long)-1); }
-      static long max() { return ~((long)-1<<(8*sizeof(long)-1)); }
-      static bool is_float() { return false; }
-      static const char* id() { static const char *const s = "long"; return s; }
-    };
-    template<> struct type<float> {
-      static float min() { return -3.4E38f; }
-      static float max() { return  3.4E38f; }
-      static bool is_float() { return true; }
-      static const char* id() { static const char *const s = "float"; return s; }
-    };
-    template<> struct type<double> {
-      static double min() { return -1.7E308; }
-      static double max() { return  1.7E308; }
-      static bool is_float() { return true; }
-      static const char* id() { static const char *const s = "double"; return s; }
-    };
-
-    // Define internal library variables.
-#if cimg_display_type==1
-    struct X11info {
-      volatile unsigned int nb_wins;
-      pthread_mutex_t* mutex;
-      pthread_t*       event_thread;
-      CImgDisplay*     wins[1024];
-      Display*         display;
-      unsigned int     nb_bits;
-      GC*              gc;
-      bool             blue_first;
-      bool             byte_order;
-      bool             shm_enabled;
-#ifdef cimg_use_xrandr
-      XRRScreenSize *resolutions;
-      Rotation curr_rotation;
-      unsigned int curr_resolution;
-      unsigned int nb_resolutions;
-#endif
-      X11info():nb_wins(0),mutex(0),event_thread(0),display(0),
-                nb_bits(0),gc(0),blue_first(false),byte_order(false),shm_enabled(false) {
-#ifdef cimg_use_xrandr
-        resolutions = 0;
-        curr_rotation = 0;
-        curr_resolution = nb_resolutions = 0;
-#endif
-      }
-    };
-#if defined(cimg_module)
-    X11info& X11attr();
-#elif defined(cimg_main)
-    X11info& X11attr() { static X11info val; return val; }
-#else
-    inline X11info& X11attr() { static X11info val; return val; }
-#endif
-
-#elif cimg_display_type==2
-    struct Win32info {
-      HANDLE wait_event;
-      Win32info() { wait_event = CreateEvent(0,FALSE,FALSE,0); }
-    };
-#if defined(cimg_module)
-    Win32info& Win32attr();
-#elif defined(cimg_main)
-    Win32info& Win32attr() { static Win32info val; return val; }
-#else
-    inline Win32info& Win32attr() { static Win32info val; return val; }
-#endif
-#endif
-
-    inline unsigned int& exception_mode() { static unsigned int mode=cimg_debug; return mode; }
-
-#ifdef cimg_color_terminal
-    const char t_normal[9]  = {0x1b,'[','0',';','0',';','0','m','\0'};
-    const char t_red[11]    = {0x1b,'[','4',';','3','1',';','5','9','m','\0'};
-    const char t_bold[5]    = {0x1b,'[','1','m','\0'};
-    const char t_purple[11] = {0x1b,'[','0',';','3','5',';','5','9','m','\0'};
-#else
-    const char t_normal[1]  = {'\0'};
-    const char *const t_red = cimg::t_normal, *const t_bold = cimg::t_normal, *const t_purple = cimg::t_normal;
-#endif
-
-#if cimg_display_type==1
-    // Keycodes for X11-based graphical systems
-    const unsigned int keyESC        = XK_Escape;
-    const unsigned int keyF1         = XK_F1;
-    const unsigned int keyF2         = XK_F2;
-    const unsigned int keyF3         = XK_F3;
-    const unsigned int keyF4         = XK_F4;
-    const unsigned int keyF5         = XK_F5;
-    const unsigned int keyF6         = XK_F6;
-    const unsigned int keyF7         = XK_F7;
-    const unsigned int keyF8         = XK_F8;
-    const unsigned int keyF9         = XK_F9;
-    const unsigned int keyF10        = XK_F10;
-    const unsigned int keyF11        = XK_F11;
-    const unsigned int keyF12        = XK_F12;
-    const unsigned int keyPAUSE      = XK_Pause;
-    const unsigned int key1          = XK_1;
-    const unsigned int key2          = XK_2;
-    const unsigned int key3          = XK_3;
-    const unsigned int key4          = XK_4;
-    const unsigned int key5          = XK_5;
-    const unsigned int key6          = XK_6;
-    const unsigned int key7          = XK_7;
-    const unsigned int key8          = XK_8;
-    const unsigned int key9          = XK_9;
-    const unsigned int key0          = XK_0;
-    const unsigned int keyBACKSPACE  = XK_BackSpace;
-    const unsigned int keyINSERT     = XK_Insert;
-    const unsigned int keyHOME       = XK_Home;
-    const unsigned int keyPAGEUP     = XK_Page_Up;
-    const unsigned int keyTAB        = XK_Tab;
-    const unsigned int keyQ          = XK_q;
-    const unsigned int keyW          = XK_w;
-    const unsigned int keyE          = XK_e;
-    const unsigned int keyR          = XK_r;
-    const unsigned int keyT          = XK_t;
-    const unsigned int keyY          = XK_y;
-    const unsigned int keyU          = XK_u;
-    const unsigned int keyI          = XK_i;
-    const unsigned int keyO          = XK_o;
-    const unsigned int keyP          = XK_p;
-    const unsigned int keyDELETE     = XK_Delete;
-    const unsigned int keyEND        = XK_End;
-    const unsigned int keyPAGEDOWN   = XK_Page_Down;
-    const unsigned int keyCAPSLOCK   = XK_Caps_Lock;
-    const unsigned int keyA          = XK_a;
-    const unsigned int keyS          = XK_s;
-    const unsigned int keyD          = XK_d;
-    const unsigned int keyF          = XK_f;
-    const unsigned int keyG          = XK_g;
-    const unsigned int keyH          = XK_h;
-    const unsigned int keyJ          = XK_j;
-    const unsigned int keyK          = XK_k;
-    const unsigned int keyL          = XK_l;
-    const unsigned int keyENTER      = XK_Return;
-    const unsigned int keySHIFTLEFT  = XK_Shift_L;
-    const unsigned int keyZ          = XK_z;
-    const unsigned int keyX          = XK_x;
-    const unsigned int keyC          = XK_c;
-    const unsigned int keyV          = XK_v;
-    const unsigned int keyB          = XK_b;
-    const unsigned int keyN          = XK_n;
-    const unsigned int keyM          = XK_m;
-    const unsigned int keySHIFTRIGHT = XK_Shift_R;
-    const unsigned int keyARROWUP    = XK_Up;
-    const unsigned int keyCTRLLEFT   = XK_Control_L;
-    const unsigned int keyAPPLEFT    = XK_Super_L;
-    const unsigned int keySPACE      = XK_space;
-    const unsigned int keyALTGR      = XK_Alt_R;
-    const unsigned int keyAPPRIGHT   = XK_Super_R;
-    const unsigned int keyMENU       = XK_Menu;
-    const unsigned int keyCTRLRIGHT  = XK_Control_R;
-    const unsigned int keyARROWLEFT  = XK_Left;
-    const unsigned int keyARROWDOWN  = XK_Down;
-    const unsigned int keyARROWRIGHT = XK_Right;
-    const unsigned int keyPAD0       = XK_KP_0;
-    const unsigned int keyPAD1       = XK_KP_1;
-    const unsigned int keyPAD2       = XK_KP_2;
-    const unsigned int keyPAD3       = XK_KP_3;
-    const unsigned int keyPAD4       = XK_KP_4;
-    const unsigned int keyPAD5       = XK_KP_5;
-    const unsigned int keyPAD6       = XK_KP_6;
-    const unsigned int keyPAD7       = XK_KP_7;
-    const unsigned int keyPAD8       = XK_KP_8;
-    const unsigned int keyPAD9       = XK_KP_9;
-    const unsigned int keyPADADD     = XK_KP_Add;
-    const unsigned int keyPADSUB     = XK_KP_Subtract;
-    const unsigned int keyPADMUL     = XK_KP_Multiply;
-    const unsigned int keyPADDIV     = XK_KP_Divide;
-
-#elif (cimg_display_type==2 && cimg_OS==2)
-    // Keycodes for Windows-OS
-    const unsigned int keyESC        = VK_ESCAPE;
-    const unsigned int keyF1         = VK_F1;
-    const unsigned int keyF2         = VK_F2;
-    const unsigned int keyF3         = VK_F3;
-    const unsigned int keyF4         = VK_F4;
-    const unsigned int keyF5         = VK_F5;
-    const unsigned int keyF6         = VK_F6;
-    const unsigned int keyF7         = VK_F7;
-    const unsigned int keyF8         = VK_F8;
-    const unsigned int keyF9         = VK_F9;
-    const unsigned int keyF10        = VK_F10;
-    const unsigned int keyF11        = VK_F11;
-    const unsigned int keyF12        = VK_F12;
-    const unsigned int keyPAUSE      = VK_PAUSE;
-    const unsigned int key1          = '1';
-    const unsigned int key2          = '2';
-    const unsigned int key3          = '3';
-    const unsigned int key4          = '4';
-    const unsigned int key5          = '5';
-    const unsigned int key6          = '6';
-    const unsigned int key7          = '7';
-    const unsigned int key8          = '8';
-    const unsigned int key9          = '9';
-    const unsigned int key0          = '0';
-    const unsigned int keyBACKSPACE  = VK_BACK;
-    const unsigned int keyINSERT     = VK_INSERT;
-    const unsigned int keyHOME       = VK_HOME;
-    const unsigned int keyPAGEUP     = VK_PRIOR;
-    const unsigned int keyTAB        = VK_TAB;
-    const unsigned int keyQ          = 'Q';
-    const unsigned int keyW          = 'W';
-    const unsigned int keyE          = 'E';
-    const unsigned int keyR          = 'R';
-    const unsigned int keyT          = 'T';
-    const unsigned int keyY          = 'Y';
-    const unsigned int keyU          = 'U';
-    const unsigned int keyI          = 'I';
-    const unsigned int keyO          = 'O';
-    const unsigned int keyP          = 'P';
-    const unsigned int keyDELETE     = VK_DELETE;
-    const unsigned int keyEND        = VK_END;
-    const unsigned int keyPAGEDOWN   = VK_NEXT;
-    const unsigned int keyCAPSLOCK   = VK_CAPITAL;
-    const unsigned int keyA          = 'A';
-    const unsigned int keyS          = 'S';
-    const unsigned int keyD          = 'D';
-    const unsigned int keyF          = 'F';
-    const unsigned int keyG          = 'G';
-    const unsigned int keyH          = 'H';
-    const unsigned int keyJ          = 'J';
-    const unsigned int keyK          = 'K';
-    const unsigned int keyL          = 'L';
-    const unsigned int keyENTER      = VK_RETURN;
-    const unsigned int keySHIFTLEFT  = VK_SHIFT;
-    const unsigned int keyZ          = 'Z';
-    const unsigned int keyX          = 'X';
-    const unsigned int keyC          = 'C';
-    const unsigned int keyV          = 'V';
-    const unsigned int keyB          = 'B';
-    const unsigned int keyN          = 'N';
-    const unsigned int keyM          = 'M';
-    const unsigned int keySHIFTRIGHT = VK_SHIFT;
-    const unsigned int keyARROWUP    = VK_UP;
-    const unsigned int keyCTRLLEFT   = VK_CONTROL;
-    const unsigned int keyAPPLEFT    = VK_LWIN;
-    const unsigned int keySPACE      = VK_SPACE;
-    const unsigned int keyALTGR      = VK_CONTROL;
-    const unsigned int keyAPPRIGHT   = VK_RWIN;
-    const unsigned int keyMENU       = VK_APPS;
-    const unsigned int keyCTRLRIGHT  = VK_CONTROL;
-    const unsigned int keyARROWLEFT  = VK_LEFT;
-    const unsigned int keyARROWDOWN  = VK_DOWN;
-    const unsigned int keyARROWRIGHT = VK_RIGHT;
-    const unsigned int keyPAD0       = 0x60;
-    const unsigned int keyPAD1       = 0x61;
-    const unsigned int keyPAD2       = 0x62;
-    const unsigned int keyPAD3       = 0x63;
-    const unsigned int keyPAD4       = 0x64;
-    const unsigned int keyPAD5       = 0x65;
-    const unsigned int keyPAD6       = 0x66;
-    const unsigned int keyPAD7       = 0x67;
-    const unsigned int keyPAD8       = 0x68;
-    const unsigned int keyPAD9       = 0x69;
-    const unsigned int keyPADADD     = VK_ADD;
-    const unsigned int keyPADSUB     = VK_SUBTRACT;
-    const unsigned int keyPADMUL     = VK_MULTIPLY;
-    const unsigned int keyPADDIV     = VK_DIVIDE;
-#else
-    // Define unknow keycodes when no display
-    const unsigned int keyESC        = 1U;
-    const unsigned int keyF1         = 2U;
-    const unsigned int keyF2         = 3U;
-    const unsigned int keyF3         = 4U;
-    const unsigned int keyF4         = 5U;
-    const unsigned int keyF5         = 6U;
-    const unsigned int keyF6         = 7U;
-    const unsigned int keyF7         = 8U;
-    const unsigned int keyF8         = 9U;
-    const unsigned int keyF9         = 10U;
-    const unsigned int keyF10        = 11U;
-    const unsigned int keyF11        = 12U;
-    const unsigned int keyF12        = 13U;
-    const unsigned int keyPAUSE      = 14U;
-    const unsigned int key1          = 15U;
-    const unsigned int key2          = 16U;
-    const unsigned int key3          = 17U;
-    const unsigned int key4          = 18U;
-    const unsigned int key5          = 19U;
-    const unsigned int key6          = 20U;
-    const unsigned int key7          = 21U;
-    const unsigned int key8          = 22U;
-    const unsigned int key9          = 23U;
-    const unsigned int key0          = 24U;
-    const unsigned int keyBACKSPACE  = 25U;
-    const unsigned int keyINSERT     = 26U;
-    const unsigned int keyHOME       = 27U;
-    const unsigned int keyPAGEUP     = 28U;
-    const unsigned int keyTAB        = 29U;
-    const unsigned int keyQ          = 30U;
-    const unsigned int keyW          = 31U;
-    const unsigned int keyE          = 32U;
-    const unsigned int keyR          = 33U;
-    const unsigned int keyT          = 34U;
-    const unsigned int keyY          = 35U;
-    const unsigned int keyU          = 36U;
-    const unsigned int keyI          = 37U;
-    const unsigned int keyO          = 38U;
-    const unsigned int keyP          = 39U;
-    const unsigned int keyDELETE     = 40U;
-    const unsigned int keyEND        = 41U;
-    const unsigned int keyPAGEDOWN   = 42U;
-    const unsigned int keyCAPSLOCK   = 43U;
-    const unsigned int keyA          = 44U;
-    const unsigned int keyS          = 45U;
-    const unsigned int keyD          = 46U;
-    const unsigned int keyF          = 47U;
-    const unsigned int keyG          = 48U;
-    const unsigned int keyH          = 49U;
-    const unsigned int keyJ          = 50U;
-    const unsigned int keyK          = 51U;
-    const unsigned int keyL          = 52U;
-    const unsigned int keyENTER      = 53U;
-    const unsigned int keySHIFTLEFT  = 54U;
-    const unsigned int keyZ          = 55U;
-    const unsigned int keyX          = 56U;
-    const unsigned int keyC          = 57U;
-    const unsigned int keyV          = 58U;
-    const unsigned int keyB          = 59U;
-    const unsigned int keyN          = 60U;
-    const unsigned int keyM          = 61U;
-    const unsigned int keySHIFTRIGHT = 62U;
-    const unsigned int keyARROWUP    = 63U;
-    const unsigned int keyCTRLLEFT   = 64U;
-    const unsigned int keyAPPLEFT    = 65U;
-    const unsigned int keySPACE      = 66U;
-    const unsigned int keyALTGR      = 67U;
-    const unsigned int keyAPPRIGHT   = 68U;
-    const unsigned int keyMENU       = 69U;
-    const unsigned int keyCTRLRIGHT  = 70U;
-    const unsigned int keyARROWLEFT  = 71U;
-    const unsigned int keyARROWDOWN  = 72U;
-    const unsigned int keyARROWRIGHT = 73U;
-    const unsigned int keyPAD0       = 74U;
-    const unsigned int keyPAD1       = 75U;
-    const unsigned int keyPAD2       = 76U;
-    const unsigned int keyPAD3       = 77U;
-    const unsigned int keyPAD4       = 78U;
-    const unsigned int keyPAD5       = 79U;
-    const unsigned int keyPAD6       = 80U;
-    const unsigned int keyPAD7       = 81U;
-    const unsigned int keyPAD8       = 82U;
-    const unsigned int keyPAD9       = 83U;
-    const unsigned int keyPADADD     = 84U;
-    const unsigned int keyPADSUB     = 85U;
-    const unsigned int keyPADMUL     = 86U;
-    const unsigned int keyPADDIV     = 87U;
-#endif
-
-#ifdef PI
-#undef PI
-#endif
-    const double PI = 3.14159265358979323846;   //!< Definition of the mathematical constant PI
-
-    // Definition of a 7x11 font, used to return a default font for drawing text.
-    const unsigned int font7x11[7*11*256/32] = {
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x90,0x0,0x7f0000,0x40000,0x0,0x0,0x4010c0a4,0x82000040,0x11848402,0x18480050,0x80430292,0x8023,0x9008000,
-      0x40218140,0x4000040,0x21800402,0x18000051,0x1060500,0x8083,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x24002,0x4031,0x80000000,0x10000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x81c0400,0x40020000,0x80070080,0x40440e00,0x0,0x0,0x1,0x88180000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x200000,0x0,0x0,0x80000,0x0,0x0,0x20212140,0x5000020,0x22400204,0x240000a0,0x40848500,0x4044,0x80010038,0x20424285,0xa000020,
-      0x42428204,0x2428e0a0,0x82090a14,0x4104,0x85022014,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10240a7,0x88484040,0x40800000,0x270c3,0x87811e0e,
-      0x7c70e000,0x78,0x3c23c1ef,0x1f3e1e89,0xf1c44819,0xa23cf0f3,0xc3cff120,0xc18307f4,0x4040400,0x20000,0x80080080,0x40200,0x0,
-      0x40000,0x2,0x8040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8188,0x50603800,0xf3c00000,0x1c004003,0xc700003e,0x18180,0xc993880,0x10204081,
-      0x2071ef9,0xf3e7cf9f,0x3e7c7911,0xe3c78f1e,0x7d1224,0x48906048,0x0,0x4000000,0x0,0x9000,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x10240aa,0x14944080,0x23610000,0x68940,0x40831010,0x8891306,0x802044,0x44522208,0x90202088,0x40448819,0xb242890a,0x24011111,
-      0x49448814,0x4040a00,0xe2c3c7,0x8e3f3cb9,0xc1c44216,0xee38b0f2,0xe78f9120,0xc18507e2,0x8040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x101c207,0x88a04001,0x9c00000,0x2200a041,0x8200113a,0x8240,0x50a3110,0x2850a142,0x850c2081,0x2040204,0x8104592,0x142850a1,
-      0x42cd1224,0x4888bc48,0x70e1c387,0xe3b3c70,0xe1c38e1c,0x38707171,0xc3870e1c,0x10791224,0x48906c41,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x10003ee,0x15140080,0x21810000,0x48840,0x40851020,0x8911306,0x31fd804,0x9c522408,0x90204088,0x4045081a,0xba42890a,0x24011111,
-      0x49285024,0x2041b00,0x132408,0x910844c8,0x4044821b,0x7244c913,0x24041111,0x49488822,0x8040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x28204,0x85006001,0x6a414000,0x3a004043,0xc700113a,0x8245,0x50a3a00,0x2850a142,0x850c4081,0x2040204,0x81045d2,0x142850a1,
-      0x24951224,0x48852250,0x8102040,0x81054089,0x12244204,0x8108992,0x24489122,0x991224,0x4888b222,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x1000143,0xa988080,0x2147c01f,0x88840,0x83091c2c,0x1070f000,0xc000608,0xa48bc408,0x9e3c46f8,0x40460816,0xaa42f10b,0xc3811111,
-      0x35102044,0x1041100,0xf22408,0x9f084488,0x40470212,0x62448912,0x6041111,0x55308846,0x8061c80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x1028704,0x8f805801,0x4be28fdf,0x220001f0,0x111a,0x60000182,0x82c5c710,0x44891224,0x489640f1,0xe3c78204,0x810e552,0x142850a1,
-      0x18a51224,0x48822250,0x78f1e3c7,0x8f1f40f9,0xf3e7c204,0x8108912,0x24489122,0x7ea91224,0x4888a222,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x10007e2,0x85648080,0x20010000,0x88841,0x8f8232,0x20881000,0xc1fc610,0xbefa2408,0x90204288,0x40450816,0xa642810a,0x4041110a,
-      0x36282084,0x1042080,0x1122408,0x90084488,0x40450212,0x62448912,0x184110a,0x55305082,0x8042700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x1028207,0x82004801,0x68050040,0x1c000040,0x110a,0x60000001,0x45484d10,0x7cf9f3e7,0xcf944081,0x2040204,0x8104532,0x142850a1,
-      0x18a51224,0x48822248,0x89122448,0x91244081,0x2040204,0x8108912,0x24489122,0xc91224,0x48852214,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x282,
-      0x89630080,0x20010c00,0x30108842,0x810222,0x20882306,0x3001800,0x408a2208,0x90202288,0x40448814,0xa642810a,0x2041110a,0x26442104,
-      0x840000,0x1122408,0x90084488,0x40448212,0x62448912,0x84130a,0x36485102,0x8040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x101c208,0x4f802801,
-      0x8028040,0x40,0x130a,0x2,0x85e897a0,0x44891224,0x489c2081,0x2040204,0x8104532,0x142850a1,0x24cd1224,0x48823c44,0x89122448,
-      0x91244081,0x2040204,0x8108912,0x24489122,0xc93264,0xc9852214,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100028f,0x109f0080,0x20010c00,
-      0x303071f3,0xc7011c1c,0x4071c306,0x802010,0x3907c1ef,0x1f201e89,0xf3844f90,0xa23c80f2,0x17810e04,0x228223f4,0x840000,0xfbc3c7,
-      0x8f083c88,0x40444212,0x6238f0f2,0x7039d04,0x228423e2,0x8040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1008780,0x2201800,0xf0014000,0x1f0,
-      0x1d0a,0x5,0x851e140,0x83060c18,0x30671ef9,0xf3e7cf9f,0x3e7c7911,0xe3c78f1e,0x42f8e1c3,0x8702205c,0x7cf9f3e7,0xcf9b3c78,0xf1e3c204,
-      0x8107111,0xc3870e1c,0x10f1d3a7,0x4e823c08,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x40,0x40000400,0x200000,0x0,0x2,0x0,0x0,0x0,0x0,0x18,
-      0x0,0x4,0x44007f,0x0,0x400,0x400000,0x8010,0x0,0x6002,0x8040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x200800,0x0,0x0,0x100a,
-      0x400000,0x44,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x62018,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x31,0x80000800,
-      0x400000,0x0,0x4,0x0,0x0,0x0,0x0,0xc,0x0,0x7,0x3c0000,0x0,0x3800,0x3800000,0x8010,0x0,0x1c001,0x881c0000,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x207000,0x0,0x0,0x100a,0xc00000,0x3c,0x0,0xc00,0x0,0x0,0x0,0x0,0x0,0x0,0x1800,0x0,0x0,0x0,0x0,0x1c2070
-    };
-
-    // Definition of a 10x13 font (used in dialog boxes).
-    const unsigned int font10x13[256*10*13/32] = {
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80100c0,
-      0x68000300,0x801,0xc00010,0x100c000,0x68100,0x100c0680,0x2,0x403000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc,0x0,0x0,0x0,0x0,0x0,0x4020120,
-      0x58120480,0x402,0x1205008,0x2012050,0x58080,0x20120581,0x40000001,0x804812,0x2000000,0x0,0x300,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x140,0x80000,0x200402,0x800000,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x7010,0x7000000,0x8000200,0x20000,0xc0002000,0x8008,0x0,0x0,0x0,0x0,0x808,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x80000000,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x480,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x70,0x80100c0,0x68000480,0x1001,
-      0xc00010,0x1018000,0x68100,0x100c0680,0x4,0x403000,0x1020000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20140,0x28081883,0x200801,
-      0x2a00000,0x10,0x1c0201c0,0x70040f80,0xc0f81c07,0x0,0x70,0x3e0303c0,0x3c3c0f83,0xe03c2107,0xe08810,0x18c31070,0x3c0703c0,
-      0x783e0842,0x22222208,0x83e04010,0x1008000,0x4000200,0x20001,0x2002,0x408008,0x0,0x0,0x100000,0x0,0x1008,0x2000000,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20080,0x38000880,0x8078140f,0x81c00000,0x3e000,0xc020180,0x60080001,0xe0000002,0xc00042,0x108e2010,
-      0xc0300c0,0x300c0303,0xf83c3e0f,0x83e0f81c,0x701c070,0x3c0c41c0,0x701c0701,0xc0001d08,0x42108421,0x8820088,0x4020120,0x58140480,
-      0x802,0x1205008,0x3014050,0xc058080,0x20120581,0x40000002,0x804814,0x2020050,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20140,
-      0x281e2484,0x80200801,0x1c02000,0x10,0x22060220,0x880c0801,0x82208,0x80000001,0x20008,0x41030220,0x40220802,0x402102,0x209010,
-      0x18c31088,0x22088220,0x80080842,0x22222208,0x80204010,0x1014000,0x200,0x20001,0x2000,0x8008,0x0,0x0,0x100000,0x0,0x1008,
-      0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x40000500,0x80800010,0x40200000,0x41000,0x12020040,0x10000003,0xa0000006,
-      0x12000c4,0x31014000,0xc0300c0,0x300c0302,0x80402008,0x2008008,0x2008020,0x220c4220,0x88220882,0x20002208,0x42108421,0x8820088,
-      0x0,0x300,0x0,0x0,0x0,0x14000000,0x0,0x200200,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0xfc282504,0x80001000,
-      0x82a02000,0x20,0x22020020,0x8140802,0x102208,0x80801006,0x18008,0x9c848220,0x80210802,0x802102,0x20a010,0x15429104,0x22104220,
-      0x80080842,0x22221405,0x404008,0x1022000,0x703c0,0x381e0701,0xc0783c02,0xc09008,0x1d83c070,0x3c078140,0x381c0882,0x21242208,
-      0x81e01008,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x201e0,0x40220500,0x80800027,0x20e02800,0x9c800,0x12020040,
-      0x20000883,0xa0200002,0x120a044,0x11064010,0x12048120,0x48120484,0x80802008,0x2008008,0x2008020,0x210a4411,0x4411044,0x10884508,
-      0x42108421,0x503c0b0,0x1c0701c0,0x701c0707,0x70381c07,0x1c07008,0x2008020,0x20f01c0,0x701c0701,0xc0201c08,0x82208822,0x883c088,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x50281903,0x20001000,0x80802000,0x20,0x22020040,0x30240f03,0xc0101c08,0x80801018,
-      0x1fc06010,0xa48483c0,0x80210f03,0xe0803f02,0x20c010,0x15429104,0x22104220,0x70080841,0x41540805,0x804008,0x1041000,0x8220,
-      0x40220881,0x882202,0x40a008,0x12422088,0x22088180,0x40100882,0x21241408,0x80201008,0x2031000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x20280,0x401c0200,0x700028,0x21205000,0x92800,0xc1fc080,0x10000883,0xa0200002,0x1205049,0x12c19010,0x12048120,0x48120484,
-      0xf0803c0f,0x3c0f008,0x2008020,0x790a4411,0x4411044,0x10504908,0x42108421,0x5022088,0x2008020,0x8020080,0x88402208,0x82208808,
-      0x2008020,0x1e088220,0x88220882,0x20002608,0x82208822,0x8822088,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x501c0264,
-      0xa0001000,0x8001fc00,0x7000020,0x22020080,0x83e0082,0x20202207,0x80000020,0x1020,0xa4848220,0x80210802,0x9c2102,0x20c010,
-      0x12425104,0x3c1043c0,0x8080841,0x41540802,0x804008,0x1000000,0x78220,0x40220f81,0x882202,0x40c008,0x12422088,0x22088100,
-      0x60100881,0x41540805,0x406008,0x1849000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20280,0xf0140200,0x880028,0x20e0a03f,0x709c800,
-      0x201c0,0x60000881,0xa0000007,0xc0284b,0x122eb020,0x12048120,0x48120487,0x80802008,0x2008008,0x2008020,0x21094411,0x4411044,
-      0x10204908,0x42108421,0x2022088,0x1e0781e0,0x781e0787,0xf8403e0f,0x83e0f808,0x2008020,0x22088220,0x88220882,0x21fc2a08,0x82208822,
-      0x5022050,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20001,0xf80a0294,0x40001000,0x80002000,0x20,0x22020100,0x8040082,0x20202200,
-      0x80000018,0x1fc06020,0xa48fc220,0x80210802,0x842102,0x20a010,0x12425104,0x20104240,0x8080841,0x41541402,0x1004008,0x1000000,
-      0x88220,0x40220801,0x882202,0x40a008,0x12422088,0x22088100,0x18100881,0x41540805,0x801008,0x2046000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x20280,0x401c0f80,0x80880028,0x20005001,0x94800,0x20000,0x880,0xa0000000,0x5015,0x4215040,0x3f0fc3f0,0xfc3f0fc8,
-      0x80802008,0x2008008,0x2008020,0x21094411,0x4411044,0x10505108,0x42108421,0x203c088,0x22088220,0x88220888,0x80402008,0x2008008,
-      0x2008020,0x22088220,0x88220882,0x20002a08,0x82208822,0x5022050,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa00a0494,0x60001000,
-      0x80002004,0x8020,0x22020200,0x88040882,0x20402201,0x801006,0x18000,0x9f084220,0x40220802,0x442102,0x209010,0x10423088,0x20088220,
-      0x8080840,0x80882202,0x2004008,0x1000000,0x88220,0x40220881,0x882202,0x409008,0x12422088,0x22088100,0x8100880,0x80881402,
-      0x1001008,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20280,0x40220200,0x80700027,0x20002801,0x92800,0x1fc000,0x980,
-      0xa0000000,0xa017,0x84417840,0x21084210,0x84210848,0x80402008,0x2008008,0x2008020,0x2208c220,0x88220882,0x20882208,0x42108421,
-      0x2020088,0x22088220,0x88220888,0xc8402208,0x82208808,0x2008020,0x22088220,0x88220882,0x20203208,0x82208822,0x2022020,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0xa03c0463,0x90000801,0x2004,0x8040,0x1c0703e0,0x70040701,0xc0401c06,0x801001,0x20020,
-      0x400843c0,0x3c3c0f82,0x3c2107,0x1c0881e,0x10423070,0x20070210,0xf0080780,0x80882202,0x3e04004,0x1000000,0x783c0,0x381e0701,
-      0x782202,0x408808,0x12422070,0x3c078100,0x700c0780,0x80882202,0x1e01008,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x201e0,
-      0xf8000200,0x80080010,0x40000001,0x41000,0x0,0xe80,0xa0000000,0x21,0x8e21038,0x21084210,0x84210848,0xf83c3e0f,0x83e0f81c,
-      0x701c070,0x3c08c1c0,0x701c0701,0xc0005c07,0x81e0781e,0x20200b0,0x1e0781e0,0x781e0787,0x30381c07,0x1c07008,0x2008020,0x1c0881c0,
-      0x701c0701,0xc0201c07,0x81e0781e,0x203c020,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x801,0x4,0x40,0x0,0x0,0x0,0x1000,
-      0x0,0x3c000000,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x4004,0x1000000,0x0,0x0,0x80000,0x400000,0x0,0x20008000,0x0,0x4,0x1008,0x2000000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x8008000f,0x80000000,0x3e000,0x0,0x800,0xa0000400,0x0,0x0,0x0,0x0,0x80000,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x2000,0x0,0x4020040,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,
-      0x402,0x8,0x40,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,0x0,0x0,0x7004,0x70000fc,0x0,0x0,0x700000,0x800000,0x0,0x20008000,
-      0x0,0x4,0x808,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x80f00000,0x0,0x0,0x0,0x800,0xa0001800,0x0,0x0,0x0,0x0,
-      0x300000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600000,0x0,0x0,0x0,0x0,0x0,0x0,0x4020040
-    };
-
-    // Definition of a 8x17 font
-    const unsigned int font8x17[8*17*256/32] = {
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x2400,0x2400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20081834,0x1c0000,0x20081800,0x20081800,0x342008,
-      0x18340000,0x200818,0x80000,0x0,0x180000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4200000,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x380000,0x4000,0x2000c00,0x40100840,0x70000000,0x0,0x0,0x1c,0x10700000,0x7,0x0,
-      0x1800,0x1800,0x0,0x0,0x0,0x14,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1010242c,0x14140000,0x10102414,0x10102414,0x2c1010,0x242c1400,
-      0x101024,0x14100038,0x0,0x240000,0x0,0x0,0x30000000,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x12,0x0,0x8100000,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x80000,0x10004000,0x2001000,0x40000040,0x10000000,0x0,0x0,0x10,0x10100000,0x4,
-      0x0,0x18000000,0x0,0x0,0x0,0x34002400,0x2400,0x0,0x0,0x0,0x3c,0x0,0x8000000,0x0,0x60607800,0x0,0x140000,0x0,0x0,0x0,0x0,0x0,
-      0x44,0x10081834,0x240000,0x10081800,0x10081800,0x1c341008,0x18340000,0x100818,0x84000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x102812,
-      0x8601c10,0x8100800,0x2,0x1c383e3e,0x67e1e7f,0x3e3c0000,0x38,0x1e087e1e,0x7c7f7f1e,0x417c1c42,0x4063611c,0x7e1c7e3e,0xfe414181,
-      0x63827f10,0x40081000,0x8004000,0x2001000,0x40000040,0x10000000,0x0,0x10000000,0x10,0x10100000,0x3c000008,0x0,0x24003e00,
-      0x3f007f00,0x0,0x0,0x2ce91800,0x1882,0x10101c,0xc2103c,0x143c3c00,0x3c00,0x18003c3c,0x10001f00,0x181c00,0x20200810,0x8080808,
-      0x8083e1e,0x7f7f7f7f,0x7c7c7c7c,0x7c611c1c,0x1c1c1c00,0x1e414141,0x41824044,0x810242c,0x14180000,0x8102414,0x8102414,0x382c0810,
-      0x242c1400,0x81024,0x14104014,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x102816,0x3e902010,0x10084910,0x4,0x22084343,0xa402102,0x41620000,
-      0x44,0x33144121,0x42404021,0x41100444,0x40636122,0x43224361,0x10416381,0x22440310,0x20082800,0x4000,0x2001000,0x40000040,
-      0x10000000,0x0,0x10000000,0x10,0x10100000,0x24000008,0x0,0x606100,0x68000300,0x8106c,0x34000000,0x4f0000,0x44,0x101020,0x441040,
-      0x420200,0x4200,0x24000404,0x7d00,0x82200,0x20203010,0x14141414,0x14082821,0x40404040,0x10101010,0x42612222,0x22222200,0x23414141,
-      0x41447e48,0x0,0x0,0x0,0x0,0x4000000,0x18,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10287f,0x49902010,0x10083e10,0x4,0x41080101,
-      0x1a404002,0x41411818,0x1004004,0x21144140,0x41404040,0x41100448,0x40555141,0x41414140,0x10412281,0x14280610,0x20084400,0x1c7c1c,
-      0x3e3c7c3a,0x5c703844,0x107f5c3c,0x7c3e3c3c,0x7e424281,0x66427e10,0x10100000,0x40100008,0x1010,0xa04000,0x48100610,0x100c3024,
-      0x24000000,0x4f3c00,0x2c107e28,0x3820,0x42281060,0x9d1e12,0xbd00,0x24100818,0x427d00,0x82248,0x20200800,0x14141414,0x14142840,
-      0x40404040,0x10101010,0x41514141,0x41414142,0x43414141,0x41284350,0x1c1c1c1c,0x1c1c6c1c,0x3c3c3c3c,0x70707070,0x3c5c3c3c,
-      0x3c3c3c18,0x3e424242,0x42427c42,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x102824,0x48623010,0x10081c10,0x8,0x41080103,0x127c5e04,
-      0x41411818,0xe7f3808,0x4f144140,0x41404040,0x41100450,0x40555141,0x41414160,0x1041225a,0x1c280410,0x1008c600,0x226622,0x66661066,
-      0x62100848,0x10496266,0x66663242,0x10426681,0x24220260,0x100c0000,0xf8280008,0x1010,0x606000,0x48280428,0x28042014,0x48000000,
-      0x494200,0x52280228,0x105420,0x3cee1058,0xa12236,0xa500,0x18101004,0x427d00,0x8226c,0x76767e10,0x14141414,0x14142840,0x40404040,
-      0x10101010,0x41514141,0x41414124,0x45414141,0x41284150,0x22222222,0x22221222,0x66666666,0x10101010,0x66626666,0x66666600,
-      0x66424242,0x42226622,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100024,0x381c4900,0x10086bfe,0x8,0x4908021c,0x22036304,0x3e630000,
-      0x70000710,0x51227e40,0x417f7f43,0x7f100470,0x40554941,0x43417e3e,0x1041225a,0x8100810,0x10080000,0x24240,0x42421042,0x42100850,
-      0x10494242,0x42422040,0x1042245a,0x18240410,0x10103900,0x407c003e,0x1818,0x1c3e10,0x4f7c087c,0x7c002010,0x48000000,0x4008,
-      0x527c0410,0x105078,0x2410104c,0xa13e6c,0x7f00b900,0xfe3c3c,0x421d18,0x1c1c36,0x38383810,0x22222222,0x22144e40,0x7f7f7f7f,
-      0x10101010,0xf1494141,0x41414118,0x49414141,0x4110435c,0x2020202,0x2021240,0x42424242,0x10101010,0x42424242,0x424242ff,0x4e424242,
-      0x42244224,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000fe,0xe664d00,0x10080810,0x380010,0x41080c03,0x42014108,0x633d0000,0x70000710,
-      0x51224140,0x41404041,0x41100448,0x40494541,0x7e414203,0x1041145a,0x14101010,0x10080000,0x3e4240,0x427e1042,0x42100870,0x10494242,
-      0x4242203c,0x1042245a,0x18241810,0x10104600,0xf8f60008,0x1010,0x600320,0x48f610f6,0xf6000000,0x187eff,0x3c04,0x5ef61810,0x105020,
-      0x24fe0064,0x9d006c,0x138ad00,0x100000,0x420518,0x36,0xc0c0c020,0x22222222,0x22224840,0x40404040,0x10101010,0x41454141,0x41414118,
-      0x51414141,0x41107e46,0x3e3e3e3e,0x3e3e7e40,0x7e7e7e7e,0x10101010,0x42424242,0x42424200,0x5a424242,0x42244224,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x28,0x9094500,0x10080010,0x10,0x41081801,0x7f014118,0x41010000,0xe7f3800,0x513e4140,0x41404041,0x41100444,
-      0x40414541,0x40414101,0x10411466,0x36103010,0x8080000,0x424240,0x42401042,0x42100848,0x10494242,0x42422002,0x10423c5a,0x18142010,
-      0x10100000,0x407c0010,0x1010,0x260140,0x487c307c,0x7c000000,0x180000,0x202,0x507c2010,0x105020,0x3c10003c,0x423e36,0x1004200,
-      0x100000,0x420500,0x3e6c,0x41e0440,0x3e3e3e3e,0x3e3e7840,0x40404040,0x10101010,0x41454141,0x41414124,0x61414141,0x41104042,
-      0x42424242,0x42425040,0x40404040,0x10101010,0x42424242,0x42424218,0x72424242,0x42144214,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100048,
-      0x49096200,0x8100010,0x18001810,0x22082043,0x2432310,0x61421818,0x1004010,0x4f634121,0x42404021,0x41104444,0x40414322,0x40234143,
-      0x10411466,0x22106010,0x8080000,0x466622,0x66621066,0x42100844,0x10494266,0x66662042,0x10461824,0x24184010,0x10100000,0x24381010,
-      0x34001018,0xda4320,0x68386038,0x38000000,0x0,0x4204,0x50384010,0x105420,0x4210100c,0x3c0012,0x3c00,0x0,0x460500,0x48,0xc020c44,
-      0x63636363,0x63228821,0x40404040,0x10101010,0x42432222,0x22222242,0x62414141,0x41104042,0x46464646,0x46465022,0x62626262,
-      0x10101010,0x66426666,0x66666618,0x66464646,0x46186618,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100048,0x3e063d00,0x8100000,0x18001820,
-      0x1c3e7f3e,0x23c1e20,0x3e3c1818,0x10,0x20417e1e,0x7c7f401e,0x417c3842,0x7f41431c,0x401e40be,0x103e0866,0x41107f10,0x4080000,
-      0x3a5c1c,0x3a3c103a,0x427c0842,0xe49423c,0x7c3e203c,0xe3a1824,0x66087e10,0x10100000,0x3c103010,0x245a1010,0x5a3e10,0x3f107f10,
-      0x10000000,0x0,0x3c08,0x2e107e10,0x1038fc,0x101004,0x0,0x0,0xfe0000,0x7f0500,0x0,0x14041438,0x41414141,0x41418e1e,0x7f7f7f7f,
-      0x7c7c7c7c,0x7c431c1c,0x1c1c1c00,0xbc3e3e3e,0x3e10405c,0x3a3a3a3a,0x3a3a6e1c,0x3c3c3c3c,0x7c7c7c7c,0x3c423c3c,0x3c3c3c00,
-      0x7c3a3a3a,0x3a087c08,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x4200000,0x10000020,0x0,0x0,0x10,0x0,0x30000000,0x0,
-      0x0,0x0,0x60000,0x0,0x1c,0x4380000,0x0,0x2,0x800,0x0,0x40020000,0x0,0x8000c,0x10600000,0x2010,0x48000000,0x240000,0x0,0x0,
-      0x0,0x0,0x0,0x1000,0x1078,0x0,0x0,0x0,0x400500,0x0,0x1e081e00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x84008,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x20000040,0x0,0x0,0x20,0x0,0x1e000000,0x0,0x0,0x0,0x20000,0x0,
-      0x0,0x2000000,0x0,0x26,0x800,0x0,0x40020000,0x0,0x100000,0x10000000,0x2030,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x0,
-      0x0,0x0,0x400000,0x8000000,0x41e0400,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x104010,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfe,0x0,0x1c,0x7000,0x0,0x40020000,0x0,0x300000,
-      0x0,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x400000,0x38000000,0x0,0x0,0x1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x1c,0x0,0x0,0x0,0x0,0x0,0x304030,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 };
-
-    // Definition of a 10x19 font
-    const unsigned int font10x19[10*19*256/32] = {
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3600000,0x36000,0x0,0x0,0x0,0x0,0x6c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x180181c0,0xe81b0300,0x1801,0x81c06c18,0x181c06c,0xe8180,0x181c0e81,0xb0000006,0x60701b,0x1800000,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c00000,0x1c000,0x0,0x0,0x0,0x0,0x6c,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0xc030360,0xb81b0480,0xc03,0x3606c0c,0x303606c,0xb80c0,0x30360b81,0xb0000003,0xc0d81b,0x3000000,0x0,
-      0x300,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x2200000,
-      0x22000,0x0,0x0,0x0,0x0,0x0,0x0,0x30000,0x0,0xe0,0x38078000,0x0,0x480,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000c080,0x480,0x3000,
-      0xc0800030,0xc08000,0x300,0xc080000,0xc,0x302000,0xc00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20120,0x41c01,0xe020060c,
-      0x800000,0x4,0x1e0703e0,0xf8060fc1,0xe1fe1e07,0x80000000,0x78,0x307e0,0x3c7c1fe7,0xf83c408f,0x80f10440,0x18660878,0x7e0787e0,
-      0x78ff9024,0xa0140a0,0x27f83840,0x700e000,0x18000400,0x8000,0x70004002,0x410078,0x0,0x0,0x0,0x0,0x1808,0xc000000,0xf000000,
-      0xe000000,0x1400,0x1e0001f,0x8007f800,0x0,0x0,0x3a3b,0x61400000,0x14202,0x20000,0x38002020,0x3c1b00,0x3e00000,0xf8,0x1c0001c0,
-      0x78060001,0xf800000e,0x1e00020,0x8004020,0xc0300c0,0x300c0301,0xf83c7f9f,0xe7f9fe3e,0xf83e0f8,0x7c1821e0,0x781e0781,0xe0001f10,
-      0x24090240,0xa02400f8,0x18018140,0xe81b0480,0x1801,0x81406c18,0x181406c,0x190e8180,0x18140e81,0xb0000006,0x60501b,0x184006c,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20120,0x26042202,0x200c06,0x800000,0x8,0x210d0611,0x40e0803,0x10026188,0x40000000,
-      0x8c,0xf030418,0xc6431004,0xc64082,0x110840,0x18660884,0x41084410,0x8c081024,0xa012110,0x40082020,0x101b000,0xc000400,0x8000,
-      0x80004002,0x410008,0x0,0x0,0x100000,0x0,0x2008,0x2000000,0x18800000,0x10000000,0x2200,0x2300024,0x800,0x0,0x0,0x2e13,0x60800000,
-      0x8104,0x20040,0x64001040,0x80401b07,0x80100000,0x1e000,0x22000020,0x40c0003,0xc8000002,0x3300020,0x8004020,0xc0300c0,0x300c0301,
-      0x40c64010,0x4010008,0x2008020,0x43182210,0x84210842,0x10002190,0x24090240,0x9044018c,0xc030220,0xb81b0300,0xc03,0x2206c0c,
-      0x302206c,0x1e0b80c0,0x30220b81,0xb0000003,0xc0881b,0x304006c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20120,0x241f2202,
-      0x200802,0x4900000,0x8,0x21010408,0x20a0802,0x44090,0x20000000,0x4,0x11878408,0x80411004,0x804082,0x111040,0x1ce50986,0x40986409,
-      0x81022,0x12012108,0x80102020,0x1031800,0x400,0x8000,0x80004000,0x10008,0x0,0x0,0x100000,0x0,0x2008,0x2000000,0x10000000,
-      0x10000000,0x18,0x4000044,0x1000,0x30180,0xd81b0000,0x13,0xe0000000,0x88,0x40,0x400018c0,0x80400018,0x61f00000,0x61800,0x22020020,
-      0x4000007,0xc8000002,0x2100020,0x8038000,0x1e0781e0,0x781e0301,0x40804010,0x4010008,0x2008020,0x41142619,0x86619866,0x18002190,
-      0x24090240,0x8887e104,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20120,0x2434a202,
-      0x200802,0x3e00000,0x10,0x40810008,0x21a0804,0x44090,0x20000000,0x80040004,0x20848409,0x409004,0x1004082,0x112040,0x14a50902,
-      0x40902409,0x81022,0x11321208,0x80202010,0x1060c00,0x7c5e0,0x781e8783,0xf07a5f0e,0x1c10808,0xfc5f078,0x5e07a170,0x7c7e1024,
-      0xa016190,0x27f82008,0x2000000,0x20000000,0x10000000,0x80200024,0x4000044,0x2000,0x18180,0xc8320000,0x12,0xa1f00037,0x7f888,
-      0x1e0,0x40410880,0x80600017,0xa2100000,0x5e800,0x22020040,0x38001027,0xc8000002,0x2100020,0x8004020,0x12048120,0x48120482,
-      0x41004010,0x4010008,0x2008020,0x40942409,0x2409024,0x9044390,0x24090240,0x88841918,0x1f07c1f0,0x7c1f07c3,0x70781e07,0x81e07838,
-      0xe0380e0,0x1f17c1e0,0x781e0781,0xe0001f90,0x24090240,0x9025e102,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20001,0xff241c41,
-      0x1001,0x1c02000,0x10,0x40810008,0x6120f85,0xe0086190,0x20c03007,0x8007800c,0x27848419,0x409004,0x1004082,0x114040,0x14a48902,
-      0x40902409,0x81022,0x11321205,0x602010,0x1000000,0x86610,0x84218840,0x80866182,0x411008,0x9261884,0x61086189,0x82101022,0x12012108,
-      0x40082008,0x2000000,0x20030000,0x20000000,0x80200024,0x4000044,0x3006030,0xc018100,0x4c260000,0x12,0x26080048,0x83000850,
-      0x20250,0x403e0500,0x8078002c,0x12302200,0x92400,0x1c0200c0,0x4001027,0xc8000002,0x3308820,0x8004020,0x12048120,0x48120482,
-      0x41004010,0x4010008,0x2008020,0x40922409,0x2409024,0x8884690,0x24090240,0x85040920,0x21886218,0x86218860,0x88842108,0x42108408,
-      0x2008020,0x21186210,0x84210842,0x10302190,0x24090240,0x88461084,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x4c240182,
-      0x80001001,0x6b02000,0x20,0x4c810010,0x78220846,0x10081e10,0x20c0301c,0x1fe0e018,0x4d8487e1,0x409fe7,0xf9007f82,0x11a040,
-      0x13248902,0x41102418,0xe0081022,0x11320c05,0x402008,0x1000000,0x2409,0x409020,0x81024082,0x412008,0x9240902,0x40902101,0x101022,
-      0x11321208,0x40102008,0x2000000,0x7e0c8000,0xfc000003,0xf0fc0018,0x43802047,0x8c8040c8,0x32008300,0x44240000,0x0,0x4000048,
-      0x8c801050,0x20440,0x40221dc0,0x808c0028,0x11d0667f,0x8009c400,0x1fc180,0x4001023,0xc8300002,0x1e0ccfb,0x3ec7b020,0x12048120,
-      0x48120482,0x79007f9f,0xe7f9fe08,0x2008020,0xf0922409,0x2409024,0x8504490,0x24090240,0x85040920,0x802008,0x2008020,0x89004090,
-      0x24090208,0x2008020,0x40902409,0x2409024,0x8304390,0x24090240,0x88440884,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,
-      0x481c0606,0xc8001001,0x802000,0x20,0x4c810020,0x4220024,0x8102108,0x60000070,0x3820,0x48884419,0x409004,0x10e4082,0x112040,
-      0x13244902,0x7e1027e0,0x3c081021,0x21320c02,0x802008,0x1000000,0x7e409,0x409020,0x81024082,0x414008,0x9240902,0x40902101,
-      0x80101022,0x11320c08,0x40202008,0x2038800,0x200bc000,0x20000000,0x80200003,0x80f04044,0xbc080bc,0x2f000200,0x0,0x0,0x6001048,
-      0x8bc02020,0x20441,0xf8220200,0x80820028,0x1000cc00,0x80094400,0x201e0,0x78001021,0xc830000f,0x8000663c,0xf03c0c0,0x21084210,
-      0x84210846,0x41004010,0x4010008,0x2008020,0x40912409,0x2409024,0x8204890,0x24090240,0x82040930,0x1f87e1f8,0x7e1f87e0,0x89004090,
-      0x24090208,0x2008020,0x40902409,0x2409024,0x8004690,0x24090240,0x88440884,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,
-      0x480719c4,0x48001001,0x81fc00,0x7800020,0x40810040,0x2420024,0x8104087,0xa0000070,0x3820,0x48884409,0x409004,0x1024082,0x111040,
-      0x13244902,0x40102410,0x2081021,0x214a1202,0x1802008,0x1000000,0x182409,0x409fe0,0x81024082,0x41a008,0x9240902,0x40902100,
-      0xf8101021,0x214a0c04,0x80c0c008,0x1847000,0x7c1ee000,0x20000000,0x8020000c,0x8c044,0x1ee181ee,0x7b800000,0x707,0xf3ff0000,
-      0x3e0084f,0x9ee0c020,0x20440,0x40221fc0,0xc2002c,0x13f11000,0x87892400,0x20000,0x1020,0x48000000,0x3f011c6,0x31cc6180,0x21084210,
-      0x84210844,0x41004010,0x4010008,0x2008020,0x40912409,0x2409024,0x8505090,0x24090240,0x8204191c,0x60982609,0x82609823,0xf9007f9f,
-      0xe7f9fe08,0x2008020,0x40902409,0x2409024,0x9fe4c90,0x24090240,0x84840848,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0xfe048224,
-      0x28001001,0x2000,0x40,0x40810080,0x27f8024,0x8104080,0x2000001c,0x1fe0e020,0x488fc409,0x409004,0x1024082,0x110840,0x10242902,
-      0x40102408,0x2081021,0x214a1202,0x1002004,0x1000000,0x102409,0x409000,0x81024082,0x411008,0x9240902,0x40902100,0x6101021,
-      0x214a0c04,0x81002008,0x2000000,0x201dc000,0x20000000,0x80200000,0x98044,0x1dc101dc,0x77000000,0x700,0x0,0x180448,0x1dc10020,
-      0x20440,0x403e0200,0x620017,0xa000cc00,0x80052800,0x20000,0x1020,0x48000000,0x6606,0x206100,0x3f0fc3f0,0xfc3f0fc7,0xc1004010,
-      0x4010008,0x2008020,0x4090a409,0x2409024,0x8886090,0x24090240,0x8207e106,0x40902409,0x2409024,0x81004010,0x4010008,0x2008020,
-      0x40902409,0x2409024,0x8005890,0x24090240,0x84840848,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x98048224,0x30001001,0x2000,
-      0x40,0x21010100,0x2020024,0x8204080,0x40000007,0x80078000,0x48884408,0x80411004,0x824082,0x110840,0x10242986,0x40086409,0x2081021,
-      0xe14a2102,0x2002004,0x1000000,0x106409,0x409000,0x81024082,0x410808,0x9240902,0x40902100,0x2101021,0x214a1202,0x82002008,
-      0x2000000,0x300f8000,0x20000000,0x80fc001d,0xe4088044,0xf8200f8,0x3e000000,0x300,0x0,0x80c48,0xf820020,0x20640,0x40410200,
-      0x803c0018,0x60006600,0x61800,0x0,0x1020,0x48000000,0xcc0a,0x20a100,0x21084210,0x84210844,0x40804010,0x4010008,0x2008020,
-      0x4110a619,0x86619866,0x19046110,0x24090240,0x82040102,0x41906419,0x6419064,0x81004010,0x4010008,0x2008020,0x40902409,0x2409024,
-      0x8307090,0x24090240,0x82840828,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x90248222,0x30000802,0x200c,0xc080,0x21010301,
-      0x4021042,0x10202108,0xc0c03000,0x80040020,0x4d902418,0xc6431004,0xc24082,0x6210440,0x10241884,0x40084409,0x86080840,0xc0842102,
-      0x4002002,0x1000000,0x18e610,0x84218820,0x80864082,0x410408,0x9240884,0x61086101,0x6101860,0xc0842103,0x4002008,0x2000000,
-      0x10850180,0x20330000,0x80200013,0x26184024,0x5040050,0x14000000,0x0,0x0,0x4180848,0x85040020,0x20350,0x40000200,0x800c0007,
-      0x80002200,0x1e000,0x0,0x1860,0x48000000,0x880a,0x40a188,0x40902409,0x2409028,0x40c64010,0x4010008,0x2008020,0x43106210,0x84210842,
-      0x10006108,0x42108421,0x2040102,0x6398e639,0x8e6398e4,0x88842088,0x22088208,0x2008020,0x21102210,0x84210842,0x10306118,0x66198661,
-      0x83061030,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20001,0x901f01c1,0xe8000802,0xc,0xc080,0x1e07c7f8,0xf8020f81,0xe0401e07,
-      0x80c03000,0x20,0x279027e0,0x3c7c1fe4,0x3c408f,0x83c1027f,0x90241878,0x4007c404,0xf8080780,0xc0844082,0x7f82002,0x1000000,
-      0xfa5e0,0x781e87c0,0x807a409f,0xc0410207,0x9240878,0x5e07a100,0xf80e0fa0,0xc0846183,0x7f82008,0x2000000,0xf020100,0x40321360,
-      0x80200014,0xa3e0201f,0x8207f820,0x8000000,0x0,0x0,0x3e01037,0x207f820,0x201e1,0xfc000200,0x80040000,0x0,0x0,0x1fc000,0x17b0,
-      0x48000000,0x12,0xc120f0,0x40902409,0x2409028,0x783c7f9f,0xe7f9fe3e,0xf83e0f8,0x7c1061e0,0x781e0781,0xe000be07,0x81e0781e,
-      0x204017c,0x3e8fa3e8,0xfa3e8fa3,0x70781f07,0xc1f07c7f,0x1fc7f1fc,0x1e1021e0,0x781e0781,0xe0007e0f,0xa3e8fa3e,0x8305e030,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0xc06,0xc,0x100,0x0,0x0,0x0,0x3000,0x0,0x20000000,0x0,0x0,0x0,0x0,0xc000,
-      0x0,0x0,0x2001,0x1000000,0x0,0x0,0x20000,0x400000,0x0,0x40002000,0x0,0x1,0x2008,0x2000000,0x100,0x40240000,0x80200008,0x40000000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x80040000,0x0,0x0,0x0,0x1000,0x48000000,0x1f,0x181f000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1040010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x60c,0x18,0x0,
-      0x0,0x0,0x0,0x6000,0x0,0x10000000,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x3800,0x7000000,0x0,0x0,0x840000,0x400000,0x0,0x40002000,
-      0x0,0x2,0x2008,0x2000000,0x200,0x40440000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x80780000,0x0,0x0,0x0,0x1000,0x48000400,
-      0x2,0x1e02000,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x2040020,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x4000,0x0,0xf000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x780000,0x3800000,0x0,0x40002000,0x0,0xe,0x1808,0xc000000,0x3,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,
-      0x0,0x0,0x0,0x1000,0x1c00,0x0,0x0,0x0,0x0,0x380000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x380000,0x0,0x0,0x0,0x0,0x0,0x0,0xe0400e0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 };
-
-    // Definition of a 12x24 font
-     const unsigned int font12x24[12*24*256/32] = {
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x19,0x80000000,0x198000,0x0,0x0,0x0,0x0,
-       0x0,0x198,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc001806,0xc81980,0x60000000,0xc001806,0x1980c00,0x18060198,0xc80c,
-       0x180600,0xc8198000,0xc001,0x80601980,0x18000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x0,0xf0000,0x0,0x0,0x0,0x0,0x0,0x198,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x600300f,0x1301980,0x90000000,0x600300f,0x1980600,0x300f0198,0x13006,0x300f01,0x30198000,0x6003,
-       0xf01980,0x30000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x0,0x60000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7007,0x3c0000,0x3006019,
-       0x80000000,0x90000000,0x3006019,0x80000300,0x60198000,0x3,0x601980,0x0,0x3006,0x1980000,0x60000000,0x0,0x0,0xe0000000,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000000,
-       0x0,0x0,0x0,0x0,0x0,0xc800019,0x80000000,0x198000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0x0,0x0,0x1001,0x420000,0x0,0x0,0x90000000,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18000c06,0xc80001,0x10000000,0x18000c06,0x1800,0xc060000,0xc818,0xc0600,0xc8000000,
-       0x18000,0xc0600000,0xc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6019,0x80660207,0x800f8060,0x300c004,0x0,0x6,
-       0xe00703f,0x3f00383,0xf80f07fc,0x1f01f000,0x0,0xf8,0x607f,0x7c7e07,0xfe7fe0f8,0x6063fc1f,0x86066007,0xe7060f0,0x7f80f07f,
-       0x81f8fff6,0x6606c03,0x70ee077f,0xe0786000,0xf0070000,0xc000060,0xc0,0x3e000,0x60006003,0x600fc00,0x0,0x0,0x0,0x0,0x0,0x3c0603,
-       0xc0000000,0x7800000,0xf0000,0x0,0xf00001f,0x80001fe0,0x7fe000,0x0,0x0,0x0,0x168fe609,0x0,0x90e07,0x6000,0x3c000e,0x70000f8,
-       0x1980001f,0x0,0x1f8,0xf00000f,0xf00180,0xfe000,0xe00e,0x1001,0x20060,0x6006006,0x600600,0x600fe07c,0x7fe7fe7f,0xe7fe3fc3,
-       0xfc3fc3fc,0x7e07060f,0xf00f00,0xf00f0000,0xf360660,0x6606606e,0x76001e0,0xc00180f,0x1681981,0x10000000,0xc00180f,0x1980c00,
-       0x180f0198,0x3801680c,0x180f01,0x68198000,0xc001,0x80f01980,0x18600198,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6019,
-       0x8044020c,0xc01f8060,0x2004004,0x0,0xc,0x3f81f07f,0x87f80383,0xf81f87fc,0x3f83f800,0x0,0x1fc,0x780607f,0x81fe7f87,0xfe7fe1fc,
-       0x6063fc1f,0x860c6007,0xe7061f8,0x7fc1f87f,0xc3fcfff6,0x6606c03,0x30c6067f,0xe0783000,0xf00d8000,0x6000060,0xc0,0x7e000,0x60006003,
-       0x600fc00,0x0,0x0,0xc00,0x0,0x0,0x7c0603,0xe0000000,0xfc00000,0x1f0000,0x0,0x900003f,0xc0003fe0,0x7fe000,0x0,0x0,0x0,0x1302660f,
-       0x0,0xf0606,0x6004,0x7e0006,0x60601f8,0x19800001,0x80000000,0x1f8,0x19800010,0x81080300,0x3f2000,0x2011,0x1001,0x1c0060,0x6006006,
-       0x600600,0x601fe1fe,0x7fe7fe7f,0xe7fe3fc3,0xfc3fc3fc,0x7f87061f,0x81f81f81,0xf81f8000,0x3fa60660,0x66066066,0x66003f0,0x6003009,
-       0x1301981,0x10000000,0x6003009,0x1980600,0x30090198,0x1f013006,0x300901,0x30198000,0x6003,0x901980,0x30600198,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6019,0x80cc0f8c,0xc0180060,0x6006044,0x40000000,0xc,0x3181b041,0xc41c0783,0x388018,
-       0x71c71800,0x0,0x106,0x18c0f061,0xc38261c6,0x600384,0x60606001,0x86186007,0xe78630c,0x60e30c60,0xe7040606,0x630cc03,0x39c30c00,
-       0xc0603000,0x3018c000,0x3000060,0xc0,0x60000,0x60000000,0x6000c00,0x0,0x0,0xc00,0x0,0x0,0x600600,0x60000000,0x18400000,0x180000,
-       0x0,0x19800070,0x40003600,0xc000,0x0,0x0,0x0,0x25a06,0x0,0x6030c,0x4,0xe20007,0xe060180,0xf000,0x80000000,0xf0000,0x10800000,
-       0x80080600,0x7f2000,0x2020,0x80001001,0x20000,0xf00f00f,0xf00f00,0x601b0382,0x60060060,0x6000600,0x60060060,0x61c78630,0xc30c30c3,
-       0xc30c000,0x30e60660,0x66066063,0xc600738,0x3006019,0x80000000,0xe0000000,0x3006019,0x80000300,0x60198000,0x3e000003,0x601980,
-       0x0,0x3006,0x1980000,0x60600000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6019,0x80cc1fcc,0xc0180060,0x6006035,0x80000000,
-       0x18,0x71c03000,0xc00c0583,0x300018,0x60c60c00,0x0,0x6,0x3060f060,0xc30060c6,0x600300,0x60606001,0x86306007,0x9e78670e,0x60670e60,
-       0x66000606,0x630c606,0x19830c01,0xc0601800,0x30306000,0x60,0xc0,0x60000,0x60000000,0x6000c00,0x0,0x0,0xc00,0x0,0x0,0x600600,
-       0x60000000,0x18000000,0x300000,0x0,0x78060,0x6600,0x1c000,0x300c,0x39819c0,0x0,0x25a00,0x0,0x30c,0x4,0xc00003,0xc060180,0x30c1f,
-       0x80000000,0x30c000,0x10800001,0x80700000,0x7f2000,0x2020,0x80001001,0x20060,0xf00f00f,0xf00f00,0xf01b0300,0x60060060,0x6000600,
-       0x60060060,0x60c78670,0xe70e70e7,0xe70e000,0x70c60660,0x66066063,0xc7f8618,0x0,0x0,0x0,0x0,0x0,0x0,0x7000000,0x0,0x0,0x0,
-       0x0,0x600000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6019,0x87ff3a4c,0xc0180060,0x400600e,0x600000,0x18,0x60c03000,
-       0xc00c0d83,0x700018,0x60c60c00,0x20,0x400006,0x3060f060,0xc6006066,0x600600,0x60606001,0x86606006,0x966c6606,0x60660660,0x66000606,
-       0x630c666,0xf019801,0x80601800,0x30603000,0x1f06f,0xf01ec0,0xf03fe1ec,0x6703e01f,0x61c0c06,0xdc6701f0,0x6f01ec0c,0xe1f87fc6,
-       0xc60cc03,0x71c60c7f,0xc0600600,0x60000000,0x30000000,0x300000,0x40040,0x88060,0x6600,0x18000,0x300c,0x1981980,0x0,0x2421f,
-       0x80003ce0,0x7fc198,0x601f,0xc02021,0x980600c0,0x40230,0x80000000,0x402000,0x19806003,0x80006,0xc7f2000,0x2020,0x80001001,
-       0x420060,0xf00f00f,0xf00f00,0xf01b0600,0x60060060,0x6000600,0x60060060,0x6066c660,0x66066066,0x6606208,0x60e60660,0x66066061,
-       0x987fc670,0x1f01f01f,0x1f01f01,0xf039c0f0,0xf00f00f,0xf03e03,0xe03e03e0,0x1f06701f,0x1f01f01,0xf01f0060,0x1e660c60,0xc60c60c6,
-       0xc6f060c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0x7ff3207,0x8c0c0000,0xc00300e,0x600000,0x30,0x60c03000,
-       0xc01c0983,0xf0600030,0x31860c06,0x6001e0,0x78000e,0x23e1f861,0xc6006066,0x600600,0x60606001,0x86c06006,0x966c6606,0x60660660,
-       0xe7000606,0x630c666,0xf01f803,0x600c00,0x30000000,0x3f87f,0x83f83fc3,0xf83fe3fc,0x7f83e01f,0x6380c07,0xfe7f83f8,0x7f83fc0d,
-       0xf3fc7fc6,0xc71cc03,0x3183187f,0xc0600600,0x60000000,0xff806000,0x300000,0x40040,0x88070,0x6600,0x60030060,0x6001818,0x1883180,
-       0x0,0x2423f,0xc0007ff0,0x607fc1f8,0x603f,0x80c01fc1,0xf80601e0,0x5f220,0x80420000,0x5f2000,0xf006006,0x80006,0xc7f2000,0x2020,
-       0x82107c07,0xc03c0060,0x1f81f81f,0x81f81f80,0xf03b0600,0x60060060,0x6000600,0x60060060,0x6066c660,0x66066066,0x660671c,0x61660660,
-       0x66066061,0xf860e6c0,0x3f83f83f,0x83f83f83,0xf87fe3f8,0x3f83f83f,0x83f83e03,0xe03e03e0,0x3f87f83f,0x83f83f83,0xf83f8060,
-       0x3fc60c60,0xc60c60c3,0x187f8318,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0x883200,0x300c0000,0xc003035,0x80600000,
-       0x30,0x66c03001,0xc0f81983,0xf86f0030,0x1f071c06,0x600787,0xfe1e001c,0x6261987f,0x86006067,0xfe7fc600,0x7fe06001,0x87c06006,
-       0xf6646606,0x60e6067f,0xc3e00606,0x61986f6,0x600f007,0x600c00,0x30000000,0x21c71,0x830831c3,0x1c06031c,0x71c06003,0x6700c06,
-       0x6671c318,0x71831c0f,0x16040c06,0xc318606,0x1b031803,0x80600600,0x60000000,0x30009000,0x300000,0x40040,0x7003e,0x67e0,0x90070090,
-       0x9001818,0x8c3100,0x0,0x60,0x4000e730,0x900380f0,0x6034,0x80c018c7,0xfe060338,0xb0121,0x80c60000,0x909000,0x6008,0x1080006,
-       0xc3f2000,0x2011,0x3180060,0x60060e0,0x19819819,0x81981981,0x9833c600,0x7fe7fe7f,0xe7fe0600,0x60060060,0x60664660,0x66066066,
-       0x66063b8,0x62660660,0x66066060,0xf06066c0,0x21c21c21,0xc21c21c2,0x1c466308,0x31c31c31,0xc31c0600,0x60060060,0x31871c31,0x83183183,
-       0x18318000,0x71860c60,0xc60c60c3,0x18718318,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0x1981a00,0xe03e0000,0xc003044,
-       0x40600000,0x60,0x66c03001,0x80f03182,0x1c7f8030,0x3f83fc06,0x601e07,0xfe078038,0x6661987f,0x86006067,0xfe7fc61e,0x7fe06001,
-       0x87e06006,0x66666606,0x7fc6067f,0x81f80606,0x61986f6,0x6006006,0x600600,0x30000000,0xc60,0xc60060c6,0xc06060c,0x60c06003,
-       0x6e00c06,0x6660c60c,0x60c60c0e,0x6000c06,0xc318666,0x1f031803,0x600600,0x603c2000,0x30016800,0x1fe0000,0x1f81f8,0x1c1f,0x804067e1,
-       0x68060168,0x16800810,0xc42300,0x0,0x60,0x20c331,0x68030060,0x6064,0x3fc1040,0xf006031c,0xa011e,0x818c7fe0,0x909000,0x7fe1f,
-       0x80f00006,0xc0f2060,0xf80e,0x18c0780,0x780781c0,0x19819819,0x81981981,0x9833c600,0x7fe7fe7f,0xe7fe0600,0x60060060,0xfc666660,
-       0x66066066,0x66061f0,0x66660660,0x66066060,0x606066e0,0xc00c00,0xc00c00c0,0xc066600,0x60c60c60,0xc60c0600,0x60060060,0x60c60c60,
-       0xc60c60c6,0xc60c000,0x61c60c60,0xc60c60c3,0x1860c318,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0x1980f81,0x80373000,
-       0xc003004,0x7fe0001,0xf0000060,0x60c03003,0x183180,0xc71c060,0x3181ec00,0x7000,0xe070,0x66619860,0xc6006066,0x60061e,0x60606001,
-       0x87606006,0x66626606,0x7f860661,0xc01c0606,0x6198696,0xf00600e,0x600600,0x30000000,0x1fc60,0xc60060c7,0xfc06060c,0x60c06003,
-       0x7c00c06,0x6660c60c,0x60c60c0c,0x7f00c06,0xc3b8666,0xe01b007,0x3c00600,0x3c7fe000,0xff03ec00,0x1fe0000,0x40040,0xe001,0xc0806603,
-       0xec0e03ec,0x3ec00010,0x0,0x60000000,0x7f,0x10c3f3,0xec070060,0x6064,0x3fc1040,0x6000030c,0xa0100,0x3187fe1,0xf09f1000,0x7fe00,
-       0x6,0xc012060,0x0,0xc63c03,0xc03c0380,0x19819819,0x81981981,0x98330600,0x60060060,0x6000600,0x60060060,0xfc662660,0x66066066,
-       0x66060e0,0x6c660660,0x66066060,0x6060e630,0x1fc1fc1f,0xc1fc1fc1,0xfc3fe600,0x7fc7fc7f,0xc7fc0600,0x60060060,0x60c60c60,0xc60c60c6,
-       0xc60c7fe,0x62c60c60,0xc60c60c1,0xb060c1b0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0xffe02c6,0x3c633000,0xc003004,
-       0x7fe0001,0xf00000c0,0x60c03006,0xc6180,0xc60c060,0x60c00c00,0x7000,0xe060,0x66639c60,0x66006066,0x600606,0x60606001,0x86306006,
-       0x66636606,0x60060660,0xc0060606,0x61f8696,0xf00600c,0x600300,0x30000000,0x3fc60,0xc60060c7,0xfc06060c,0x60c06003,0x7c00c06,
-       0x6660c60c,0x60c60c0c,0x1f80c06,0xc1b0666,0xe01b00e,0x3c00600,0x3c43c000,0x3007de00,0x600000,0x40040,0x30000,0x61006607,0xde0c07de,
-       0x7de00000,0x0,0xf07fefff,0x1f,0x8008c3f7,0xde0e0060,0x6064,0xc01047,0xfe00018c,0xb013f,0x86300061,0xf0911000,0x6000,0x6,
-       0xc012060,0x3f,0x8063c0cc,0x3cc0c700,0x39c39c39,0xc39c39c1,0x98630600,0x60060060,0x6000600,0x60060060,0x60663660,0x66066066,
-       0x66061f0,0x78660660,0x66066060,0x607fc618,0x3fc3fc3f,0xc3fc3fc3,0xfc7fe600,0x7fc7fc7f,0xc7fc0600,0x60060060,0x60c60c60,0xc60c60c6,
-       0xc60c7fe,0x64c60c60,0xc60c60c1,0xb060c1b0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0xffe0260,0x6661b000,0xc003000,
-       0x600000,0xc0,0x60c0300c,0xc7fe0,0xc60c060,0x60c01c00,0x1e07,0xfe078060,0x6663fc60,0x66006066,0x600606,0x60606001,0x86386006,
-       0x6636606,0x60060660,0xe0060606,0x60f039c,0x1b806018,0x600300,0x30000000,0x70c60,0xc60060c6,0x6060c,0x60c06003,0x7600c06,
-       0x6660c60c,0x60c60c0c,0x1c0c06,0xc1b03fc,0xe01f01c,0xe00600,0x70000000,0x3007fc00,0x600000,0x40040,0x0,0x62006607,0xfc1807fc,
-       0x7fc00000,0x0,0xf0000000,0x1,0xc004c307,0xfc1c0060,0x6064,0xc018c0,0x600000d8,0x5f200,0x3180060,0x50a000,0x6000,0x6,0xc012000,
-       0x0,0xc601c0,0x4201c600,0x3fc3fc3f,0xc3fc3fc3,0xfc7f0600,0x60060060,0x6000600,0x60060060,0x60663660,0x66066066,0x66063b8,
-       0x70660660,0x66066060,0x607f860c,0x70c70c70,0xc70c70c7,0xcc60600,0x60060060,0x6000600,0x60060060,0x60c60c60,0xc60c60c6,0xc60c000,
-       0x68c60c60,0xc60c60c1,0xf060c1f0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3300260,0x6661e000,0xc003000,0x600000,
-       0x180,0x71c03018,0xc7fe0,0xc60c0c0,0x60c01800,0x787,0xfe1e0060,0x6663fc60,0x630060c6,0x600306,0x60606001,0x86186006,0x661e70e,
-       0x60070c60,0x60060606,0x60f039c,0x19806038,0x600180,0x30000000,0x60c60,0xc60060c6,0x6060c,0x60c06003,0x6700c06,0x6660c60c,
-       0x60c60c0c,0xc0c06,0xc1b039c,0x1f00e018,0x600600,0x60000000,0x1803f800,0x600000,0x40040,0x39e00,0x63006603,0xf83803f8,0x3f800000,
-       0x0,0x60000000,0x0,0xc00cc303,0xf8180060,0x6064,0xc01fc0,0x60060070,0x40200,0x18c0060,0x402000,0x6000,0x6,0xc012000,0x0,0x18c0140,
-       0x2014600,0x3fc3fc3f,0xc3fc3fc3,0xfc7f0300,0x60060060,0x6000600,0x60060060,0x60c61e70,0xe70e70e7,0xe70e71c,0x60e60660,0x66066060,
-       0x6060060c,0x60c60c60,0xc60c60c6,0xcc60600,0x60060060,0x6000600,0x60060060,0x60c60c60,0xc60c60c6,0xc60c000,0x70c60c60,0xc60c60c0,
-       0xe060c0e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x33022e0,0x6670c000,0xc003000,0x600600,0x60180,0x31803030,
-       0x41c0184,0x1831c0c0,0x71c23806,0x6001e0,0x780000,0x62630c60,0xe38261c6,0x600386,0x60606043,0x860c6006,0x661e30c,0x60030c60,
-       0x740e0607,0xe0f039c,0x31c06030,0x600180,0x30000000,0x61c71,0x830831c3,0x406031c,0x60c06003,0x6300c06,0x6660c318,0x71831c0c,
-       0x41c0c07,0x1c0e039c,0x1b00e030,0x600600,0x60000000,0x1c41b00e,0x601cc0,0x401f8,0x45240,0xe1803601,0xb03001b0,0x1b000000,
-       0x0,0x0,0x41,0xc008e711,0xb0300060,0x6034,0x80c02020,0x60060030,0x30c00,0xc60000,0x30c000,0x0,0x7,0x1c012000,0x0,0x3180240,
-       0x6024608,0x30c30c30,0xc30c30c3,0xc630382,0x60060060,0x6000600,0x60060060,0x61c61e30,0xc30c30c3,0xc30c208,0x70c70e70,0xe70e70e0,
-       0x6060068c,0x61c61c61,0xc61c61c6,0x1cc62308,0x30430430,0x43040600,0x60060060,0x31860c31,0x83183183,0x18318060,0x31c71c71,
-       0xc71c71c0,0xe07180e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0x2203fc0,0x663f6000,0x6006000,0x600600,0x60300,
-       0x3f81fe7f,0xc7f80187,0xf83f80c0,0x3f83f006,0x600020,0x400060,0x33e6067f,0xc1fe7f87,0xfe6001fe,0x6063fc7f,0x60e7fe6,0x660e3f8,
-       0x6001f860,0x37fc0603,0xfc06030c,0x30c0607f,0xe06000c0,0x30000000,0x7fc7f,0x83f83fc3,0xfc0603fc,0x60c7fe03,0x61807c6,0x6660c3f8,
-       0x7f83fc0c,0x7f80fc3,0xfc0e039c,0x3180607f,0xc0600600,0x60000000,0xfc0e00c,0x601986,0x66040040,0x4527f,0xc0803fe0,0xe07fe0e0,
-       0xe000000,0x0,0x0,0x7f,0x80107ff0,0xe07fc060,0x603f,0x83fe0000,0x60060018,0xf000,0x420000,0xf0000,0x7fe00,0x7,0xfe012000,
-       0x0,0x2100640,0xc0643f8,0x60660660,0x66066067,0xec3e1fe,0x7fe7fe7f,0xe7fe3fc3,0xfc3fc3fc,0x7f860e3f,0x83f83f83,0xf83f8000,
-       0x5fc3fc3f,0xc3fc3fc0,0x606006fc,0x7fc7fc7f,0xc7fc7fc7,0xfcffe3f8,0x3fc3fc3f,0xc3fc7fe7,0xfe7fe7fe,0x3f860c3f,0x83f83f83,
-       0xf83f8060,0x7f83fc3f,0xc3fc3fc0,0x607f8060,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0x2201f80,0x3c1e7000,0x6006000,
-       0x600,0x60300,0xe01fe7f,0xc3f00183,0xe01f0180,0x1f01e006,0x600000,0x60,0x3006067f,0x807c7e07,0xfe6000f8,0x6063fc3e,0x6067fe6,
-       0x660e0f0,0x6000f060,0x3bf80601,0xf806030c,0x60e0607f,0xe06000c0,0x30000000,0x1ec6f,0xf01ec0,0xf80601ec,0x60c7fe03,0x61c03c6,
-       0x6660c1f0,0x6f01ec0c,0x3f007c1,0xcc0e030c,0x71c0c07f,0xc0600600,0x60000000,0x7804018,0xe01186,0x66040040,0x39e3f,0x80401fe0,
-       0x407fe040,0x4000000,0x0,0x0,0x3f,0x203ce0,0x407fc060,0x601f,0x3fe0000,0x60060018,0x0,0x0,0x0,0x7fe00,0x6,0xe6012000,0x0,
-       0x7e0,0x1807e1f0,0x60660660,0x66066066,0x6c3e07c,0x7fe7fe7f,0xe7fe3fc3,0xfc3fc3fc,0x7e060e0f,0xf00f00,0xf00f0000,0x8f01f81f,
-       0x81f81f80,0x60600670,0x1ec1ec1e,0xc1ec1ec1,0xec79c0f0,0xf80f80f,0x80f87fe7,0xfe7fe7fe,0x1f060c1f,0x1f01f01,0xf01f0000,0x4f01cc1c,
-       0xc1cc1cc0,0xc06f00c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x6006000,0x600,0x600,0x0,0x0,0x0,0x0,
-       0x600000,0x0,0x18000000,0x0,0x0,0x0,0x0,0x0,0x1800,0x0,0x0,0x0,0x600060,0x30000000,0x0,0x0,0xc,0x3,0x0,0x0,0x60000c00,0x0,
-       0x0,0xc000,0x600600,0x60000000,0x18,0xc03100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x601f8,0x0,0x0,0x0,0x0,0x6,
-       0x12000,0x2000000,0x40,0x20004000,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0xc06000c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x2004000,0xc00,0x0,0x0,0x0,0x0,0x0,0xc00000,
-       0x0,0x1c000000,0x0,0x0,0x0,0x0,0x0,0xc00,0x0,0x0,0x0,0x780000,0xf0000000,0x0,0x0,0x21c,0x3,0x0,0x0,0x60000c00,0x0,0x0,0xc000,
-       0x7c0603,0xe0000000,0x10,0xc02300,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x601f0,0x0,0x0,0x0,0x0,0x6,0x12000,0x1000000,
-       0x40,0x7e004000,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc06000c0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x300c000,0xc00,0x0,0x0,0x0,0x0,0x0,0xc00000,0x0,0x7800000,0x0,
-       0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x780000,0xf0000000,0x0,0x0,0x3f8,0x3e,0x0,0x0,0x60000c00,0x0,0x0,0x38000,0x3c0603,0xc0000000,
-       0x10,0xfc00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x60000,0x0,0x0,0x0,0x0,0x6,0x0,0x1000000,0x0,0x0,0x0,0x0,
-       0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x80600380,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffc,0x0,
-       0x0,0x1f0,0x3c,0x0,0x0,0x60000c00,0x0,0x0,0x38000,0x600,0x0,0x0,0xf000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x6,0x0,0xe000000,0x0,0x0,0x0,0x0,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x70,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x3,0x80600380,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-       0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 };
-
-    // Definition of a 16x32 font
-    const unsigned int font16x32[16*32*256/32] = {
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc300000,0x0,0xc300000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x70000e0,0x3c00730,0xe7001c0,0x0,0x70000e0,0x3c00e70,0x70000e0,0x3c00e70,0x730,0x70000e0,0x3c00730,
-      0xe700000,0x700,0xe003c0,0xe7000e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x6600000,0x0,0x6600000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x18001c0,0x6600ff0,0xe7003e0,0x0,0x18001c0,0x6600e70,0x18001c0,0x6600e70,0xff0,0x18001c0,0x6600ff0,0xe700000,0x180,
-      0x1c00660,0xe7001c0,0x0,0x0,0x0,0x380,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,
-      0x0,0x3c00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c00380,
-      0xc300ce0,0xe700630,0x0,0x1c00380,0xc300e70,0x1c00380,0xc300e70,0xce0,0x1c00380,0xc300ce0,0xe700000,0x1c0,0x3800c30,0xe700380,
-      0x0,0x0,0x0,0x7c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0xe000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1800000,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0xc300000,0x0,0xc300000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x700000,0x0,0x0,0x0,0x7c007c00,0x3e000000,
-      0x0,0x0,0x630,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe000070,0x1800000,0xc60,0x0,0xe000070,0x1800000,0xe000070,
-      0x1800000,0x0,0xe000070,0x1800000,0x0,0xe00,0x700180,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x800000,0x0,0x600600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x3f0,0xfc0,0x0,0x7000000,0x38000000,0x1c0000,0xfc0000,0x380001c0,0xe01c00,0x7f800000,0x0,0x0,0x0,0x0,0x0,0x0,0x7c,
-      0x1801f00,0x0,0x0,0x1c,0x0,0x0,0x3c00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7300000,0x6600000,0x0,0x6600000,0x0,0x0,0x0,0x0,0xe700000,
-      0x0,0x0,0x0,0x0,0x0,0xe00000,0x0,0x0,0x0,0xc000c00,0x43800000,0x0,0x0,0x630,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0xf80,0x70000e0,0x3c00730,0xe700c60,0x0,0x70000e0,0x3c00e70,0x70000e0,0x3c00e70,0xe000730,0x70000e0,0x3c00730,0xe700000,0x700,
-      0xe003c0,0xe7000e0,0x38000e70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x6300000,0x803c00,0x7c00180,
-      0xc00300,0x1000000,0x0,0x1c,0x3c007c0,0xfc007e0,0xe01ff8,0x3f03ffc,0x7e007c0,0x0,0x0,0x7c0,0x1c0,0x7f8003f0,0x7f007ff8,0x7ff803f0,
-      0x70381ffc,0xff0700e,0x7000783c,0x783807c0,0x7fc007c0,0x7fc00fc0,0x7fff7038,0x700ee007,0x780f780f,0x7ffc03f0,0x70000fc0,0x3c00000,
-      0x3000000,0x38000000,0x1c0000,0x1fc0000,0x380001c0,0xe01c00,0x7f800000,0x0,0x0,0x0,0x0,0x0,0x0,0xfc,0x1801f80,0x0,0x1f80000,
-      0x7e,0x0,0x0,0x2400000,0xfc00000,0x7ff0000,0x7ffc0000,0x0,0x0,0x0,0x0,0xf30fb0c,0x2400000,0x0,0x240780f,0x1c0,0xfc,0x780f,
-      0x18003f0,0xe700000,0x7c00000,0x0,0xff0,0x3c00000,0x78007c0,0xc00000,0xff80000,0xf80,0x7c00000,0xc000c00,0x18001c0,0x1c001c0,
-      0x1c001c0,0x1c003e0,0x7fe03f0,0x7ff87ff8,0x7ff87ff8,0x1ffc1ffc,0x1ffc1ffc,0x7f007838,0x7c007c0,0x7c007c0,0x7c00000,0x7c67038,
-      0x70387038,0x7038780f,0x70001fe0,0x30000c0,0x2400f30,0xe700c60,0x0,0x30000c0,0x2400e70,0x30000c0,0x2400e70,0xf700f30,0x30000c0,
-      0x2400f30,0xe700000,0x300,0xc00240,0xe7000c0,0x38000e70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,
-      0x630018c,0x807e00,0xfe00180,0xc00300,0x1000000,0x0,0x38,0xff01fc0,0x3ff01ff0,0x1e01ff8,0x7f83ffc,0x1ff80ff0,0x0,0x0,0xff0,
-      0x1f003e0,0x7fe00ff8,0x7fc07ff8,0x7ff80ff8,0x70381ffc,0xff0701c,0x7000783c,0x78381ff0,0x7fe01ff0,0x7fe01ff0,0x7fff7038,0x781ee007,
-      0x3c1e380e,0x7ffc0380,0x380001c0,0x3c00000,0x1800000,0x38000000,0x1c0000,0x3c00000,0x380001c0,0xe01c00,0x3800000,0x0,0x0,
-      0x0,0x7000000,0x0,0x0,0x1e0,0x18003c0,0x0,0x3fc0000,0x70,0x0,0x0,0x6600000,0x1ff00000,0x1fff0000,0x7ffc0000,0x0,0x0,0x0,0x0,
-      0xcf0239c,0x3c00000,0x0,0x3c0380e,0x1c0,0x2001fe,0x380e,0x18007f8,0xe700000,0x8600000,0x0,0xff0,0x7e00000,0x8c00870,0x1800000,
-      0x1ff80000,0x180,0xc600000,0xc000c00,0x38001c0,0x3e003e0,0x3e003e0,0x3e001c0,0x7fe0ff8,0x7ff87ff8,0x7ff87ff8,0x1ffc1ffc,0x1ffc1ffc,
-      0x7fc07838,0x1ff01ff0,0x1ff01ff0,0x1ff00000,0x1fec7038,0x70387038,0x7038380e,0x70003ce0,0x1800180,0x6600cf0,0xe7007c0,0x0,
-      0x1800180,0x6600e70,0x1800180,0x6600e70,0x7c00cf0,0x1800180,0x6600cf0,0xe700000,0x180,0x1800660,0xe700180,0x38000e70,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x630030c,0x3f0e700,0x1e200180,0x1800180,0x21100000,0x0,
-      0x38,0x1e7819c0,0x38781038,0x1e01c00,0xf080038,0x1c381c38,0x0,0x0,0x1878,0x7fc03e0,0x70e01e18,0x70e07000,0x70001e18,0x703801c0,
-      0x707038,0x70007c7c,0x7c381c70,0x70701c70,0x70703830,0x1c07038,0x381ce007,0x1c1c3c1e,0x3c0380,0x380001c0,0x7e00000,0xc00000,
-      0x38000000,0x1c0000,0x3800000,0x38000000,0x1c00,0x3800000,0x0,0x0,0x0,0x7000000,0x0,0x0,0x1c0,0x18001c0,0x0,0x70c0000,0xe0,
-      0x0,0x0,0xc300000,0x38300000,0x3c700000,0x3c0000,0x0,0x0,0x0,0x0,0xce022f4,0x1800000,0x0,0x1803c1e,0x1c0,0x2003c2,0x3c1e,
-      0x1800e08,0x7e0,0x300000,0x0,0x7e00000,0xe700000,0x600030,0x3000000,0x3f980000,0x180,0x18200000,0xc000c00,0x1e0001c0,0x3e003e0,
-      0x3e003e0,0x3e003e0,0xfe01e18,0x70007000,0x70007000,0x1c001c0,0x1c001c0,0x70e07c38,0x1c701c70,0x1c701c70,0x1c700000,0x3c787038,
-      0x70387038,0x70383c1e,0x70003870,0xc00300,0xc300ce0,0x380,0x0,0xc00300,0xc300000,0xc00300,0xc300000,0xfc00ce0,0xc00300,0xc300ce0,
-      0x0,0xc0,0x3000c30,0x300,0x38000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x630031c,0xff8c300,
-      0x1c000180,0x1800180,0x39380000,0x0,0x70,0x1c3801c0,0x203c001c,0x3e01c00,0x1c000038,0x381c3838,0x0,0x0,0x1038,0xe0e03e0,0x70703c08,
-      0x70707000,0x70003808,0x703801c0,0x707070,0x70007c7c,0x7c383838,0x70383838,0x70387010,0x1c07038,0x381c700e,0x1e3c1c1c,0x780380,
-      0x1c0001c0,0xe700000,0x0,0x38000000,0x1c0000,0x3800000,0x38000000,0x1c00,0x3800000,0x0,0x0,0x0,0x7000000,0x0,0x0,0x1c0,0x18001c0,
-      0x0,0xe000000,0xe0,0x0,0x1000100,0x3800,0x70100000,0x38700000,0x780000,0x1c0,0x7801ce0,0xe380000,0x0,0x2264,0x0,0x0,0x1c1c,
-      0x0,0x200780,0x1c1c,0x1800c00,0x1818,0x7f00000,0x0,0x18180000,0xc300000,0x600070,0x0,0x7f980000,0x180,0x18300000,0xc000c00,
-      0x3000000,0x3e003e0,0x3e003e0,0x3e003e0,0xee03c08,0x70007000,0x70007000,0x1c001c0,0x1c001c0,0x70707c38,0x38383838,0x38383838,
-      0x38380000,0x38387038,0x70387038,0x70381c1c,0x7fc03870,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbc00000,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x38000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x6300318,0xe88c300,0x1c000180,0x38001c0,
-      0xfe00180,0x0,0x70,0x1c3801c0,0x1c001c,0x6e01c00,0x1c000078,0x381c3818,0x0,0x40000,0x40000038,0x1c0607e0,0x70703800,0x70707000,
-      0x70003800,0x703801c0,0x7070e0,0x70007c7c,0x7c383838,0x70383838,0x70387000,0x1c07038,0x381c700e,0xf780e38,0x700380,0x1c0001c0,
-      0x1c380000,0x0,0x38000000,0x1c0000,0x3800000,0x38000000,0x1c00,0x3800000,0x0,0x0,0x0,0x7000000,0x0,0x0,0x1c0,0x18001c0,0x0,
-      0xe000000,0xe0,0x0,0x1000100,0x4400,0x70000000,0x38700000,0x700000,0xe0,0x7001c70,0xe380000,0x0,0x2264,0x0,0x0,0xe38,0x0,
-      0x200700,0xe38,0x1800c00,0x300c,0xc300000,0x0,0x300c0000,0xc300180,0x6003c0,0x0,0x7f980000,0x180,0x18300000,0xc000c00,0x1800000,
-      0x7e007e0,0x7e007e0,0x7e003e0,0xee03800,0x70007000,0x70007000,0x1c001c0,0x1c001c0,0x70707c38,0x38383838,0x38383838,0x38380000,
-      0x38387038,0x70387038,0x70380e38,0x7ff039f0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e00000,0x0,0x0,0x0,0x40000,0x0,0x0,0x38000000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x6300318,0x1c80e700,0x1c000180,0x38001c0,0x3800180,
-      0x0,0xe0,0x381c01c0,0x1c001c,0x6e01c00,0x38000070,0x381c381c,0x0,0x3c0000,0x78000078,0x38030770,0x70707800,0x70387000,0x70007000,
-      0x703801c0,0x7071c0,0x7000745c,0x7638701c,0x7038701c,0x70387000,0x1c07038,0x1c38718e,0x7700f78,0xf00380,0xe0001c0,0x381c0000,
-      0x7e0,0x39e003e0,0x79c03f0,0x3ffc079c,0x39e01fc0,0xfe01c1e,0x3807778,0x39e007e0,0x39e0079c,0x73c07e0,0x7ff83838,0x701ce007,
-      0x783c701c,0x1ffc01c0,0x18001c0,0x0,0x1c000100,0xe0,0x0,0x1000100,0x4200,0x70000000,0x70700100,0xf00100,0x10000e0,0x7000c70,
-      0xc700000,0x0,0x2204,0x7e00000,0x1e380100,0x1ffc0f78,0x0,0xf80700,0xf78,0x1800e00,0x63e6,0x18300000,0x0,0x6fe60000,0xe700180,
-      0xc00060,0x3838,0x7f980000,0x180,0x18300000,0xc000c00,0x18001c0,0x7700770,0x7700770,0x77007f0,0xee07800,0x70007000,0x70007000,
-      0x1c001c0,0x1c001c0,0x70387638,0x701c701c,0x701c701c,0x701c1008,0x707c7038,0x70387038,0x70380f78,0x707039c0,0x7e007e0,0x7e007e0,
-      0x7e007e0,0x1f3c03e0,0x3f003f0,0x3f003f0,0x1fc01fc0,0x1fc01fc0,0x7f039e0,0x7e007e0,0x7e007e0,0x7e00380,0x7ce3838,0x38383838,
-      0x3838701c,0x39e0701c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x6307fff,0x1c807e0c,0xe000180,
-      0x30000c0,0x3800180,0x0,0xe0,0x381c01c0,0x1c001c,0xce01fe0,0x38000070,0x381c381c,0x3800380,0xfc0000,0x7e0000f0,0x30030770,
-      0x70707000,0x70387000,0x70007000,0x703801c0,0x707380,0x700076dc,0x7638701c,0x7038701c,0x70387800,0x1c07038,0x1c3873ce,0x7f00770,
-      0xe00380,0xe0001c0,0x700e0000,0x1ff8,0x3ff00ff0,0xffc0ff8,0x3ffc0ffc,0x3bf01fc0,0xfe01c3c,0x3807f78,0x3bf00ff0,0x3ff00ffc,
-      0x77e0ff0,0x7ff83838,0x3838e007,0x3c783838,0x1ffc01c0,0x18001c0,0x0,0x7ff00380,0x1e0,0x0,0x1000100,0x4200,0x78000000,0x70700380,
-      0xe00380,0x3800060,0xe000e30,0x1c600000,0x0,0x2204,0xff00000,0x7f7c0380,0x1ffc0770,0x1c0,0x3fc0700,0x18040770,0x1800780,0x4e12,
-      0x18300104,0x0,0x4c320000,0x7e00180,0x1c00030,0x3838,0x7f980000,0x180,0x18302080,0xc000c00,0x18001c0,0x7700770,0x7700770,
-      0x7700770,0x1ee07000,0x70007000,0x70007000,0x1c001c0,0x1c001c0,0x70387638,0x701c701c,0x701c701c,0x701c381c,0x705c7038,0x70387038,
-      0x70380770,0x70383b80,0x1ff81ff8,0x1ff81ff8,0x1ff81ff8,0x3fbe0ff0,0xff80ff8,0xff80ff8,0x1fc01fc0,0x1fc01fc0,0xff83bf0,0xff00ff0,
-      0xff00ff0,0xff00380,0xffc3838,0x38383838,0x38383838,0x3ff03838,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x1c0,0x7fff,0x1c803c38,0xf000000,0x70000e0,0xfe00180,0x0,0x1c0,0x381c01c0,0x3c0078,0xce01ff0,0x39e000f0,0x1c38381c,0x3800380,
-      0x3e07ffc,0xf8001f0,0x307b0770,0x70e07000,0x70387000,0x70007000,0x703801c0,0x707700,0x700076dc,0x7638701c,0x7038701c,0x70387e00,
-      0x1c07038,0x1c3873ce,0x3e007f0,0x1e00380,0x70001c0,0x0,0x1038,0x3c381e18,0x1c7c1e3c,0x3801e3c,0x3c7801c0,0xe01c78,0x380739c,
-      0x3c781c38,0x3c381c3c,0x7c21e10,0x7003838,0x3838700e,0x1ef03838,0x3c01c0,0x18001c0,0x0,0x7fe007c0,0x1c0,0x0,0x1000100,0x6400,
-      0x7e000000,0x707007c0,0x1e007c0,0x7c00070,0xe000638,0x18600000,0x0,0x0,0x1e100000,0x73ce07c0,0x3c07f0,0x1c0,0x7240700,0x1ddc3ffe,
-      0x1800de0,0x8c01,0x1870030c,0x0,0x8c310000,0x3c00180,0x3800030,0x3838,0x7f980000,0x180,0x183030c0,0xc000c00,0x430001c0,0x7700770,
-      0x7700770,0x7700770,0x1ce07000,0x70007000,0x70007000,0x1c001c0,0x1c001c0,0x70387638,0x701c701c,0x701c701c,0x701c1c38,0x70dc7038,
-      0x70387038,0x703807f0,0x70383b80,0x10381038,0x10381038,0x10381038,0x21e71e18,0x1e3c1e3c,0x1e3c1e3c,0x1c001c0,0x1c001c0,0x1e383c78,
-      0x1c381c38,0x1c381c38,0x1c380380,0x1c383838,0x38383838,0x38383838,0x3c383838,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x1c0,0x630,0x1e8000e0,0x1f000000,0x70000e0,0x39380180,0x0,0x1c0,0x3b9c01c0,0x3c07f0,0x18e01078,0x3bf800e0,
-      0x7e0383c,0x3800380,0x1f807ffc,0x3f001c0,0x61ff0e38,0x7fc07000,0x70387ff0,0x7ff07000,0x7ff801c0,0x707f00,0x7000729c,0x7338701c,
-      0x7070701c,0x70703fc0,0x1c07038,0x1e7873ce,0x1c003e0,0x3c00380,0x70001c0,0x0,0x1c,0x3c381c00,0x1c3c1c1c,0x3801c3c,0x383801c0,
-      0xe01cf0,0x380739c,0x38381c38,0x3c381c3c,0x7801c00,0x7003838,0x3838700e,0xfe03c78,0x7801c0,0x18001c0,0x0,0x1c000c20,0xff8,
-      0x0,0x1ff01ff0,0x3818,0x3fc00100,0x707e0c20,0x3c00c20,0xc200030,0xc000618,0x18c00000,0x0,0x0,0x1c000080,0xe1ce0c20,0x7803e0,
-      0x1c0,0xe200700,0xff83ffe,0x1801878,0x9801,0x1cf0071c,0x7ffc0000,0x8c310000,0x7ffe,0x7000030,0x3838,0x3f980380,0x180,0xc6038e0,
-      0x7f9c7f9c,0x3e1c01c0,0xe380e38,0xe380e38,0xe380f78,0x1cfc7000,0x7ff07ff0,0x7ff07ff0,0x1c001c0,0x1c001c0,0xfe387338,0x701c701c,
-      0x701c701c,0x701c0e70,0x719c7038,0x70387038,0x703803e0,0x70383b80,0x1c001c,0x1c001c,0x1c001c,0xe71c00,0x1c1c1c1c,0x1c1c1c1c,
-      0x1c001c0,0x1c001c0,0x1c383838,0x1c381c38,0x1c381c38,0x1c380000,0x3c383838,0x38383838,0x38383c78,0x3c383c78,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x630,0xf800380,0x3f830000,0x70000e0,0x31080180,0x0,0x380,0x3b9c01c0,
-      0x7807e0,0x38e00038,0x3c3800e0,0xff01c3c,0x3800380,0x7c000000,0x7c03c0,0x61870e38,0x7fc07000,0x70387ff0,0x7ff070fc,0x7ff801c0,
-      0x707f80,0x7000739c,0x7338701c,0x7ff0701c,0x7fe00ff0,0x1c07038,0xe7073ce,0x1c003e0,0x3800380,0x38001c0,0x0,0x1c,0x381c3800,
-      0x381c380e,0x380381c,0x383801c0,0xe01de0,0x380739c,0x3838381c,0x381c381c,0x7001e00,0x7003838,0x1c70718e,0x7e01c70,0xf00380,
-      0x18001e0,0x1e000000,0x1c001bb0,0xff8,0x0,0x1000100,0xe0,0xff00300,0x707e1bb0,0x3801bb0,0x1bb00010,0x8000308,0x30c00000,0x0,
-      0x0,0x1e0000c0,0xe1ce1bb0,0xf003e0,0x1c0,0x1c203ff8,0x63003e0,0x180181c,0x9801,0xfb00e38,0x7ffc0000,0x8fc10000,0x7ffe,0xe000860,
-      0x3838,0x1f980380,0x180,0x7c01c70,0x1f001f0,0x1f003c0,0xe380e38,0xe380e38,0xe380e38,0x1cfc7000,0x7ff07ff0,0x7ff07ff0,0x1c001c0,
-      0x1c001c0,0xfe387338,0x701c701c,0x701c701c,0x701c07e0,0x731c7038,0x70387038,0x703803e0,0x70383980,0x1c001c,0x1c001c,0x1c001c,
-      0xe73800,0x380e380e,0x380e380e,0x1c001c0,0x1c001c0,0x381c3838,0x381c381c,0x381c381c,0x381c0000,0x387c3838,0x38383838,0x38381c70,
-      0x381c1c70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0xc30,0x7f00e00,0x33c30000,0x70000e0,0x1007ffe,
-      0x0,0x380,0x3b9c01c0,0xf00078,0x30e0001c,0x3c1c01c0,0x1c381fdc,0x0,0x70000000,0x1c0380,0x63030e38,0x70707000,0x70387000,0x700070fc,
-      0x703801c0,0x707b80,0x7000739c,0x7338701c,0x7fc0701c,0x7fc001f0,0x1c07038,0xe703e5c,0x3e001c0,0x7800380,0x38001c0,0x0,0x7fc,
-      0x381c3800,0x381c380e,0x380381c,0x383801c0,0xe01fe0,0x380739c,0x3838381c,0x381c381c,0x7001fc0,0x7003838,0x1c70718e,0x7c01c70,
-      0xe01f00,0x180007c,0x7f8c0000,0x7fc03fb8,0x1c0,0x0,0x1000100,0x700,0x1f00600,0x70703fb8,0x7803fb8,0x3fb80000,0x8000000,0x180,
-      0x0,0x0,0x1fc00060,0xe1ce3fb8,0xe001c0,0x1c0,0x1c203ff8,0xc1801c0,0x180c,0x9801,0x1c70,0xc0000,0x8cc10000,0x180,0xfe007c0,
-      0x3838,0x7980380,0xff0,0xe38,0x3e003e00,0x3e000380,0xe380e38,0xe380e38,0xe380e38,0x38e07000,0x70007000,0x70007000,0x1c001c0,
-      0x1c001c0,0x70387338,0x701c701c,0x701c701c,0x701c03c0,0x731c7038,0x70387038,0x703801c0,0x703838e0,0x7fc07fc,0x7fc07fc,0x7fc07fc,
-      0xe73800,0x380e380e,0x380e380e,0x1c001c0,0x1c001c0,0x381c3838,0x381c381c,0x381c381c,0x381c7ffc,0x38dc3838,0x38383838,0x38381c70,
-      0x381c1c70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0xc60,0xf83878,0x71e30000,0x70000e0,0x1007ffe,
-      0x7f0,0x380,0x381c01c0,0x1e0003c,0x60e0001c,0x381c01c0,0x381c079c,0x0,0x7c000000,0x7c0380,0x63031c1c,0x70307000,0x70387000,
-      0x7000701c,0x703801c0,0x7071c0,0x7000739c,0x71b8701c,0x7000701c,0x71e00078,0x1c07038,0xe703e7c,0x7e001c0,0xf000380,0x38001c0,
-      0x0,0x1ffc,0x381c3800,0x381c3ffe,0x380381c,0x383801c0,0xe01fc0,0x380739c,0x3838381c,0x381c381c,0x7000ff0,0x7003838,0x1ef03bdc,
-      0x3800ee0,0x1e01f00,0x180007c,0x61fc0000,0x7fc07f3c,0x1c0,0x0,0x1000100,0x1800,0x780c00,0x70707f3c,0xf007f3c,0x7f3c0000,0x0,
-      0x3c0,0x3ffcffff,0x0,0xff00030,0xe1fe7f3c,0x1e001c0,0x1c0,0x1c200700,0xc183ffe,0xe0c,0x9801,0x1ff038e0,0xc07f0,0x8c610000,
-      0x180,0x0,0x3838,0x1980380,0x0,0x1ff0071c,0xe000e000,0xe0000f80,0x1c1c1c1c,0x1c1c1c1c,0x1c1c1e38,0x38e07000,0x70007000,0x70007000,
-      0x1c001c0,0x1c001c0,0x703871b8,0x701c701c,0x701c701c,0x701c03c0,0x761c7038,0x70387038,0x703801c0,0x70703870,0x1ffc1ffc,0x1ffc1ffc,
-      0x1ffc1ffc,0xfff3800,0x3ffe3ffe,0x3ffe3ffe,0x1c001c0,0x1c001c0,0x381c3838,0x381c381c,0x381c381c,0x381c7ffc,0x389c3838,0x38383838,
-      0x38380ee0,0x381c0ee0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0xfffc,0xbc60fc,0x70e30000,0x70000e0,
-      0x180,0x7f0,0x700,0x381c01c0,0x3e0001c,0x7ffc001c,0x381c03c0,0x381c001c,0x0,0x1f807ffc,0x3f00380,0x63031ffc,0x70387000,0x70387000,
-      0x7000701c,0x703801c0,0x7071e0,0x7000701c,0x71b8701c,0x7000701c,0x70f00038,0x1c07038,0x7e03e7c,0x77001c0,0xe000380,0x1c001c0,
-      0x0,0x3c1c,0x381c3800,0x381c3ffe,0x380381c,0x383801c0,0xe01fe0,0x380739c,0x3838381c,0x381c381c,0x70003f8,0x7003838,0xee03bdc,
-      0x3c00ee0,0x3c00380,0x18000e0,0xf00000,0x1c007e7c,0x3c0,0x0,0x1000100,0x0,0x381800,0x70707e7c,0xe007e7c,0x7e7c0000,0x0,0x7c0,
-      0x0,0x0,0x3f80018,0xe1fe7e7c,0x3c001c0,0x1c0,0x1c200700,0xc183ffe,0xf0c,0x8c01,0x38e0,0xc07f0,0x8c710000,0x180,0x0,0x3838,
-      0x1980000,0x0,0x71c,0x7000f0,0x700f00,0x1ffc1ffc,0x1ffc1ffc,0x1ffc1ffc,0x3fe07000,0x70007000,0x70007000,0x1c001c0,0x1c001c0,
-      0x703871b8,0x701c701c,0x701c701c,0x701c07e0,0x7c1c7038,0x70387038,0x703801c0,0x7ff03838,0x3c1c3c1c,0x3c1c3c1c,0x3c1c3c1c,
-      0x3fff3800,0x3ffe3ffe,0x3ffe3ffe,0x1c001c0,0x1c001c0,0x381c3838,0x381c381c,0x381c381c,0x381c0000,0x391c3838,0x38383838,0x38380ee0,
-      0x381c0ee0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffc,0x9c01ce,0x70f60000,0x70000e0,0x180,
-      0x0,0x700,0x381c01c0,0x780001c,0x7ffc001c,0x381c0380,0x381c003c,0x0,0x3e07ffc,0xf800380,0x63031ffc,0x70387000,0x70387000,
-      0x7000701c,0x703801c0,0x7070f0,0x7000701c,0x71b8701c,0x7000701c,0x70700038,0x1c07038,0x7e03e7c,0xf7801c0,0x1e000380,0x1c001c0,
-      0x0,0x381c,0x381c3800,0x381c3800,0x380381c,0x383801c0,0xe01fe0,0x380739c,0x3838381c,0x381c381c,0x7000078,0x7003838,0xee03a5c,
-      0x7c00fe0,0x78001c0,0x18001c0,0x0,0x1c003ef8,0x380,0x0,0x1000100,0x810,0x383000,0x70703ef8,0x1e003ef8,0x3ef80000,0x0,0x7c0,
-      0x0,0x0,0x78000c,0xe1c03ef8,0x78001c0,0x1c0,0x1c200700,0x63001c0,0x18003f8,0x4e12,0x1c70,0xc0000,0x4c320000,0x180,0x0,0x3838,
-      0x1980000,0x0,0xe38,0x700118,0x701e00,0x1ffc1ffc,0x1ffc1ffc,0x1ffc1ffc,0x7fe07000,0x70007000,0x70007000,0x1c001c0,0x1c001c0,
-      0x703871b8,0x701c701c,0x701c701c,0x701c0e70,0x7c1c7038,0x70387038,0x703801c0,0x7fc0381c,0x381c381c,0x381c381c,0x381c381c,
-      0x78e03800,0x38003800,0x38003800,0x1c001c0,0x1c001c0,0x381c3838,0x381c381c,0x381c381c,0x381c0000,0x3b1c3838,0x38383838,0x38380fe0,
-      0x381c0fe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1860,0x9c0186,0x707e0000,0x30000c0,0x180,
-      0x0,0xe00,0x183801c0,0xf00001c,0xe0001c,0x181c0380,0x381c0038,0x0,0xfc0000,0x7e000000,0x61873c1e,0x70383800,0x70707000,0x7000381c,
-      0x703801c0,0x707070,0x7000701c,0x70f83838,0x70003838,0x70780038,0x1c07038,0x7e03c3c,0xe3801c0,0x1c000380,0xe001c0,0x0,0x381c,
-      0x381c3800,0x381c3800,0x380381c,0x383801c0,0xe01ef0,0x380739c,0x3838381c,0x381c381c,0x7000038,0x7003838,0xfe03e7c,0xfe007c0,
-      0x70001c0,0x18001c0,0x0,0xe001ff0,0x380,0x0,0x1000100,0x162c,0x381800,0x30701ff0,0x1c001ff0,0x1ff00000,0x0,0x3c0,0x0,0x0,
-      0x380018,0xe1c01ff0,0x70001c0,0x1c0,0x1c200700,0xff801c0,0x18000f0,0x63e6,0xe38,0x0,0x6c3e0000,0x0,0x0,0x3838,0x1980000,0x0,
-      0x1c70,0xf0000c,0xf01c00,0x3c1e3c1e,0x3c1e3c1e,0x3c1e3c1c,0x70e03800,0x70007000,0x70007000,0x1c001c0,0x1c001c0,0x707070f8,
-      0x38383838,0x38383838,0x38381c38,0x38387038,0x70387038,0x703801c0,0x7000381c,0x381c381c,0x381c381c,0x381c381c,0x70e03800,
-      0x38003800,0x38003800,0x1c001c0,0x1c001c0,0x381c3838,0x381c381c,0x381c381c,0x381c0380,0x3e1c3838,0x38383838,0x383807c0,0x381c07c0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18c0,0x9c0186,0x783c0000,0x38001c0,0x180,0x3800000,
-      0x3800e00,0x1c3801c0,0x1e00003c,0xe00038,0x1c1c0780,0x381c0038,0x3800380,0x3c0000,0x78000000,0x61ff380e,0x70383808,0x70707000,
-      0x7000381c,0x703801c0,0x40707078,0x7000701c,0x70f83838,0x70003838,0x70384038,0x1c07038,0x7e03c3c,0x1e3c01c0,0x3c000380,0xe001c0,
-      0x0,0x383c,0x3c381c00,0x1c3c1c00,0x3801c3c,0x383801c0,0xe01c78,0x380739c,0x38381c38,0x3c381c3c,0x7000038,0x7003878,0x7c01e78,
-      0x1ef007c0,0xf0001c0,0x18001c0,0x0,0xe000ee0,0x7800380,0xe380000,0x1001ff0,0x2242,0x40380c00,0x38700ee0,0x3c000ee0,0xee00000,
-      0x0,0x0,0x0,0x0,0x380030,0xe1c00ee0,0xf0001c0,0x1c0,0xe200700,0xdd801c0,0x1800038,0x300c,0x71c,0x0,0x300c0000,0x0,0x0,0x3838,
-      0x1980000,0x0,0x38e0,0xb0000c,0xb01c08,0x380e380e,0x380e380e,0x380e380e,0x70e03808,0x70007000,0x70007000,0x1c001c0,0x1c001c0,
-      0x707070f8,0x38383838,0x38383838,0x3838381c,0x38387038,0x70387038,0x703801c0,0x7000381c,0x383c383c,0x383c383c,0x383c383c,
-      0x70e01c00,0x1c001c00,0x1c001c00,0x1c001c0,0x1c001c0,0x1c383838,0x1c381c38,0x1c381c38,0x1c380380,0x1c383878,0x38783878,0x387807c0,
-      0x3c3807c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x18c0,0x10b801ce,0x3c3e0000,0x38001c0,0x180,
-      0x3800000,0x3801c00,0x1e7801c0,0x3c002078,0xe02078,0x1c380700,0x1c3810f0,0x3800380,0x40000,0x40000380,0x307b380e,0x70701e18,
-      0x70e07000,0x70001c1c,0x703801c0,0x60e0703c,0x7000701c,0x70f83c78,0x70003c70,0x703c70f0,0x1c03870,0x3c01c3c,0x3c1c01c0,0x78000380,
-      0x7001c0,0x0,0x3c7c,0x3c381e18,0x1c7c1e0c,0x3801c3c,0x383801c0,0xe01c38,0x3c0739c,0x38381c38,0x3c381c3c,0x7001078,0x7803c78,
-      0x7c01c38,0x1c780380,0x1e0001c0,0x18001c0,0x0,0x70c06c0,0x7000380,0xe300000,0x1000100,0x2142,0x70f00600,0x3c7006c0,0x780006c0,
-      0x6c00000,0x0,0x0,0x0,0x0,0x10780060,0x73e206c0,0x1e0001c0,0x1c0,0x7240700,0x180c01c0,0x1800018,0x1818,0x30c,0x0,0x18180000,
-      0x0,0x0,0x3c78,0x1980000,0x0,0x30c0,0x130000c,0x1301c18,0x380e380e,0x380e380e,0x380e380e,0x70e01e18,0x70007000,0x70007000,
-      0x1c001c0,0x1c001c0,0x70e070f8,0x3c783c78,0x3c783c78,0x3c781008,0x7c783870,0x38703870,0x387001c0,0x70003a3c,0x3c7c3c7c,0x3c7c3c7c,
-      0x3c7c3c7c,0x79f11e18,0x1e0c1e0c,0x1e0c1e0c,0x1c001c0,0x1c001c0,0x1c783838,0x1c381c38,0x1c381c38,0x1c380380,0x1c383c78,0x3c783c78,
-      0x3c780380,0x3c380380,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x38c0,0x1ff800fc,0x1fee0000,
-      0x1800180,0x180,0x3800000,0x3801c00,0xff01ffc,0x3ffc3ff0,0xe03ff0,0xff00700,0x1ff81fe0,0x3800380,0x0,0x380,0x3000780f,0x7ff00ff8,
-      0x7fc07ff8,0x70000ffc,0x70381ffc,0x7fe0701c,0x7ff8701c,0x70781ff0,0x70001ff0,0x701c7ff0,0x1c01fe0,0x3c01c38,0x380e01c0,0x7ffc0380,
-      0x7001c0,0x0,0x1fdc,0x3ff00ff0,0xffc0ffc,0x3800fdc,0x38383ffe,0xe01c3c,0x1fc739c,0x38380ff0,0x3ff00ffc,0x7001ff0,0x3f81fb8,
-      0x7c01c38,0x3c3c0380,0x1ffc01c0,0x18001c0,0x0,0x3fc0380,0x7000380,0xc70718c,0x1000100,0x2244,0x7ff00200,0x1fff0380,0x7ffc0380,
-      0x3800000,0x0,0x0,0x0,0x0,0x1ff000c0,0x7f7e0380,0x1ffc01c0,0x1c0,0x3fc3ffe,0x1c0,0x1800018,0x7e0,0x104,0x0,0x7e00000,0x7ffe,
-      0x0,0x3fde,0x1980000,0x0,0x2080,0x3300018,0x3300ff0,0x780f780f,0x780f780f,0x780f780e,0xf0fe0ff8,0x7ff87ff8,0x7ff87ff8,0x1ffc1ffc,
-      0x1ffc1ffc,0x7fc07078,0x1ff01ff0,0x1ff01ff0,0x1ff00000,0x7ff01fe0,0x1fe01fe0,0x1fe001c0,0x70003bf8,0x1fdc1fdc,0x1fdc1fdc,
-      0x1fdc1fdc,0x3fbf0ff0,0xffc0ffc,0xffc0ffc,0x3ffe3ffe,0x3ffe3ffe,0xff03838,0xff00ff0,0xff00ff0,0xff00000,0x3ff01fb8,0x1fb81fb8,
-      0x1fb80380,0x3ff00380,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0,0x31c0,0x7e00078,0x7cf0000,0x1800180,
-      0x0,0x3800000,0x3803800,0x3c01ffc,0x3ffc0fe0,0xe01fc0,0x3e00e00,0x7e00f80,0x3800380,0x0,0x380,0x18007007,0x7fc003f0,0x7f007ff8,
-      0x700003f0,0x70381ffc,0x3f80701e,0x7ff8701c,0x707807c0,0x700007c0,0x701e1fc0,0x1c00fc0,0x3c01818,0x780f01c0,0x7ffc0380,0x3801c0,
-      0x0,0xf9c,0x39e003e0,0x79c03f0,0x380079c,0x38383ffe,0xe01c1e,0x7c739c,0x383807e0,0x39e0079c,0x7000fc0,0x1f80f38,0x3801c38,
-      0x781e0380,0x1ffc01c0,0x18001c0,0x0,0x1f80100,0xe000700,0x1c60718c,0x1000100,0x1e3c,0x1fc00100,0x7ff0100,0x7ffc0100,0x1000000,
-      0x0,0x0,0x0,0x0,0xfc00080,0x3e3c0100,0x1ffc01c0,0x1c0,0xf83ffe,0x1c0,0x1800838,0x0,0x0,0x0,0x0,0x7ffe,0x0,0x3b9e,0x1980000,
-      0x0,0x0,0x2300038,0x23003e0,0x70077007,0x70077007,0x70077007,0xe0fe03f0,0x7ff87ff8,0x7ff87ff8,0x1ffc1ffc,0x1ffc1ffc,0x7f007078,
-      0x7c007c0,0x7c007c0,0x7c00000,0xc7c00fc0,0xfc00fc0,0xfc001c0,0x700039f0,0xf9c0f9c,0xf9c0f9c,0xf9c0f9c,0x1f1e03e0,0x3f003f0,
-      0x3f003f0,0x3ffe3ffe,0x3ffe3ffe,0x7e03838,0x7e007e0,0x7e007e0,0x7e00000,0x63e00f38,0xf380f38,0xf380380,0x39e00380,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0xc00300,0x0,0x3000000,0x3800,0x0,0x0,0x0,0x0,
-      0x0,0x300,0x0,0x0,0x1c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe0,0x0,0x0,0x0,0x0,0x380,0x3801c0,0x0,0x0,0x0,0x0,0x1c,0x0,0xe00000,
-      0x0,0x0,0x3800001c,0x0,0x0,0x0,0x700,0x1c0,0x18001c0,0x0,0x0,0xe000700,0x18600000,0x1000100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x1800ff0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x1980000,0x1800000,0x0,0x6300070,0x6300000,0x0,
-      0x0,0x0,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,
-      0x0,0x700,0x38000700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0xc00300,0x0,0x7000000,
-      0x7000,0x0,0x0,0x0,0x0,0x0,0x700,0x0,0x0,0xf040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78,0x0,0x0,0x0,0x0,0x3f0,0x1c0fc0,0x0,0x0,
-      0x0,0x0,0x1c,0x0,0xe00000,0x0,0x0,0x3800001c,0x0,0x0,0x0,0x700,0x1e0,0x18003c0,0x0,0x0,0xc000700,0x18c00000,0x1000000,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x18007e0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x1980000,0xc00000,
-      0x0,0x7f800e0,0x7f80000,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x700,0x38000700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,
-      0x0,0x600600,0x0,0x6000000,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x7fc0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30,0x0,0x0,0x0,0x0,
-      0x3f0,0xfc0,0x0,0x0,0x0,0x0,0x838,0x0,0x1e00000,0x0,0x0,0x3800001c,0x0,0x0,0x0,0xf00,0xfc,0x1801f80,0x0,0x0,0x8008e00,0x30c00000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x1800000,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x1980000,0xc00000,
-      0x0,0x3001c0,0x300000,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0xf00,0x38000f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0xff0,0x0,0x1fc00000,0x0,0x0,0x3800001c,0x0,0x0,0x0,0x3e00,0x7c,0x1801f00,0x0,0x0,0x800fe00,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x1800000,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x0,0x7c00000,0x0,0x3001fc,0x300000,
-      0x0,0x0,0x0,0x3e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x3e00,0x38003e00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff8,0x0,0x0,0x0,0x7e0,0x0,0x1f000000,
-      0x0,0x0,0x3800001c,0x0,0x0,0x0,0x3c00,0x0,0x1800000,0x0,0x0,0x7800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x0,0x7800000,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00,0x38003c00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1800000,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0 };
-
-    // Definition of a 19x38 font
-    const unsigned int font19x38[19*38*256/32] = {
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c380000,0x0,0x1c380,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800007,0x3c003,0x86000000,
-      0x1e00000,0x3,0x80000700,0x3c00000,0x380000,0x70003c00,0x0,0xe1800e,0x1c00,0xf000e18,0x0,0x0,0x700000e0,0x780000,0x7000,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe700000,0x0,0xe700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x38e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c0000e,0x7e003,0xe60071c0,0x7f80000,0x1,0xc0000e00,0x7e0038e,0x1c0000,
-      0xe0007e00,0x38e00000,0xf98007,0x3800,0x1f800f98,0x1c70000,0x0,0x380001c0,0xfc0071,0xc000e000,0x0,0x0,0x0,0x0,0x3e00000,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x7e00000,0x0,0x7e00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x38e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe0001c,0xe7006,0x7c0071c0,0xe180000,0x0,0xe0001c00,0xe70038e,0xe0001,0xc000e700,0x38e00000,
-      0x19f0003,0x80007000,0x39c019f0,0x1c70000,0x0,0x1c000380,0x1ce0071,0xc001c000,0x0,0x0,0x0,0x0,0x7f00000,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,
-      0x0,0x3c00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x38e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x700038,0x1c3806,0x3c0071c0,0xc0c0000,0x0,0x70003800,0x1c38038e,0x70003,0x8001c380,0x38e00000,0x18f0001,0xc000e000,
-      0x70e018f0,0x1c70000,0x0,0xe000700,0x3870071,0xc0038000,0x0,0x0,0x0,0x0,0xe380000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0xe000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60000000,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c38,0x0,0x1,0xc3800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c00000,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0xc0c0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe000003,0x80018000,0x0,0xc180000,
-      0xe,0x380,0x1800000,0xe00000,0x38001800,0x0,0x38,0xe00,0x6000000,0x0,0x1,0xc0000070,0x300000,0x3800,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7000000,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78c00,0xc30,
-      0x0,0x0,0xc3000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800000,0x0,0x0,0x0,0xe0,0x1c000f,0xc0000000,0x0,0x0,
-      0x0,0xc0c0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7000007,0x3c003,0xc6000000,0xc180000,0x7,0x700,
-      0x3c00000,0x700000,0x70003c00,0x0,0xf1801c,0x1c00,0xf000f18,0x0,0x0,0xe00000e0,0x780000,0x7000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x1c007000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfe0000,0xfe000,0x0,0x3800000,0x700000,0x38,
-      0x7,0xe000001c,0x1c00,0x1c00700,0x7fc0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf800e,0x3e0000,0x0,0x0,0x0,0x1e00000,0x0,0x1,
-      0xf8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7cc00,0x660,0x0,0x0,0x66000000,0x0,0x0,0x0,0x0,0x7,0x1c000000,0x0,0x0,0x0,0x3fe00000,
-      0x0,0x0,0x7000000,0x0,0x0,0x0,0x3e0,0x7c001f,0xe0000000,0x0,0x0,0x0,0xe1c0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x1f80,0x380000e,0x7e007,0xe60071c0,0xc180000,0x3,0x80000e00,0x7e0038e,0x380000,0xe0007e00,0x38e00f00,0x1f9800e,
-      0x3800,0x1f801f98,0x1c70000,0x0,0x700001c0,0xfc0071,0xc000e007,0x38e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x1c7000,0x61c00600,0x1e00007e,0x70000,0x18003000,0x1800000,0x0,0x0,0x1c01f0,0x7e003f,0xc003f800,
-      0x1e03ffc,0x7f01ff,0xfc03f000,0x7e000000,0x0,0x0,0xfc0,0x1e,0x7fe000,0x7e03fe00,0x3fff07ff,0xe007e038,0x383ffe0,0xff81c01,
-      0xe1c000f8,0xf8f00e0,0xfc01ffc,0x3f00ff,0xc000fe07,0xfffc7007,0x1c007700,0x73c01ef,0x78ffff,0xfe0380,0xfe000,0x38000000,0x1800000,
-      0x700000,0x38,0x1f,0xe000001c,0x1c00,0x1c00700,0x7fc0000,0x0,0x0,0x0,0x0,0x1c000000,0x0,0x0,0x0,0x3f800e,0x3f8000,0x0,0xfc0000,
-      0x0,0x7f00000,0x0,0x1,0x98000000,0x7f00000,0x3ffe00,0xffff0,0x0,0x0,0x0,0x0,0x0,0xcf81f,0xee3807e0,0x0,0x0,0x7e03c01e,0x1c,
-      0x0,0x1f800000,0xf0078038,0xfc007,0x1c000000,0xfe00000,0x0,0x0,0x3fe000f0,0xf,0xc001f800,0x6000000,0xffc000,0x0,0x1c0007e0,
-      0x360,0x6c0010,0x70000700,0xf0001e,0x3c000,0x78000f00,0x7f800ff,0xf007e01f,0xff83fff0,0x7ffe0fff,0xc1fff03f,0xfe07ffc0,0xfff83fc0,
-      0x7807007,0xe000fc00,0x1f8003f0,0x7e0000,0x1f867,0x70e00e,0x1c01c380,0x38f00787,0x3fe0,0x180000c,0x66006,0x7c0071c0,0xe380000,
-      0x1,0x80000c00,0x660038e,0x180000,0xc0006600,0x38e0078e,0x19f0006,0x3000,0x198019f0,0x1c70000,0x0,0x30000180,0xcc0071,0xc000c007,
-      0x38e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x1c7000,0x61800600,0x7f8001ff,0x70000,
-      0x38003800,0x1800000,0x0,0x0,0x3807fc,0x1fe00ff,0xf00ffe00,0x3e03ffc,0xff81ff,0xfc07fc01,0xff800000,0x0,0x0,0x3fe0,0xfe001e,
-      0x7ff801,0xff83ff80,0x3fff07ff,0xe01ff838,0x383ffe0,0xff81c03,0xc1c000f8,0xf8f80e0,0x3ff01fff,0xffc0ff,0xf003ff87,0xfffc7007,
-      0x1e00f700,0x71c03c7,0x70ffff,0xfe01c0,0xfe000,0x7c000000,0xc00000,0x700000,0x38,0x3f,0xe000001c,0x1c00,0x1c00700,0x7fc0000,
-      0x0,0x0,0x0,0x0,0x1c000000,0x0,0x0,0x0,0x3f800e,0x3f8000,0x0,0x3fe0000,0x0,0xff00000,0x0,0x3,0xc000000,0x1ffc0000,0xfffe00,
-      0xffff0,0x0,0x0,0x0,0x0,0x0,0xc781f,0xee3803c0,0x0,0x0,0x3c01c01c,0x1c,0xc000,0x7fc00000,0x70070038,0x3fe007,0x1c000000,0x1ff80000,
-      0x0,0x0,0x3fe003fc,0x1f,0xe003fc00,0xc000000,0x3ffc000,0x0,0x7c000ff0,0x60,0xc0000,0x30000700,0xf0001e,0x3c000,0x78000f00,
-      0x3f000ff,0xf01ff81f,0xff83fff0,0x7ffe0fff,0xc1fff03f,0xfe07ffc0,0xfff83ff8,0x7c0701f,0xf803ff00,0x7fe00ffc,0x1ff8000,0x7fe67,
-      0x70e00e,0x1c01c380,0x38700707,0x7ff0,0xc00018,0xc3006,0x3c0071c0,0x7f00000,0x0,0xc0001800,0xc30038e,0xc0001,0x8000c300,0x38e003fc,
-      0x18f0003,0x6000,0x30c018f0,0x1c70000,0x0,0x18000300,0x1860071,0xc0018007,0x38e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x1c7000,0xe1801fc0,0x618001ff,0x70000,0x30001800,0x21840000,0x0,0x0,0x380ffe,0x1fe00ff,
-      0xfc0fff00,0x3e03ffc,0x1ff81ff,0xfc0ffe03,0xffc00000,0x0,0x0,0x7ff0,0x3ff803f,0x7ffc03,0xffc3ffc0,0x3fff07ff,0xe03ffc38,0x383ffe0,
-      0xff81c07,0x81c000f8,0xf8f80e0,0x7ff81fff,0x81ffe0ff,0xf80fff87,0xfffc7007,0xe00e700,0x70e0387,0x80f0ffff,0xe001c0,0xe000,
-      0xfe000000,0xe00000,0x700000,0x38,0x3c,0x1c,0x1c00,0x1c00700,0x1c0000,0x0,0x0,0x0,0x0,0x1c000000,0x0,0x0,0x0,0x78000e,0x3c000,
-      0x0,0x7ff0000,0x0,0xf100000,0x0,0x7,0xe000000,0x7ffc0000,0x1fffe00,0xffff0,0x0,0x0,0x0,0x0,0x0,0x3,0xf780180,0x0,0x0,0x1801e03c,
-      0x1c,0xc000,0xffc00000,0x780f0038,0x786000,0x7f00,0x18380000,0x0,0xfe00,0x30c,0x10,0x70020e00,0x1c000000,0x7f8c000,0x0,0x6c001c38,
-      0x60,0xc0000,0x70000700,0x1f8003f,0x7e000,0xfc001f80,0x3f000ff,0xf03ffc1f,0xff83fff0,0x7ffe0fff,0xc1fff03f,0xfe07ffc0,0xfff83ffc,
-      0x7c0703f,0xfc07ff80,0xfff01ffe,0x3ffc000,0xffec7,0x70e00e,0x1c01c380,0x38780f07,0xf070,0xe00038,0x1c3800,0x0,0x3e00000,0x0,
-      0xe0003800,0x1c380000,0xe0003,0x8001c380,0x3e0,0x3,0x8000e000,0x70e00000,0x0,0x0,0x1c000700,0x3870000,0x38007,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x1c7000,0xe3807ff0,0xc0c003c1,0x70000,0x70001c00,
-      0x718e0000,0x0,0x0,0x700f1e,0x1ce00c0,0x3c0c0f80,0x7e03800,0x3e08000,0x381e0f03,0xc1e00000,0x0,0x0,0x7078,0x783c03f,0x701e07,
-      0xc1c383e0,0x38000700,0x7c1c38,0x3801c00,0x381c0f,0x1c000fc,0x1f8f80e0,0x78781c07,0x81e1e0e0,0x780f0180,0xe007007,0xe00e380,
-      0xe0f0783,0x80e0000e,0xe000e0,0xe001,0xef000000,0x0,0x700000,0x38,0x38,0x1c,0x0,0x700,0x1c0000,0x0,0x0,0x0,0x0,0x1c000000,
-      0x0,0x0,0x0,0x70000e,0x1c000,0x0,0xf830000,0x0,0x1e000000,0x0,0x0,0x10000,0x780c0000,0x3e38000,0xe0,0x0,0x0,0x0,0x0,0x0,0x3,
-      0xd580000,0x0,0x0,0xe038,0x1c,0xc000,0xf0400000,0x380e0038,0x702000,0x1ffc0,0xc0000,0x0,0x3ff80,0x606,0x0,0x30000600,0x0,
-      0x7f8c000,0x0,0xc001818,0x60,0xc0003,0xe0000700,0x1f8003f,0x7e000,0xfc001f80,0x73801ee,0x7c1c1c,0x38000,0x70000e00,0xe0001,
-      0xc0003800,0x700383e,0x7c0703c,0x3c078780,0xf0f01e1e,0x3c3c000,0xf0f87,0x70e00e,0x1c01c380,0x38380e07,0xe038,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0xff0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x1c,0x1c7000,0xc380fff0,0xc0c00380,0x70000,0x70001c00,0x3dbc0070,0x0,0x0,0x701e0f,0xe0000,0x1e000380,
-      0x6e03800,0x7800000,0x781c0707,0x80e00000,0x0,0x0,0x4038,0xe00c03f,0x700e07,0x4380f0,0x38000700,0x700438,0x3801c00,0x381c0e,
-      0x1c000ec,0x1b8fc0e0,0xf03c1c03,0xc3c0f0e0,0x3c1e0000,0xe007007,0xe00e380,0xe070703,0xc1e0001e,0xe000e0,0xe001,0xc7000000,
-      0x0,0x700000,0x38,0x38,0x1c,0x0,0x700,0x1c0000,0x0,0x0,0x0,0x0,0x1c000000,0x0,0x0,0x0,0x70000e,0x1c000,0x0,0xe010000,0x0,
-      0x1c000000,0x10,0x20000,0x6c000,0xf0000000,0x3838000,0x1e0,0x0,0xf000f,0xf1e00,0x78f00000,0x0,0x3,0xdd80000,0x0,0x0,0xf078,
-      0x0,0xc001,0xe0000000,0x1c1c0038,0x700000,0x3c1e0,0xc0000,0x0,0x783c0,0x606,0x0,0x30000e00,0x0,0xff8c000,0x0,0xc00300c,0x60,
-      0xc0003,0xe0000000,0x1f8003f,0x7e000,0xfc001f80,0x73801ce,0x70041c,0x38000,0x70000e00,0xe0001,0xc0003800,0x700380f,0x7e07078,
-      0x1e0f03c1,0xe0783c0f,0x781e000,0x1c0787,0x70e00e,0x1c01c380,0x383c1e07,0xff00e038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x878,
-      0x0,0x0,0x0,0x7,0x80000080,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,
-      0x1c7000,0xc301e630,0xc0c00380,0x70000,0xe0000e00,0xff00070,0x0,0x0,0xe01c07,0xe0000,0xe000380,0xce03800,0x7000000,0x701c0707,
-      0x600000,0x0,0x4000010,0x38,0x1c00e07f,0x80700e0e,0x38070,0x38000700,0xe00038,0x3801c00,0x381c1c,0x1c000ec,0x1b8ec0e0,0xe01c1c01,
-      0xc38070e0,0x1c1c0000,0xe007007,0x701c380,0xe078e01,0xc1c0003c,0xe00070,0xe003,0x83800000,0x7f,0x71f000,0x3e003e38,0x3f007ff,
-      0xe01f1c1c,0x7801fc00,0x3fc00701,0xe01c0077,0x8f071e00,0xf801c7c,0x7c700e,0x3e01fc03,0xfff8380e,0xe007700,0x73c0787,0x387ffc,
-      0x70000e,0x1c000,0x0,0xe000000,0x0,0x1c000000,0x10,0x20000,0xc2000,0xe0000000,0x3838000,0x3c0,0x0,0xf000f,0x78e00,0x70e00000,
-      0x0,0x3,0xc980fe0,0x1f0,0xf8000007,0xffc07070,0x0,0x3f801,0xc0000000,0x1e3c0038,0x700000,0x70070,0x7fc0000,0x0,0xe00e0,0x606,
-      0x1c0000,0x70007c00,0x380e,0xff8c000,0x0,0xc00300c,0x60,0xc0000,0x70000000,0x3fc007f,0x800ff001,0xfe003fc0,0x73801ce,0xe0001c,
-      0x38000,0x70000e00,0xe0001,0xc0003800,0x7003807,0x7607070,0xe0e01c1,0xc0383807,0x700e000,0x1c0387,0x70e00e,0x1c01c380,0x381c1c07,
-      0xffc0e0f8,0x3f8007f,0xfe001,0xfc003f80,0x7f007e3,0xe003e001,0xf8003f00,0x7e000fc,0xfe001f,0xc003f800,0x7f00003c,0x38f0007,
-      0xc000f800,0x1f0003e0,0x7c0007,0x8003f0c3,0x80e0701c,0xe0381c0,0x70700387,0x1f01c00e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x1c701f,0xfff1c600,0xc0c00380,0x70000,0xe0000e00,0x3c00070,0x0,0x0,0xe03c07,
-      0x800e0000,0xe000380,0x1ce03800,0x7000000,0x701c0707,0x7003c0,0x780000,0x3c00001e,0x38,0x18006073,0x80700e0e,0x38070,0x38000700,
-      0xe00038,0x3801c00,0x381c38,0x1c000ee,0x3b8ee0e1,0xe01e1c01,0xc78078e0,0x1c1c0000,0xe007007,0x701c387,0xe03de00,0xe3800038,
-      0xe00070,0xe007,0x1c00000,0x1ff,0xc077f801,0xff807fb8,0xff807ff,0xe03fdc1d,0xfc01fc00,0x3fc00703,0xc01c007f,0xdf877f00,0x3fe01dfe,
-      0xff700e,0xff07ff03,0xfff8380e,0x700f700,0x71e0f03,0x80707ffc,0x70000e,0x1c000,0x0,0x1c000008,0x0,0x1c000000,0x10,0x20000,
-      0x82000,0xe0000000,0x7038000,0x80000380,0x2000040,0x7000e,0x38700,0xf1e00000,0x0,0x3,0xc183ff8,0x3fd,0xfc008007,0xffc038e0,
-      0x0,0xffc01,0xc0008008,0xe380038,0x380000,0xe3e38,0x1ffc0040,0x80000000,0x1cfc70,0x606,0x1c0000,0xe0007c00,0x380e,0xff8c000,
-      0x0,0xc00300c,0x8100060,0xc0000,0x30000700,0x39c0073,0x800e7001,0xce0039c0,0x73801ce,0xe0001c,0x38000,0x70000e00,0xe0001,
-      0xc0003800,0x7003807,0x77070f0,0xf1e01e3,0xc03c7807,0x8f00f080,0x83c0787,0x70e00e,0x1c01c380,0x380e3807,0xffe0e1c0,0xffe01ff,
-      0xc03ff807,0xff00ffe0,0x1ffc0ff7,0xf01ff807,0xfc00ff80,0x1ff003fe,0xfe001f,0xc003f800,0x7f0003fc,0x3bf801f,0xf003fe00,0x7fc00ff8,
-      0x1ff0007,0x8007fd83,0x80e0701c,0xe0381c0,0x70380707,0x7f80e01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x1c,0x1c701f,0xfff1c600,0x618081c0,0x70000,0xe0000e00,0x3c00070,0x0,0x0,0xe03803,0x800e0000,0xe000380,0x18e03800,
-      0xf000000,0xf01c0707,0x7003c0,0x780000,0xfc00001f,0x80000078,0x301e6073,0x80700e1c,0x38038,0x38000700,0x1c00038,0x3801c00,
-      0x381c70,0x1c000e6,0x338ee0e1,0xc00e1c01,0xc70038e0,0x1c1c0000,0xe007007,0x701c387,0xe01dc00,0xf7800078,0xe00070,0xe00e,0xe00000,
-      0x3ff,0xe07ffc03,0xffc0fff8,0x1ffc07ff,0xe07ffc1d,0xfe01fc00,0x3fc00707,0x801c007f,0xdf877f80,0x7ff01fff,0x1fff00e,0xff07ff03,
-      0xfff8380e,0x700e380,0xe0e0e03,0x80707ffc,0x70000e,0x1c000,0x0,0x7ffc001c,0x0,0x1c000000,0x10,0x20000,0x82000,0xe0000000,
-      0x7038001,0xc0000780,0x70000e0,0x3800e,0x38700,0xe1c00000,0x0,0x3,0xc183ff8,0x7ff,0xfc01c007,0xffc03de0,0x0,0x1ffc01,0xc001c01c,
-      0xf780038,0x3c0000,0xcff18,0x380c00c1,0x80000000,0x18fe30,0x30c,0x1c0001,0xc0000e00,0x380e,0xff8c000,0x0,0xc00300c,0xc180060,
-      0xc0000,0x30000700,0x39c0073,0x800e7001,0xce0039c0,0xe1c038e,0x1c0001c,0x38000,0x70000e00,0xe0001,0xc0003800,0x7003803,0x877070e0,
-      0x71c00e3,0x801c7003,0x8e0071c0,0x1c380fc7,0x70e00e,0x1c01c380,0x380f7807,0x1e0e380,0x1fff03ff,0xe07ffc0f,0xff81fff0,0x3ffe0fff,
-      0xf03ffc0f,0xfe01ffc0,0x3ff807ff,0xfe001f,0xc003f800,0x7f0007fe,0x3bfc03f,0xf807ff00,0xffe01ffc,0x3ff8007,0x800fff83,0x80e0701c,
-      0xe0381c0,0x70380707,0xffc0e01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x1c701f,
-      0xfff1c600,0x7f8381e0,0x70000,0xc0000600,0xff00070,0x0,0x0,0x1c03803,0x800e0000,0xe000f00,0x38e03fe0,0xe000000,0xe00e0e07,
-      0x7003c0,0x780007,0xf0ffff87,0xf00000f0,0x307fe0f3,0xc0703c1c,0x38038,0x38000700,0x1c00038,0x3801c00,0x381ce0,0x1c000e6,0x338e70e1,
-      0xc00e1c01,0xc70038e0,0x3c1e0000,0xe007007,0x783c38f,0x8e01fc00,0x770000f0,0xe00038,0xe01c,0x700000,0x381,0xe07c1e07,0xc0c1e0f8,
-      0x3c1e0038,0xf07c1f,0xe001c00,0x1c0070f,0x1c0079,0xf3c7c380,0xf0781f07,0x83c1f00f,0xc10f0300,0x1c00380e,0x700e380,0xe0f1e03,
-      0xc0f00078,0x70000e,0x1c000,0x0,0xfff8003e,0x0,0x3c000000,0x10,0x20000,0xc6000,0xf0000000,0x7038003,0xe0000f00,0xf8001f0,
-      0x3801c,0x18300,0xe1800000,0x0,0x3,0xc187818,0x70f,0x9e03e000,0x7801dc0,0x1c,0x3cc401,0xc000efb8,0x7f7f0038,0x3f0000,0x1ce11c,
-      0x300c01c3,0x80000000,0x38c638,0x3fc,0x1c0003,0x80000600,0x380e,0xff8c000,0x0,0xc00300c,0xe1c0060,0xc0010,0x70000700,0x79e00f3,
-      0xc01e7803,0xcf0079e0,0xe1c038e,0x1c0001c,0x38000,0x70000e00,0xe0001,0xc0003800,0x7003803,0x873870e0,0x71c00e3,0x801c7003,
-      0x8e0070e0,0x38381dc7,0x70e00e,0x1c01c380,0x38077007,0xf0e700,0x1c0f0381,0xe0703c0e,0x781c0f0,0x381e083e,0x787c0c1e,0xf03c1e0,
-      0x783c0f07,0x800e0001,0xc0003800,0x7000fff,0x3e1c078,0x3c0f0781,0xe0f03c1e,0x783c000,0x1e0f03,0x80e0701c,0xe0381c0,0x70380f07,
-      0xc1e0e03c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x1,0x8701c600,0x1e0f01e0,0x1,
-      0xc0000700,0x3dbc0070,0x0,0x0,0x1c03803,0x800e0000,0x1e01fe00,0x70e03ff8,0xe3e0001,0xe007fc07,0x80f003c0,0x78001f,0xc0ffff81,
-      0xfc0001e0,0x30e1e0e1,0xc07ff81c,0x38038,0x3ffe07ff,0xc1c0003f,0xff801c00,0x381de0,0x1c000e7,0x738e70e1,0xc00e1c03,0xc70038e0,
-      0x780f8000,0xe007007,0x383838d,0x8e00f800,0x7f0000e0,0xe00038,0xe000,0x0,0x200,0xf0780e07,0x8041c078,0x380e0038,0xe03c1e,
-      0xf001c00,0x1c0071e,0x1c0070,0xe1c783c0,0xe0381e03,0x8380f00f,0xe0000,0x1c00380e,0x381c380,0xe07bc01,0xc0e00078,0x70000e,
-      0x1c000,0x0,0x1c000061,0x0,0x38000000,0x10,0x20000,0x7c000,0x7c000000,0x703fc06,0x10000e00,0x18400308,0x1801c,0x1c381,0xc3800000,
-      0x0,0x0,0x7000,0xe0f,0xe061000,0x7801fc0,0x1c,0x38c001,0xc0007ff0,0x7fff0038,0x77c000,0x19c00c,0x301c0387,0x0,0x30c618,0xf0,
-      0x1c0007,0x600,0x380e,0x7f8c007,0x80000000,0xc001818,0x70e03fc,0x387f871f,0xe0e00700,0x70e00e1,0xc01c3803,0x870070e0,0xe1c038f,
-      0xe1c0001f,0xff03ffe0,0x7ffc0fff,0x800e0001,0xc0003800,0x7003803,0x873870e0,0x71c00e3,0x801c7003,0x8e007070,0x703839c7,0x70e00e,
-      0x1c01c380,0x3807f007,0x70e700,0x10078200,0xf0401e08,0x3c10078,0x200f001c,0x3878041c,0x70380e0,0x701c0e03,0x800e0001,0xc0003800,
-      0x7001e0f,0x3c1e070,0x1c0e0381,0xc070380e,0x701c000,0x1c0f03,0x80e0701c,0xe0381c0,0x701c0e07,0x80e07038,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x3,0x8600e600,0x7803f0,0x1,0xc0000700,0x718e0070,0x0,0x0,0x38038c3,
-      0x800e0000,0x3c01f800,0x60e03ffc,0xeff8001,0xc001f003,0xc1f003c0,0x7800fe,0xffff80,0x3f8003c0,0x60c0e0e1,0xc07fe01c,0x38038,
-      0x3ffe07ff,0xc1c07e3f,0xff801c00,0x381fe0,0x1c000e3,0x638e30e1,0xc00e1c07,0x870038ff,0xf00ff800,0xe007007,0x38381cd,0x9c007000,
-      0x3e0001e0,0xe0001c,0xe000,0x0,0x0,0x70780f0f,0x3c078,0x70070038,0x1e03c1c,0x7001c00,0x1c0073c,0x1c0070,0xe1c701c1,0xe03c1e03,
-      0xc780f00f,0xe0000,0x1c00380e,0x381c387,0xe03f801,0xc0e000f0,0x70000e,0x1c007,0xe0100000,0x1c0000cd,0x80000003,0xffc00000,
-      0x3ff,0x807ff000,0xe0,0x7fc00060,0x703fc0c,0xd8001e00,0x3360066c,0x1c018,0xc181,0x83000000,0x0,0x0,0x7000,0x300e07,0xe0cd800,
-      0xf000f80,0x1c,0x78c00f,0xff0038e0,0x3e00038,0xe1e000,0x19800c,0x383c070e,0x7fffc00,0x30fc18,0x0,0xffff80e,0x20e00,0x380e,
-      0x7f8c007,0x80000000,0xc001c38,0x38703ff,0xf87fff0f,0xcfe00f00,0x70e00e1,0xc01c3803,0x870070e0,0x1e1e078f,0xe1c0001f,0xff03ffe0,
-      0x7ffc0fff,0x800e0001,0xc0003800,0x700ff83,0x871870e0,0x71c00e3,0x801c7003,0x8e007038,0xe03871c7,0x70e00e,0x1c01c380,0x3803e007,
-      0x70e700,0x38000,0x70000e00,0x1c00038,0x7001c,0x38f00038,0x3870070,0xe00e1c01,0xc00e0001,0xc0003800,0x7001c07,0x380e0f0,0x1e1e03c3,
-      0xc078780f,0xf01e000,0x3c0f03,0x80e0701c,0xe0381c0,0x701c0e07,0x80f07038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x3,0x8600ff00,0x1e00778,0x38000001,0xc0000700,0x21843fff,0xe0000000,0x0,0x38039e3,0x800e0000,
-      0x7c01fe00,0xe0e0203e,0xeffc001,0xc00ffe03,0xff700000,0x7f0,0x0,0x7f00380,0x618060e1,0xc07ffc1c,0x38038,0x3ffe07ff,0xc1c07e3f,
-      0xff801c00,0x381ff0,0x1c000e3,0x638e38e1,0xc00e1fff,0x870038ff,0xc003fe00,0xe007007,0x38381cd,0x9c00f800,0x3e0003c0,0xe0001c,
-      0xe000,0x0,0x0,0x7070070e,0x38038,0x70070038,0x1c01c1c,0x7001c00,0x1c00778,0x1c0070,0xe1c701c1,0xc01c1c01,0xc700700e,0xfc000,
-      0x1c00380e,0x381c3c7,0x1e01f001,0xe1e001e0,0xf0000e,0x1e01f,0xf8300000,0x1c00019c,0xc0000003,0xffc00000,0x10,0x20000,0x700,
-      0x1ff000c0,0x703fc19,0xcc003c00,0x67300ce6,0xc038,0xc181,0x83000000,0x0,0x0,0x7e00,0x180e07,0xe19cc00,0x1e000f80,0x1c,0x70c00f,
-      0xff007070,0x3e00038,0xe0f000,0x19800c,0x1fec0e1c,0x7fffc00,0x30f818,0x0,0xffff81f,0xf003fc00,0x380e,0x3f8c007,0x80000000,
-      0x7f800ff0,0x1c3803f,0xe007fc00,0xff800e00,0x70e00e1,0xc01c3803,0x870070e0,0x1c0e070f,0xe1c0001f,0xff03ffe0,0x7ffc0fff,0x800e0001,
-      0xc0003800,0x700ff83,0x871c70e0,0x71c00e3,0x801c7003,0x8e00701d,0xc038e1c7,0x70e00e,0x1c01c380,0x3803e007,0x70e3c0,0x38000,
-      0x70000e00,0x1c00038,0x7001c,0x38e00038,0x3870070,0xe00e1c01,0xc00e0001,0xc0003800,0x7003c07,0x8380e0e0,0xe1c01c3,0x80387007,
-      0xe00e1ff,0xfe381b83,0x80e0701c,0xe0381c0,0x701e1e07,0x707878,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x1c,0x3,0xe007fe0,0x7800e3c,0x38000001,0xc0000700,0x1803fff,0xe0000000,0x0,0x70039c3,0x800e0000,0xf8000f80,
-      0xc0e0000e,0xf83c003,0xc01e0f01,0xff700000,0x7c0,0x0,0x1f00780,0x618061c0,0xe0701e1c,0x38038,0x38000700,0x1c07e38,0x3801c00,
-      0x381e78,0x1c000e3,0xe38e18e1,0xc00e1fff,0x70038ff,0xe0007f80,0xe007007,0x1c701dd,0x9c00f800,0x1c000780,0xe0000e,0xe000,0x0,
-      0x7f,0xf070070e,0x38038,0x7fff0038,0x1c01c1c,0x7001c00,0x1c007f8,0x1c0070,0xe1c701c1,0xc01c1c01,0xc700700e,0x7fc00,0x1c00380e,
-      0x1c381c7,0x1c01f000,0xe1c001c0,0xfe0000e,0xfe1f,0xfff00000,0x7ff003fc,0xe0000003,0xffc00000,0x10,0x20000,0x3800,0x3fc0180,
-      0x703803f,0xce007800,0xff381fe7,0x30,0x0,0xc0,0x0,0x0,0x3fe0,0xc0e07,0xfe3fce00,0x1c000700,0x1c,0x70c00f,0xff006030,0x1c00000,
-      0xe07800,0x19800c,0xfcc1c38,0x7fffc00,0x30d818,0x0,0xffff81f,0xf001f800,0x380e,0xf8c007,0x80000000,0x7f8007e0,0xe1c3fe,0x7fc00f,
-      0xf8001e00,0xe0701c0,0xe0381c07,0x380e070,0x1c0e070e,0x1c0001c,0x38000,0x70000e00,0xe0001,0xc0003800,0x700ff83,0x870c70e0,
-      0x71c00e3,0x801c7003,0x8e00700f,0x8038c1c7,0x70e00e,0x1c01c380,0x3801c007,0xf0e3e0,0x3ff807f,0xf00ffe01,0xffc03ff8,0x7ff03ff,
-      0xf8e0003f,0xff87fff0,0xfffe1fff,0xc00e0001,0xc0003800,0x7003803,0x8380e0e0,0xe1c01c3,0x80387007,0xe00e1ff,0xfe383383,0x80e0701c,
-      0xe0381c0,0x700e1c07,0x703870,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x3,0xc000ff0,
-      0x3c1e1c1c,0x38000001,0xc0000700,0x1803fff,0xe0000007,0xf8000000,0x7003803,0x800e0001,0xf0000381,0xc0e00007,0xf01e003,0x801c0700,
-      0x7c700000,0x7c0,0x0,0x1f00700,0x618061c0,0xe0700e1c,0x38038,0x38000700,0x1c00e38,0x3801c00,0x381e38,0x1c000e1,0xc38e1ce1,
-      0xc00e1ffc,0x70038e0,0xf0000780,0xe007007,0x1c701dd,0xdc01fc00,0x1c000780,0xe0000e,0xe000,0x0,0x1ff,0xf070070e,0x38038,0x7fff0038,
-      0x1c01c1c,0x7001c00,0x1c007f8,0x1c0070,0xe1c701c1,0xc01c1c01,0xc700700e,0x3ff00,0x1c00380e,0x1c381cd,0x9c00e000,0xe1c003c0,
-      0xf80000e,0x3e18,0x3ff00000,0xffe007fd,0xf0000000,0x38000000,0x10,0x20000,0x1c000,0x3c0300,0x703807f,0xdf007801,0xff7c3fef,
-      0x80000000,0x0,0x3e0,0x7ffe7ff,0xff000000,0x1ff8,0x60e07,0xfe7fdf00,0x3c000700,0x1c,0x70c001,0xc0006030,0x7fff0000,0xf03800,
-      0x19800c,0x1c38,0x1c07,0xf830cc18,0x0,0x1c0000,0x0,0x380e,0x18c007,0x80000000,0x0,0xe1cfe0,0x1fc003f,0x80003c00,0xe0701c0,
-      0xe0381c07,0x380e070,0x1c0e070e,0x1c0001c,0x38000,0x70000e00,0xe0001,0xc0003800,0x7003803,0x870e70e0,0x71c00e3,0x801c7003,
-      0x8e007007,0x3981c7,0x70e00e,0x1c01c380,0x3801c007,0x1e0e0f8,0xfff81ff,0xf03ffe07,0xffc0fff8,0x1fff07ff,0xf8e0003f,0xff87fff0,
-      0xfffe1fff,0xc00e0001,0xc0003800,0x7003803,0x8380e0e0,0xe1c01c3,0x80387007,0xe00e1ff,0xfe386383,0x80e0701c,0xe0381c0,0x700e1c07,
-      0x703870,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0x7f,0xffc00678,0x707f9c1e,0x38000001,
-      0xc0000700,0x70,0x7,0xf8000000,0xe003803,0x800e0003,0xe00001c3,0x80e00007,0xe00e007,0x80380380,0x700000,0x7f0,0x0,0x7f00700,
-      0x618061ff,0xe070071c,0x38038,0x38000700,0x1c00e38,0x3801c00,0x381c3c,0x1c000e1,0xc38e1ce1,0xc00e1c00,0x70038e0,0x700003c0,
-      0xe007007,0x1c701d8,0xdc03dc00,0x1c000f00,0xe00007,0xe000,0x0,0x3ff,0xf070070e,0x38038,0x7fff0038,0x1c01c1c,0x7001c00,0x1c007fc,
-      0x1c0070,0xe1c701c1,0xc01c1c01,0xc700700e,0x3f00,0x1c00380e,0x1c381cd,0x9c01f000,0x73800780,0xfe0000e,0xfe10,0x7c00000,0x1c000ffb,
-      0xf8000000,0x38000000,0x10,0x20000,0x20000,0x1e0700,0x70380ff,0xbf80f003,0xfefe7fdf,0xc0000000,0x0,0x3f0,0x7ffe7ff,0xff000000,
-      0x1f8,0x30e07,0xfeffbf80,0x78000700,0x1c,0x70c001,0xc0006030,0x7fff0000,0x783800,0x1ce11c,0xe1c,0x1c07,0xf838ce38,0x0,0x1c0000,
-      0x0,0x380e,0x18c000,0x0,0x0,0x1c38c00,0x1800030,0x7800,0xfff01ff,0xe03ffc07,0xff80fff0,0x3fff0ffe,0x1c0001c,0x38000,0x70000e00,
-      0xe0001,0xc0003800,0x7003803,0x870e70e0,0x71c00e3,0x801c7003,0x8e00700f,0x803b81c7,0x70e00e,0x1c01c380,0x3801c007,0xffe0e03c,
-      0x1fff83ff,0xf07ffe0f,0xffc1fff8,0x3fff0fff,0xf8e0003f,0xff87fff0,0xfffe1fff,0xc00e0001,0xc0003800,0x7003803,0x8380e0e0,0xe1c01c3,
-      0x80387007,0xe00e000,0x38c383,0x80e0701c,0xe0381c0,0x70073807,0x701ce0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0xffc0063c,0x40619c0f,0x30000001,0xc0000700,0x70,0x7,0xf8000000,0xe003803,0x800e0007,0xc00001c3,
-      0xfffc0007,0xe00e007,0x380380,0xf00000,0xfe,0xffff80,0x3f800700,0x618063ff,0xf070071c,0x38038,0x38000700,0x1c00e38,0x3801c00,
-      0x381c1e,0x1c000e0,0x38e0ee1,0xc00e1c00,0x70038e0,0x380001c0,0xe007007,0x1ef01d8,0xdc038e00,0x1c001e00,0xe00007,0xe000,0x0,
-      0x7c0,0x7070070e,0x38038,0x70000038,0x1c01c1c,0x7001c00,0x1c0079e,0x1c0070,0xe1c701c1,0xc01c1c01,0xc700700e,0x780,0x1c00380e,
-      0xe701cd,0x9c01f000,0x73800f00,0xe0000e,0xe000,0x0,0x1c0007f7,0xf0000000,0x70000000,0x10,0x20000,0x0,0xe0e00,0x703807f,0x7f01e001,
-      0xfdfc3fbf,0x80000000,0x0,0x7f0,0x0,0x0,0x3c,0x18e07,0x7f7f00,0xf0000700,0x1c,0x70c001,0xc0007070,0x1c00000,0x3e7000,0xcff18,
-      0x3ffc070e,0x1c07,0xf818c630,0x0,0x1c0000,0x0,0x380e,0x18c000,0x0,0x3ffc,0x3870000,0xe000fc00,0x380f000,0x1fff83ff,0xf07ffe0f,
-      0xffc1fff8,0x3fff0ffe,0x1c0001c,0x38000,0x70000e00,0xe0001,0xc0003800,0x7003803,0x870770e0,0x71c00e3,0x801c7003,0x8e00701d,
-      0xc03f01c7,0x70e00e,0x1c01c380,0x3801c007,0xffc0e01c,0x3e0387c0,0x70f80e1f,0x1c3e038,0x7c071e1c,0xe00038,0x70000,0xe0001c00,
-      0xe0001,0xc0003800,0x7003803,0x8380e0e0,0xe1c01c3,0x80387007,0xe00e000,0x398383,0x80e0701c,0xe0381c0,0x70073807,0x701ce0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0xffc0061c,0xc0dc07,0xf0000001,0xc0000700,
-      0x70,0x0,0x0,0x1c003c07,0x800e000f,0x1c3,0xfffc0007,0xe00e007,0x380380,0xe00000,0x1f,0xc0ffff81,0xfc000700,0x618063ff,0xf070070e,
-      0x38070,0x38000700,0xe00e38,0x3801c00,0x381c0e,0x1c000e0,0x38e0ee1,0xe01e1c00,0x78078e0,0x380001c0,0xe007007,0xee01f8,0xfc078f00,
-      0x1c001c00,0xe00003,0x8000e000,0x0,0x700,0x7070070e,0x38038,0x70000038,0x1c01c1c,0x7001c00,0x1c0070e,0x1c0070,0xe1c701c1,
-      0xc01c1c01,0xc700700e,0x380,0x1c00380e,0xe700ed,0xb803f800,0x77800f00,0x70000e,0x1c000,0x0,0xe0003f7,0xe0000000,0x70000000,
-      0x10,0x20000,0x1c0e0,0xe1c00,0x703803f,0x7e01c000,0xfdf81fbf,0x0,0x0,0x3f0,0x0,0x0,0x1c,0x1ce07,0x3f7e00,0xf0000700,0x1c,
-      0x70c001,0xc00038e0,0x1c00038,0xf7000,0xe3e38,0x3ffc0387,0x1c00,0x1cc770,0x0,0x1c0000,0x0,0x380e,0x18c000,0x0,0x3ffc,0x70e0001,
-      0xe001fe00,0x780e000,0x1fff83ff,0xf07ffe0f,0xffc1fff8,0x3fff0ffe,0xe0001c,0x38000,0x70000e00,0xe0001,0xc0003800,0x7003807,
-      0x70770f0,0xf1e01e3,0xc03c7807,0x8f00f038,0xe03e03c7,0x70e00e,0x1c01c380,0x3801c007,0xff00e00e,0x38038700,0x70e00e1c,0x1c38038,
-      0x70071c1c,0xe00038,0x70000,0xe0001c00,0xe0001,0xc0003800,0x7003803,0x8380e0e0,0xe1c01c3,0x80387007,0xe00e000,0x3b0383,0x80e0701c,
-      0xe0381c0,0x70077807,0x701de0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x1c00061c,
-      0xc0de03,0xe0000001,0xc0000700,0x70,0x0,0x0,0x1c001c07,0xe001e,0x1c3,0xfffc0007,0x600e00e,0x380380,0xe00000,0x7,0xf0ffff87,
-      0xf0000000,0x60c0e380,0x7070070e,0x38070,0x38000700,0xe00e38,0x3801c00,0x381c0f,0x1c000e0,0x38e06e0,0xe01c1c00,0x38070e0,
-      0x1c0001c0,0xe007007,0xee00f8,0xf80f0700,0x1c003c00,0xe00003,0x8000e000,0x0,0x700,0x70780f0f,0x3c078,0x70000038,0x1e03c1c,
-      0x7001c00,0x1c0070f,0x1c0070,0xe1c701c1,0xe03c1e03,0xc780f00e,0x380,0x1c00380e,0xe700f8,0xf807bc00,0x3f001e00,0x70000e,0x1c000,
-      0x0,0xe0001ff,0xc0000000,0x70000000,0x10,0x20000,0x33110,0xe0e00,0x383801f,0xfc03c000,0x7ff00ffe,0x0,0x0,0x3e0,0x0,0x0,0x1c,
-      0x38e07,0x1ffc01,0xe0000700,0x1c,0x78c001,0xc0007ff0,0x1c00038,0x7c000,0x70070,0x1c3,0x80001c00,0xe00e0,0x0,0x1c0000,0x0,
-      0x380e,0x18c000,0x0,0x0,0xe1c0001,0xe0010700,0x780e000,0x1c038380,0x70700e0e,0x1c1c038,0x78070e0e,0xe0001c,0x38000,0x70000e00,
-      0xe0001,0xc0003800,0x7003807,0x7037070,0xe0e01c1,0xc0383807,0x700e070,0x701c0387,0x70e00e,0x1c01c380,0x3801c007,0xe00e,0x38038700,
-      0x70e00e1c,0x1c38038,0x70071c1c,0xf00038,0x70000,0xe0001c00,0xe0001,0xc0003800,0x7003c07,0x8380e0f0,0x1e1e03c3,0xc078780f,
-      0xf01e007,0x803e0783,0x80e0701c,0xe0381c0,0x7003f007,0x80f00fc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x6,0x1800061c,0xc0de01,0xc0000000,0xc0000e00,0x70,0xf0000,0x3c00,0x38001c0f,0xe003c,0x3c0,0xe0000e,0x701e00e,
-      0x3c0780,0x1e003c0,0x780000,0xfc00001f,0x80000000,0x60e1e780,0x78700f07,0x4380f0,0x38000700,0xf00e38,0x3801c00,0xc0781c07,
-      0x81c000e0,0x38e07e0,0xe03c1c00,0x380f0e0,0x1e0003c0,0xe00780f,0xee00f0,0x780e0780,0x1c007800,0xe00001,0xc000e000,0x0,0x700,
-      0xf0780e07,0x8041c078,0x38020038,0xe03c1c,0x7001c00,0x1c00707,0x801c0070,0xe1c701c0,0xe0381e03,0x8380f00e,0x80380,0x1c003c1e,
-      0x7e00f8,0xf80f1e00,0x3f003c00,0x70000e,0x1c000,0x0,0xf0100f7,0x80078000,0x700078f0,0x10,0x7ff000,0x61208,0x1e0700,0x383800f,
-      0x78078000,0x3de007bc,0x0,0x0,0x0,0x0,0x0,0x401c,0x70e0f,0xf7803,0xc0000700,0x1c,0x38c001,0xc000efb8,0x1c00038,0x1e000,0x3c1e0,
-      0xc1,0x80000000,0x783c0,0x0,0x0,0x0,0x3c1e,0x18c000,0x0,0x0,0xc180003,0x60000300,0xd80e010,0x3c03c780,0x78f00f1e,0x1e3c03c,
-      0x70039c0e,0x70041c,0x38000,0x70000e00,0xe0001,0xc0003800,0x700380f,0x703f070,0x1e0e03c1,0xc078380f,0x701e0e0,0x381c0787,
-      0x80f0f01e,0x1e03c3c0,0x7801c007,0xe00e,0x38078700,0xf0e01e1c,0x3c38078,0x700f1c1c,0x78041c,0x1038020,0x70040e00,0x800e0001,
-      0xc0003800,0x7001c07,0x380e070,0x1c0e0381,0xc070380e,0x701c007,0x801e0703,0xc1e0783c,0xf0781e0,0xf003f007,0x80e00fc0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0xe,0x1801867c,0xc0cf83,0xe0000000,0xe0000e00,
-      0x70,0xf0000,0x3c00,0x38000f1e,0xe0070,0x180780,0xe0603e,0x783c01e,0x1e0f01,0x7c003c0,0x780000,0x3c00001e,0x700,0x307fe700,
-      0x38701e07,0xc1c383e0,0x38000700,0x7c1e38,0x3801c00,0xe0f01c03,0x81c000e0,0x38e03e0,0x78781c00,0x1e1e0e0,0xe180780,0xe003c1e,
-      0x7c00f0,0x781e03c0,0x1c007000,0xe00001,0xc000e000,0x0,0x783,0xf07c1e07,0xc0c1e0f8,0x3e0e0038,0xf07c1c,0x7001c00,0x1c00703,
-      0xc01e0070,0xe1c701c0,0xf0781f07,0x83c1f00e,0xe0f80,0x1e003c3e,0x7e00f8,0xf80e0e00,0x3f003800,0x70000e,0x1c000,0x0,0x7830077,
-      0xf0000,0x700078f0,0x10,0x20000,0x41208,0xc03c0380,0x3c38007,0x70070000,0x1dc003b8,0x0,0x0,0x0,0x0,0x0,0x707c,0x6070f,0x86077003,
-      0x80000700,0x1c,0x3ec401,0xc001c01c,0x1c00038,0xf000,0x1ffc0,0x40,0x80000000,0x3ff80,0x0,0x0,0x0,0x3e3e,0x18c000,0x0,0x0,
-      0x8100006,0x60000300,0x1980f070,0x3801c700,0x38e0071c,0xe3801c,0x70039c0e,0x7c1c1c,0x38000,0x70000e00,0xe0001,0xc0003800,
-      0x700383e,0x701f03c,0x3c078780,0xf0f01e1e,0x3c3c1c0,0x1c3f0f03,0xc1e0783c,0xf0781e0,0xf001c007,0xe81e,0x3c1f8783,0xf0f07e1e,
-      0xfc3c1f8,0x783f1e3e,0x187c0c1f,0x703e0e0,0x7c1c0f83,0x800e0001,0xc0003800,0x7001e0f,0x380e078,0x3c0f0781,0xe0f03c1e,0x783c007,
-      0x801e0f03,0xc3e0787c,0xf0f81e1,0xf003f007,0xc1e00fc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x1c,0xe,0x3801fff8,0x6187ff,0xe0000000,0xe0000e00,0x70,0xf0000,0x3c00,0x38000ffe,0x1fff0ff,0xfe1fff80,0xe07ffc,0x3ffc01c,
-      0x1fff01,0xff8003c0,0x780000,0x4000010,0x700,0x301e6700,0x387ffe03,0xffc3ffc0,0x3fff0700,0x3ffe38,0x383ffe0,0xfff01c03,0xc1fff8e0,
-      0x38e03e0,0x7ff81c00,0x1ffe0e0,0xf1fff80,0xe003ffe,0x7c00f0,0x781c01c0,0x1c00ffff,0xe00001,0xc000e000,0x0,0x3ff,0x707ffc03,
-      0xffc0fff8,0x1ffe0038,0x7ffc1c,0x707fff0,0x1c00701,0xc00ff070,0xe1c701c0,0x7ff01fff,0x1fff00e,0xfff00,0xff81fee,0x7e00f0,
-      0x781e0f00,0x1e007ffc,0x70000e,0x1c000,0x0,0x3ff003e,0xf0000,0xe00070e0,0x60830010,0x20000,0x41208,0xfffc01c0,0x1fffe03,0xe00ffff0,
-      0xf8001f0,0x0,0x0,0x0,0x0,0x0,0x7ff8,0xc07fd,0xfe03e007,0xffc00700,0x1c,0x1ffc1f,0xffc08008,0x1c00038,0x7000,0x7f00,0x0,0x0,
-      0xfe00,0x0,0xffff800,0x0,0x3ff7,0x8018c000,0x0,0x0,0x6,0x60000700,0x19807ff0,0x3801c700,0x38e0071c,0xe3801c,0x70039c0f,0xf03ffc1f,
-      0xff83fff0,0x7ffe0fff,0xc1fff03f,0xfe07ffc0,0xfff83ffc,0x701f03f,0xfc07ff80,0xfff01ffe,0x3ffc080,0x83fff03,0xffe07ffc,0xfff81ff,
-      0xf001c007,0xeffc,0x1ffb83ff,0x707fee0f,0xfdc1ffb8,0x3ff70ff7,0xf83ffc0f,0xff01ffe0,0x3ffc07ff,0x83fff87f,0xff0fffe1,0xfffc0ffe,
-      0x380e03f,0xf807ff00,0xffe01ffc,0x3ff8007,0x803ffe01,0xfee03fdc,0x7fb80ff,0x7001e007,0xffc00780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0xc,0x3801fff0,0x7f83fe,0x70000000,0xe0000e00,0x0,0xf0000,0x3c00,0x700007fc,
-      0x1fff0ff,0xfe1ffe00,0xe07ff8,0x1ff801c,0xffe01,0xff0003c0,0x780000,0x0,0x700,0x38000f00,0x3c7ffc01,0xff83ff80,0x3fff0700,
-      0x1ffc38,0x383ffe0,0x7fe01c01,0xe1fff8e0,0x38e03e0,0x3ff01c00,0xffc0e0,0x71fff00,0xe001ffc,0x7c00f0,0x783c01e0,0x1c00ffff,
-      0xe00000,0xe000e000,0x0,0x1ff,0x7077f801,0xff807fb8,0xffc0038,0x3fdc1c,0x707fff0,0x1c00701,0xe007f070,0xe1c701c0,0x3fe01dfe,
-      0xff700e,0x7fe00,0xff80fee,0x3c0070,0x703c0780,0x1e007ffc,0x70000e,0x1c000,0x0,0x1fe001c,0xe0000,0xe000e1c0,0x71c78010,0x20000,
-      0x21318,0xfff800c0,0xfffe01,0xc00ffff0,0x70000e0,0x0,0x0,0x0,0x0,0x0,0x3ff0,0x1803fd,0xfe01c007,0xffc00700,0x1c,0xffc1f,0xffc00000,
-      0x1c00038,0x7000,0x0,0x0,0x0,0x0,0x0,0xffff800,0x0,0x3ff7,0x8018c000,0x0,0x0,0xc,0x60000e00,0x31803fe0,0x7801ef00,0x3de007bc,
-      0xf7801e,0xf003fc0f,0xf01ff81f,0xff83fff0,0x7ffe0fff,0xc1fff03f,0xfe07ffc0,0xfff83ff8,0x701f01f,0xf803ff00,0x7fe00ffc,0x1ff8000,
-      0x67fe01,0xffc03ff8,0x7ff00ff,0xe001c007,0xeff8,0xffb81ff,0x703fee07,0xfdc0ffb8,0x1ff70ff7,0xf81ff807,0xfe00ffc0,0x1ff803ff,
-      0x3fff87f,0xff0fffe1,0xfffc07fc,0x380e01f,0xf003fe00,0x7fc00ff8,0x1ff0000,0x37fc00,0xfee01fdc,0x3fb807f,0x7001e007,0x7f800780,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c,0xc,0x30007fc0,0x1e00f8,0x78000000,0x70001c00,
-      0x0,0xe0000,0x3c00,0x700001f0,0x1fff0ff,0xfe07f800,0xe01fe0,0x7e0038,0x3f800,0xfc0003c0,0x700000,0x0,0x700,0x18000e00,0x1c7ff000,
-      0x7e03fe00,0x3fff0700,0x7f038,0x383ffe0,0x1f801c00,0xf1fff8e0,0x38e01e0,0xfc01c00,0x3f80e0,0x787fc00,0xe0007f0,0x7c00f0,0x387800f0,
-      0x1c00ffff,0xe00000,0xe000e000,0x0,0xfc,0x7071f000,0x3f003e38,0x3f00038,0x1f1c1c,0x707fff0,0x1c00700,0xf003f070,0xe1c701c0,
-      0x1f801c7c,0x7c700e,0x1f800,0x3f8078e,0x3c0070,0x707803c0,0x1c007ffc,0x70000e,0x1c000,0x0,0x7c0008,0x1e0000,0xe000e1c0,0x71c30010,
-      0x20000,0x1e1f0,0x3fe00020,0x3ffe00,0x800ffff0,0x2000040,0x0,0x0,0x0,0x0,0x0,0xfc0,0x3001f0,0x78008007,0xffc00700,0x1c,0x3f81f,
-      0xffc00000,0x1c00038,0x407000,0x0,0x0,0x0,0x0,0x0,0xffff800,0x0,0x39c7,0x18c000,0x0,0x0,0x18,0x60001c00,0x61801f80,0x7000ee00,
-      0x1dc003b8,0x77000e,0xe001f80f,0xf007e01f,0xff83fff0,0x7ffe0fff,0xc1fff03f,0xfe07ffc0,0xfff83fc0,0x700f007,0xe000fc00,0x1f8003f0,
-      0x7e0000,0xe1f800,0x7f000fe0,0x1fc003f,0x8001c007,0xe7f0,0x7e380fc,0x701f8e03,0xf1c07e38,0xfc703c1,0xe003f001,0xf8003f00,
-      0x7e000fc,0x3fff87f,0xff0fffe1,0xfffc03f8,0x380e00f,0xc001f800,0x3f0007e0,0xfc0000,0x61f800,0x78e00f1c,0x1e3803c,0x7001c007,
-      0x1f000700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x70001c00,0x0,
-      0x1c0000,0x0,0xe0000000,0x0,0x0,0x0,0x0,0x0,0x0,0xe00000,0x0,0x0,0xc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c000,0x0,
-      0x0,0x0,0x0,0x0,0xe00000,0x7000e000,0x0,0x0,0x0,0x0,0x0,0x1c00,0x0,0x1c00000,0x0,0x0,0x1c00,0x7000,0x0,0x0,0x0,0x0,0x1c000000,
-      0x70000e,0x1c000,0x0,0x0,0x1c0000,0xe000c180,0x10,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,
-      0x0,0x38,0x70e000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x18c000,0x2000,0x0,0x1f,0xf8003800,0x7fe00000,0x0,0x0,0x0,0x0,0x4000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,
-      0x0,0x0,0x1c007,0x700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x30001800,
-      0x0,0x1c0000,0x0,0xe0000000,0x0,0x0,0x0,0x0,0x0,0x0,0xe00000,0x0,0x0,0xe000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e000,
-      0x0,0x0,0x0,0x0,0x0,0xe00000,0x7000e000,0x0,0x0,0x0,0x0,0x0,0x1c00,0x0,0x1c00000,0x0,0x0,0x1c00,0x7000,0x0,0x0,0x0,0x0,0x1c000000,
-      0x70000e,0x1c000,0x0,0x0,0x1c0001,0xe001c380,0x10,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,
-      0x0,0x38,0x7fe000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x18c000,0x3000,0x0,0x1f,0xf8007000,0x7fe00000,0x0,0x0,0x0,0x0,0x6000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x1c007,0x700,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x38003800,
-      0x0,0x380000,0x1,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x1c00000,0x0,0x0,0x3c18000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf000,
-      0x0,0x0,0x0,0x0,0x0,0xfe0000,0x380fe000,0x0,0x0,0x0,0x0,0x0,0x3800,0x0,0x1c00000,0x0,0x0,0x1c00,0x7000,0x0,0x0,0x0,0x0,0x38000000,
-      0x78000e,0x3c000,0x0,0x0,0x180001,0xc0018300,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,0x0,
-      0x38,0x1f8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x18c000,0x1800,0x0,0x0,0x6000e000,0x1800000,0x0,0x0,0x0,0x0,0x3000,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x38007,0xe00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x18003000,
-      0x0,0x300000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1800000,0x0,0x0,0x1ff8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,
-      0x0,0x0,0x0,0xfe0000,0xfe000,0x0,0x0,0x0,0x0,0x0,0x607800,0x0,0x3c00000,0x0,0x0,0x1c00,0x7000,0x0,0x0,0x0,0x0,0x78000000,
-      0x3f800e,0x3f8000,0x0,0x0,0x300043,0xc0018200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,
-      0x0,0x38,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x0,0x11800,0x0,0x0,0x6001ff00,0x1800000,0x0,0x0,0x0,0x0,0x23000,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x23000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78007,
-      0x1e00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x0,0x0,0x1c007000,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfe0000,
-      0xfe000,0x0,0x0,0x0,0x0,0x0,0x7ff000,0x0,0x7f800000,0x0,0x0,0x1c00,0x7000,0x0,0x0,0x0,0x3,0xf8000000,0x3f800e,0x3f8000,0x0,
-      0x0,0x10007f,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,0x0,0x38,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x3800,0x0,0x1f800,0x0,0x0,0x6001ff00,0x1800000,0x0,0x0,0x0,0x0,0x3f000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f8007,0xfe00,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fff8,0x0,0x0,0x0,0x0,0x7fe000,0x0,
-      0x7f000000,0x0,0x0,0x1c00,0x7000,0x0,0x0,0x0,0x3,0xf0000000,0xf800e,0x3e0000,0x0,0x0,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800,0x0,0x1f000,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x3e000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e000,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x3f0007,0xfc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x7fff8,0x0,0x0,0x0,0x0,0x1fc000,0x0,0x7e000000,0x0,0x0,0x1c00,0x7000,0x0,0x0,0x0,0x3,0xc0000000,0xe,0x0,
-      0x0,0x0,0x3e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x3800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0007,0xf000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fff8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 };
-
-    // Definition of a 29x57 font
-    const unsigned int font29x57[29*57*256/32] = {
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x781e00,0x0,0x0,0x7,0x81e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7c0000,0xf8000,0x7e00000,0x0,0x7,
-      0xc0000000,0x0,0x7c00,0xf80,0x7e000,0x0,0x7c00000,0xf80000,0x7e000000,0x0,0x0,0x1f00,0x3e0,0x1f800,0x0,0x0,0x0,0x3,0xe0000000,
-      0x7c00003f,0x0,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x3c3c00,0x0,0x0,0x3,0xc3c00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e1f00,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e0000,
-      0x1f0000,0x7e00000,0xf838001f,0xf80001f,0xf0000000,0x0,0x3e00,0x1f00,0x7e000,0x3e1f000,0x3e00000,0x1f00000,0x7e00003e,0x1f000000,
-      0x3e0,0xe0000f80,0x7c0,0x1f800,0x3e0e00,0x7c3e000,0x0,0x1,0xf0000000,0xf800003f,0x1f0f,0x800001f0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e7800,0x0,0x0,
-      0x1,0xe7800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e1f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e0000,0x1e0000,0xff00001,0xfe38001f,0xf80003f,
-      0xf8000000,0x0,0x1e00,0x1e00,0xff000,0x3e1f000,0x1e00000,0x1e00000,0xff00003e,0x1f000000,0x7f8,0xe0000780,0x780,0x3fc00,0x7f8e00,
-      0x7c3e000,0x0,0x0,0xf0000000,0xf000007f,0x80001f0f,0x800001e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef000,0x0,0x0,0x0,0xef000000,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e1f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0000,0x3c0000,0x1e780003,0xfff8001f,0xf80003c,0x78000000,0x0,0xf00,0x3c00,0x1e7800,
-      0x3e1f000,0xf00000,0x3c00001,0xe780003e,0x1f000000,0xfff,0xe00003c0,0xf00,0x79e00,0xfffe00,0x7c3e000,0x0,0x0,0x78000001,0xe00000f3,
-      0xc0001f0f,0x800003c0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7e000,0x0,0x0,0x0,0x7e000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x3e1f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x78000,0x780000,0x3c3c0003,0x8ff0001f,0xf800078,0x3c000000,0x0,0x780,0x7800,0x3c3c00,0x3e1f000,0x780000,0x7800003,0xc3c0003e,
-      0x1f000000,0xe3f,0xc00001e0,0x1e00,0xf0f00,0xe3fc00,0x7c3e000,0x0,0x0,0x3c000003,0xc00001e1,0xe0001f0f,0x80000780,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x1f,0xf0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x7e000,0x0,0x0,0x0,0x7e000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e1f00,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc00,0x7e000,0xfe000,0x0,0x3c000,0xf00000,0x781e0003,
-      0x83e0001f,0xf800070,0x1c000000,0x0,0x3c0,0xf000,0x781e00,0x3e1f000,0x3c0000,0xf000007,0x81e0003e,0x1f000000,0xe0f,0x800000f0,
-      0x3c00,0x1e0780,0xe0f800,0x7c3e000,0x0,0x0,0x1e000007,0x800003c0,0xf0001f0f,0x80000f00,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0xf8000000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc00,0x1fe000,0x3ff800,0x0,0x0,0x0,0x0,0x0,0x70,0x1c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c,0x78000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x78,0xf000000,0x0,0x0,0x780f0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7c0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x3fc00,0x1fe000,0x3ffc00,0x0,0x0,0x0,0x0,0x0,0x70,0x1c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f00000,0x3e000,0x3e00000,0x0,0x78,0x3c000000,0x0,0x1f000,0x3e0,
-      0x3e000,0x0,0x1f000000,0x3e0000,0x3e000000,0x0,0x0,0x7c00,0xf8,0xf800,0x0,0x0,0x0,0xf,0x80000000,0x1f00001f,0x0,0x3e,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x30000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf80000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0xf80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x781c0000,0x38,0xe000000,0x0,0x0,0x380e0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf80,0x0,0x0,0x0,0x0,0x0,0x0,0x39c00,0x1ce000,0x303e00,
-      0x0,0x0,0x0,0x0,0x0,0x78,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,
-      0x0,0x0,0xf80000,0x7c000,0x3e00000,0xf0380000,0x70,0x1c000000,0x0,0xf800,0x7c0,0x3e000,0x0,0xf800000,0x7c0000,0x3e000000,
-      0x0,0x3c0,0xe0003e00,0x1f0,0xf800,0x3c0e00,0x0,0x0,0x7,0xc0000000,0x3e00001f,0x0,0x7c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0xff,0x0,
-      0xf8,0xf8000,0x1c000,0x0,0x0,0x0,0x0,0x1f,0xc0000000,0x1ff8,0xff00,0x0,0x0,0x3fe000,0x0,0x1fc00001,0xfe000000,0x0,0x0,0x0,
-      0x0,0x7f800,0x0,0x0,0x0,0xff00000,0x0,0x0,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0xf8000000,0xfe,0x0,0x7f80,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x3f,0xf0000000,0x7fe0,0x0,0x0,0x780000,0x1,0xe0000000,0x0,0x780000,0x3,0xfe000000,0x78000,0x3c00,0xf000,0x7800003,0xffe00000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc0000f0,0x3f000,0x0,0x0,0x3fc00,0x0,0x0,0x1fc000,0x0,0x0,0x0,0x1fc0,
-      0x0,0xff000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfe1c0000,0x1c,0x1c000000,0x0,0x0,0x1c1c0,0x0,0x0,0x0,0x0,0x1fe0000,
-      0x0,0x0,0x1ff,0x1f0f8,0x0,0xff000,0x0,0x0,0x0,0x3f,0xff00000f,0x80000000,0xfe0,0x3f80,0xf00,0x0,0x0,0x0,0x1,0xf8000003,0xe0000000,
-      0x1c00,0xe000,0xe00,0x0,0x0,0x0,0x0,0x0,0x3c,0x78000000,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f0,0x3f80,0x1fc00,0xfe000,
-      0x7f0000,0x0,0x1fc07000,0x0,0x0,0x0,0x0,0x0,0x3f800,0x780000,0x78000,0x7f00001,0xfc38001f,0xf800070,0x1c000000,0x0,0x7800,
-      0x780,0x7f000,0x3e1f000,0x7800000,0x780000,0x7f00003e,0x1f0003f0,0x7f0,0xe0001e00,0x1e0,0x1fc00,0x7f0e00,0x7c3e000,0x0,0x3,
-      0xc0000000,0x3c00003f,0x80001f0f,0x80000078,0x1e0000,0x3e1f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x3c1e0000,0x1e078000,0x30000000,0x3ff,0xc00001e0,0xf0,
-      0x78000,0x1c000,0x0,0x0,0x0,0x0,0x1e0007f,0xf000007e,0x1ffff,0x7ffe0,0x1f80,0x3ffff80,0xfff803,0xfffff800,0xfff80007,0xff800000,
-      0x0,0x0,0x0,0x0,0x1ffe00,0x0,0xfe0003,0xfff80000,0x3ffe01ff,0xe00003ff,0xffe01fff,0xff0003ff,0xe01e0007,0x803ffff0,0xfff80,
-      0x3c000fc0,0x7800001f,0x8003f07e,0x1e000f,0xfe0007ff,0xf00003ff,0x8007ffe0,0x1fff8,0x7fffffe,0xf0003c1,0xe000079e,0xf1f,0x1f3e0,
-      0x1f01ff,0xfff8003f,0xf003c000,0x7fe0,0x3f00,0x0,0x3c0000,0x1,0xe0000000,0x0,0x780000,0xf,0xfe000000,0x78000,0x3c00,0xf000,
-      0x7800003,0xffe00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0xfc0000f0,0x3fe00,0x0,0x0,0xfff00,0x0,0x0,0x3fe000,
-      0x0,0x0,0x0,0x1dc0,0x0,0x3fff00,0x0,0x3ffff80,0x1f,0xffff8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff1c07ff,0x3c0f001e,0x3c000000,
-      0x0,0x0,0x1e3c0,0xf80007c,0x0,0x780000,0x0,0xfff8000,0x3e00,0x1f00000,0x7ff,0xc001f0f8,0x0,0x3ffc00,0x0,0x0,0x0,0x3f,0xff00003f,
-      0xe0000000,0x3ff8,0xffe0,0x1e00,0x0,0xfffc00,0x0,0x7,0xf800000f,0xf8000000,0x1c00,0xe000,0xe00,0xf000,0x1fc000,0xfe0000,0x7f00000,
-      0x3f800001,0xfc00003f,0xf80000ff,0xffc003ff,0xe007ffff,0xc03ffffe,0x1fffff0,0xfffff80,0x7fffe003,0xffff001f,0xfff800ff,0xffc01ffc,
-      0xfc00,0x3c001ffc,0xffe0,0x7ff00,0x3ff800,0x1ffc000,0x0,0x7ff8f0f0,0x3c0780,0x1e03c00,0xf01e000,0x783e0001,0xf01e0000,0xffe00,
-      0x3c0000,0xf0000,0x7700001,0xfe38001f,0xf800070,0x1c000000,0x0,0x3c00,0xf00,0x77000,0x3e1f000,0x3c00000,0xf00000,0x7700003e,
-      0x1f0000f8,0xc0007f8,0xe0000f00,0x3c0,0x1dc00,0x7f8e00,0x7c3e000,0x0,0x1,0xe0000000,0x7800003b,0x80001f0f,0x800000f0,0x1e0000,
-      0x3e1f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x780000,0x3c1e0000,0x1e070000,0x300001f0,0x7ff,0xc00001e0,0x1e0,0x7c000,0x1c000,0x0,0x0,0x0,0x0,0x3c000ff,0xf80007fe,
-      0x3ffff,0x801ffff8,0x1f80,0x3ffff80,0x3fff803,0xfffff801,0xfffc000f,0xffc00000,0x0,0x0,0x0,0x0,0x7fff80,0x0,0xfe0003,0xffff0000,
-      0xffff01ff,0xfc0003ff,0xffe01fff,0xff000fff,0xf01e0007,0x803ffff0,0xfff80,0x3c001f80,0x7800001f,0xc007f07e,0x1e001f,0xff0007ff,
-      0xfc0007ff,0xc007fffc,0x3fffc,0x7fffffe,0xf0003c1,0xf0000f9e,0xf0f,0x8003e1e0,0x1e01ff,0xfff8003f,0xf001e000,0x7fe0,0x3f00,
-      0x0,0x1e0000,0x1,0xe0000000,0x0,0x780000,0x1f,0xfe000000,0x78000,0x3c00,0xf000,0x7800003,0xffe00000,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0xf,0xfc0000f0,0x3ff00,0x0,0x0,0x1fff80,0x0,0x0,0xffe000,0x0,0x0,0x0,0x3de0,0x0,0x7fff80,0x0,0xfffff80,
-      0x1f,0xffff8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xe7bc07ff,0x3e1f000f,0x78000000,0x0,0x0,0xf780,0x7800078,0x0,0x780000,0x180000,
-      0x1fff8000,0x1e00,0x1e0003c,0xfff,0xc001f0f8,0x0,0x7ffe00,0x0,0x0,0x0,0x3f,0xff00007f,0xf0000000,0x3ffc,0xfff0,0x3c00,0x0,
-      0x7fffc00,0x0,0x7,0xf800003f,0xfe000000,0x1c00,0xe000,0xe00,0xf000,0x1fc000,0xfe0000,0x7f00000,0x3f800001,0xfc00001f,0xe00001ff,
-      0xffc00fff,0xf007ffff,0xc03ffffe,0x1fffff0,0xfffff80,0x7fffe003,0xffff001f,0xfff800ff,0xffc01fff,0xc000fc00,0x3c003ffe,0x1fff0,
-      0xfff80,0x7ffc00,0x3ffe000,0x0,0xfffce0f0,0x3c0780,0x1e03c00,0xf01e000,0x781e0001,0xe01e0000,0x3fff00,0x1e0000,0x1e0000,0xf780003,
-      0xcf78001f,0xf800078,0x3c000000,0x0,0x1e00,0x1e00,0xf7800,0x3e1f000,0x1e00000,0x1e00000,0xf780003e,0x1f0000fc,0x7c000f3d,
-      0xe0000780,0x780,0x3de00,0xf3de00,0x7c3e000,0x0,0x0,0xf0000000,0xf000007b,0xc0001f0f,0x800001e0,0x1e0000,0x3e1f00,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,
-      0x3c1e0000,0x1e0f0000,0x300007fc,0xfff,0xc00001e0,0x1e0,0x3c000,0x1c000,0x0,0x0,0x0,0x0,0x3c001ff,0xfc001ffe,0x3ffff,0xc01ffffc,
-      0x3f80,0x3ffff80,0x7fff803,0xfffff803,0xfffe001f,0xffe00000,0x0,0x0,0x0,0x0,0xffff80,0x7f800,0xfe0003,0xffff8001,0xffff01ff,
-      0xff0003ff,0xffe01fff,0xff001fff,0xf01e0007,0x803ffff0,0xfff80,0x3c003f00,0x7800001f,0xc007f07f,0x1e003f,0xff8007ff,0xff000fff,
-      0xe007ffff,0x7fffc,0x7fffffe,0xf0003c0,0xf0000f1e,0xf07,0x8003c1f0,0x3e01ff,0xfff8003f,0xf001e000,0x7fe0,0x7f80,0x0,0xe0000,
-      0x1,0xe0000000,0x0,0x780000,0x1f,0xfe000000,0x78000,0x3c00,0xf000,0x7800003,0xffe00000,0x0,0x0,0x0,0x0,0x0,0x0,0x3c000,0x0,
-      0x0,0x0,0x0,0x0,0xf,0xfc0000f0,0x3ff00,0x0,0x0,0x3fff80,0x0,0x0,0xffe000,0x0,0x0,0x0,0x78f0,0x0,0xffff80,0x0,0x3fffff80,0x1f,
-      0xffff8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xc7f80070,0x3e1f0007,0x70000000,0x0,0x0,0x7700,0x7c000f8,0x0,0x780000,0x180000,
-      0x3fff8000,0x1f00,0x3e0003c,0x1f03,0xc001f0f8,0x0,0x703f00,0x0,0x0,0x0,0x3f,0xff0000f0,0xf8000000,0x303e,0xc0f8,0x7800,0x0,
-      0xffffc00,0x0,0x7,0x3800003e,0x3e000000,0x1c00,0xe000,0x3c00,0xf000,0x1fc000,0xfe0000,0x7f00000,0x3f800001,0xfc00000f,0xe00001ff,
-      0xffc01fff,0xf007ffff,0xc03ffffe,0x1fffff0,0xfffff80,0x7fffe003,0xffff001f,0xfff800ff,0xffc01fff,0xf000fe00,0x3c007fff,0x3fff8,
-      0x1fffc0,0xfffe00,0x7fff000,0x1,0xffffc0f0,0x3c0780,0x1e03c00,0xf01e000,0x781f0003,0xe01e0000,0x3fff80,0xe0000,0x3c0000,0x1e3c0003,
-      0x8ff0001f,0xf80003c,0x78000000,0x0,0xe00,0x3c00,0x1e3c00,0x3e1f000,0xe00000,0x3c00001,0xe3c0003e,0x1f00007f,0xf8000e3f,0xc0000380,
-      0xf00,0x78f00,0xe3fc00,0x7c3e000,0x0,0x0,0x70000001,0xe00000f1,0xe0001f0f,0x800003c0,0x1e0000,0x3e1f00,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x3c1e0000,0x3c0f0000,
-      0x30000ffe,0xf80,0xc00001e0,0x3c0,0x1e000,0x101c040,0x0,0x0,0x0,0x0,0x78003f0,0x7e001ffe,0x3f807,0xe01f00fe,0x3f80,0x3ffff80,
-      0x7e01803,0xfffff007,0xe03f003f,0x3f00000,0x0,0x0,0x0,0x0,0xfc0fc0,0x3ffe00,0xfe0003,0xffffc003,0xf81f01ff,0xff8003ff,0xffe01fff,
-      0xff003f01,0xf01e0007,0x803ffff0,0xfff80,0x3c007e00,0x7800001f,0xc007f07f,0x1e007e,0xfc007ff,0xff801f83,0xf007ffff,0x800fc07c,
-      0x7fffffe,0xf0003c0,0xf0000f0f,0x1e07,0xc007c0f8,0x7c01ff,0xfff8003c,0xf000,0x1e0,0xffc0,0x0,0xf0000,0x1,0xe0000000,0x0,0x780000,
-      0x3e,0x0,0x78000,0x3c00,0xf000,0x7800000,0x1e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x3c000,0x0,0x0,0x0,0x0,0x0,0x1f,0x800000f0,0x1f80,
-      0x0,0x0,0x7e0780,0x0,0x0,0x1f82000,0x0,0x0,0x0,0x7070,0x0,0x1f80f80,0x0,0x7fffff80,0x1f,0xffff8000,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x1,0xc3f80070,0x3f3f0007,0xf0000000,0x0,0x0,0x7f00,0x3e001f0,0x0,0x780000,0x180000,0x7f018000,0xf80,0x7c0003c,0x3e00,
-      0x4001f0f8,0xfe00,0x400f00,0x0,0x0,0x0,0x7f000000,0xe0,0x38000000,0x1e,0x38,0x7800,0x0,0x1ffe1c00,0x0,0x0,0x38000078,0xf000000,
-      0x1c00,0xe000,0x7f800,0xf000,0x1fc000,0xfe0000,0x7f00000,0x3f800001,0xfc00001f,0xf00001ff,0xffc03f81,0xf007ffff,0xc03ffffe,
-      0x1fffff0,0xfffff80,0x7fffe003,0xffff001f,0xfff800ff,0xffc01fff,0xf800fe00,0x3c00fc1f,0x8007e0fc,0x3f07e0,0x1f83f00,0xfc1f800,
-      0x3,0xf07fc0f0,0x3c0780,0x1e03c00,0xf01e000,0x780f8007,0xc01e0000,0x7e0fc0,0xf0000,0x3c0000,0x1c1c0003,0x87f0001f,0xf80003f,
-      0xf8000000,0x0,0xf00,0x3c00,0x1c1c00,0x3e1f000,0xf00000,0x3c00001,0xc1c0003e,0x1f00003f,0xc0000e1f,0xc00003c0,0xf00,0x70700,
-      0xe1fc00,0x7c3e000,0x0,0x0,0x78000001,0xe00000e0,0xe0001f0f,0x800003c0,0x1e0000,0x3e1f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x3c1e0000,0x3c0f0001,0xff801e0f,
-      0x1f00,0x1e0,0x3c0,0x1e000,0x3c1c1e0,0x0,0x0,0x0,0x0,0x78007c0,0x1f001f9e,0x3c001,0xf010003e,0x7780,0x3c00000,0xf800000,0xf007,
-      0xc01f007c,0x1f80000,0x0,0x0,0x0,0x0,0xe003e0,0x7fff00,0x1ef0003,0xc007e007,0xc00301e0,0x1fc003c0,0x1e00,0x7c00,0x301e0007,
-      0x80007800,0x780,0x3c00fc00,0x7800001f,0xe00ff07f,0x1e00f8,0x3e00780,0x1fc03e00,0xf807801f,0xc01f001c,0xf000,0xf0003c0,0xf0000f0f,
-      0x1e03,0xc00f8078,0x780000,0xf0003c,0xf000,0x1e0,0x1f3e0,0x0,0x78000,0x1,0xe0000000,0x0,0x780000,0x3c,0x0,0x78000,0x0,0x0,
-      0x7800000,0x1e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x3c000,0x0,0x0,0x0,0x0,0x0,0x1f,0xf0,0xf80,0x0,0x0,0xf80180,0x0,0x0,0x1e00000,
-      0x0,0x0,0x0,0xe038,0x0,0x3e00380,0x0,0xfe0f0000,0x0,0xf0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xc0f00070,0x3b370003,0xe0000000,
-      0x0,0x0,0x3e00,0x1e001e0,0x0,0x780000,0x180000,0x7c000000,0x780,0x780003c,0x3c00,0x0,0x7ffc0,0x780,0x0,0x0,0x3,0xffe00000,
-      0x1c0,0x3c000000,0xe,0x38,0xf000,0x0,0x3ffe1c00,0x0,0x0,0x38000078,0xf000000,0x1c00,0xe000,0x7f000,0xf000,0x3de000,0x1ef0000,
-      0xf780000,0x7bc00003,0xde00001e,0xf00003e7,0x80007c00,0x30078000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,
-      0xe0001e03,0xfc00fe00,0x3c01f007,0xc00f803e,0x7c01f0,0x3e00f80,0x1f007c00,0x7,0xc01f80f0,0x3c0780,0x1e03c00,0xf01e000,0x78078007,
-      0x801e0000,0x7803c0,0x78000,0x780000,0x380e0003,0x81e00000,0x1f,0xf0000000,0x0,0x780,0x7800,0x380e00,0x0,0x780000,0x7800003,
-      0x80e00000,0x1ff,0x80000e07,0x800001e0,0x1e00,0xe0380,0xe07800,0x0,0x0,0x0,0x3c000003,0xc00001c0,0x70000000,0x780,0x1e0000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x780000,0x3c1e0000,0x3c0e0007,0xfff01c07,0x1e00,0x1e0,0x780,0xf000,0x3e1c3e0,0x0,0x0,0x0,0x0,0xf0007c0,0x1f00181e,0x20000,
-      0xf000001f,0xf780,0x3c00000,0x1f000000,0x1f00f,0x800f8078,0xf80000,0x0,0x0,0x0,0x0,0x8003e0,0x1fc0f80,0x1ef0003,0xc001e007,
-      0x800101e0,0x7e003c0,0x1e00,0x7800,0x101e0007,0x80007800,0x780,0x3c00f800,0x7800001e,0xe00ef07f,0x801e00f0,0x1e00780,0x7c03c00,
-      0x78078007,0xc01e0004,0xf000,0xf0003c0,0x78001e0f,0x1e03,0xe00f807c,0xf80000,0x1f0003c,0x7800,0x1e0,0x3e1f0,0x0,0x3c000,0x1,
-      0xe0000000,0x0,0x780000,0x3c,0x0,0x78000,0x0,0x0,0x7800000,0x1e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x3c000,0x0,0x0,0x0,0x0,0x0,
-      0x1e,0xf0,0x780,0x0,0x0,0x1f00080,0x0,0x0,0x3c00000,0x0,0x0,0x0,0x1e03c,0x0,0x3c00080,0x0,0xf80f0000,0x0,0x1f0000,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x70,0x3bf70003,0xe0000000,0x0,0x0,0x3e00,0x1f003e0,0x0,0x780000,0x180000,0x78000000,0x7c0,0xf80003c,
-      0x3c00,0x0,0x1f01f0,0x780,0x0,0x0,0xf,0x80f80000,0x1c0,0x1c000000,0xe,0x38,0x1e000,0x0,0x7ffe1c00,0x0,0x0,0x380000f0,0x7800000,
-      0x1c00,0xe000,0x7fc00,0xf000,0x3de000,0x1ef0000,0xf780000,0x7bc00003,0xde00001e,0xf00003c7,0x80007800,0x10078000,0x3c0000,
-      0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x7e00ff00,0x3c01e003,0xc00f001e,0x7800f0,0x3c00780,0x1e003c00,
-      0x7,0x800f00f0,0x3c0780,0x1e03c00,0xf01e000,0x7807c00f,0x801e0000,0xf803c0,0x3c000,0xf00000,0x780f0000,0x0,0x7,0xc0000000,
-      0x0,0x3c0,0xf000,0x780f00,0x0,0x3c0000,0xf000007,0x80f00000,0x7ff,0xc0000000,0xf0,0x3c00,0x1e03c0,0x0,0x0,0x0,0x0,0x1e000007,
-      0x800003c0,0x78000000,0xf00,0x1e0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x3c1e0000,0x3c1e001f,0xfff03803,0x80001e00,0x1e0,0x780,0xf000,0xf9cf80,
-      0x0,0x0,0x0,0x0,0xf000780,0xf00001e,0x0,0xf800000f,0xe780,0x3c00000,0x1e000000,0x1e00f,0x78078,0x7c0000,0x0,0x0,0x0,0x0,0x1e0,
-      0x3f003c0,0x1ef0003,0xc000f00f,0x800001e0,0x1f003c0,0x1e00,0xf000,0x1e0007,0x80007800,0x780,0x3c01f000,0x7800001e,0xe00ef07f,
-      0x801e01f0,0x1e00780,0x3c07c00,0x78078003,0xc03e0000,0xf000,0xf0003c0,0x78001e0f,0x1e01,0xf01f003c,0xf00000,0x3e0003c,0x7800,
-      0x1e0,0x7c0f8,0x0,0x0,0x1,0xe0000000,0x0,0x780000,0x3c,0x0,0x78000,0x0,0x0,0x7800000,0x1e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x3c000,
-      0x0,0x0,0x0,0x0,0x0,0x1e,0xf0,0x780,0x0,0x0,0x1e00000,0x0,0x0,0x3c00000,0x0,0x8,0x40,0x0,0x7e0000,0x7c00000,0x1,0xf00f0000,
-      0x0,0x3e0000,0x0,0x3f,0xfc0,0xfc3f0,0xfc3f0,0x0,0x0,0x0,0x70,0x39e70000,0x0,0x0,0x0,0x0,0xf003c0,0x0,0x0,0x180000,0xf8000000,
-      0x3c0,0xf00003c,0x3c00,0x0,0x3c0078,0x7ff80,0x0,0x0,0x1e,0x3c0000,0x1c0,0x1c000000,0xe,0xf0,0x0,0x0,0x7ffe1c00,0x0,0x0,0x380000f0,
-      0x7800000,0x1c00,0xe000,0x3c00,0x0,0x3de000,0x1ef0000,0xf780000,0x7bc00003,0xde00001e,0xf00003c7,0x8000f800,0x78000,0x3c0000,
-      0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x1f00ff00,0x3c03e003,0xc01f001e,0xf800f0,0x7c00780,0x3e003c00,
-      0xf,0x800f80f0,0x3c0780,0x1e03c00,0xf01e000,0x7803c00f,0x1fffc0,0xf001e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x307,0xe0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x3c1e0000,0x781e003f,0xfff03803,
-      0x80001e00,0x1e0,0xf80,0xf000,0x3dde00,0x0,0x0,0x0,0x0,0xf000f00,0x780001e,0x0,0x7800000f,0x1e780,0x3c00000,0x3e000000,0x3e00f,
-      0x780f0,0x7c0000,0x0,0x0,0x0,0x0,0x1e0,0x7c001e0,0x3ef8003,0xc000f00f,0x1e0,0xf003c0,0x1e00,0xf000,0x1e0007,0x80007800,0x780,
-      0x3c03e000,0x7800001e,0xf01ef07b,0xc01e01e0,0xf00780,0x3e07800,0x3c078003,0xe03c0000,0xf000,0xf0003c0,0x78001e0f,0x1e00,0xf01e003e,
-      0x1f00000,0x3c0003c,0x7800,0x1e0,0x78078,0x0,0x0,0x1,0xe0000000,0x0,0x780000,0x3c,0x0,0x78000,0x0,0x0,0x7800000,0x1e00000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x3c000,0x0,0x0,0x0,0x0,0x0,0x1e,0xf0,0x780,0x0,0x0,0x1e00000,0x0,0x0,0x3c00000,0x0,0x18,0xc0,0x0,
-      0xe70000,0x7800000,0x1,0xe00f0000,0x0,0x3c0000,0x0,0x3f,0xfc0,0xfc1f0,0x1f83f0,0x0,0x0,0x0,0x70,0x39e70000,0x0,0x0,0x0,0x0,
-      0xf807c0,0x0,0x0,0x180000,0xf0000000,0x3e0,0x1f00003c,0x3e00,0x0,0x70001c,0x3fff80,0x0,0x0,0x38,0xe0000,0x1c0,0x1c000078,
-      0x1c,0x1fe0,0x0,0x0,0xfffe1c00,0x0,0x0,0x380000f0,0x7800000,0x1c00,0xe000,0xe00,0x0,0x7df000,0x3ef8000,0x1f7c0000,0xfbe00007,
-      0xdf00003c,0x780003c7,0x8000f000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0xf00f780,
-      0x3c03c001,0xe01e000f,0xf00078,0x78003c0,0x3c001e00,0xf,0xf80f0,0x3c0780,0x1e03c00,0xf01e000,0x7803e01f,0x1ffff8,0xf001e0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0xe0000000,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,0x0,0x0,0x0,0x0,0x1e0000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x780000,0x3c1e0000,0x781e003e,0x30703803,0x80001e00,0x1e0,0xf00,0x7800,0xff800,0x1e0000,0x0,0x0,0x0,0x1e000f00,0x780001e,
-      0x0,0x7800000f,0x3c780,0x3c00000,0x3c000000,0x3c00f,0x780f0,0x3c0000,0x0,0x0,0x2000000,0x800000,0x1e0,0x78000e0,0x3c78003,
-      0xc000f01e,0x1e0,0xf803c0,0x1e00,0x1e000,0x1e0007,0x80007800,0x780,0x3c07c000,0x7800001e,0x701cf07b,0xc01e01e0,0xf00780,0x1e07800,
-      0x3c078001,0xe03c0000,0xf000,0xf0003c0,0x7c003e0f,0x1e00,0xf83e001e,0x1e00000,0x7c0003c,0x3c00,0x1e0,0xf807c,0x0,0x0,0x1fe0001,
-      0xe1fc0000,0x7f00003,0xf8780007,0xf000003c,0x7f0,0x783f0,0x0,0x0,0x7800000,0x1e00000,0x3e0f8000,0xfc00007,0xf8000007,0xf00001fc,
-      0xf,0xc0003fc0,0x3c000,0x0,0x0,0x0,0x0,0x0,0x1e,0xf0,0x780,0x0,0x0,0x3c00000,0x0,0x0,0x3c00000,0x0,0x18,0xc0,0x0,0x1818000,
-      0x7800000,0x1,0xe00f0000,0x0,0x7c0000,0x0,0x1f,0x80001f80,0x7c1f8,0x1f83e0,0x0,0x0,0x0,0x70,0x38c70007,0xf8000000,0x7f03,
-      0xf0000000,0x0,0x780780,0x0,0x0,0xfe0000,0xf0000000,0x1e0,0x1e00003c,0x3f00,0x0,0xe07f0e,0x7fff80,0x0,0x0,0x70,0x70000,0x1c0,
-      0x1c000078,0x3c,0x1fc0,0x0,0x0,0xfffe1c00,0x0,0x0,0x380000f0,0x7800000,0x1c00,0xe000,0xe00,0x0,0x78f000,0x3c78000,0x1e3c0000,
-      0xf1e00007,0x8f00003c,0x78000787,0x8001e000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,
-      0xf80f780,0x3c03c001,0xe01e000f,0xf00078,0x78003c0,0x3c001e00,0xf,0x1f80f0,0x3c0780,0x1e03c00,0xf01e000,0x7801e01e,0x1ffffc,
-      0xf007e0,0x3fc000,0x1fe0000,0xff00000,0x7f800003,0xfc00001f,0xe0000fc0,0xfc00007f,0xfe0,0x7f00,0x3f800,0x1fc000,0x0,0x0,0x0,
-      0x1,0xf000001f,0x80000ff0,0x7f80,0x3fc00,0x1fe000,0xff0000,0x1f80000,0x1fc1e000,0x0,0x0,0x0,0x0,0x1e1fc0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x3c1e0000,
-      0x781c007c,0x30003803,0x80001f00,0x1e0,0xf00,0x7800,0x7f000,0x1e0000,0x0,0x0,0x0,0x1e000f00,0x780001e,0x0,0x7800000f,0x3c780,
-      0x3c00000,0x3c000000,0x3c00f,0x780f0,0x3c0000,0x0,0x0,0x1e000000,0xf00000,0x3e0,0xf0000e0,0x3c78003,0xc000f01e,0x1e0,0x7803c0,
-      0x1e00,0x1e000,0x1e0007,0x80007800,0x780,0x3c0f8000,0x7800001e,0x701cf079,0xe01e01e0,0xf00780,0x1e07800,0x3c078001,0xe03c0000,
-      0xf000,0xf0003c0,0x3c003c0f,0x3e00,0x787c001f,0x3e00000,0xf80003c,0x3c00,0x1e0,0x1f003e,0x0,0x0,0x1fffc001,0xe7ff0000,0x3ffe000f,
-      0xfe78003f,0xfc001fff,0xfe001ffc,0xf0078ffc,0x1ffc00,0x7ff000,0x7800f80,0x1e0000f,0x7f1fc01e,0x3ff0001f,0xfe00079f,0xfc0007ff,
-      0x3c003c7f,0xf001fff8,0x1fffff0,0x3c003c0,0xf0000f1e,0xf1f,0x7c1f0,0x1f00ff,0xffe0001e,0xf0,0x780,0x0,0x0,0x3c00000,0x100000,
-      0x0,0x7800000,0x0,0x18,0xc0,0x0,0x1818000,0x7800000,0x1,0xe00f0000,0x1000000,0xf80000,0x40000002,0xf,0x80001f00,0x7e0f8,0x1f07c0,
-      0x0,0x0,0x0,0x70,0x38c7003f,0xff000000,0xff8f,0xf8000100,0xffffe,0x7c0f80,0x0,0x0,0x3ffc000,0xf0000020,0x1001f0,0x3c00003c,
-      0x1f80,0x0,0x1c3ffc7,0x7c0780,0x0,0x0,0xe3,0xff038000,0xe0,0x38000078,0x78,0x1ff0,0x0,0x3c003c0,0xfffe1c00,0x0,0x0,0x380000f0,
-      0x7800000,0x1c00,0xe000,0xe00,0xf000,0x78f000,0x3c78000,0x1e3c0000,0xf1e00007,0x8f00003c,0x78000787,0x8001e000,0x78000,0x3c0000,
-      0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x780f3c0,0x3c03c001,0xe01e000f,0xf00078,0x78003c0,0x3c001e00,
-      0x4000200f,0x3f80f0,0x3c0780,0x1e03c00,0xf01e000,0x7801f03e,0x1ffffe,0xf01fe0,0x3fff800,0x1fffc000,0xfffe0007,0xfff0003f,
-      0xff8001ff,0xfc003ff3,0xfe0003ff,0xe0007ff8,0x3ffc0,0x1ffe00,0xfff000,0x3ff80001,0xffc0000f,0xfe00007f,0xf000003f,0xf8003c7f,
-      0xe0003ffc,0x1ffe0,0xfff00,0x7ff800,0x3ffc000,0x1f80000,0xfff1c03c,0x3c01e0,0x1e00f00,0xf007800,0x781f0001,0xf01e7ff0,0x7c0007c,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,
-      0x3c1e003f,0xfffff078,0x30003803,0x80000f00,0x1e0,0x1f00,0x7800,0x7f000,0x1e0000,0x0,0x0,0x0,0x3c000f00,0x780001e,0x0,0x7800000f,
-      0x78780,0x3c00000,0x3c000000,0x7c00f,0x780f0,0x3c0007,0xe000003f,0x0,0xfe000000,0xfe0000,0x3c0,0x1f000070,0x7c7c003,0xc000f01e,
-      0x1e0,0x7803c0,0x1e00,0x1e000,0x1e0007,0x80007800,0x780,0x3c1f0000,0x7800001e,0x783cf079,0xe01e03c0,0xf00780,0x1e0f000,0x3c078001,
-      0xe03c0000,0xf000,0xf0003c0,0x3c003c07,0x81f03c00,0x7c7c000f,0x87c00000,0xf00003c,0x1e00,0x1e0,0x3e001f,0x0,0x0,0x3fffe001,
-      0xefff8000,0x7fff001f,0xff78007f,0xfe001fff,0xfe003ffe,0xf0079ffe,0x1ffc00,0x7ff000,0x7801f00,0x1e0000f,0xffbfe01e,0x7ff8003f,
-      0xff0007bf,0xfe000fff,0xbc003cff,0xf803fffc,0x1fffff0,0x3c003c0,0x78001e1e,0xf0f,0x800f80f0,0x1e00ff,0xffe0001e,0xf0,0x780,
-      0x0,0x0,0x3c00000,0x380000,0x0,0x7800000,0x0,0x18,0xc0,0x0,0x1008000,0x7800000,0x3,0xe00f0000,0x3800000,0xf00000,0xe0000007,
-      0xf,0x80001f00,0x3e0f8,0x1e07c0,0x0,0x0,0x0,0x70,0x3807007f,0xff800000,0x1ffdf,0xfc000380,0xffffe,0x3e1f00,0x0,0x0,0xfffe000,
-      0xf0000030,0x3800f8,0x7c00003c,0xfc0,0x0,0x18780c3,0xf00780,0x80100,0x0,0xc3,0xffc18000,0xf0,0x78000078,0xf0,0xf0,0x0,0x3c003c0,
-      0xfffe1c00,0x0,0x0,0x380000f0,0x7800801,0x1c00,0xe000,0x1e00,0xf000,0xf8f800,0x7c7c000,0x3e3e0001,0xf1f0000f,0x8f80007c,0x7c000787,
-      0x8001e000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x780f3c0,0x3c078001,0xe03c000f,
-      0x1e00078,0xf0003c0,0x78001e00,0xe000701f,0x3fc0f0,0x3c0780,0x1e03c00,0xf01e000,0x7800f87c,0x1e007f,0xf07e00,0x7fffc00,0x3fffe001,
-      0xffff000f,0xfff8007f,0xffc003ff,0xfe007ff7,0xff0007ff,0xf000fffc,0x7ffe0,0x3fff00,0x1fff800,0x3ff80001,0xffc0000f,0xfe00007f,
-      0xf00000ff,0xf8003cff,0xf0007ffe,0x3fff0,0x1fff80,0xfffc00,0x7ffe000,0x1f80001,0xfffb803c,0x3c01e0,0x1e00f00,0xf007800,0x780f0001,
-      0xe01efff8,0x3c00078,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x780000,0x3c1e003f,0xfffff078,0x30001c07,0xf80,0x1e0,0x1e00,0x3c00,0xff800,0x1e0000,0x0,0x0,0x0,0x3c001e00,
-      0x3c0001e,0x0,0x7800001e,0x70780,0x3c00000,0x78000000,0x78007,0x800f00f0,0x3e0007,0xe000003f,0x3,0xfe000000,0xff8000,0x7c0,
-      0x1e000070,0x783c003,0xc001f01e,0x1e0,0x7803c0,0x1e00,0x1e000,0x1e0007,0x80007800,0x780,0x3c3e0000,0x7800001e,0x3838f079,
-      0xe01e03c0,0x780780,0x1e0f000,0x1e078001,0xe03c0000,0xf000,0xf0003c0,0x3c007c07,0x81f03c00,0x3ef80007,0x87800000,0x1f00003c,
-      0x1e00,0x1e0,0x7c000f,0x80000000,0x0,0x3ffff001,0xffffc000,0xffff003f,0xff7800ff,0xff001fff,0xfe007ffe,0xf007bffe,0x1ffc00,
-      0x7ff000,0x7803e00,0x1e0000f,0xffffe01e,0xfff8007f,0xff8007ff,0xff001fff,0xbc003dff,0xf807fffc,0x1fffff0,0x3c003c0,0x78001e0f,
-      0x1e07,0xc01f00f0,0x1e00ff,0xffe0001e,0xf0,0x780,0x0,0x0,0x7c00000,0x7c0000,0x0,0x7800000,0x0,0x18,0xc0,0x0,0x1018000,0x7800000,
-      0x3,0xc00f0000,0x7c00000,0x1f00001,0xf000000f,0x80000007,0xc0003e00,0x1e07c,0x3e0780,0x0,0x0,0x0,0x70,0x380700ff,0xff800000,
-      0x3ffff,0xfe0007c0,0xffffe,0x1e1e00,0x0,0x780000,0x1fffe000,0xf0000078,0x7c0078,0x7800003c,0xff0,0x0,0x38e0003,0x80f00780,
-      0x180300,0x0,0x1c3,0x81e1c000,0x7f,0xf0000078,0x1e0,0x38,0x0,0x3c003c0,0xfffe1c00,0x0,0x0,0x380000f0,0x7800c01,0x80001c00,
-      0xe000,0x603e00,0xf000,0xf07800,0x783c000,0x3c1e0001,0xe0f0000f,0x7800078,0x3c000f87,0x8001e000,0x78000,0x3c0000,0x1e00000,
-      0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x780f3c0,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f01,0xf000f81e,
-      0x7bc0f0,0x3c0780,0x1e03c00,0xf01e000,0x78007878,0x1e001f,0xf0f800,0x7fffe00,0x3ffff001,0xffff800f,0xfffc007f,0xffe003ff,
-      0xff007fff,0xff800fff,0xf001fffe,0xffff0,0x7fff80,0x3fffc00,0x3ff80001,0xffc0000f,0xfe00007f,0xf00001ff,0xfc003dff,0xf000ffff,
-      0x7fff8,0x3fffc0,0x1fffe00,0xffff000,0x1f80003,0xffff803c,0x3c01e0,0x1e00f00,0xf007800,0x780f0001,0xe01ffffc,0x3c00078,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,
-      0x3c1e003f,0xfffff078,0x30001e0f,0x300780,0x1e0,0x1e00,0x3c00,0x3dde00,0x1e0000,0x0,0x0,0x0,0x78001e00,0x3c0001e,0x0,0xf800003e,
-      0xf0780,0x3dfc000,0x783f8000,0xf8007,0xc01f00f0,0x3e0007,0xe000003f,0x1f,0xfc000000,0x7ff000,0xf80,0x3e007c70,0x783c003,0xc001e03c,
-      0x1e0,0x3c03c0,0x1e00,0x3c000,0x1e0007,0x80007800,0x780,0x3c7c0000,0x7800001e,0x3878f078,0xf01e03c0,0x780780,0x1e0f000,0x1e078001,
-      0xe03e0000,0xf000,0xf0003c0,0x1e007807,0x83f03c00,0x3ef00007,0xcf800000,0x3e00003c,0xf00,0x1e0,0xf80007,0xc0000000,0x0,0x3e01f801,
-      0xfe07e001,0xf80f007e,0x7f801f8,0x1f801fff,0xfe00fc0f,0xf007f83f,0x1ffc00,0x7ff000,0x7807c00,0x1e0000f,0x87e1e01f,0xe0fc00fc,
-      0xfc007f8,0x1f803f03,0xfc003df0,0x3807e03c,0x1fffff0,0x3c003c0,0x78003e0f,0x1e03,0xe03e00f8,0x3e00ff,0xffe0001e,0xf0,0x780,
-      0x0,0x0,0x7800000,0xfe0000,0x0,0x7800000,0x0,0x18,0xc0,0x0,0x1818000,0x7c00000,0x3,0xc00f0000,0xfe00000,0x3e00003,0xf800001f,
-      0xc0000007,0xc0003e00,0x1e03c,0x3c0f80,0x0,0x0,0x0,0x70,0x380700fc,0x7800000,0x7c1fe,0x3e000fe0,0xffffe,0x1f3e00,0x0,0x780000,
-      0x3f98e000,0xf000003c,0xfcf8007c,0xf800003c,0x3ffc,0x0,0x31c0001,0x80f00f80,0x380700,0x0,0x183,0x80e0c000,0x3f,0xe0000078,
-      0x3c0,0x38,0x0,0x3c003c0,0xfffe1c00,0x0,0x0,0x38000078,0xf000e01,0xc003ffe0,0x1fff00,0x7ffc00,0xf000,0xf07800,0x783c000,0x3c1e0001,
-      0xe0f0000f,0x7800078,0x3c000f07,0x8003c000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,
-      0x3c0f1e0,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f00,0xf801f01e,0xf3c0f0,0x3c0780,0x1e03c00,0xf01e000,0x78007cf8,
-      0x1e000f,0x80f0f000,0x7c03f00,0x3e01f801,0xf00fc00f,0x807e007c,0x3f003e0,0x1f80707f,0x8f801f80,0xf003f03f,0x1f81f8,0xfc0fc0,
-      0x7e07e00,0x3ff80001,0xffc0000f,0xfe00007f,0xf00003ff,0xfc003fc1,0xf801f81f,0x800fc0fc,0x7e07e0,0x3f03f00,0x1f81f800,0x1f80007,
-      0xe07f003c,0x3c01e0,0x1e00f00,0xf007800,0x780f8003,0xe01fe07e,0x3e000f8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x3f,0xfffff078,0x30000ffe,0x1f007c0,0x0,0x1e00,
-      0x3c00,0xf9cf80,0x1e0000,0x0,0x0,0x0,0x78001e00,0x3c0001e,0x0,0xf00000fc,0x1e0780,0x3fff800,0x78ffe000,0xf0003,0xe03e00f0,
-      0x3e0007,0xe000003f,0x7f,0xe01fffff,0xf00ffc00,0x1f80,0x3c01ff70,0x783c003,0xc007e03c,0x1e0,0x3c03c0,0x1e00,0x3c000,0x1e0007,
-      0x80007800,0x780,0x3cfc0000,0x7800001e,0x3c78f078,0xf01e03c0,0x780780,0x3e0f000,0x1e078003,0xc01f0000,0xf000,0xf0003c0,0x1e007807,
-      0x83f83c00,0x1ff00003,0xcf000000,0x3e00003c,0xf00,0x1e0,0x0,0x0,0x0,0x20007801,0xfc03e003,0xe003007c,0x3f803e0,0x7c0003c,
-      0xf807,0xf007e00f,0x3c00,0xf000,0x780f800,0x1e0000f,0x87e1f01f,0x803c00f8,0x7c007f0,0xf803e01,0xfc003f80,0x80f8004,0x3c000,
-      0x3c003c0,0x3c003c0f,0x1e03,0xe03e0078,0x3c0000,0x7c0001e,0xf0,0x780,0x0,0x0,0x3ffff800,0x1ff0000,0x0,0x7800000,0x0,0x18,
-      0xc0,0x0,0x1818000,0x3e00000,0x3,0xc00f0000,0x1ff00000,0x3e00007,0xfc00003f,0xe0000003,0xc0003c00,0xf03c,0x3c0f00,0x0,0x0,
-      0x0,0x70,0x380701f0,0x800000,0x780fc,0x1e001ff0,0x7c,0xf3c00,0x0,0x780000,0x7e182000,0xf000001f,0xfff00ffc,0xffc0003c,0x3cfe,
-      0x0,0x31c0001,0x80f01f80,0x780f00,0x0,0x183,0x80e0c000,0xf,0x80000078,0x780,0x38,0x0,0x3c003c0,0x7ffe1c00,0x0,0x0,0x38000078,
-      0xf000f01,0xe003ffe0,0x1fff00,0x7ff800,0xf000,0xf07800,0x783c000,0x3c1e0001,0xe0f0000f,0x78000f8,0x3e000f07,0x8003c000,0x78000,
-      0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x3c0f1e0,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,
-      0x78000f00,0x7c03e01e,0x1e3c0f0,0x3c0780,0x1e03c00,0xf01e000,0x78003cf0,0x1e0007,0x80f1e000,0x4000f00,0x20007801,0x3c008,
-      0x1e0040,0xf00200,0x780403f,0x7803e00,0x3007c00f,0x803e007c,0x1f003e0,0xf801f00,0x780000,0x3c00000,0x1e000000,0xf00007f0,
-      0x3e003f00,0x7801f00f,0x800f807c,0x7c03e0,0x3e01f00,0x1f00f800,0x1f80007,0xc03e003c,0x3c01e0,0x1e00f00,0xf007800,0x78078003,
-      0xc01fc03e,0x1e000f0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x780000,0x0,0xf078007c,0x300007fc,0x7e00fe0,0x0,0x1e00,0x3c00,0x3e1c3e0,0x1e0000,0x0,0x0,0x0,0xf0001e00,
-      0x3c0001e,0x1,0xf000fff8,0x1e0780,0x3fffe00,0x79fff000,0x1f0001,0xfffc00f0,0x7e0007,0xe000003f,0x3ff,0x801fffff,0xf003ff80,
-      0x3f00,0x3c03fff0,0xf01e003,0xffffc03c,0x1e0,0x3c03ff,0xffc01fff,0xfe03c000,0x1fffff,0x80007800,0x780,0x3df80000,0x7800001e,
-      0x1c70f078,0x781e03c0,0x780780,0x3c0f000,0x1e078007,0xc01f8000,0xf000,0xf0003c0,0x1e007807,0x83f83c00,0xfe00003,0xff000000,
-      0x7c00003c,0x780,0x1e0,0x0,0x0,0x0,0x7c01,0xf801f007,0xc00100f8,0x1f803c0,0x3c0003c,0x1f003,0xf007c00f,0x80003c00,0xf000,
-      0x783f000,0x1e0000f,0x3c0f01f,0x3e01f0,0x3e007e0,0x7c07c00,0xfc003f00,0xf0000,0x3c000,0x3c003c0,0x3c003c0f,0x1e01,0xf07c007c,
-      0x7c0000,0xfc0001e,0xf0,0x780,0x0,0x0,0x3ffff000,0x3838000,0x0,0x7800000,0x0,0x18,0xc0,0x0,0xff0000,0x3f00000,0x3,0xc00fff00,
-      0x38380000,0x7c0000e,0xe000070,0x70000001,0xe0003c00,0xf01e,0x780e00,0x0,0x0,0x0,0x0,0x1e0,0x0,0x780f8,0xf003838,0xfc,0xffc00,
-      0x0,0x780000,0x7c180000,0xf000000f,0xffe00fff,0xffc0003c,0x783f,0x80000000,0x6380000,0xc0f83f80,0xf81f00,0x0,0x303,0x80e06000,
-      0x0,0x78,0xf00,0x78,0x0,0x3c003c0,0x7ffe1c00,0x0,0x0,0x3800003c,0x3e000f81,0xf003ffe0,0x1fff00,0x1fc000,0xf000,0x1e03c00,
-      0xf01e000,0x780f0003,0xc078001e,0x3c000f0,0x1e000f07,0xff83c000,0x7ffff,0x803ffffc,0x1ffffe0,0xfffff00,0xf00000,0x7800000,
-      0x3c000001,0xe0001e00,0x3c0f0f0,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f00,0x3e07c01e,0x1e3c0f0,0x3c0780,0x1e03c00,
-      0xf01e000,0x78003ff0,0x1e0007,0x80f1e000,0xf80,0x7c00,0x3e000,0x1f0000,0xf80000,0x7c0001e,0x3c07c00,0x10078007,0x803c003c,
-      0x1e001e0,0xf000f00,0x780000,0x3c00000,0x1e000000,0xf00007c0,0x1e003e00,0x7c03e007,0xc01f003e,0xf801f0,0x7c00f80,0x3e007c00,
-      0xf,0x801f003c,0x3c01e0,0x1e00f00,0xf007800,0x7807c007,0xc01f801f,0x1f001f0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x0,0xe078003c,0x300001f0,0x3f801ff0,0x0,
-      0x3c00,0x1e00,0x3c1c1e0,0x1e0000,0x0,0x0,0x0,0xf0001e0f,0x3c0001e,0x3,0xe000fff0,0x3c0780,0x3ffff00,0x7bfff800,0x1e0000,0x7ff00078,
-      0x7e0007,0xe000003f,0x1ffc,0x1fffff,0xf0007ff0,0x7e00,0x3c07c3f0,0xf01e003,0xffff003c,0x1e0,0x3c03ff,0xffc01fff,0xfe03c000,
-      0x1fffff,0x80007800,0x780,0x3ffc0000,0x7800001e,0x1ef0f078,0x781e03c0,0x780780,0x7c0f000,0x1e07801f,0x800ff000,0xf000,0xf0003c0,
-      0xf00f807,0x83b83c00,0xfc00001,0xfe000000,0xf800003c,0x780,0x1e0,0x0,0x0,0x0,0x3c01,0xf000f007,0xc00000f0,0xf80780,0x3c0003c,
-      0x1e001,0xf007c007,0x80003c00,0xf000,0x787e000,0x1e0000f,0x3c0f01f,0x1e01e0,0x1e007c0,0x3c07800,0x7c003f00,0xf0000,0x3c000,
-      0x3c003c0,0x3e007c07,0x80003c00,0xf8f8003c,0x780000,0xf80001e,0xf0,0x780,0x0,0x0,0x7ffff000,0x601c000,0x3,0xffff0000,0x0,
-      0xfff,0xf8007fff,0xc0000000,0x7e003c,0x1fe0000,0xc0003,0xc00fff00,0x601c0000,0xf800018,0x70000c0,0x38000001,0xe0007800,0x701e,
-      0x701e00,0x0,0x0,0x0,0x0,0x1e0,0x6,0x700f8,0xf00601c,0xf8,0x7f800,0x0,0x780000,0xf8180000,0xf000000f,0x87c00fff,0xffc0003c,
-      0xf01f,0xc0000000,0x6380000,0xc07ff780,0x1f03e03,0xfffffe00,0x303,0x81c06000,0x0,0x1ffff,0xfe001e00,0x180f8,0x0,0x3c003c0,
-      0x3ffe1c00,0x3f00000,0x0,0x3800003f,0xfe0007c0,0xf8000000,0x18000000,0xc0000006,0x1f000,0x1e03c00,0xf01e000,0x780f0003,0xc078001e,
-      0x3c000f0,0x1e001f07,0xff83c000,0x7ffff,0x803ffffc,0x1ffffe0,0xfffff00,0xf00000,0x7800000,0x3c000001,0xe000fff8,0x3c0f0f0,
-      0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f00,0x1f0f801e,0x3c3c0f0,0x3c0780,0x1e03c00,0xf01e000,0x78001fe0,0x1e0007,
-      0x80f1e000,0x780,0x3c00,0x1e000,0xf0000,0x780000,0x3c0001e,0x3c07c00,0xf0007,0x8078003c,0x3c001e0,0x1e000f00,0x780000,0x3c00000,
-      0x1e000000,0xf0000f80,0x1f003e00,0x3c03c003,0xc01e001e,0xf000f0,0x7800780,0x3c003c00,0xf,0x3f003c,0x3c01e0,0x1e00f00,0xf007800,
-      0x7803c007,0x801f000f,0xf001e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1,0xe078003f,0xb0000000,0xfc003cf0,0x0,0x3c00,0x1e00,0x101c040,0x1e0000,0x0,0x0,0x1,
-      0xe0001e1f,0x83c0001e,0x7,0xe000fff0,0x3c0780,0x3c03f80,0x7fc0fc00,0x1e0000,0xfff80078,0xfe0007,0xe000003f,0x7fe0,0x1fffff,
-      0xf0000ffc,0xfc00,0x780f81f0,0xf01e003,0xffff003c,0x1e0,0x3c03ff,0xffc01fff,0xfe03c000,0x1fffff,0x80007800,0x780,0x3ffc0000,
-      0x7800001e,0x1ef0f078,0x3c1e03c0,0x780780,0x1fc0f000,0x1e07ffff,0x7ff00,0xf000,0xf0003c0,0xf00f007,0xc3b87c00,0x7c00001,0xfe000000,
-      0xf800003c,0x3c0,0x1e0,0x0,0x0,0x0,0x3c01,0xf000f007,0x800000f0,0xf80780,0x1e0003c,0x1e001,0xf0078007,0x80003c00,0xf000,0x78fc000,
-      0x1e0000f,0x3c0f01e,0x1e01e0,0x1e007c0,0x3c07800,0x7c003e00,0xf0000,0x3c000,0x3c003c0,0x1e007807,0x80003c00,0x7df0003c,0x780000,
-      0x1f00001e,0xf0,0x780,0x0,0x0,0x7800000,0xe7ce000,0x3,0xffff0000,0x0,0xfff,0xf8007fff,0xc0000000,0x1f0,0xffe000,0x1c0003,
-      0xc00fff00,0xe7ce0000,0xf800039,0xf38001cf,0x9c000000,0xe0007800,0x780e,0x701c00,0x0,0x0,0x0,0x0,0x1e0,0x7,0xf0078,0xf00e7ce,
-      0x1f0,0x7f800,0x0,0x780000,0xf0180000,0xf000000e,0x1c0001f,0xe000003c,0xf007,0xe0000000,0x6380000,0xc03fe780,0x3e07c03,0xfffffe00,
-      0x303,0xffc06000,0x0,0x1ffff,0xfe003ffe,0x1fff0,0x0,0x3c003c0,0x1ffe1c00,0x3f00000,0x7,0xffc0001f,0xfc0003e0,0x7c000001,0xfc00000f,
-      0xe000007f,0x1e000,0x1e03c00,0xf01e000,0x780f0003,0xc078001e,0x3c000f0,0x1e001e07,0xff83c000,0x7ffff,0x803ffffc,0x1ffffe0,
-      0xfffff00,0xf00000,0x7800000,0x3c000001,0xe000fff8,0x3c0f078,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f00,0xf9f001e,
-      0x783c0f0,0x3c0780,0x1e03c00,0xf01e000,0x78001fe0,0x1e0007,0x80f1e000,0x780,0x3c00,0x1e000,0xf0000,0x780000,0x3c0001e,0x3c07800,
-      0xf0003,0xc078001e,0x3c000f0,0x1e000780,0x780000,0x3c00000,0x1e000000,0xf0000f00,0xf003c00,0x3c03c003,0xc01e001e,0xf000f0,
-      0x7800780,0x3c003c00,0xf,0x7f003c,0x3c01e0,0x1e00f00,0xf007800,0x7803c007,0x801f000f,0xf001e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1,0xe070001f,0xf8000007,
-      0xf0007cf8,0x7800000,0x3c00,0x1e00,0x1c000,0x1e0000,0x0,0x0,0x1,0xe0001e1f,0x83c0001e,0xf,0xc000fff8,0x780780,0x2000f80,0x7f803e00,
-      0x3e0003,0xfffe007c,0x1fe0000,0x0,0x3ff00,0x0,0x1ff,0x8001f000,0x780f00f0,0x1f00f003,0xffffc03c,0x1e0,0x3c03ff,0xffc01fff,
-      0xfe03c00f,0xf81fffff,0x80007800,0x780,0x3ffe0000,0x7800001e,0xee0f078,0x3c1e03c0,0x7807ff,0xff80f000,0x1e07fffe,0x3ffe0,
-      0xf000,0xf0003c0,0xf00f003,0xc7bc7800,0xfc00000,0xfc000001,0xf000003c,0x3c0,0x1e0,0x0,0x0,0x0,0x3c01,0xe000f80f,0x800001e0,
-      0xf80f00,0x1e0003c,0x3c000,0xf0078007,0x80003c00,0xf000,0x79f8000,0x1e0000f,0x3c0f01e,0x1e03c0,0x1f00780,0x3e0f000,0x7c003e00,
-      0xf0000,0x3c000,0x3c003c0,0x1e007807,0x81e03c00,0x7df0003e,0xf80000,0x3e00003e,0xf0,0x7c0,0xfc000,0x80000000,0x7800000,0x1e7cf000,
-      0x3,0xffff0000,0x0,0x18,0xc0,0x0,0xf80,0x7ffc00,0x380003,0xc00fff01,0xe7cf0000,0x1f000079,0xf3c003cf,0x9e000000,0xe0007000,
-      0x380e,0xe01c00,0x0,0x0,0x0,0x0,0x1e0,0x3,0x800f0078,0xf01e7cf,0x3e0,0x3f000,0x0,0x780000,0xf018001f,0xfff8001e,0x1e0000f,
-      0xc000003c,0xf003,0xe0000000,0x6380000,0xc00fc780,0x7c0f803,0xfffffe00,0x303,0xfe006000,0x0,0x1ffff,0xfe003ffe,0x1ffe0,0x0,
-      0x3c003c0,0xffe1c00,0x3f00000,0x7,0xffc00007,0xf00001f0,0x3e00001f,0xfc0000ff,0xe00007ff,0x3e000,0x3e01e00,0x1f00f000,0xf8078007,
-      0xc03c003e,0x1e001e0,0xf001e07,0xff83c000,0x7ffff,0x803ffffc,0x1ffffe0,0xfffff00,0xf00000,0x7800000,0x3c000001,0xe000fff8,
-      0x3c0f078,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f00,0x7fe001e,0xf03c0f0,0x3c0780,0x1e03c00,0xf01e000,0x78000fc0,
-      0x1e0007,0x80f1f000,0x780,0x3c00,0x1e000,0xf0000,0x780000,0x3c0001e,0x3c0f800,0x1e0003,0xc0f0001e,0x78000f0,0x3c000780,0x780000,
-      0x3c00000,0x1e000000,0xf0000f00,0xf003c00,0x3c078003,0xe03c001f,0x1e000f8,0xf0007c0,0x78003e00,0x1e,0xf7803c,0x3c01e0,0x1e00f00,
-      0xf007800,0x7803e00f,0x801e000f,0x80f803e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1,0xe0f0000f,0xff00001f,0x8000f87c,0x7800000,0x3c00,0x1e00,0x1c000,0x7fffff80,
-      0x0,0x0,0x3,0xc0001e1f,0x83c0001e,0x1f,0x800000fe,0xf00780,0x7c0,0x7f001e00,0x3c0007,0xe03f003f,0x3fe0000,0x0,0x3fc00,0x0,
-      0x7f,0x8001e000,0x781f00f0,0x1e00f003,0xc007e03c,0x1e0,0x3c03c0,0x1e00,0x3c00f,0xf81e0007,0x80007800,0x780,0x3f9f0000,0x7800001e,
-      0xfe0f078,0x3c1e03c0,0x7807ff,0xff00f000,0x1e07fff8,0xfff8,0xf000,0xf0003c0,0xf81f003,0xc7bc7800,0xfe00000,0x78000003,0xe000003c,
-      0x1e0,0x1e0,0x0,0x0,0x0,0x1fffc01,0xe000780f,0x1e0,0x780f00,0x1e0003c,0x3c000,0xf0078007,0x80003c00,0xf000,0x7bf0000,0x1e0000f,
-      0x3c0f01e,0x1e03c0,0xf00780,0x1e0f000,0x3c003c00,0xf8000,0x3c000,0x3c003c0,0x1f00f807,0x81f03c00,0x3fe0001e,0xf00000,0x7c00007c,
-      0xf0,0x3e0,0x3ff801,0x80000000,0x7800000,0x3cfcf800,0x3,0xffff0000,0x0,0x18,0xc0,0x0,0x7c00,0x1fff00,0x700003,0xc00f0003,
-      0xcfcf8000,0x3e0000f3,0xf3e0079f,0x9f000000,0xf000,0x1000,0x0,0x0,0x0,0x0,0x0,0x1f0,0x1,0xc00f0078,0xf03cfcf,0x800007c0,0x1e000,
-      0x0,0x780001,0xe018001f,0xfff8001c,0xe00007,0x8000003c,0xf001,0xf0000000,0x6380000,0xc0000000,0xf81f003,0xfffffe00,0x303,
-      0x87006000,0x0,0x1ffff,0xfe003ffe,0x7f00,0x0,0x3c003c0,0x3fe1c00,0x3f00000,0x7,0xffc00000,0xf8,0x1f0001ff,0xf0000fff,0x80007ffc,
-      0xfc000,0x3c01e00,0x1e00f000,0xf0078007,0x803c003c,0x1e001e0,0xf001e07,0x8003c000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,
-      0x7800000,0x3c000001,0xe000fff8,0x3c0f078,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f00,0x3fc001e,0x1e03c0f0,0x3c0780,
-      0x1e03c00,0xf01e000,0x78000780,0x1e0007,0x80f0fc00,0x3fff80,0x1fffc00,0xfffe000,0x7fff0003,0xfff8001f,0xffc0001e,0x3c0f000,
-      0x1e0003,0xc0f0001e,0x78000f0,0x3c000780,0x780000,0x3c00000,0x1e000000,0xf0001e00,0xf803c00,0x3c078001,0xe03c000f,0x1e00078,
-      0xf0003c0,0x78001e07,0xfffffe1e,0x1e7803c,0x3c01e0,0x1e00f00,0xf007800,0x7801e00f,0x1e0007,0x807803c0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x3,0xc0f00007,
-      0xffc0007e,0xf03e,0x7800000,0x3c00,0x1e00,0x1c000,0x7fffff80,0x0,0x0,0x3,0xc0001e1f,0x83c0001e,0x3f,0x3e,0xf00780,0x3c0,0x7e001e00,
-      0x7c000f,0x800f001f,0xffde0000,0x0,0x3e000,0x0,0xf,0x8003e000,0x781e0070,0x1e00f003,0xc001f03c,0x1e0,0x3c03c0,0x1e00,0x3c00f,
-      0xf81e0007,0x80007800,0x780,0x3f1f0000,0x7800001e,0x7c0f078,0x1e1e03c0,0x7807ff,0xfc00f000,0x1e07fffe,0xffc,0xf000,0xf0003c0,
-      0x781e003,0xc71c7800,0x1ff00000,0x78000003,0xe000003c,0x1e0,0x1e0,0x0,0x0,0x0,0xffffc01,0xe000780f,0x1e0,0x780fff,0xffe0003c,
-      0x3c000,0xf0078007,0x80003c00,0xf000,0x7ff0000,0x1e0000f,0x3c0f01e,0x1e03c0,0xf00780,0x1e0f000,0x3c003c00,0x7f000,0x3c000,
-      0x3c003c0,0xf00f007,0xc1f07c00,0x1fc0001f,0x1f00000,0xfc000ff8,0xf0,0x1ff,0xfffe07,0x80000000,0x7800000,0x7ffcfc00,0x0,0xf000000,
-      0x0,0x18,0xc0,0x0,0x3e000,0x1ff80,0xe00003,0xc00f0007,0xffcfc000,0x3e0001ff,0xf3f00fff,0x9f800000,0x6000,0x0,0x0,0x7c000,
-      0x0,0x0,0x0,0xfe,0x0,0xe00f007f,0xff07ffcf,0xc0000fc0,0x1e000,0x0,0x780001,0xe018001f,0xfff8001c,0xe00007,0x80000000,0xf800,
-      0xf0000000,0x6380000,0xc0000000,0x1f03c000,0x1e00,0x303,0x83806000,0x0,0x78,0x0,0x0,0x0,0x3c003c0,0xfe1c00,0x3f00000,0x0,
-      0x0,0x3c,0xf801fff,0xfff8,0x7ffc0,0x1f8000,0x3c01e00,0x1e00f000,0xf0078007,0x803c003c,0x1e001e0,0xf003c07,0x8003c000,0x78000,
-      0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x3c0f03c,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,
-      0x78000f00,0x1f8001e,0x1e03c0f0,0x3c0780,0x1e03c00,0xf01e000,0x78000780,0x1e000f,0x80f0ff00,0x1ffff80,0xffffc00,0x7fffe003,
-      0xffff001f,0xfff800ff,0xffc007ff,0xffc0f000,0x1fffff,0xc0fffffe,0x7fffff0,0x3fffff80,0x780000,0x3c00000,0x1e000000,0xf0001e00,
-      0x7803c00,0x3c078001,0xe03c000f,0x1e00078,0xf0003c0,0x78001e07,0xfffffe1e,0x3c7803c,0x3c01e0,0x1e00f00,0xf007800,0x7801f01f,
-      0x1e0007,0x807c07c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x780000,0x3,0xc0f00000,0xfff003f0,0x1f00f03e,0x7800000,0x3c00,0x1e00,0x1c000,0x7fffff80,0x0,0x7ff80000,0x3,
-      0xc0001e0f,0x3c0001e,0x7e,0x1f,0x1e00780,0x3e0,0x7e000f00,0x78000f,0x7800f,0xff9e0000,0x0,0x3fc00,0x0,0x7f,0x8003c000,0x781e0070,
-      0x3e00f803,0xc000f03c,0x1e0,0x3c03c0,0x1e00,0x3c00f,0xf81e0007,0x80007800,0x780,0x3e0f8000,0x7800001e,0x7c0f078,0x1e1e03c0,
-      0x7807ff,0xf000f000,0x1e07807f,0xfe,0xf000,0xf0003c0,0x781e003,0xc71c7800,0x3ef00000,0x78000007,0xc000003c,0x1e0,0x1e0,0x0,
-      0x0,0x0,0x1ffffc01,0xe000780f,0x1e0,0x780fff,0xffe0003c,0x3c000,0xf0078007,0x80003c00,0xf000,0x7ff0000,0x1e0000f,0x3c0f01e,
-      0x1e03c0,0xf00780,0x1e0f000,0x3c003c00,0x7ff80,0x3c000,0x3c003c0,0xf00f003,0xc1f07800,0x1fc0000f,0x1e00000,0xf8000ff0,0xf0,
-      0xff,0xffffff,0x80000000,0x3fffc000,0xfff9fe00,0x0,0xf000000,0x0,0x18,0xc0,0x0,0x1f0000,0x1fc0,0x1c00003,0xc00f000f,0xff9fe000,
-      0x7c0003ff,0xe7f81fff,0x3fc00000,0x0,0x0,0x0,0xfe000,0x1ffffc0f,0xfffffc00,0x0,0xff,0xf0000000,0x700f007f,0xff0fff9f,0xe0000f80,
-      0x1e000,0x0,0x780001,0xe018001f,0xfff8001c,0xe00fff,0xffc00000,0xf800,0xf0000000,0x6380000,0xc0ffff80,0x3e078000,0x1e00,0x7ff80303,
-      0x83c06000,0x0,0x78,0x0,0x0,0x0,0x3c003c0,0xe1c00,0x3f00000,0x0,0x7f,0xff00001e,0x7c1fff0,0xfff80,0x7ffc00,0x3f0000,0x7c01f00,
-      0x3e00f801,0xf007c00f,0x803e007c,0x1f003e0,0xf803c07,0x8003c000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,
-      0xe0001e00,0x3c0f03c,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f00,0x1f8001e,0x3c03c0f0,0x3c0780,0x1e03c00,0xf01e000,
-      0x78000780,0x1e001f,0xf07f80,0x3ffff80,0x1ffffc00,0xffffe007,0xffff003f,0xfff801ff,0xffc03fff,0xffc0f000,0x1fffff,0xc0fffffe,
-      0x7fffff0,0x3fffff80,0x780000,0x3c00000,0x1e000000,0xf0001e00,0x7803c00,0x3c078001,0xe03c000f,0x1e00078,0xf0003c0,0x78001e07,
-      0xfffffe1e,0x787803c,0x3c01e0,0x1e00f00,0xf007800,0x7800f01e,0x1e0007,0x803c0780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1ff,0xffff8000,0x3ff80fc0,0x7fc1e01f,
-      0x7800000,0x3c00,0x1e00,0x0,0x7fffff80,0x0,0x7ff80000,0x7,0x80001e00,0x3c0001e,0xfc,0xf,0x1e00780,0x1e0,0x7c000f00,0x78000f,
-      0x78007,0xff1e0000,0x0,0x3ff00,0x0,0x1ff,0x8003c000,0x781e0070,0x3c007803,0xc000f03c,0x1e0,0x3c03c0,0x1e00,0x3c000,0x781e0007,
-      0x80007800,0x780,0x3c07c000,0x7800001e,0x7c0f078,0xf1e03c0,0x780780,0xf000,0x1e07801f,0x3e,0xf000,0xf0003c0,0x781e003,0xcf1c7800,
-      0x3cf80000,0x7800000f,0x8000003c,0xf0,0x1e0,0x0,0x0,0x0,0x3ffffc01,0xe000780f,0x1e0,0x780fff,0xffe0003c,0x3c000,0xf0078007,
-      0x80003c00,0xf000,0x7ff8000,0x1e0000f,0x3c0f01e,0x1e03c0,0xf00780,0x1e0f000,0x3c003c00,0x3fff0,0x3c000,0x3c003c0,0xf81f003,
-      0xc3b87800,0xf80000f,0x1e00001,0xf0000ff0,0xf0,0xff,0xf03fff,0x80000000,0x3fff8001,0xfff1ff00,0x0,0xf000000,0x0,0x18,0xc0,
-      0x0,0x380000,0x7c0,0x3c00003,0xc00f001f,0xff1ff000,0xf80007ff,0xc7fc3ffe,0x3fe00000,0x0,0x0,0x0,0x1ff000,0x7ffffe1f,0xffffff00,
-      0x0,0x7f,0xfe000000,0x780f007f,0xff1fff1f,0xf0001f00,0x1e000,0x0,0x780001,0xe0180000,0xf000001c,0xe00fff,0xffc00000,0x7c00,
-      0xf0000000,0x31c0001,0x80ffff80,0x3e078000,0x1e00,0x7ff80183,0x81c0c000,0x0,0x78,0x0,0x0,0x0,0x3c003c0,0xe1c00,0x3f00000,
-      0x0,0x7f,0xff00001e,0x7c7ff03,0xc03ff8fe,0x1ffc0f0,0x7e0000,0x7800f00,0x3c007801,0xe003c00f,0x1e0078,0xf003c0,0x7803c07,0x8003c000,
-      0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x3c0f01e,0x3c078000,0xf03c0007,0x81e0003c,
-      0xf0001e0,0x78000f00,0x3fc001e,0x7803c0f0,0x3c0780,0x1e03c00,0xf01e000,0x78000780,0x1e007f,0xf03fe0,0x7ffff80,0x3ffffc01,
-      0xffffe00f,0xffff007f,0xfff803ff,0xffc07fff,0xffc0f000,0x1fffff,0xc0fffffe,0x7fffff0,0x3fffff80,0x780000,0x3c00000,0x1e000000,
-      0xf0001e00,0x7803c00,0x3c078001,0xe03c000f,0x1e00078,0xf0003c0,0x78001e07,0xfffffe1e,0x707803c,0x3c01e0,0x1e00f00,0xf007800,
-      0x7800f01e,0x1e0007,0x803c0780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1ff,0xffff8000,0x30f81f00,0xffe1e00f,0x87800000,0x3c00,0x1e00,0x0,0x1e0000,0x0,0x7ff80000,
-      0x7,0x80001e00,0x3c0001e,0x1f8,0x7,0x83c00780,0x1e0,0x7c000f00,0xf8001e,0x3c001,0xfc1e0000,0x0,0x7fe0,0x0,0xffc,0x3c000,0x781e0070,
-      0x3ffff803,0xc000783c,0x1e0,0x3c03c0,0x1e00,0x3c000,0x781e0007,0x80007800,0x780,0x3c07c000,0x7800001e,0x380f078,0xf1e03c0,
-      0x780780,0xf000,0x1e07800f,0x8000001e,0xf000,0xf0003c0,0x3c3c003,0xcf1e7800,0x7c780000,0x7800000f,0x8000003c,0xf0,0x1e0,0x0,
-      0x0,0x0,0x7f003c01,0xe000780f,0x1e0,0x780fff,0xffe0003c,0x3c000,0xf0078007,0x80003c00,0xf000,0x7f7c000,0x1e0000f,0x3c0f01e,
-      0x1e03c0,0xf00780,0x1e0f000,0x3c003c00,0xfff8,0x3c000,0x3c003c0,0x781e003,0xc3b87800,0x1fc00007,0x83e00003,0xe0000ff8,0xf0,
-      0x1ff,0xc007fe,0x0,0x7fff8001,0xffe3ff00,0x0,0x1e000000,0x0,0x18,0xc0,0x0,0x0,0x3c0,0x7800003,0xc00f001f,0xfe3ff000,0xf80007ff,
-      0x8ffc3ffc,0x7fe00000,0x0,0x0,0x0,0x1ff000,0x0,0x0,0x0,0x1f,0xff000000,0x3c0f007f,0xff1ffe3f,0xf0003e00,0x1e000,0x0,0x780001,
-      0xe0180000,0xf000001e,0x1e00fff,0xffc00000,0x3f00,0xf0000000,0x31c0001,0x80ffff80,0x1f03c000,0x1e00,0x7ff80183,0x81c0c000,
-      0x0,0x78,0x0,0x0,0x0,0x3c003c0,0xe1c00,0x0,0x0,0x7f,0xff00003c,0xf87f007,0xc03f83ff,0x81fc01f0,0x7c0000,0x7ffff00,0x3ffff801,
-      0xffffc00f,0xfffe007f,0xfff003ff,0xff807fff,0x8003c000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,
-      0xe0001e00,0x3c0f01e,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f00,0x7fe001e,0xf003c0f0,0x3c0780,0x1e03c00,0xf01e000,
-      0x78000780,0x1ffffe,0xf00ff0,0xfe00780,0x7f003c03,0xf801e01f,0xc00f00fe,0x7807f0,0x3c0ffff,0xffc0f000,0x1fffff,0xc0fffffe,
-      0x7fffff0,0x3fffff80,0x780000,0x3c00000,0x1e000000,0xf0001e00,0x7803c00,0x3c078001,0xe03c000f,0x1e00078,0xf0003c0,0x78001e00,
-      0x1e,0xf07803c,0x3c01e0,0x1e00f00,0xf007800,0x7800783e,0x1e0007,0x801e0f80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1ff,0xffff8000,0x307c0801,0xe1f1e00f,0x87000000,
-      0x3c00,0x1e00,0x0,0x1e0000,0x0,0x7ff80000,0xf,0x1e00,0x3c0001e,0x3f0,0x7,0x83fffffc,0x1e0,0x7c000f00,0xf0001e,0x3c000,0x3e0000,
-      0x0,0x1ffc,0x1fffff,0xf0007ff0,0x3c000,0x781e0070,0x7ffffc03,0xc000781e,0x1e0,0x7803c0,0x1e00,0x3c000,0x781e0007,0x80007800,
-      0x780,0x3c03e000,0x7800001e,0xf078,0x79e03c0,0x780780,0xf000,0x1e078007,0x8000000f,0xf000,0xf0003c0,0x3c3c001,0xee0ef000,
-      0xf87c0000,0x7800001f,0x3c,0x78,0x1e0,0x0,0x0,0x0,0x7c003c01,0xe000780f,0x1e0,0x780f00,0x3c,0x3c000,0xf0078007,0x80003c00,
-      0xf000,0x7e3e000,0x1e0000f,0x3c0f01e,0x1e03c0,0xf00780,0x1e0f000,0x3c003c00,0x1ffc,0x3c000,0x3c003c0,0x781e003,0xe3b8f800,
-      0x1fc00007,0x83c00007,0xc00000fc,0xf0,0x3e0,0x8001f8,0x0,0x7800000,0xffc7fe00,0x0,0x1e000000,0x0,0x18,0xc0,0x0,0x0,0x1e0,
-      0xf000003,0xc00f000f,0xfc7fe001,0xf00003ff,0x1ff81ff8,0xffc00000,0x0,0x0,0x0,0x1ff000,0x0,0x0,0x0,0x3,0xff800000,0x1e0f0078,
-      0xffc7f,0xe0007c00,0x1e000,0x0,0x780001,0xe0180000,0xf000000e,0x1c00007,0x80000000,0x1f81,0xe0000000,0x38e0003,0x80000000,
-      0xf81f000,0x1e00,0x7ff801c3,0x80e1c000,0x0,0x78,0x0,0x0,0x0,0x3c003c0,0xe1c00,0x0,0x0,0x0,0xf8,0x1f070007,0xc03803ff,0xc1c001f0,
-      0xf80000,0xfffff00,0x7ffff803,0xffffc01f,0xfffe00ff,0xfff007ff,0xffc07fff,0x8001e000,0x78000,0x3c0000,0x1e00000,0xf000000,
-      0xf00000,0x7800000,0x3c000001,0xe0001e00,0x780f00f,0x3c078000,0xf03c0007,0x81e0003c,0xf0001e0,0x78000f00,0xf9f001e,0xf003c0f0,
-      0x3c0780,0x1e03c00,0xf01e000,0x78000780,0x1ffffc,0xf003f8,0xf800780,0x7c003c03,0xe001e01f,0xf00f8,0x7807c0,0x3c0fc1e,0xf000,
-      0x1e0000,0xf00000,0x7800000,0x3c000000,0x780000,0x3c00000,0x1e000000,0xf0001e00,0x7803c00,0x3c078001,0xe03c000f,0x1e00078,
-      0xf0003c0,0x78001e00,0x1e,0x1e07803c,0x3c01e0,0x1e00f00,0xf007800,0x7800783c,0x1e0007,0x801e0f00,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ff,0xffff8000,0x303c0001,
-      0xc071e007,0xcf000000,0x3c00,0x1e00,0x0,0x1e0000,0x0,0x0,0xf,0xf00,0x780001e,0x7e0,0x7,0x83fffffc,0x1e0,0x7c000f00,0x1f0001e,
-      0x3c000,0x3c0000,0x0,0x3ff,0x801fffff,0xf003ff80,0x3c000,0x781e0070,0x7ffffc03,0xc000781e,0x1e0,0x7803c0,0x1e00,0x1e000,0x781e0007,
-      0x80007800,0x780,0x3c01f000,0x7800001e,0xf078,0x79e03c0,0xf00780,0xf000,0x3e078007,0xc000000f,0xf000,0xf0003c0,0x3c3c001,
-      0xee0ef000,0xf03e0000,0x7800003e,0x3c,0x78,0x1e0,0x0,0x0,0x0,0xf8003c01,0xe000780f,0x1e0,0x780f00,0x3c,0x3c000,0xf0078007,
-      0x80003c00,0xf000,0x7c3e000,0x1e0000f,0x3c0f01e,0x1e03c0,0xf00780,0x1e0f000,0x3c003c00,0xfc,0x3c000,0x3c003c0,0x3c3e001,0xe7b8f000,
-      0x3fe00007,0xc7c0000f,0xc000003e,0xf0,0x7c0,0x0,0x0,0x7c00000,0x7fcffc00,0x0,0x1e000000,0x0,0x18,0xc0,0x0,0x0,0x1e0,0x1e000003,
-      0xc00f0007,0xfcffc003,0xe00001ff,0x3ff00ff9,0xff800000,0x0,0x0,0x0,0x1ff000,0x0,0x0,0x0,0x0,0x1f800000,0xf0f0078,0x7fcff,
-      0xc000fc00,0x1e000,0x0,0x780001,0xe0180000,0xf000000f,0x87c00007,0x80000000,0xfe3,0xe0000000,0x18780c3,0x0,0x7c0f800,0x1e00,
-      0xc3,0x80e18000,0x0,0x78,0x0,0x0,0x0,0x3c003c0,0xe1c00,0x0,0x0,0x0,0x1f0,0x3e00000f,0xc0000303,0xe00003f0,0xf00000,0xfffff80,
-      0x7ffffc03,0xffffe01f,0xffff00ff,0xfff807ff,0xffc07fff,0x8001e000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,
-      0x3c000001,0xe0001e00,0x780f00f,0x3c078001,0xe03c000f,0x1e00078,0xf0003c0,0x78001e00,0x1f0f801f,0xe00780f0,0x3c0780,0x1e03c00,
-      0xf01e000,0x78000780,0x1ffff8,0xf000f8,0x1f000780,0xf8003c07,0xc001e03e,0xf01f0,0x780f80,0x3c1f01e,0xf000,0x1e0000,0xf00000,
-      0x7800000,0x3c000000,0x780000,0x3c00000,0x1e000000,0xf0001e00,0x7803c00,0x3c078001,0xe03c000f,0x1e00078,0xf0003c0,0x78001e00,
-      0x1e,0x3c07803c,0x3c01e0,0x1e00f00,0xf007800,0x78007c7c,0x1e0007,0x801f1f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x81c00000,0x303c0003,0x8039e003,0xef000000,
-      0x3c00,0x1e00,0x0,0x1e0000,0x0,0x0,0x1e,0xf00,0x780001e,0xfc0,0x7,0x83fffffc,0x1e0,0x3c000f00,0x1e0001e,0x3c000,0x3c0000,
-      0x0,0x7f,0xe01fffff,0xf00ffc00,0x3c000,0x781f00f0,0x7ffffc03,0xc000781e,0x1e0,0x7803c0,0x1e00,0x1e000,0x781e0007,0x80007800,
-      0x780,0x3c01f000,0x7800001e,0xf078,0x7de01e0,0xf00780,0x7800,0x3c078003,0xc000000f,0xf000,0xf0003c0,0x3e7c001,0xee0ef001,
-      0xf01e0000,0x7800003e,0x3c,0x3c,0x1e0,0x0,0x0,0x0,0xf0003c01,0xe000780f,0x1e0,0x780f00,0x3c,0x3c000,0xf0078007,0x80003c00,
-      0xf000,0x781f000,0x1e0000f,0x3c0f01e,0x1e03c0,0xf00780,0x1e0f000,0x3c003c00,0x3e,0x3c000,0x3c003c0,0x3c3c001,0xe71cf000,0x7df00003,
-      0xc780000f,0x8000003e,0xf0,0x780,0x0,0x0,0x3c00000,0x3fcff800,0x0,0x1e000000,0x0,0x18,0xc0,0x0,0x1f00fc,0x1e0,0x1e000001,
-      0xe00f0003,0xfcff8003,0xe00000ff,0x3fe007f9,0xff000000,0x0,0x0,0x0,0x1ff000,0x0,0x0,0x0,0x0,0x7c00000,0xf0f0078,0x3fcff,0x8000f800,
-      0x1e000,0x0,0x780001,0xe0180000,0xf000001f,0xffe00007,0x8000003c,0x7ff,0xc0000000,0x1c3ffc7,0x0,0x3e07c00,0x1e00,0xe3,0x80738000,
-      0x0,0x78,0x0,0x0,0x0,0x3c003c0,0xe1c00,0x0,0x0,0x0,0x3e0,0x7c00001d,0xc0000001,0xe0000770,0x1f00000,0xfffff80,0x7ffffc03,
-      0xffffe01f,0xffff00ff,0xfff807ff,0xffc07fff,0x8001e000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,
-      0xe0001e00,0x780f00f,0x3c03c001,0xe01e000f,0xf00078,0x78003c0,0x3c001e00,0x3e07c01f,0xc00780f0,0x3c0780,0x1e03c00,0xf01e000,
-      0x78000780,0x1fffc0,0xf0007c,0x1e000780,0xf0003c07,0x8001e03c,0xf01e0,0x780f00,0x3c1e01e,0xf000,0x1e0000,0xf00000,0x7800000,
-      0x3c000000,0x780000,0x3c00000,0x1e000000,0xf0001e00,0x7803c00,0x3c078001,0xe03c000f,0x1e00078,0xf0003c0,0x78001e00,0x1e,0x7807803c,
-      0x3c01e0,0x1e00f00,0xf007800,0x78003c78,0x1e0007,0x800f1e00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x83c00000,0x303c0003,0x8039e001,0xee000000,0x1e00,0x3c00,
-      0x0,0x1e0000,0x0,0x0,0x1e,0xf00,0x780001e,0x1f80,0x7,0x83fffffc,0x1e0,0x3c000f00,0x1e0001e,0x3c000,0x3c0000,0x0,0x1f,0xfc1fffff,
-      0xf07ff000,0x0,0x780f00f0,0x78003c03,0xc000781e,0x1e0,0xf803c0,0x1e00,0x1e000,0x781e0007,0x80007800,0x780,0x3c00f800,0x7800001e,
-      0xf078,0x3de01e0,0xf00780,0x7800,0x3c078003,0xe000000f,0xf000,0xf0003c0,0x1e78001,0xfe0ff003,0xe01f0000,0x7800007c,0x3c,0x3c,
-      0x1e0,0x0,0x0,0x0,0xf0007c01,0xe000f80f,0x800001e0,0xf80f00,0x3c,0x1e001,0xf0078007,0x80003c00,0xf000,0x780f800,0x1e0000f,
-      0x3c0f01e,0x1e03c0,0x1f00780,0x3e0f000,0x7c003c00,0x1e,0x3c000,0x3c003c0,0x3c3c001,0xe71cf000,0xf8f80003,0xe780001f,0x1e,
-      0xf0,0x780,0x0,0x0,0x3c00000,0x1ffff000,0x0,0x1e000000,0x0,0x18,0xc0,0x0,0x3bc1de,0x1e0,0xf000001,0xe00f0001,0xffff0007,0xc000007f,
-      0xffc003ff,0xfe000000,0x0,0x0,0x0,0xfe000,0x0,0x0,0x0,0x0,0x3c00000,0x1e0f0078,0x1ffff,0x1f000,0x1e000,0x0,0x780000,0xf0180000,
-      0xf000001f,0xfff00007,0x8000003c,0x1ff,0x80000000,0xe0ff0e,0x0,0x1f03e00,0x1e00,0x70,0x70000,0x0,0x78,0x0,0x0,0x0,0x3c003c0,
-      0xe1c00,0x0,0x0,0x0,0x7c0,0xf8000019,0xc0000000,0xe0000670,0x1e00000,0xf000780,0x78003c03,0xc001e01e,0xf00f0,0x780780,0x3c0f807,
-      0x8001e000,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0xf80f007,0xbc03c001,0xe01e000f,
-      0xf00078,0x78003c0,0x3c001e00,0x7c03e00f,0x800780f0,0x3c0780,0x1e03c00,0xf01e000,0x78000780,0x1e0000,0xf0003c,0x1e000f80,
-      0xf0007c07,0x8003e03c,0x1f01e0,0xf80f00,0x7c1e01e,0xf800,0x1e0000,0xf00000,0x7800000,0x3c000000,0x780000,0x3c00000,0x1e000000,
-      0xf0001e00,0x7803c00,0x3c078003,0xe03c001f,0x1e000f8,0xf0007c0,0x78003e00,0x1f8001f,0xf00f803c,0x3c01e0,0x1e00f00,0xf007800,
-      0x78003e78,0x1e000f,0x800f9e00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x3c00000,0x303c0003,0x8039f001,0xfe000000,0x1e00,0x3c00,0x0,0x1e0000,0x0,0x0,0x3c,0xf00,
-      0x780001e,0x3f00,0x7,0x80000780,0x3e0,0x3e000f00,0x3c0001e,0x3c000,0x7c0000,0x0,0x3,0xfe000000,0xff8000,0x0,0x3c0f81f0,0xf0001e03,
-      0xc000780f,0x1e0,0xf003c0,0x1e00,0xf000,0x781e0007,0x80007800,0x780,0x3c007c00,0x7800001e,0xf078,0x3de01e0,0xf00780,0x7800,
-      0x3c078001,0xe000000f,0xf000,0xf0003c0,0x1e78001,0xfc07f003,0xe00f0000,0x78000078,0x3c,0x1e,0x1e0,0x0,0x0,0x0,0xf0007c01,
-      0xf000f007,0x800000f0,0xf80780,0x3c,0x1e001,0xf0078007,0x80003c00,0xf000,0x7807c00,0x1e0000f,0x3c0f01e,0x1e01e0,0x1e007c0,
-      0x3c07800,0x7c003c00,0x1e,0x3c000,0x3c007c0,0x1e78001,0xe71df000,0xf8f80001,0xef80003e,0x1e,0xf0,0x780,0x0,0x0,0x3c00000,
-      0xfffe000,0x0,0x3e000000,0x0,0x18,0x7fff,0xc0000000,0x60c306,0x1e0,0x7800001,0xe00f0000,0xfffe0007,0x8000003f,0xff8001ff,
-      0xfc000000,0x0,0x0,0x0,0x7c000,0x0,0x0,0x0,0x0,0x3c00000,0x3c0f0078,0xfffe,0x3e000,0x1e000,0x0,0x780000,0xf0180000,0xf000003c,
-      0xfcf80007,0x8000003c,0x7f,0x0,0x70001c,0x0,0xf81f00,0x0,0x38,0xe0000,0x0,0x0,0x0,0x0,0x0,0x3c003c0,0xe1c00,0x0,0x0,0x0,0xf81,
-      0xf0000039,0xc0000000,0xe0000e70,0x1e00000,0x1e0003c0,0xf0001e07,0x8000f03c,0x781e0,0x3c0f00,0x1e0f007,0x8000f000,0x78000,
-      0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0xf00f007,0xbc03c001,0xe01e000f,0xf00078,0x78003c0,
-      0x3c001e00,0xf801f00f,0x800780f0,0x3c0780,0x1e03c00,0xf01e000,0x78000780,0x1e0000,0xf0003c,0x1e000f80,0xf0007c07,0x8003e03c,
-      0x1f01e0,0xf80f00,0x7c1e01e,0x7800,0xf0000,0x780000,0x3c00000,0x1e000000,0x780000,0x3c00000,0x1e000000,0xf0000f00,0xf003c00,
-      0x3c03c003,0xc01e001e,0xf000f0,0x7800780,0x3c003c00,0x1f8000f,0xe00f003c,0x7c01e0,0x3e00f00,0x1f007800,0xf8001ef8,0x1f000f,
-      0x7be00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0xf,0x3c00000,0x307c0003,0x8038f000,0xfc000000,0x1e00,0x3c00,0x0,0x1e0000,0xfc0000,0x0,0x7e00003c,0x780,0xf00001e,
-      0x7e00,0xf,0x80000780,0x3c0,0x3e001e00,0x3c0001f,0x7c000,0x780007,0xe000003f,0x0,0xfe000000,0xfe0000,0x0,0x3c07c3f0,0xf0001e03,
-      0xc000f80f,0x800001e0,0x1f003c0,0x1e00,0xf000,0x781e0007,0x80007800,0x4000f80,0x3c003c00,0x7800001e,0xf078,0x1fe01f0,0x1f00780,
-      0x7c00,0x7c078001,0xf000001f,0xf000,0xf0003c0,0x1e78001,0xfc07f007,0xc00f8000,0x780000f8,0x3c,0x1e,0x1e0,0x0,0x0,0x0,0xf0007c01,
-      0xf000f007,0xc00000f0,0xf80780,0x3c,0x1f003,0xf0078007,0x80003c00,0xf000,0x7807c00,0x1e0000f,0x3c0f01e,0x1e01e0,0x1e007c0,
-      0x3c07800,0x7c003c00,0x1e,0x3c000,0x3c007c0,0x1e78000,0xfe0fe001,0xf07c0001,0xef00007c,0x1e,0xf0,0x780,0x0,0x0,0x1e00000,
-      0x7cfc000,0xfc00000,0x3c00000f,0xc3f00000,0x18,0x7fff,0xc0000000,0x406303,0x3e0,0x3c00001,0xf00f0000,0x7cfc000f,0x8000001f,
-      0x3f0000f9,0xf8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,0x780700f8,0x7cfc,0x7c000,0x1e000,0x0,0x780000,0xf8180000,
-      0xf0000070,0x3c0007,0x8000003c,0x3f,0x80000000,0x3c0078,0x0,0x780f00,0x0,0x1e,0x3c0000,0x0,0x0,0x0,0x0,0x0,0x3e007c0,0xe1c00,
-      0x0,0x0,0x0,0xf01,0xe0000071,0xc0000000,0xe0001c70,0x1e00000,0x1e0003c0,0xf0001e07,0x8000f03c,0x781e0,0x3c0f00,0x1e0f007,
-      0x8000f800,0x78000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x1f00f003,0xfc03e003,0xe01f001f,
-      0xf800f8,0x7c007c0,0x3e003e01,0xf000f80f,0xf00f0,0x3c0780,0x1e03c00,0xf01e000,0x78000780,0x1e0000,0xf0003c,0x1e000f80,0xf0007c07,
-      0x8003e03c,0x1f01e0,0xf80f00,0x7c1e01e,0x7c00,0xf0000,0x780000,0x3c00000,0x1e000000,0x780000,0x3c00000,0x1e000000,0xf0000f00,
-      0xf003c00,0x3c03c003,0xc01e001e,0xf000f0,0x7800780,0x3c003c00,0x1f8000f,0xc00f003c,0x7c01e0,0x3e00f00,0x1f007800,0xf8001ef0,
-      0x1f000f,0x7bc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x780000,0xf,0x3800040,0x30780003,0x8038f800,0x78000000,0x1e00,0x3c00,0x0,0x1e0000,0xfc0000,0x0,0x7e000078,
-      0x780,0x1f00001e,0xfc00,0x20001f,0x780,0x80007c0,0x1f001e00,0x7c0000f,0x78000,0xf80007,0xe000003f,0x0,0x1e000000,0xf00000,
-      0x3c000,0x3c03fff0,0xf0001e03,0xc001f007,0x800101e0,0x7e003c0,0x1e00,0x7800,0x781e0007,0x80007800,0x6000f00,0x3c003e00,0x7800001e,
-      0xf078,0x1fe00f0,0x1e00780,0x3c00,0x78078000,0xf020001e,0xf000,0x7800780,0xff0001,0xfc07f00f,0x8007c000,0x780001f0,0x3c,0xf,
-      0x1e0,0x0,0x0,0x0,0xf800fc01,0xf801f007,0xc00100f8,0x1f807c0,0x40003c,0xf807,0xf0078007,0x80003c00,0xf000,0x7803e00,0x1f0000f,
-      0x3c0f01e,0x1e01f0,0x3e007e0,0x7c07c00,0xfc003c00,0x1e,0x3e000,0x3e007c0,0x1ff8000,0xfe0fe003,0xe03e0001,0xff0000fc,0x1e,
-      0xf0,0x780,0x0,0x0,0x1f00080,0x3cf8000,0xfc00000,0x3c00001f,0x83f00000,0x18,0xc0,0x0,0xc06203,0x40003c0,0x1c00000,0xf80f0000,
-      0x3cf8001f,0xf,0x3e000079,0xf0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,0x700780fc,0x3cf8,0xfc000,0x1e000,0x0,0x780000,
-      0x7c180000,0xf0000020,0x100007,0x8000003c,0xf,0x80000000,0x1f01f0,0x0,0x380700,0x0,0xf,0x80f80000,0x0,0x0,0x0,0x0,0x0,0x3e007c0,
-      0xe1c00,0x0,0x0,0x0,0xe01,0xc0000071,0xc0000001,0xc0001c70,0x1e00040,0x1e0003c0,0xf0001e07,0x8000f03c,0x781e0,0x3c0f00,0x1e0f007,
-      0x80007800,0x10078000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e00,0x7e00f003,0xfc01e003,0xc00f001e,
-      0x7800f0,0x3c00780,0x1e003c00,0xe000700f,0x800f0078,0x7803c0,0x3c01e00,0x1e00f000,0xf0000780,0x1e0000,0xf0003c,0x1f001f80,
-      0xf800fc07,0xc007e03e,0x3f01f0,0x1f80f80,0xfc1e01f,0x7c00,0x100f8000,0x807c0004,0x3e00020,0x1f000100,0x780000,0x3c00000,0x1e000000,
-      0xf0000f80,0x1f003c00,0x3c03e007,0xc01f003e,0xf801f0,0x7c00f80,0x3e007c00,0x1f8000f,0x801f003e,0x7c01f0,0x3e00f80,0x1f007c00,
-      0xf8001ff0,0x1f801f,0x7fc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0xf,0x7800078,0x31f80001,0xc070fc00,0xfc000000,0x1e00,0x7c00,0x0,0x1e0000,0xfc0000,0x0,0x7e000078,
-      0x7c0,0x1f00001e,0x1f000,0x38003f,0x780,0xe000f80,0x1f803e00,0x780000f,0x800f8000,0x1f00007,0xe000003f,0x0,0x2000000,0x800000,
-      0x3c000,0x3e01ff71,0xf0001f03,0xc007f007,0xc00301e0,0x1fc003c0,0x1e00,0x7c00,0x781e0007,0x80007800,0x7801f00,0x3c001f00,0x7800001e,
-      0xf078,0xfe00f8,0x3e00780,0x3e00,0xf8078000,0xf838003e,0xf000,0x7c00f80,0xff0000,0xfc07e00f,0x8003c000,0x780001e0,0x3c,0xf,
-      0x1e0,0x0,0x0,0x0,0xf801fc01,0xfc03e003,0xe003007c,0x3f803e0,0x1c0003c,0xfc0f,0xf0078007,0x80003c00,0xf000,0x7801f00,0xf8000f,
-      0x3c0f01e,0x1e00f8,0x7c007f0,0xf803e01,0xfc003c00,0x8003e,0x1f000,0x1e00fc0,0xff0000,0xfe0fe007,0xc01f0000,0xfe0000f8,0x1e,
-      0xf0,0x780,0x0,0x0,0xf80180,0x1cf0000,0x1f800000,0x3c00001f,0x83e00000,0x18,0xc0,0x0,0xc06203,0x70007c0,0xe00000,0x7e0f0000,
-      0x1cf0001e,0x7,0x3c000039,0xe0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x7c00000,0xe00780fc,0x2001cf0,0xf8000,0x1e000,0x0,
-      0x780000,0x7e182000,0xf0000000,0x7,0x8000003c,0x7,0xc0000000,0x7ffc0,0x0,0x180300,0x0,0x3,0xffe00000,0x0,0x0,0x0,0x0,0x0,
-      0x3f00fc0,0xe1c00,0x0,0x0,0x0,0xc01,0x800000e1,0xc0000003,0xc0003870,0x1f001c0,0x3e0003e1,0xf0001f0f,0x8000f87c,0x7c3e0,0x3e1f00,
-      0x1f1e007,0x80007c00,0x30078000,0x3c0000,0x1e00000,0xf000000,0xf00000,0x7800000,0x3c000001,0xe0001e03,0xfc00f001,0xfc01f007,
-      0xc00f803e,0x7c01f0,0x3e00f80,0x1f007c00,0x4000201f,0xc01f007c,0xf803e0,0x7c01f00,0x3e00f801,0xf0000780,0x1e0000,0xf0007c,
-      0x1f003f80,0xf801fc07,0xc00fe03e,0x7f01f0,0x3f80f80,0x1fc1f03f,0x803e00,0x3007c003,0x803e001c,0x1f000e0,0xf800700,0x780000,
-      0x3c00000,0x1e000000,0xf00007c0,0x3e003c00,0x3c01f00f,0x800f807c,0x7c03e0,0x3e01f00,0x1f00f800,0x1f80007,0xc03e001e,0xfc00f0,
-      0x7e00780,0x3f003c01,0xf8000fe0,0x1fc03e,0x3f800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1e,0x780007f,0xfff00001,0xe0f07f03,0xfe000000,0xf00,0x7800,0x0,
-      0x1e0000,0xfc0000,0x0,0x7e0000f0,0x3f0,0x7e000fff,0xfc03ffff,0xf83f00fe,0x780,0xfc03f80,0xfc0fc00,0xf800007,0xe03f0018,0x7e00007,
-      0xe000003f,0x0,0x0,0x0,0x3c000,0x1e007c71,0xe0000f03,0xffffe003,0xf01f01ff,0xff8003ff,0xffe01e00,0x3f01,0xf81e0007,0x803ffff0,
-      0x7e03f00,0x3c000f00,0x7ffffe1e,0xf078,0xfe007e,0xfc00780,0x1f83,0xf0078000,0x783f00fe,0xf000,0x3f03f00,0xff0000,0xfc07e01f,
-      0x3e000,0x780003ff,0xfffc003c,0x7,0x800001e0,0x0,0x0,0x0,0x7e07fc01,0xfe07e001,0xf80f007e,0x7f801f8,0xfc0003c,0x7ffe,0xf0078007,
-      0x807ffffe,0xf000,0x7801f00,0xfff00f,0x3c0f01e,0x1e00fc,0xfc007f8,0x1f803f03,0xfc003c00,0xf80fc,0x1fff0,0x1f83fc0,0xff0000,
-      0xfc07e007,0xc01f0000,0xfe0001ff,0xffe0001e,0xf0,0x780,0x0,0x0,0xfe0780,0xfe0000,0x1f000000,0x3c00001f,0x7c00e03,0x81c00018,
-      0xc0,0x0,0x406203,0x7e01fc0,0x700000,0x7fffff80,0xfe0003f,0xffffc003,0xf800001f,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f0,
-      0x1f800001,0xc007c1fe,0x6000fe0,0x1ffffe,0x1e000,0x0,0x780000,0x3f98e03f,0xffff8000,0x7,0x8000003c,0x7,0xc0000000,0xfe00,
-      0x0,0x80100,0x0,0x0,0x7f000000,0x0,0x1ffff,0xfe000000,0x0,0x0,0x3f83fe8,0xe1c00,0x0,0x0,0x0,0x801,0xc1,0xc0000007,0x80003070,
-      0xfc0fc0,0x3c0001e1,0xe0000f0f,0x7878,0x3c3c0,0x1e1e00,0xf1e007,0xffc03f01,0xf007ffff,0xc03ffffe,0x1fffff0,0xfffff80,0x7fffe003,
-      0xffff001f,0xfff800ff,0xffc01fff,0xf800f001,0xfc00fc1f,0x8007e0fc,0x3f07e0,0x1f83f00,0xfc1f800,0x1f,0xf07e003f,0x3f001f8,
-      0x1f800fc0,0xfc007e07,0xe0000780,0x1e0000,0xf301f8,0xfc0ff80,0x7e07fc03,0xf03fe01f,0x81ff00fc,0xff807e0,0x7fc0f87f,0x81801f80,
-      0xf003f01f,0x801f80fc,0xfc07e0,0x7e03f00,0xfffffc07,0xffffe03f,0xffff01ff,0xfff807e0,0x7e003c00,0x3c01f81f,0x800fc0fc,0x7e07e0,
-      0x3f03f00,0x1f81f800,0x1f8000f,0xe07e001f,0x83fc00fc,0x1fe007e0,0xff003f07,0xf8000fe0,0x1fe07e,0x3f800,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1e,0x780007f,
-      0xffe00000,0xffe03fff,0xdf000000,0xf00,0x7800,0x0,0x0,0xfc0000,0x0,0x7e0000f0,0x1ff,0xfc000fff,0xfc03ffff,0xf83ffffc,0x780,
-      0xfffff00,0x7fff800,0xf000007,0xffff001f,0xffe00007,0xe000003f,0x0,0x0,0x0,0x3c000,0x1e000001,0xe0000f03,0xffffc001,0xffff01ff,
-      0xff0003ff,0xffe01e00,0x1fff,0xf81e0007,0x803ffff0,0x7fffe00,0x3c000f80,0x7ffffe1e,0xf078,0xfe003f,0xff800780,0xfff,0xf0078000,
-      0x7c3ffffc,0xf000,0x3ffff00,0xff0000,0xf803e01e,0x1e000,0x780003ff,0xfffc003c,0x7,0x800001e0,0x0,0x0,0x0,0x7fffbc01,0xffffc000,
-      0xffff003f,0xfff800ff,0xffc0003c,0x3ffe,0xf0078007,0x807ffffe,0xf000,0x7800f80,0x7ff00f,0x3c0f01e,0x1e007f,0xff8007ff,0xff001fff,
-      0xbc003c00,0xffffc,0x1fff0,0x1fffbc0,0xff0000,0x7c07c00f,0x800f8000,0x7e0001ff,0xffe0001e,0xf0,0x780,0x0,0x0,0x7fff80,0x7c0000,
-      0x1f000000,0x3c00001e,0x7c00f07,0xc1e00018,0xc0,0x0,0x60e303,0x7ffff80,0x380000,0x3fffff80,0x7c0003f,0xffffc001,0xf000000f,
-      0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ff,0xff800003,0x8003ffff,0xfe0007c0,0x1ffffe,0x1e000,0x0,0x780000,0x1fffe03f,0xffff8000,
-      0x7,0x8000003c,0x3,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffff,0xfe000000,0x0,0x0,0x3fffdf8,0xe1c00,0x0,0x0,0x0,0x0,0x1c1,
-      0xc000000f,0x7070,0x7fffc0,0x3c0001e1,0xe0000f0f,0x7878,0x3c3c0,0x1e1e00,0xf1e007,0xffc01fff,0xf007ffff,0xc03ffffe,0x1fffff0,
-      0xfffff80,0x7fffe003,0xffff001f,0xfff800ff,0xffc01fff,0xf000f001,0xfc007fff,0x3fff8,0x1fffc0,0xfffe00,0x7fff000,0x3b,0xfffc003f,
-      0xfff001ff,0xff800fff,0xfc007fff,0xe0000780,0x1e0000,0xf3fff8,0xffff780,0x7fffbc03,0xfffde01f,0xffef00ff,0xff7807ff,0xfbc0ffff,
-      0xff800fff,0xf001ffff,0x800ffffc,0x7fffe0,0x3ffff00,0xfffffc07,0xffffe03f,0xffff01ff,0xfff803ff,0xfc003c00,0x3c00ffff,0x7fff8,
-      0x3fffc0,0x1fffe00,0xffff000,0x1f,0xfffc001f,0xffbc00ff,0xfde007ff,0xef003fff,0x780007e0,0x1ffffc,0x1f800,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1e,0x700003f,
-      0xffc00000,0x7fc01fff,0x9f800000,0xf80,0xf800,0x0,0x0,0xfc0000,0x0,0x7e0000f0,0xff,0xf8000fff,0xfc03ffff,0xf83ffff8,0x780,
-      0xffffe00,0x7fff000,0xf000003,0xfffe001f,0xffc00007,0xe000003f,0x0,0x0,0x0,0x3c000,0xf000003,0xe0000f83,0xffff0000,0xffff01ff,
-      0xfc0003ff,0xffe01e00,0xfff,0xf01e0007,0x803ffff0,0x7fffc00,0x3c0007c0,0x7ffffe1e,0xf078,0x7e003f,0xff000780,0x7ff,0xe0078000,
-      0x3c3ffff8,0xf000,0x1fffe00,0x7e0000,0xf803e03e,0x1f000,0x780003ff,0xfffc003c,0x7,0x800001e0,0x0,0x0,0x0,0x3fff3c01,0xefff8000,
-      0x7ffe001f,0xff78007f,0xff80003c,0x1ffc,0xf0078007,0x807ffffe,0xf000,0x78007c0,0x3ff00f,0x3c0f01e,0x1e003f,0xff0007bf,0xfe000fff,
-      0xbc003c00,0xffff8,0xfff0,0xfff3c0,0x7e0000,0x7c07c01f,0x7c000,0x7c0001ff,0xffe0001e,0xf0,0x780,0x0,0x0,0x3fff80,0x380000,
-      0x3e000000,0x7c00003e,0x7801f07,0xc1e00018,0xc0,0x0,0x39c1ce,0x7ffff00,0x1c0000,0xfffff80,0x380003f,0xffffc000,0xe0000007,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ff,0xff000007,0x1ffcf,0xfe000380,0x1ffffe,0x1e000,0x0,0x780000,0xfffe03f,0xffff8000,0x7,
-      0x8000003c,0x3,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffff,0xfe000000,0x0,0x0,0x3dffdf8,0xe1c00,0x0,0x0,0x0,0x0,0x381,
-      0xc000001e,0xe070,0x7fff80,0x7c0001f3,0xe0000f9f,0x7cf8,0x3e7c0,0x1f3e00,0xfbe007,0xffc00fff,0xf007ffff,0xc03ffffe,0x1fffff0,
-      0xfffff80,0x7fffe003,0xffff001f,0xfff800ff,0xffc01fff,0xc000f000,0xfc007ffe,0x3fff0,0x1fff80,0xfffc00,0x7ffe000,0x79,0xfff8001f,
-      0xffe000ff,0xff0007ff,0xf8003fff,0xc0000780,0x1e0000,0xf3fff0,0x7ffe780,0x3fff3c01,0xfff9e00f,0xffcf007f,0xfe7803ff,0xf3c07ff3,
-      0xff8007ff,0xe000ffff,0x7fff8,0x3fffc0,0x1fffe00,0xfffffc07,0xffffe03f,0xffff01ff,0xfff801ff,0xf8003c00,0x3c007ffe,0x3fff0,
-      0x1fff80,0xfffc00,0x7ffe000,0x1d,0xfff8000f,0xff3c007f,0xf9e003ff,0xcf001ffe,0x780007c0,0x1efff8,0x1f000,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780000,0x1e,0xf000003,
-      0xfe000000,0x1f000fff,0xfc00000,0x780,0xf000,0x0,0x0,0xf80000,0x0,0x7e0001e0,0x7f,0xf0000fff,0xfc03ffff,0xf81ffff0,0x780,
-      0x7fff800,0x1ffe000,0x1f000000,0xfff8001f,0xff000007,0xe000003e,0x0,0x0,0x0,0x3c000,0xf800003,0xc0000783,0xfff80000,0x3ffe01ff,
-      0xe00003ff,0xffe01e00,0x7ff,0xc01e0007,0x803ffff0,0x3fff800,0x3c0003c0,0x7ffffe1e,0xf078,0x7e000f,0xfe000780,0x3ff,0xc0078000,
-      0x3e1fffe0,0xf000,0x7ff800,0x7e0000,0xf803e07c,0xf800,0x780003ff,0xfffc003c,0x3,0xc00001e0,0x0,0x0,0x0,0xffe3c01,0xe7ff0000,
-      0x3ffc000f,0xfe78003f,0xfe00003c,0x7f0,0xf0078007,0x807ffffe,0xf000,0x78003e0,0xff00f,0x3c0f01e,0x1e001f,0xfe00079f,0xfc0007ff,
-      0x3c003c00,0x7ffe0,0x1ff0,0x7fe3c0,0x7e0000,0x7c07c03e,0x3e000,0x7c0001ff,0xffe0001e,0xf0,0x780,0x0,0x0,0xfff00,0x100000,
-      0x3e000000,0x7800003c,0xf800f07,0xc1e00018,0xc0,0x0,0x1f80fc,0x3fffc00,0xc0000,0x3ffff80,0x100003f,0xffffc000,0x40000002,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0xfc000006,0xff87,0xfc000100,0x1ffffe,0x1e000,0x0,0x780000,0x3ffc03f,0xffff8000,0x7,
-      0x8000003c,0x3,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffff,0xfe000000,0x0,0x0,0x3dff9f8,0xe1c00,0x0,0x0,0x0,0x0,0x3ff,
-      0xf800003c,0xfffe,0x1ffe00,0x780000f3,0xc000079e,0x3cf0,0x1e780,0xf3c00,0x7bc007,0xffc003ff,0xe007ffff,0xc03ffffe,0x1fffff0,
-      0xfffff80,0x7fffe003,0xffff001f,0xfff800ff,0xffc01ffc,0xf000,0xfc001ffc,0xffe0,0x7ff00,0x3ff800,0x1ffc000,0x70,0xfff00007,
-      0xff80003f,0xfc0001ff,0xe0000fff,0x780,0x1e0000,0xf3ffe0,0x1ffc780,0xffe3c00,0x7ff1e003,0xff8f001f,0xfc7800ff,0xe3c03fe1,
-      0xff0003ff,0xc0007ffc,0x3ffe0,0x1fff00,0xfff800,0xfffffc07,0xffffe03f,0xffff01ff,0xfff800ff,0xf0003c00,0x3c003ffc,0x1ffe0,
-      0xfff00,0x7ff800,0x3ffc000,0x38,0xfff00007,0xfe3c003f,0xf1e001ff,0x8f000ffc,0x780007c0,0x1e7ff0,0x1f000,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,
-      0x1fc,0x0,0x780,0xf000,0x0,0x0,0x1f80000,0x0,0x1e0,0x1f,0xc0000000,0x0,0x1ff80,0x0,0xffc000,0x7f8000,0x0,0x3fe00007,0xfc000000,
-      0x7e,0x0,0x0,0x0,0x0,0x7c00000,0x0,0x0,0xff00000,0x0,0x0,0xfe,0x0,0x0,0x3fc000,0x0,0x0,0x0,0x3,0xf8000000,0xff,0xc0000000,
-      0x1ff00,0x0,0x1fe000,0x0,0x0,0x0,0x0,0x3c,0x3,0xc00001e0,0x0,0x0,0x0,0x3f80000,0x1fc0000,0x7f00003,0xf8000007,0xf0000000,
-      0x0,0xf0000000,0x0,0xf000,0x0,0x0,0x0,0x7,0xf8000787,0xf00001fc,0x3c000000,0x7f80,0x0,0x1f8000,0x0,0x0,0x0,0x7c000000,0x1e,
-      0xf0,0x780,0x0,0x0,0x3fc00,0x0,0x3c000000,0x7800003c,0xf000601,0xc00018,0xc0,0x0,0x0,0x3fe000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0xf,0xf0000000,0x7e03,0xf0000000,0x0,0x0,0x0,0x0,0xfe0000,0x0,0x0,0x3c,0x2007,0x80000000,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c7e0f0,0xe1c00,0x0,0x3800000,0x0,0x0,0x3ff,0xf8000078,0xfffe,0x7f800,0x0,0x0,0x0,0x0,
-      0x0,0x0,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f0,0x3f80,0x1fc00,0xfe000,0x7f0000,0x70,0x3fc00001,0xfe00000f,0xf000007f,
-      0x800003fc,0x0,0x0,0xff00,0x7f0000,0x3f80000,0x1fc00000,0xfe000007,0xf000003f,0x80001f80,0xfc00007f,0xfe0,0x7f00,0x3f800,
-      0x1fc000,0x0,0x0,0x0,0x3f,0xc0000000,0xff0,0x7f80,0x3fc00,0x1fe000,0xff0000,0x78,0x3fc00001,0xf800000f,0xc000007e,0x3f0,0x7c0,
-      0x1e1fc0,0x1f000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x0,0x0,0x3c0,0x1e000,0x0,0x0,0x1f00000,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x7c,0x0,0x0,0x0,0x0,0x3e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0xe0000000,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x3c,0x1,0xe00001e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0000000,0x0,0xf000,0x0,0x0,0x0,0x0,0x780,0x0,0x3c000000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x78000000,0x1e,0xf0,0x780,0x0,0x0,0x0,0x0,0x3c000000,0x78000078,0xf000000,0x18,0xc0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x0,0x0,0x3c,0x3c0f,0x80000000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,0xe1c00,0x0,0x1800000,0x0,0x0,0x3ff,0xf80000f0,0xfffe,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30,0x0,0x0,0x0,0x0,0x780,0x1e0000,0x1e000,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,
-      0x0,0x0,0x3c0,0x1e000,0x0,0x0,0x1f00000,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7c,0x0,0x0,0x0,0x0,0x1f80000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0xf0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c,0x1,0xe00001e0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xe0000000,0x0,0xf000,0x0,0x0,0x0,0x0,0x780,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x0,0xf8000000,
-      0x1f,0xf0,0xf80,0x0,0x0,0x0,0x0,0x78000000,0xf8000078,0x1e000000,0x8,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x0,0x0,0x3c,0x3fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x3c00000,0xe1c00,0x0,0x1c00000,0x0,0x0,0x1,0xc00001e0,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf80,0x1e0000,0x3e000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x0,0x0,0x1e0,0x3c000,0x0,0x0,0x1f00000,
-      0x0,0x780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7c,0x0,0x0,0x0,0x0,0xfe0100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0xf8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0xf0000000,0xf0007fe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xe0000000,
-      0x0,0xf000,0x0,0x0,0x0,0x0,0x780,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x0,0xf0000000,0x1f,0x800000f0,0x1f80,0x0,0x0,0x0,0x0,
-      0x78000000,0xf0000070,0x1c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x180000,0x0,0x0,0x3c,0x3ffe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,0xe1c00,0x0,0xe00000,
-      0x0,0x0,0x1,0xc00003ff,0xe0000070,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0xf00,0x1e0000,0x3c000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x0,0x0,0x1e0,0x7c000,0x0,0x0,0x1e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x78,0x0,0x0,0x0,0x0,0x7fff80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78000000,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0xf0000000,0x7fe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4003,0xe0000000,0x0,0x1f000,0x0,0x0,
-      0x0,0x0,0x780,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x1,0xf0000000,0xf,0xfc0000f0,0x3ff00,0x0,0x0,0x0,0x0,0x70000001,0xf00000e0,
-      0x1c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,
-      0x0,0x0,0x3c,0xff8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,0xe1c00,0x0,0xe00000,0x0,0x0,0x1,0xc00003ff,
-      0xe0000070,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f00,0x1e0000,
-      0x7c000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x30000000,0x0,0x0,0xf0,0x78000,0x0,0x0,0x3e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8,0x0,
-      0x0,0x0,0x0,0x1fff80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,
-      0xf0000000,0x7fe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x780f,0xc0000000,0x0,0x3e000,0x0,0x0,0x0,0x0,0x780,0x0,0x3c000000,0x0,
-      0x0,0x0,0x0,0x0,0x3,0xe0000000,0xf,0xfc0000f0,0x3ff00,0x0,0x0,0x0,0x0,0xf0000103,0xe0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x0,0x0,0x3c,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,0x0,0x0,0x21e00000,0x0,0x0,0x1,0xc00003ff,0xe0000070,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10f,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10f,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e00,0x1e0000,0xf8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x0,0x0,
-      0xf8,0xf8000,0x0,0x0,0x3c00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0x1fe00,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f,0xf0000000,0x7fe0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x7fff,0xc0000000,0x0,0x3ffe000,0x0,0x0,0x0,0x0,0x780,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x7f,0xe0000000,0x7,0xfc0000f0,
-      0x3fe00,0x0,0x0,0x0,0x0,0x600001ff,0xe0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x0,0x0,0x3c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,0x0,0x0,
-      0x3fe00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x7fe00,0x1e0000,0x1ff8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x1fffffe0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fff,0x80000000,0x0,0x3ffc000,0x0,0x0,0x0,0x0,0x780,0x0,0x3c000000,0x0,
-      0x0,0x0,0x0,0x0,0x7f,0xc0000000,0x0,0xfc0000f0,0x3f000,0x0,0x0,0x0,0x0,0x1ff,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x3c00000,0x0,0x0,0x3fc00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fe,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fe,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fc00,0x1e0000,0x1ff0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fffffe0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffe,0x0,0x0,0x3ff8000,0x0,0x0,0x0,
-      0x0,0x780,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x7f,0x80000000,0x0,0xf0,0x0,0x0,0x0,0x0,0x0,0x1ff,0x80000000,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,0x0,0x0,0x3f800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fc,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fc,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f800,0x1e0000,0x1fe0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fffffe0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f8,0x0,0x0,0x3fe0000,
-      0x0,0x0,0x0,0x0,0x780,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x7e,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7e000,0x1e0000,0x1f80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fffffe0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
-      0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 };
-
-    // Definition of a 40x38 'danger' color logo
-    const unsigned char logo40x38[4576] = {
-      177,200,200,200,3,123,123,0,36,200,200,200,1,123,123,0,2,255,255,0,1,189,189,189,1,0,0,0,34,200,200,200,
-      1,123,123,0,4,255,255,0,1,189,189,189,1,0,0,0,1,123,123,123,32,200,200,200,1,123,123,0,5,255,255,0,1,0,0,
-      0,2,123,123,123,30,200,200,200,1,123,123,0,6,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,29,200,200,200,
-      1,123,123,0,7,255,255,0,1,0,0,0,2,123,123,123,28,200,200,200,1,123,123,0,8,255,255,0,1,189,189,189,1,0,0,0,
-      2,123,123,123,27,200,200,200,1,123,123,0,9,255,255,0,1,0,0,0,2,123,123,123,26,200,200,200,1,123,123,0,10,255,
-      255,0,1,189,189,189,1,0,0,0,2,123,123,123,25,200,200,200,1,123,123,0,3,255,255,0,1,189,189,189,3,0,0,0,1,189,
-      189,189,3,255,255,0,1,0,0,0,2,123,123,123,24,200,200,200,1,123,123,0,4,255,255,0,5,0,0,0,3,255,255,0,1,189,
-      189,189,1,0,0,0,2,123,123,123,23,200,200,200,1,123,123,0,4,255,255,0,5,0,0,0,4,255,255,0,1,0,0,0,2,123,123,123,
-      22,200,200,200,1,123,123,0,5,255,255,0,5,0,0,0,4,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,21,200,200,200,
-      1,123,123,0,5,255,255,0,5,0,0,0,5,255,255,0,1,0,0,0,2,123,123,123,20,200,200,200,1,123,123,0,6,255,255,0,5,0,0,
-      0,5,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,19,200,200,200,1,123,123,0,6,255,255,0,1,123,123,0,3,0,0,0,1,
-      123,123,0,6,255,255,0,1,0,0,0,2,123,123,123,18,200,200,200,1,123,123,0,7,255,255,0,1,189,189,189,3,0,0,0,1,189,
-      189,189,6,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,17,200,200,200,1,123,123,0,8,255,255,0,3,0,0,0,8,255,255,
-      0,1,0,0,0,2,123,123,123,16,200,200,200,1,123,123,0,9,255,255,0,1,123,123,0,1,0,0,0,1,123,123,0,8,255,255,0,1,189,
-      189,189,1,0,0,0,2,123,123,123,15,200,200,200,1,123,123,0,9,255,255,0,1,189,189,189,1,0,0,0,1,189,189,189,9,255,255,
-      0,1,0,0,0,2,123,123,123,14,200,200,200,1,123,123,0,11,255,255,0,1,0,0,0,10,255,255,0,1,189,189,189,1,0,0,0,2,123,
-      123,123,13,200,200,200,1,123,123,0,23,255,255,0,1,0,0,0,2,123,123,123,12,200,200,200,1,123,123,0,11,255,255,0,1,189,
-      189,189,2,0,0,0,1,189,189,189,9,255,255,0,1,189,189,189,1,0,0,0,2,123,123,123,11,200,200,200,1,123,123,0,11,255,255,
-      0,4,0,0,0,10,255,255,0,1,0,0,0,2,123,123,123,10,200,200,200,1,123,123,0,12,255,255,0,4,0,0,0,10,255,255,0,1,189,189,
-      189,1,0,0,0,2,123,123,123,9,200,200,200,1,123,123,0,12,255,255,0,1,189,189,189,2,0,0,0,1,189,189,189,11,255,255,0,1,
-      0,0,0,2,123,123,123,9,200,200,200,1,123,123,0,27,255,255,0,1,0,0,0,3,123,123,123,8,200,200,200,1,123,123,0,26,255,
-      255,0,1,189,189,189,1,0,0,0,3,123,123,123,9,200,200,200,1,123,123,0,24,255,255,0,1,189,189,189,1,0,0,0,4,123,123,
-      123,10,200,200,200,1,123,123,0,24,0,0,0,5,123,123,123,12,200,200,200,27,123,123,123,14,200,200,200,25,123,123,123,86,
-      200,200,200,91,49,124,118,124,71,32,124,95,49,56,114,52,82,121,0};
-
-    // Display a warning message if parameter 'cond' is true.
-    inline void warn(const bool cond, const char *format,...) {
-      if (cimg::exception_mode()>=1 && cond) {
-        std::va_list ap;
-        va_start(ap,format);
-        std::fprintf(stderr,"\n<CImg Warning> ");
-        std::vfprintf(stderr,format,ap);
-        std::fputc('\n',stderr);
-        va_end(ap);
-      }
-    }
-
-    inline int xln(const int x) {
-      return x>0?(int)(1+std::log10((double)x)):1;
-    }
-
-    inline char uncase(const char x) {
-      return (char)((x<'A'||x>'Z')?x:x-'A'+'a');
-    }
-
-    inline float atof(const char *str) {
-      float x=0,y=1;
-      if (!str) return 0; else { std::sscanf(str,"%g/%g",&x,&y); return x/y; }
-    }
-
-    inline int strlen(const char *s) {
-      if (s) { int k; for (k=0; s[k]; k++) ; return k; }
-      return -1;
-    }
-
-    inline int strncmp(const char *s1,const char *s2,const int l) {
-      if (s1 && s2) { int n=0; for (int k=0; k<l; k++) n+=std::abs(s1[k] - s2[k]); return n; }
-      return 0;
-    }
-
-    inline int strncasecmp(const char *s1,const char *s2,const int l) {
-      if (s1 && s2) { int n=0; for (int k=0; k<l; k++) n+=std::abs(uncase(s1[k])-uncase(s2[k])); return n; }
-      return 0;
-    }
-
-    inline int strcmp(const char *s1,const char *s2) {
-      const int l1 = cimg::strlen(s1), l2 = cimg::strlen(s2);
-      return cimg::strncmp(s1,s2,1+(l1<l2?l1:l2));
-    }
-
-    inline int strcasecmp(const char *s1,const char *s2) {
-      const int l1 = cimg::strlen(s1), l2 = cimg::strlen(s2);
-      return cimg::strncasecmp(s1,s2,1+(l1<l2?l1:l2));
-    }
-
-    inline int strfind(const char *s,const char c) {
-      if (s) {
-        int l; for (l=cimg::strlen(s); l>=0 && s[l]!=c; l--) ;
-        return l;
-      }
-      return -1;
-    }
-
-    inline const char* basename(const char *s)  {
-      return (cimg_OS!=2)?(s?s+1+cimg::strfind(s,'/'):0):(s?s+1+cimg::strfind(s,'\\'):0);
-    }
-
-    inline void system(const char *command, const char *module_name=0) {
-#if cimg_OS==2
-      PROCESS_INFORMATION pi;
-      STARTUPINFO si;
-      std::memset(&pi, 0, sizeof(PROCESS_INFORMATION));
-      std::memset(&si, 0, sizeof(STARTUPINFO));
-      GetStartupInfo(&si);
-      si.cb = sizeof(si);
-      si.wShowWindow = SW_HIDE;
-      si.dwFlags |= SW_HIDE;
-      const BOOL res = CreateProcess((LPCTSTR)module_name,(LPTSTR)command,0,0,FALSE,0,0,0,&si,&pi);
-      if (res) {
-        WaitForSingleObject(pi.hProcess, INFINITE);
-        CloseHandle(pi.hThread);
-        CloseHandle(pi.hProcess);
-      } else
-#endif
-      std::system(command);
-      command=module_name=0;
-    }
-
-    //! Return path of the ImageMagick's \c convert tool.
-    /**
-       If you have installed the <a href="http://www.imagemagick.org">ImageMagick package</a>
-       in a standard directory, this function should return the correct path of the \c convert tool
-       used by the %CImg Library to load and save compressed image formats.
-       Conversely, if the \c convert executable is not auto-detected by the function,
-       you can define the macro \c cimg_imagemagick_path with the correct path
-       of the \c convert executable, before including <tt>CImg.h</tt> in your program :
-       \code
-       #define cimg_imagemagick_path "/users/thatsme/local/bin/convert"
-       #include "CImg.h"
-
-       int main() {
-         CImg<> img("my_image.jpg");     // Read a JPEG image file.
-         return 0;
-       }
-       \endcode
-
-       Note that non compressed image formats can be read without installing ImageMagick.
-
-       \sa temporary_path(), get_load_imagemagick(), load_imagemagick(), save_imagemagick().
-    **/
-    inline const char* imagemagick_path() {
-      static char *st_imagemagick_path = 0;
-      if (!st_imagemagick_path) {
-        st_imagemagick_path = new char[1024];
-        bool path_found = false;
-        std::FILE *file = 0;
-#ifdef cimg_imagemagick_path
-        std::strcpy(st_imagemagick_path,cimg_imagemagick_path);
-        if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-#endif
-#if cimg_OS==2
-        if (!path_found) {
-          std::sprintf(st_imagemagick_path,".\\convert.exe");
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"C:\\IMAGEM~1.%u-Q\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"C:\\IMAGEM~1.%u\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"C:\\IMAGEM~1.%u-Q\\VISUA~1\\BIN\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"C:\\IMAGEM~1.%u\\VISUA~1\\BIN\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"C:\\PROGRA~1\\IMAGEM~1.%u-Q\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"C:\\PROGRA~1\\IMAGEM~1.%u\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"C:\\PROGRA~1\\IMAGEM~1.%u-Q\\VISUA~1\\BIN\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"C:\\PROGRA~1\\IMAGEM~1.%u\\VISUA~1\\BIN\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"D:\\IMAGEM~1.%u-Q\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"D:\\IMAGEM~1.%u\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"D:\\IMAGEM~1.%u-Q\\VISUA~1\\BIN\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"D:\\IMAGEM~1.%u\\VISUA~1\\BIN\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"D:\\PROGRA~1\\IMAGEM~1.%u-Q\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"D:\\PROGRA~1\\IMAGEM~1.%u\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"D:\\PROGRA~1\\IMAGEM~1.%u-Q\\VISUA~1\\BIN\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_imagemagick_path,"D:\\PROGRA~1\\IMAGEM~1.%u\\VISUA~1\\BIN\\convert.exe",k);
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        if (!path_found) std::strcpy(st_imagemagick_path,"convert.exe");
-#else
-        if (!path_found) {
-          std::sprintf(st_imagemagick_path,"./convert");
-          if ((file=std::fopen(st_imagemagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }
-        if (!path_found) std::strcpy(st_imagemagick_path,"convert");
-#endif
-      }
-      return st_imagemagick_path;
-    }
-
-    //! Return path of the GraphicsMagick's \c gm tool.
-    /**
-       If you have installed the <a href="http://www.graphicsmagick.org">GraphicsMagick package</a>
-       in a standard directory, this function should return the correct path of the \c gm tool
-       used by the %CImg Library to load and save compressed image formats.
-       Conversely, if the \c gm executable is not auto-detected by the function,
-       you can define the macro \c cimg_graphicsmagick_path with the correct path
-       of the \c gm executable, before including <tt>CImg.h</tt> in your program :
-       \code
-       #define cimg_graphicsmagick_path "/users/thatsme/local/bin/gm"
-       #include "CImg.h"
-
-       int main() {
-         CImg<> img("my_image.jpg");     // Read a JPEG image file.
-         return 0;
-       }
-       \endcode
-
-       Note that non compressed image formats can be read without installing ImageMagick.
-
-       \sa temporary_path(), get_load_imagemagick(), load_imagemagick(), save_imagemagick().
-    **/
-    inline const char* graphicsmagick_path() {
-      static char *st_graphicsmagick_path = 0;
-      if (!st_graphicsmagick_path) {
-        st_graphicsmagick_path = new char[1024];
-        bool path_found = false;
-        std::FILE *file = 0;
-#ifdef cimg_graphicsmagick_path
-        std::strcpy(st_graphicsmagick_path,cimg_graphicsmagick_path);
-        if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-#endif
-#if cimg_OS==2
-        if (!path_found) {
-          std::sprintf(st_graphicsmagick_path,".\\gm.exe");
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"C:\\GRAPHI~1.%u-Q\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"C:\\GRAPHI~1.%u\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"C:\\GRAPHI~1.%u-Q\\VISUA~1\\BIN\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"C:\\GRAPHI~1.%u\\VISUA~1\\BIN\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"C:\\PROGRA~1\\GRAPHI~1.%u-Q\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"C:\\PROGRA~1\\GRAPHI~1.%u\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"C:\\PROGRA~1\\GRAPHI~1.%u-Q\\VISUA~1\\BIN\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"C:\\PROGRA~1\\GRAPHI~1.%u\\VISUA~1\\BIN\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"D:\\GRAPHI~1.%u-Q\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"D:\\GRAPHI~1.%u\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"D:\\GRAPHI~1.%u-Q\\VISUA~1\\BIN\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"D:\\GRAPHI~1.%u\\VISUA~1\\BIN\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"D:\\PROGRA~1\\GRAPHI~1.%u-Q\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"D:\\PROGRA~1\\GRAPHI~1.%u\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"D:\\PROGRA~1\\GRAPHI~1.%u-Q\\VISUA~1\\BIN\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        { for (unsigned int k=0; k<=9 && !path_found; k++) {
-          std::sprintf(st_graphicsmagick_path,"D:\\PROGRA~1\\GRAPHI~1.%u\\VISUA~1\\BIN\\gm.exe",k);
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }}
-        if (!path_found) std::strcpy(st_graphicsmagick_path,"gm.exe");
-#else
-        if (!path_found) {
-          std::sprintf(st_graphicsmagick_path,"./gm");
-          if ((file=std::fopen(st_graphicsmagick_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }
-        if (!path_found) std::strcpy(st_graphicsmagick_path,"gm");
-#endif
-      }
-      return st_graphicsmagick_path;
-    }
-
-    //! Return path of the \c XMedcon tool.
-    /**
-       If you have installed the <a href="http://xmedcon.sourceforge.net/">XMedcon package</a>
-       in a standard directory, this function should return the correct path of the \c medcon tool
-       used by the %CIg Library to load DICOM image formats.
-       Conversely, if the \c medcon executable is not auto-detected by the function,
-       you can define the macro \c cimg_medcon_path with the correct path
-       of the \c medcon executable, before including <tt>CImg.h</tt> in your program :
-       \code
-       #define cimg_medcon_path "/users/thatsme/local/bin/medcon"
-       #include "CImg.h"
-
-       int main() {
-         CImg<> img("my_image.dcm");    // Read a DICOM image file.
-         return 0;
-       }
-       \endcode
-
-       Note that \c medcon is only needed if you want to read DICOM image formats.
-
-       \sa temporary_path(), get_load_dicom(), load_dicom().
-    **/
-    inline const char* medcon_path() {
-      static char *st_medcon_path = 0;
-      if (!st_medcon_path) {
-        st_medcon_path = new char[1024];
-        bool path_found = false;
-        std::FILE *file = 0;
-#ifdef cimg_medcon_path
-        std::strcpy(st_medcon_path,cimg_medcon_path);
-        if ((file=std::fopen(st_medcon_path,"r"))!=0) { std::fclose(file); path_found = true; }
-#endif
-#if cimg_OS==2
-        if (!path_found) {
-          std::sprintf(st_medcon_path,".\\medcon.bat");
-          if ((file=std::fopen(st_medcon_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }
-        if (!path_found) {
-          std::sprintf(st_medcon_path,"C:\\PROGRA~1\\XMedCon\\bin\\medcon.bat");
-          if ((file=std::fopen(st_medcon_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }
-        if (!path_found) {
-          std::sprintf(st_medcon_path,"D:\\PROGRA~1\\XMedCon\\bin\\medcon.bat");
-          if ((file=std::fopen(st_medcon_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }
-        if (!path_found) std::strcpy(st_medcon_path,"medcon.bat");
-#else
-        if (!path_found) {
-          std::sprintf(st_medcon_path,"./medcon");
-          if ((file=std::fopen(st_medcon_path,"r"))!=0) { std::fclose(file); path_found = true; }
-        }
-        if (!path_found) std::strcpy(st_medcon_path,"medcon");
-#endif
-      }
-      return st_medcon_path;
-    }
-
-    //! Return path to store temporary files.
-    /**
-       If you are running on a standard Unix or Windows system, this function should return a correct path
-       where temporary files can be stored. If such a path is not auto-detected by this function,
-       you can define the macro \c cimg_temporary_path with a correct path, before including <tt>CImg.h</tt>
-       in your program :
-       \code
-       #define cimg_temporary_path "/users/thatsme/tmp"
-       #include "CImg.h"
-
-       int main() {
-         CImg<> img("my_image.jpg");   // Read a JPEG image file (using the defined temporay path).
-         return 0;
-       }
-       \endcode
-
-       A temporary path is necessary to load and save compressed image formats, using \c convert
-       or \c medcon.
-
-       \sa imagemagick_path(), get_load_imagemagick(), load_imagemagick(), save_imagemagick(), get_load_dicom(), load_dicom().
-    **/
-    inline const char* temporary_path() {
-
-#define cimg_test_temporary_path(p) \
-      if (!path_found) { \
-        std::sprintf(st_temporary_path,p); \
-        std::sprintf(tmp,"%s%s%s",st_temporary_path,cimg_OS==2?"\\":"/",filetmp); \
-        if ((file=std::fopen(tmp,"wb"))!=0) { std::fclose(file); std::remove(tmp); path_found = true; } \
-      }
-
-      static char *st_temporary_path = 0;
-      if (!st_temporary_path) {
-        st_temporary_path = new char[1024];
-        bool path_found = false;
-        char tmp[1024], filetmp[512];
-        std::FILE *file = 0;
-        std::sprintf(filetmp,"CImg%.4d.tmp",std::rand()%10000);
-#ifdef cimg_temporary_path
-        cimg_test_temporary_path(cimg_temporary_path);
-#endif
-#if cimg_OS==2
-        cimg_test_temporary_path("C:\\WINNT\\Temp");
-        cimg_test_temporary_path("C:\\WINDOWS\\Temp");
-        cimg_test_temporary_path("C:\\Temp");
-        cimg_test_temporary_path("C:");
-        cimg_test_temporary_path("D:\\WINNT\\Temp");
-        cimg_test_temporary_path("D:\\WINDOWS\\Temp");
-        cimg_test_temporary_path("D:\\Temp");
-        cimg_test_temporary_path("D:");
-#else
-        cimg_test_temporary_path("/tmp");
-        cimg_test_temporary_path("/var/tmp");
-#endif
-        if (!path_found) {
-          st_temporary_path[0]='\0';
-          std::strcpy(tmp,filetmp);
-          if ((file=std::fopen(tmp,"wb"))!=0) { std::fclose(file); std::remove(tmp); path_found = true; }
-        }
-        if (!path_found)
-          throw CImgIOException("cimg::temporary_path() : Unable to find a temporary path accessible for writing\n"
-                                "you have to set the macro 'cimg_temporary_path' to a valid path where you have writing access :\n"
-                                "#define cimg_temporary_path \"path\" (before including 'CImg.h')");
-      }
-      return st_temporary_path;
-    }
-
-    inline const char *filename_split(const char *const filename, char *const body=0) {
-      if (!filename) { if (body) body[0]='\0'; return 0; }
-      int l = cimg::strfind(filename,'.');
-      if (l>=0) { if (body) { std::strncpy(body,filename,l); body[l]='\0'; }}
-      else { if (body) std::strcpy(body,filename); l=(int)std::strlen(filename)-1; }
-      return filename+l+1;
-    }
-
-    inline char* filename_number(const char *const filename, const int number, const unsigned int n, char *const string) {
-      if (!filename) { if (string) string[0]='\0'; return 0; }
-      char format[1024],body[1024];
-      const char *ext = cimg::filename_split(filename,body);
-      if (n>0) std::sprintf(format,"%s_%%.%ud.%s",body,n,ext);
-      else std::sprintf(format,"%s_%%d.%s",body,ext);
-      std::sprintf(string,format,number);
-      return string;
-    }
-
-    inline std::FILE *fopen(const char *const path,const char *const mode) {
-      if(!path || !mode)
-        throw CImgArgumentException("cimg::fopen() : File '%s' cannot be opened with mode '%s'.",
-                                    path?path:"(null)",mode?mode:"(null)");
-      if (path[0]=='-') return (mode[0]=='r')?stdin:stdout;
-      std::FILE *dest = std::fopen(path,mode);
-      if (!dest)
-        throw CImgIOException("cimg::fopen() : File '%s' cannot be opened%s",
-                              path,mode[0]=='r'?" for reading.":(mode[0]=='w'?" for writing.":"."),path);
-      return dest;
-    }
-
-    inline int fclose(std::FILE *file) {
-      warn(!file,"cimg::fclose() : Can't close (null) file");
-      if (!file || file==stdin || file==stdout) return 0;
-      const int errn=std::fclose(file);
-      warn(errn!=0,"cimg::fclose() : Error %d during file closing",errn);
-      return errn;
-    }
-
-    template<typename T> inline int fread(T *const ptr, const unsigned int nmemb, std::FILE *stream) {
-      if (!ptr || nmemb<=0 || !stream)
-        throw CImgArgumentException("cimg::fread() : Can't read %u x %u bytes of file pointer '%p' in buffer '%p'",
-                                    nmemb,sizeof(T),stream,ptr);
-      const unsigned long wlimitT = 63*1024*1024, wlimit = wlimitT/sizeof(T);
-      unsigned int toread=nmemb, alread=0, ltoread=0, lalread=0;
-      do {
-        ltoread = (toread*sizeof(T))<wlimitT?toread:wlimit;
-        lalread = (unsigned int)std::fread((void*)(ptr+alread),sizeof(T),ltoread,stream);
-        alread+=lalread;
-        toread-=lalread;
-      } while (ltoread==lalread && toread>0);
-      cimg::warn(toread>0,"cimg::fread() : File reading problems, only %u/%u elements read",alread,nmemb);
-      return alread;
-    }
-
-    template<typename T> inline int fwrite(const T *ptr, const unsigned int nmemb, std::FILE *stream) {
-      if (!ptr || !stream)
-        throw CImgArgumentException("cimg::fwrite() : Can't write %u x %u bytes of file pointer '%p' from buffer '%p'",
-                                    nmemb,sizeof(T),stream,ptr);
-      if (nmemb<=0) return 0;
-      const unsigned long wlimitT = 63*1024*1024, wlimit = wlimitT/sizeof(T);
-      unsigned int towrite=nmemb, alwrite=0, ltowrite=0, lalwrite=0;
-      do {
-        ltowrite = (towrite*sizeof(T))<wlimitT?towrite:wlimit;
-        lalwrite = (unsigned int)std::fwrite((void*)(ptr+alwrite),sizeof(T),ltowrite,stream);
-        alwrite+=lalwrite;
-        towrite-=lalwrite;
-      } while (ltowrite==lalwrite && towrite>0);
-      cimg::warn(towrite>0,"cimg::fwrite() : File writing problems, only %u/%u elements written",alwrite,nmemb);
-      return alwrite;
-    }
-
-    // Exchange the values of variables \p a and \p b
-    template<typename T> inline void swap(T& a,T& b) { T t=a; a=b; b=t; }
-    template<typename T1,typename T2> inline void swap(T1& a1,T1& b1,T2& a2,T2& b2) {
-      cimg::swap(a1,b1); cimg::swap(a2,b2);
-    }
-    template<typename T1,typename T2,typename T3> inline void swap(T1& a1,T1& b1,T2& a2,T2& b2,T3& a3,T3& b3) {
-      cimg::swap(a1,b1,a2,b2); cimg::swap(a3,b3);
-    }
-    template<typename T1,typename T2,typename T3,typename T4>
-    inline void swap(T1& a1,T1& b1,T2& a2,T2& b2,T3& a3,T3& b3,T4& a4,T4& b4) {
-      cimg::swap(a1,b1,a2,b2,a3,b3); cimg::swap(a4,b4);
-    }
-    template<typename T1,typename T2,typename T3,typename T4,typename T5>
-    inline void swap(T1& a1,T1& b1,T2& a2,T2& b2,T3& a3,T3& b3,T4& a4,T4& b4,T5& a5,T5& b5) {
-      cimg::swap(a1,b1,a2,b2,a3,b3,a4,b4); cimg::swap(a5,b5);
-    }
-    template<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6>
-    inline void swap(T1& a1,T1& b1,T2& a2,T2& b2,T3& a3,T3& b3,T4& a4,T4& b4,T5& a5,T5& b5,T6& a6,T6& b6) {
-      cimg::swap(a1,b1,a2,b2,a3,b3,a4,b4,a5,b5); cimg::swap(a6,b6);
-    }
-
-    template<typename T> inline void endian_swap(T* const buffer, const unsigned int size) {
-      switch (sizeof(T)) {
-      case 1: break;
-      case 2: {
-        for (unsigned short *ptr = (unsigned short*)buffer+size; ptr>(unsigned short*)buffer;) {
-          const unsigned short val = *(--ptr);
-          *ptr = (val>>8)|((val<<8));
-        }
-      } break;
-      case 4: {
-        for (unsigned int *ptr = (unsigned int*)buffer+size; ptr>(unsigned int*)buffer;) {
-          const unsigned int val = *(--ptr);
-          *ptr = (val>>24)|((val>>8)&0xff00)|((val<<8)&0xff0000)|(val<<24);
-        }
-      } break;
-      default: {
-        for (T* ptr = buffer+size; ptr>buffer; --ptr) {
-          unsigned char *pb=(unsigned char*)(--ptr), *pe=pb+sizeof(T);
-          for (int i=0; i<(int)sizeof(T)/2; i++) cimg::swap(*(pb++),*(--pe));
-        } break;
-      }
-      }
-    }
-    template<typename T> inline T& endian_swap(T& a) { endian_swap(&a,1); return a; }
-
-    inline const char* option(const char *const name, const int argc, char **argv,
-                              const char *defaut, const char *const usage=0) {
-      static bool first=true, visu=false;
-      const char *res = 0;
-      if (first) {
-        first=false;
-        visu = (cimg::option("-h",argc,argv,(char*)0)!=0);
-        visu |= (cimg::option("-help",argc,argv,(char*)0)!=0);
-        visu |= (cimg::option("--help",argc,argv,(char*)0)!=0);
-      }
-      if (!name && visu) {
-        if (usage) {
-          std::fprintf(stderr,"\n %s%s%s",cimg::t_red,cimg::basename(argv[0]),cimg::t_normal);
-          std::fprintf(stderr," : %s",usage);
-          std::fprintf(stderr," (%s, %s)\n\n",__DATE__,__TIME__);
-        }
-        if (defaut) std::fprintf(stderr,"%s\n",defaut);
-      }
-      if (name) {
-        if (argc>0) {
-          int k=0;
-          while (k<argc && cimg::strcmp(argv[k],name)) k++;
-          res=(k++==argc?defaut:(k==argc?argv[--k]:argv[k]));
-        } else res = defaut;
-        if (visu && usage) std::fprintf(stderr,"    %s%-8s%s = %-12s : %s%s%s\n",
-                                        cimg::t_bold,name,cimg::t_normal,res?res:"0",cimg::t_purple,usage,cimg::t_normal);
-      }
-      return res;
-    }
-
-    inline bool option(const char *const name, const int argc, char **argv,
-                       const bool defaut, const char *const usage=0) {
-      const char *s = cimg::option(name,argc,argv,(char*)0);
-      const bool res = s?(cimg::strcasecmp(s,"false") && cimg::strcasecmp(s,"off") && cimg::strcasecmp(s,"0")):defaut;
-      cimg::option(name,0,0,res?"true":"false",usage);
-      return res;
-    }
-
-    inline int option(const char *const name, const int argc, char **argv,
-                      const int defaut, const char *const usage=0) {
-      const char *s = cimg::option(name,argc,argv,(char*)0);
-      const int res = s?std::atoi(s):defaut;
-      char tmp[256];
-      std::sprintf(tmp,"%d",res);
-      cimg::option(name,0,0,tmp,usage);
-      return res;
-    }
-
-    inline char option(const char *const name, const int argc, char **argv,
-                       const char defaut, const char *const usage=0) {
-      const char *s = cimg::option(name,argc,argv,(char*)0);
-      const char res = s?s[0]:defaut;
-      char tmp[8];
-      tmp[0] = res;
-      tmp[1] ='\0';
-      cimg::option(name,0,0,tmp,usage);
-      return res;
-    }
-
-    inline float option(const char *const name, const int argc, char **argv,
-                        const float defaut, const char *const usage=0) {
-      const char *s = cimg::option(name,argc,argv,(char*)0);
-      const float res = s?cimg::atof(s):defaut;
-      char tmp[256];
-      std::sprintf(tmp,"%g",res);
-      cimg::option(name,0,0,tmp,usage);
-      return res;
-    }
-
-    inline double option(const char *const name, const int argc, char **argv,
-                         const double defaut, const char *const usage=0) {
-      const char *s = cimg::option(name,argc,argv,(char*)0);
-      const double res = s?cimg::atof(s):defaut;
-      char tmp[256];
-      std::sprintf(tmp,"%g",res);
-      cimg::option(name,0,0,tmp,usage);
-      return res;
-    }
-
-    //! Return \c false for little endian CPUs (Intel), \c true for big endian CPUs (Motorola).
-    inline bool endian() {
-      const int x=1;
-      return ((unsigned char*)&x)[0]?false:true;
-    }
-
-    //! Print informations about %CImg environement variables.
-    /**
-       Printing is done on the standart error output.
-    **/
-    inline void info() {
-      char tmp[1024] = {0};
-      std::fprintf(stderr,"\n %sCImg Library %g%s, compiled %s ( %s ) with the following flags :\n\n",
-                   cimg::t_red,cimg_version,cimg::t_normal,__DATE__,__TIME__);
-
-      std::fprintf(stderr,"  > CPU endianness :         %s%s Endian%s\n",
-                   cimg::t_bold,
-                   cimg::endian()?"Big":"Little",
-                   cimg::t_normal);
-
-      std::fprintf(stderr,"  > Operating System :       %s%-13s%s %s('cimg_OS'=%d)%s\n",
-                   cimg::t_bold,
-                   cimg_OS==1?"Unix":(cimg_OS==2?"Windows":"Unknow"),
-                   cimg::t_normal,cimg::t_purple,
-                   cimg_OS,
-                   cimg::t_normal);
-
-#ifdef cimg_use_visualcpp6
-      std::fprintf(stderr,"  > Using Visual C++ 6.0 :       %s%-13s%s %s('cimg_use_visual_cpp6' defined)%s\n",
-                   cimg::t_bold,"Yes",cimg::t_normal,cimg::t_purple,cimg::t_normal);
-#endif
-
-      std::fprintf(stderr,"  > Display type :           %s%-13s%s %s('cimg_display_type'=%d)%s\n",
-                   cimg::t_bold,
-                   cimg_display_type==0?"No display":(cimg_display_type==1?"X11":(cimg_display_type==2?"Windows GDI":"Unknow")),
-                   cimg::t_normal,cimg::t_purple,
-                   cimg_display_type,
-                   cimg::t_normal);
-
-      std::fprintf(stderr,"  > Color terminal :         %s%-13s%s %s('cimg_color_terminal' %s)%s\n",
-                   cimg::t_bold,
-#ifdef cimg_color_terminal
-                   "Yes",cimg::t_normal,cimg::t_purple,"defined",
-#else
-                   "No",cimg::t_normal,cimg::t_purple,"undefined",
-#endif
-                   cimg::t_normal);
-
-      std::fprintf(stderr,"  > Debug messages :         %s%-13s%s %s('cimg_debug'=%d)%s\n",
-                   cimg::t_bold,
-                   cimg_debug==0?"No":(cimg_debug==1 || cimg_debug==2?"Yes":(cimg_debug==3?"Yes+":"Unknown")),
-                   cimg::t_normal,cimg::t_purple,
-                   cimg_debug,
-                   cimg::t_normal);
-
-#if cimg_display_type==1
-      std::fprintf(stderr,"  > Using XShm for X11 :     %s%-13s%s %s('cimg_use_xshm' %s)%s\n",
-                   cimg::t_bold,
-#ifdef cimg_use_xshm
-                   "Yes",cimg::t_normal,cimg::t_purple,"defined",
-#else
-                   "No",cimg::t_normal,cimg::t_purple,"undefined",
-#endif
-                   cimg::t_normal);
-
-      std::fprintf(stderr,"  > Using XRand for X11 :    %s%-13s%s %s('cimg_use_xrandr' %s)%s\n",
-                   cimg::t_bold,
-#ifdef cimg_use_xrandr
-                   "Yes",cimg::t_normal,cimg::t_purple,"defined",
-#else
-                   "No",cimg::t_normal,cimg::t_purple,"undefined",
-#endif
-                   cimg::t_normal);
-#endif
-
-      std::fprintf(stderr,"  > Using PNG library :      %s%-13s%s %s('cimg_use_png' %s)%s\n",
-                   cimg::t_bold,
-#ifdef cimg_use_png
-                   "Yes",cimg::t_normal,cimg::t_purple,"defined",
-#else
-                   "No",cimg::t_normal,cimg::t_purple,"undefined",
-#endif
-                   cimg::t_normal);
-      std::fprintf(stderr,"  > Using JPEG library :     %s%-13s%s %s('cimg_use_jpeg' %s)%s\n",
-                   cimg::t_bold,
-#ifdef cimg_use_jpeg
-                   "Yes",cimg::t_normal,cimg::t_purple,"defined",
-#else
-                   "No",cimg::t_normal,cimg::t_purple,"undefined",
-#endif
-                   cimg::t_normal);
-
-      std::fprintf(stderr,"  > Using TIFF library :     %s%-13s%s %s('cimg_use_tiff' %s)%s\n",
-                   cimg::t_bold,
-#ifdef cimg_use_tiff
-                   "Yes",cimg::t_normal,cimg::t_purple,"defined",
-#else
-                   "No",cimg::t_normal,cimg::t_purple,"undefined",
-#endif
-                   cimg::t_normal);
-
-      std::fprintf(stderr,"  > Using Magick++ library : %s%-13s%s %s('cimg_use_magick' %s)%s\n",
-                   cimg::t_bold,
-#ifdef cimg_use_magick
-                   "Yes",cimg::t_normal,cimg::t_purple,"defined",
-#else
-                   "No",cimg::t_normal,cimg::t_purple,"undefined",
-#endif
-                   cimg::t_normal);
-
-      std::fprintf(stderr,"  > Using FFTW3 library :    %s%-13s%s %s('cimg_use_fftw3' %s)%s\n",
-                   cimg::t_bold,
-#ifdef cimg_use_fftw3
-                   "Yes",cimg::t_normal,cimg::t_purple,"defined",
-#else
-                   "No",cimg::t_normal,cimg::t_purple,"undefined",
-#endif
-                   cimg::t_normal);
-
-      std::sprintf(tmp,"\"%.1020s\"",cimg::imagemagick_path());
-      std::fprintf(stderr,"  > Path of ImageMagick :    %s%-13s%s %s('cimg_imagemagick_path'%s)%s\n",
-                   cimg::t_bold,
-                   tmp,
-                   cimg::t_normal,
-#ifdef cimg_imagemagick_path
-                   cimg::t_purple,"=\""cimg_imagemagick_path"\"",
-#else
-                   cimg::t_purple," undefined",
-#endif
-                   cimg::t_normal);
-
-      std::sprintf(tmp,"\"%.1020s\"",cimg::graphicsmagick_path());
-      std::fprintf(stderr,"  > Path of GraphicsMagick : %s%-13s%s %s('cimg_graphicsmagick_path'%s)%s\n",
-                   cimg::t_bold,
-                   tmp,
-                   cimg::t_normal,
-#ifdef cimg_graphicsmagick_path
-                   cimg::t_purple,"=\""cimg_graphicsmagick_path"\"",
-#else
-                   cimg::t_purple," undefined",
-#endif
-                   cimg::t_normal);
-
-      std::sprintf(tmp,"\"%.1020s\"",cimg::medcon_path());
-      std::fprintf(stderr,"  > Path of 'medcon' :       %s%-13s%s %s('cimg_medcon_path'%s)%s\n",
-                   cimg::t_bold,
-                   tmp,
-                   cimg::t_normal,
-#ifdef cimg_medcon_path
-                   cimg::t_purple,"=\""cimg_medcon_path"\"",
-#else
-                   cimg::t_purple," undefined",
-#endif
-                   cimg::t_normal);
-
-      std::sprintf(tmp,"\"%.1020s\"",cimg::temporary_path());
-      std::fprintf(stderr,"  > Temporary path :         %s%-13s%s %s('cimg_temporary_path'%s)%s\n",
-                   cimg::t_bold,
-                   tmp,
-                   cimg::t_normal,
-#ifdef cimg_temporary_path
-                   cimg::t_purple,"=\""cimg_temporary_path"\"",
-#else
-                   cimg::t_purple," undefined",
-#endif
-                   cimg::t_normal);
-
-      std::fprintf(stderr,"\n");
-    }
-
-    //! Get the value of a system timer with a millisecond precision.
-    inline unsigned long time() {
-#if cimg_OS==1
-      struct timeval st_time;
-      gettimeofday(&st_time,0);
-      return (unsigned long)(st_time.tv_usec/1000 + st_time.tv_sec*1000);
-#elif cimg_OS==2
-      static SYSTEMTIME st_time;
-      GetSystemTime(&st_time);
-      return (unsigned long)(st_time.wMilliseconds + 1000*(st_time.wSecond + 60*(st_time.wMinute + 60*st_time.wHour)));
-#else
-      return 0;
-#endif
-    }
-
-    //! Sleep for a certain numbers of milliseconds.
-    /**
-       This function frees the CPU ressources during the sleeping time.
-       It may be used to temporize your program properly, without wasting CPU time.
-       \sa wait(), time().
-    **/
-    inline void sleep(const unsigned int milliseconds) {
-#if cimg_OS==1
-      struct timespec tv;
-      tv.tv_sec = milliseconds/1000;
-      tv.tv_nsec = (milliseconds%1000)*1000000;
-      nanosleep(&tv,0);
-#elif cimg_OS==2
-      Sleep(milliseconds);
-#endif
-    }
-
-    inline unsigned int wait(const unsigned int milliseconds, unsigned long& timer) {
-      if (!timer) timer = cimg::time();
-      const unsigned long current_time = cimg::time();
-      if (current_time>=timer+milliseconds) { timer = current_time; return 0; }
-      const unsigned long time_diff = timer + milliseconds - current_time;
-      timer = current_time + time_diff;
-      cimg::sleep(time_diff);
-      return (unsigned int)time_diff;
-    }
-
-    //! Wait for a certain number of milliseconds since the last call.
-    /**
-       This function is equivalent to sleep() but the waiting time is computed with regard to the last call
-       of wait(). It may be used to temporize your program properly.
-       \sa sleep(), time().
-    **/
-    inline unsigned int wait(const unsigned int milliseconds) {
-      static unsigned long timer = 0;
-      if (!timer) timer = cimg::time();
-      return wait(milliseconds,timer);
-    }
-
-    template<typename T> inline const T rol(const T& a, const unsigned int n=1) {
-      return (T)((a<<n)|(a>>((sizeof(T)<<3)-n)));
-    }
-
-    template<typename T> inline const T ror(const T& a, const unsigned int n=1) {
-      return (T)((a>>n)|(a<<((sizeof(T)<<3)-n)));
-    }
-
-    //! Return the absolute value of \p a
-    template<typename T> inline T abs(const T a)      { return a>=0?a:-a; }
-    inline bool abs(const bool a)                     { return a; }
-    inline unsigned char abs(const unsigned char a)   { return a; }
-    inline unsigned short abs(const unsigned short a) { return a; }
-    inline unsigned int abs(const unsigned int a)     { return a; }
-    inline unsigned long abs(const unsigned long a)   { return a; }
-    inline double abs(const double a)                 { return std::fabs(a); }
-    inline float abs(const float a)                   { return (float)std::fabs((double)a); }
-    inline int abs(const int a)                       { return std::abs(a); }
-
-    //! Return the minimum between \p a and \p b.
-    template<typename T> inline const T min(const T a,const T b) { return a<=b?a:b; }
-
-    //! Return the minimum between \p a,\p b and \a c.
-    template<typename T> inline const T min(const T a,const T b,const T c) { return cimg::min(cimg::min(a,b),c); }
-
-    //! Return the minimum between \p a,\p b,\p c and \p d.
-    template<typename T> inline const T min(const T a,const T b,const T c,const T d) { return cimg::min(cimg::min(a,b,c),d); }
-
-    //! Return the maximum between \p a and \p b.
-    template<typename T> inline const T max(const T a,const T b) { return a>=b?a:b; }
-
-    //! Return the maximum between \p a,\p b and \p c.
-    template<typename T> inline const T max(const T a,const T b,const T c) { return cimg::max(cimg::max(a,b),c); }
-
-    //! Return the maximum between \p a,\p b,\p c and \p d.
-    template<typename T> inline const T max(const T a,const T b,const T c,const T d) { return cimg::max(cimg::max(a,b,c),d); }
-
-    //! Return the sign of \p x.
-    template<typename T> inline T sign(const T x) { return (x<0)?(T)(-1):(x==0?(T)0:(T)1); }
-
-    //! Return the nearest power of 2 higher than \p x.
-    template<typename T> inline unsigned long nearest_pow2(const T& x) {
-      unsigned long i=1;
-      while (x>i) i<<=1;
-      return i;
-    }
-
-    //! Return \p x modulo \p m (generic modulo).
-    /**
-       This modulo function accepts negative and floating-points modulo numbers \p m.
-    **/
-    inline double mod(const double x, const double m) { return x-m*std::floor(x/m); }
-    inline float  mod(const float x, const float m)   { return (float)(x-m*std::floor((double)x/m)); }
-    inline int    mod(const int x, const int m)       { return x>=0?x%m:(x%m?m+x%m:0); }
-
-    //! Return minmod(\p a,\p b).
-    /**
-       The operator minmod(\p a,\p b) is defined to be :
-       - minmod(\p a,\p b) = min(\p a,\p b), if (\p a * \p b)>0.
-       - minmod(\p a,\p b) = 0,              if (\p a * \p b)<=0
-    **/
-    template<typename T> inline T minmod(const T& a,const T& b) { return a*b<=0?0:(a>0?(a<b?a:b):(a<b?b:a)); }
-
-    //! Return a random variable between [0,1], followin a uniform distribution.
-    inline double rand() { return (double)std::rand()/RAND_MAX; }
-
-    //! Return a random variable between [-1,1], following a uniform distribution.
-    inline double crand() { return 1-2*cimg::rand(); }
-
-    //! Return a random variable following a gaussian distribution and a standard deviation of 1.
-    inline double grand() {
-      return std::sqrt(-2*std::log((double)(1e-10 + (1-2e-10)*cimg::rand())))*std::cos((double)(2*PI*cimg::rand()));
-    }
-
-    inline double pythagore(double a, double b) {
-      const double absa = cimg::abs(a), absb = cimg::abs(b);
-      if (absa>absb) { const double tmp = absb/absa; return absa*std::sqrt(1.0+tmp*tmp); }
-      else { const double tmp = absa/absb; return (absb==0?0:absb*std::sqrt(1.0+tmp*tmp)); }
-    }
-
-    // End of the 'cimg' namespace
-  }
-
-  /*
-   #----------------------------------------
-   #
-   #
-   #
-   # Definition of the CImgStats structure
-   #
-   #
-   #
-   #----------------------------------------
-   */
-  //! Class used to compute basic statistics on pixel values of a \ref CImg image.
-  /**
-      Constructing a CImgStats instance from an image CImg<T> or a list CImgList<T>
-      will compute the minimum, maximum and average pixel values of the input object.
-      Optionally, the variance of the pixel values can be computed.
-      Coordinates of the pixels whose values are minimum and maximum are also stored.
-      The example below shows how to use CImgStats objects to retrieve simple statistics of an image :
-      \code
-      const CImg<float> img("my_image.jpg");                 // Read JPEG image file.
-      const CImgStats stats(img);                            // Compute basic statistics on the image.
-      stats.print("My statistics");                          // Display statistics.
-      std::printf("Max-Min = %lf",stats.max-stats.min);      // Compute the difference between extremum values.
-      \endcode
-
-      Note that statistics are computed by considering the set of \a scalar values of the image pixels.
-      No vector-valued statistics are computed.
-  **/
-  struct CImgStats {
-    double min;                 //!< Minimum of the pixel values.
-    double max;                 //!< Maximum of the pixel values.
-    double mean;                //!< Mean of the pixel values.
-    double variance;            //!< Variance of the pixel values.
-    int xmin;                   //!< X-coordinate of the pixel with minimum value.
-    int ymin;                   //!< Y-coordinate of the pixel with minimum value.
-    int zmin;                   //!< Z-coordinate of the pixel with minimum value.
-    int vmin;                   //!< V-coordinate of the pixel with minimum value.
-    int lmin;                   //!< Image number (for a list) containing the minimum pixel.
-    int xmax;                   //!< X-coordinate of the pixel with maximum value.
-    int ymax;                   //!< Y-coordinate of the pixel with maximum value.
-    int zmax;                   //!< Z-coordinate of the pixel with maximum value.
-    int vmax;                   //!< V-coordinate of the pixel with maximum value.
-    int lmax;                   //!< Image number (for a list) containing the maximum pixel.
-
-#ifdef cimgstats_plugin
-#include cimgstats_plugin
-#endif
-
-    //! Default constructor.
-    CImgStats():min(0),max(0),mean(0),variance(0),xmin(-1),ymin(-1),zmin(-1),vmin(-1),lmin(-1),
-                xmax(-1),ymax(-1),zmax(-1),vmax(-1),lmax(-1) {}
-
-    //! In-place version of the default constructor
-    CImgStats& assign() {
-      min = max = mean = variance = 0;
-      xmin = ymin = zmin = vmin = lmin = xmax = ymax = zmax = vmax = lmax = -1;
-      return *this;
-    }
-
-    //! Copy constructor.
-    CImgStats(const CImgStats& stats) {
-      assign(stats);
-    };
-
-    //! In-place version of the copy constructor.
-    CImgStats& assign(const CImgStats& stats) {
-      min = stats.min;
-      max = stats.max;
-      mean = stats.mean;
-      variance = stats.variance;
-      xmin = stats.xmin; ymin = stats.ymin; zmin = stats.zmin; vmin = stats.vmin; lmin = stats.lmin;
-      xmax = stats.xmax; ymax = stats.ymax; zmax = stats.zmax; vmax = stats.vmax; lmax = stats.lmax;
-      return *this;
-    }
-
-    //! Constructor that computes statistics of an input image \p img.
-    /**
-        \param img The input image.
-        \param compute_variance If true, the \c variance field is computed, else it is set to 0.
-    **/
-    template<typename T> CImgStats(const CImg<T>& img, const bool compute_variance=true) {
-      assign(img,compute_variance);
-    }
-
-    //! In-place version of the previous constructor.
-    template<typename T> CImgStats& assign(const CImg<T>& img, const bool compute_variance=true) {
-      if (img.is_empty())
-        throw CImgArgumentException("CImgStats::CImgStats() : Specified input image (%u,%u,%u,%u,%p) is empty.",
-                                    img.width,img.height,img.depth,img.dim,img.data);
-      mean = variance = 0;
-      lmin = lmax = -1;
-      T pmin=img[0], pmax=pmin, *ptrmin=img.data, *ptrmax=ptrmin;
-      cimg_for(img,ptr,T) {
-        const T& a=*ptr;
-        mean+=(double)a;
-        if (a<pmin) { pmin=a; ptrmin = ptr; }
-        if (a>pmax) { pmax=a; ptrmax = ptr; }
-      }
-      mean/=img.size();
-      min=(double)pmin;
-      max=(double)pmax;
-      unsigned long offmin = (unsigned long)(ptrmin-img.data), offmax = (unsigned long)(ptrmax-img.data);
-      const unsigned long whz = img.width*img.height*img.depth, wh = img.width*img.height;
-      vmin = offmin/whz; offmin%=whz; zmin = offmin/wh; offmin%=wh; ymin = offmin/img.width; xmin = offmin%img.width;
-      vmax = offmax/whz; offmax%=whz; zmax = offmax/wh; offmax%=wh; ymax = offmax/img.width; xmax = offmax%img.width;
-      if (compute_variance) {
-        cimg_for(img,ptr,T) { const double tmpf=(*ptr)-mean; variance+=tmpf*tmpf; }
-        const unsigned int siz = img.size();
-        if (siz>1) variance/=(siz-1); else variance=0;
-      }
-      return *this;
-    }
-
-    //! Constructor that computes statistics of an input image list \p list.
-    /**
-       \param list The input list of images.
-       \param compute_variance If true, the \c variance field is computed, else it is set to 0.
-    **/
-    template<typename T> CImgStats(const CImgList<T>& list, const bool compute_variance=true) {
-      assign(list,compute_variance);
-    }
-
-    //! In-place version of the previous constructor.
-    template<typename T> CImgStats& assign(const CImgList<T>& list,const bool compute_variance=true) {
-      if (list.is_empty())
-        throw CImgArgumentException("CImgStats::CImgStats() : Specified input list (%u,%p) is empty.",
-                                    list.size,list.data);
-      mean = variance = lmin = lmax = 0;
-      T pmin = list[0][0], pmax = pmin, *ptrmin = list[0].data, *ptrmax = ptrmin;
-      int psize = 0;
-      cimglist_for(list,l) {
-        cimg_for(list[l],ptr,T) {
-          const T& a=*ptr;
-          mean+=(double)a;
-          if (a<pmin) { pmin=a; ptrmin = ptr; lmin = l; }
-          if (a>pmax) { pmax=a; ptrmax = ptr; lmax = l; }
-        }
-        psize+=list[l].size();
-      }
-      mean/=psize;
-      min=(double)pmin;
-      max=(double)pmax;
-      const CImg<T> &imin = list[lmin], &imax = list[lmax];
-      unsigned long offmin = (ptrmin-imin.data), offmax = (ptrmax-imax.data);
-      const unsigned long whz1 = imin.width*imin.height*imin.depth, wh1 = imin.width*imin.height;
-      vmin = offmin/whz1; offmin%=whz1; zmin = offmin/wh1; offmin%=wh1; ymin = offmin/imin.width; xmin = offmin%imin.width;
-      const unsigned long whz2 = imax.width*imax.height*imax.depth, wh2 = imax.width*imax.height;
-      vmax = offmax/whz2; offmax%=whz2; zmax = offmax/wh2; offmax%=wh2; ymax = offmax/imax.width; xmax = offmax%imax.width;
-      if (compute_variance) {
-        cimglist_for(list,l) cimg_for(list[l],ptr,T) { const double tmpf=(*ptr)-mean; variance+=tmpf*tmpf; }
-        if (psize>1) variance/=(psize-1); else variance=0;
-      }
-      return *this;
-    }
-
-    //! Assignement operator.
-    CImgStats& operator=(const CImgStats& stats) {
-      return assign(stats);
-    }
-
-    //! Return true if the current instance contains valid statistics
-    bool is_empty() const {
-      return (xmin>=0 && ymin>=0 && zmin>=0 && vmin>=0 && xmax>=0 && ymax>=0 && zmax>=0 && vmax>=0);
-    }
-
-    //! Print the current statistics.
-    /**
-       Printing is done on the standart error output.
-    **/
-    const CImgStats& print(const char* title=0) const {
-      if (lmin>=0 && lmax>=0)
-        std::fprintf(stderr,"%-8s(this=%p) : { min=%g, mean=%g [var=%g], max=%g, "
-                     "pmin=[%d](%d,%d,%d,%d), pmax=[%d](%d,%d,%d,%d) }\n",
-                     title?title:"CImgStats",(void*)this,min,mean,variance,max,
-                     lmin,xmin,ymin,zmin,vmin,lmax,xmax,ymax,zmax,vmax);
-      else
-        std::fprintf(stderr,"%-8s(this=%p) : { min=%g, mean=%g [var=%g], max=%g, "
-                     "pmin=(%d,%d,%d,%d), pmax=(%d,%d,%d,%d) }\n",
-                     title?title:"CImgStats",(void*)this,min,mean,variance,max,
-                     xmin,ymin,zmin,vmin,xmax,ymax,zmax,vmax);
-      return *this;
-    }
-
-  };
-
-  /*
-   #-------------------------------------------
-   #
-   #
-   #
-   # Definition of the CImgDisplay structure
-   #
-   #
-   #
-   #-------------------------------------------
-   */
-
-  //! This class represents a window which can display \ref CImg images and handles mouse and keyboard events.
-  /**
-     Creating a \c CImgDisplay instance opens a window that can be used to display a \c CImg<T> image
-     of a \c CImgList<T> image list inside. When a display is created, associated window events
-     (such as mouse motion, keyboard and window size changes) are handled and can be easily
-     detected by testing specific \c CImgDisplay data fields.
-     See \ref cimg_displays for a complete tutorial on using the \c CImgDisplay class.
-  **/
-
-  struct CImgDisplay {
-
-    //! Width of the display
-    unsigned int width;
-
-    //! Height of the display
-    unsigned int height;
-
-    //! Normalization type used for the display
-    unsigned int normalization;
-
-    //! Range of events detected by the display
-    unsigned int events;
-
-    //! Fullscreen state of the display
-    bool is_fullscreen;
-
-    //! Display title
-    char* title;
-
-    //! X-pos of the display on the screen
-    volatile int window_x;
-
-    //! Y-pos of the display on the screen
-    volatile int window_y;
-
-    //! Width of the underlying window
-    volatile unsigned int window_width;
-
-    //! Height of the underlying window
-    volatile unsigned int window_height;
-
-    //! X-coordinate of the mouse pointer on the display
-    volatile int mouse_x;
-
-    //! Y-coordinate of the mouse pointer on the display
-    volatile int mouse_y;
-
-    //! Button state of the mouse
-    volatile unsigned int buttons[256];
-    volatile unsigned int& button;
-
-    //! Wheel state of the mouse
-    volatile int wheel;
-
-    //! Key value if pressed
-    volatile unsigned int& key;
-    volatile unsigned int keys[256];
-
-    //! Key value if released
-    volatile unsigned int& released_key;
-    volatile unsigned int released_keys[256];
-
-    //! Closed state of the window
-    volatile bool is_closed;
-
-    //! Resized state of the window
-    volatile bool is_resized;
-
-    //! Moved state of the window
-    volatile bool is_moved;
-
-    //! Event state of the window
-    volatile bool is_event;
-
-    float fps_fps, min, max;
-    unsigned long timer, fps_frames, fps_timer;
-
-#ifdef cimgdisplay_plugin
-#include cimgdisplay_plugin
-#endif
-
-    //! Create a display window with a specified size \p pwidth x \p height.
-    /** \param dimw       : Width of the display window.
-        \param dimh       : Height of the display window.
-        \param title      : Title of the display window.
-        \param normalization_type  : Normalization type of the display window (see CImgDisplay::normalize).
-        \param events_type : Type of events handled by the display window.
-        \param fullscreen_flag : Fullscreen mode.
-        \param closed_flag : Initially visible mode.
-        A black image will be initially displayed in the display window.
-    **/
-    CImgDisplay(const unsigned int dimw, const unsigned int dimh, const char *title=0,
-                const unsigned int normalization_type=3, const unsigned int events_type=3,
-                const bool fullscreen_flag=false, const bool closed_flag=false):
-      width(0),height(0),normalization(0),events(0),is_fullscreen(false),title(0),
-      window_x(0),window_y(0),window_width(0),window_height(0),
-      mouse_x(0),mouse_y(0),button(*buttons),wheel(0),key(*keys),released_key(*released_keys),
-      is_closed(true),is_resized(false),is_moved(false),is_event(false),
-      min(0),max(0) {
-      assign(dimw,dimh,title,normalization_type,events_type,fullscreen_flag,closed_flag);
-    }
-
-    //! Create a display window from an image.
-    /** \param img : Image that will be used to create the display window.
-        \param title : Title of the display window
-        \param normalization_type : Normalization type of the display window.
-        \param events_type : Type of events handled by the display window.
-        \param fullscreen_flag : Fullscreen mode.
-        \param closed_flag : Initially visible mode.
-    **/
-    template<typename T>
-    CImgDisplay(const CImg<T>& img, const char *title=0,
-                const unsigned int normalization_type=3, const unsigned int events_type=3,
-                const bool fullscreen_flag=false, const bool closed_flag=false):
-      width(0),height(0),normalization(0),events(0),is_fullscreen(false),title(0),
-      window_x(0),window_y(0),window_width(0),window_height(0),
-      mouse_x(0),mouse_y(0),button(*buttons),wheel(0),key(*keys),released_key(*released_keys),
-      is_closed(true),is_resized(false),is_moved(false),is_event(false),min(0),max(0) {
-      assign(img,title,normalization_type,events_type,fullscreen_flag,closed_flag);
-    }
-
-    //! Create a display window from an image list.
-    /** \param list : The list of images to display.
-        \param title : Title of the display window
-        \param normalization_type : Normalization type of the display window.
-        \param events_type : Type of events handled by the display window.
-        \param fullscreen_flag : Fullscreen mode.
-        \param closed_flag : Initially visible mode.
-    **/
-    template<typename T>
-    CImgDisplay(const CImgList<T>& list,const char *title=0,
-                const unsigned int normalization_type=3,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      width(0),height(0),normalization(0),events(0),is_fullscreen(false),title(0),
-      window_x(0),window_y(0),window_width(0),window_height(0),
-      mouse_x(0),mouse_y(0),button(*buttons),wheel(0),key(*keys),released_key(*released_keys),
-      is_closed(true),is_resized(false),is_moved(false),is_event(false),min(0),max(0) {
-      assign(list,title,normalization_type,events_type,fullscreen_flag,closed_flag);
-    }
-
-    //! Create a display window by copying another one.
-    /** \param win   : Display window to copy.
-        \param title : Title of the new display window.
-    **/
-    CImgDisplay(const CImgDisplay& disp):
-      width(0),height(0),normalization(0),events(0),is_fullscreen(false),title(0),
-      window_x(0),window_y(0),window_width(0),window_height(0),
-      mouse_x(0),mouse_y(0),button(*buttons),wheel(0),key(*keys),released_key(*released_keys),
-      is_closed(true),is_resized(false),is_moved(false),is_event(false),min(0),max(0) {
-      assign(disp);
-    }
-
-    //! Destructor
-    ~CImgDisplay() {
-      _assign();
-    }
-
-    //! Assignement operator
-    CImgDisplay& operator=(const CImgDisplay& disp) {
-      return assign(disp);
-    }
-
-    //! Return display width
-    int dimx() const {
-      return (int)width;
-    }
-
-    //! Return display height
-    int dimy() const {
-      return (int)height;
-    }
-
-    //! Return display window width
-    int window_dimx() const {
-      return (int)window_width;
-    }
-
-    //! Return display window height
-    int window_dimy() const {
-      return (int)window_height;
-    }
-
-    //! Return X-coordinate of the window
-    int window_posx() const {
-      return window_x;
-    }
-
-    //! Return Y-coordinate of the window
-    int window_posy() const {
-      return window_y;
-    }
-
-    //! Synchronized waiting function. Same as cimg::wait().
-    /** \see cimg::wait()
-     **/
-    CImgDisplay& wait(const unsigned int milliseconds) {
-      cimg::wait(milliseconds, timer);
-      return *this;
-    }
-
-    //! Wait for an event occuring on the current display
-    CImgDisplay& wait() {
-      wait(*this);
-      return *this;
-    }
-
-    //! Wait for any event occuring on the display \c disp1
-    static void wait(CImgDisplay& disp1) {
-      disp1.is_event = 0;
-      while (!disp1.is_event) wait_all();
-    }
-
-    //! Wait for any event occuring either on the display \c disp1 or \c disp2
-    static void wait(CImgDisplay& disp1, CImgDisplay& disp2) {
-      disp1.is_event = disp2.is_event = 0;
-      while (!disp1.is_event && !disp2.is_event) wait_all();
-    }
-
-    //! Wait for any event occuring either on the display \c disp1, \c disp2 or \c disp3
-    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3) {
-      disp1.is_event = disp2.is_event = disp3.is_event = 0;
-      while (!disp1.is_event && !disp2.is_event && !disp3.is_event) wait_all();
-    }
-
-    //! Wait for any event occuring either on the display \c disp1, \c disp2, \c disp3 or \c disp4
-    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4) {
-      disp1.is_event = disp2.is_event = disp3.is_event = disp4.is_event = 0;
-      while (!disp1.is_event && !disp2.is_event && !disp3.is_event && !disp4.is_event) wait_all();
-    }
-
-    //! Return the frame per second rate
-    float frames_per_second() {
-      if (!fps_timer) fps_timer = cimg::time();
-      const float delta = (cimg::time()-fps_timer)/1000.0f;
-      fps_frames++;
-      if (delta>=1.0f) {
-        fps_fps = fps_frames/delta;
-        fps_frames = 0;
-        fps_timer = cimg::time();
-      }
-      return fps_fps;
-    }
-
-    //! Display an image list CImgList<T> into a display window.
-    /** First, all images of the list are appended into a single image used for visualization,
-        then this image is displayed in the current display window.
-        \param list     : The list of images to display.
-        \param axe      : The axe used to append the image for visualization. Can be 'x' (default),'y','z' or 'v'.
-        \param align : Defines the relative alignment of images when displaying images of different sizes.
-        Can be '\p c' (centered, which is the default), '\p p' (top alignment) and '\p n' (bottom aligment).
-
-        \see CImg::get_append()
-    **/
-    template<typename T> CImgDisplay& display(const CImgList<T>& list,const char axe='x',const char align='c') {
-      return display(list.get_append(axe,align));
-    }
-
-    //! Display an image CImg<T> into a display window.
-    template<typename T> CImgDisplay& operator<<(const CImg<T>& img) {
-      return display(img);
-    }
-
-    //! Display an image CImg<T> into a display window.
-    template<typename T> CImgDisplay& operator<<(const CImgList<T>& list) {
-      return display(list);
-    }
-
-    //! Resize a display window with the size of an image.
-    /** \param img    : Input image. \p image.width and \p image.height give the new dimensions of the display window.
-        \param redraw : If \p true (default), the current displayed image in the display window will
-        be bloc-interpolated to fit the new dimensions. If \p false, a black image will be drawn in the resized window.
-        \see CImgDisplay::is_resized, CImgDisplay::resizedimx(), CImgDisplay::resizedimy()
-    **/
-    template<typename T> CImgDisplay& resize(const CImg<T>& img, const bool redraw=true) {
-      return resize(img.width,img.height,redraw);
-    }
-
-    //! Resize a display window using the size of the given display \p disp
-    CImgDisplay& resize(const CImgDisplay& disp, const bool redraw=true) {
-      return resize(disp.width,disp.height,redraw);
-    }
-
-    //! Resize a display window in its current size.
-    CImgDisplay& resize(const bool redraw=true) {
-      resize(window_width,window_height,redraw);
-      return *this;
-    }
-
-    //! Display a 3d object
-    template<typename tp, typename tf, typename T, typename to>
-    CImgDisplay& display_object3d(const tp& points, const CImgList<tf>& primitives,
-                                  const CImgList<T>& colors, const to& opacities,
-                                  const bool centering=true,
-                                  const int render_static=4, const int render_motion=1,
-                                  const bool double_sided=false,
-                                  const float focale=500.0f, const float ambiant_light=0.05f,
-                                  const bool display_axes = true, float *const pose_matrix=0) {
-      CImg<T>(width,height,1,3,0).display_object3d(points,primitives,colors,opacities,*this,
-                                                   centering,render_static,render_motion,
-                                                   double_sided,focale,ambiant_light,display_axes,pose_matrix);
-      return *this;
-    }
-
-    //! Display a 3D object.
-    template<typename tp, typename tf, typename T>
-    CImgDisplay& display_object3d(const tp& points, const CImgList<tf>& primitives,
-                                  const CImgList<T>& colors,
-                                  const bool centering=true,
-                                  const int render_static=4, const int render_motion=1,
-                                  const bool double_sided=false,
-                                  const float focale=500.0f, const float ambiant_light=0.05f,
-                                  const float opacity=1.0f, const bool display_axes = true, float *const pose_matrix=0) {
-      typedef typename cimg::largest<tp,float>::type to;
-      CImg<T>(width,height,1,3,0).display_object3d(points,primitives,colors,
-                                                   CImg<to>(primitives.size)=(to)opacity,*this,
-                                                   centering,render_static,render_motion,
-                                                   double_sided,focale,ambiant_light,display_axes,pose_matrix);
-      return *this;
-    }
-
-    //! Toggle fullscreen mode
-    CImgDisplay& toggle_fullscreen() {
-      return assign(width,height,title,normalization,events,!is_fullscreen,is_closed);
-    }
-
-    // Inner routine used for fast resizing of buffer to display size.
-    template<typename t, typename T> static void _render_resize(const T *ptrs, const unsigned int ws, const unsigned int hs,
-                                                                t *ptrd, const unsigned int wd, const unsigned int hd) {
-      unsigned int *const offx = new unsigned int[wd], *const offy = new unsigned int[hd+1], *poffx, *poffy;
-      float s, curr, old;
-      s = (float)ws/wd;
-      poffx = offx; curr=0; for (unsigned int x=0; x<wd; x++) { old=curr; curr+=s; *(poffx++) = (unsigned int)curr-(unsigned int)old; }
-      s = (float)hs/hd;
-      poffy = offy; curr=0; for (unsigned int y=0; y<hd; y++) { old=curr; curr+=s; *(poffy++) = ws*((unsigned int)curr-(unsigned int)old); }
-      *poffy=0;
-      poffy = offy;
-      {for (unsigned int y=0; y<hd; ) {
-        const T *ptr = ptrs;
-        poffx = offx;
-        for (unsigned int x=0; x<wd; x++) { *(ptrd++)=*ptr; ptr+=*(poffx++); }
-        y++;
-        unsigned int dy=*(poffy++);
-        for (;!dy && y<hd; std::memcpy(ptrd, ptrd-wd, sizeof(t)*wd), y++, ptrd+=wd, dy=*(poffy++));
-        ptrs+=dy;
-      }}
-      delete[] offx; delete[] offy;
-    }
-
-    //! Test if a specific key is pressed
-    bool is_pressed(const unsigned int key1) const {
-      bool pressed = false;
-      for (unsigned int i=0; i<256; ++i) {
-        if (released_keys[i]==key1) { pressed = false; break; }
-        if (keys[i]==key1) { pressed = true; break; }
-      }
-      return pressed;
-    }
-
-    //! Test if a key sequence has been typed
-    bool is_typed(const unsigned int *const keyseq, const unsigned int N, const bool remove=true) {
-      if (keyseq && N) {
-        const unsigned int *const ps_end = keyseq+N-1, k = *ps_end, *const pk_end = (unsigned int*)keys+257-N;
-        for (unsigned int *pk = (unsigned int*)keys; pk<pk_end; ) {
-          if (*(pk++)==k) {
-            bool res = true;
-            const unsigned int *ps = ps_end, *pk2 = pk;
-            for (unsigned int i=1; i<N; ++i) res = (*(--ps)==*(pk2++));
-            if (res) {
-              if (remove) std::memset((void*)(pk-1),0,sizeof(unsigned int)*N);
-              return true;
-            }
-          }
-        }
-      }
-      return false;
-    }
-
-    //! Test if a key combination has been typed
-    bool is_typed(const unsigned int key1, const bool remove=true) {
-      return is_typed(&key1,1,remove);
-    }
-
-    //! Test if a key combination has been typed
-    bool is_typed(const unsigned int key1, const unsigned int key2, const bool remove=true) {
-      const unsigned int seq[2] = { key1, key2 };
-      return is_typed(seq,2,remove);
-    }
-
-    //! Test if a key combination has been typed
-    bool is_typed(const unsigned int key1, const unsigned int key2, const unsigned int key3, const bool remove=true) {
-      const unsigned int seq[3] = { key1, key2, key3 };
-      return is_typed(seq,3,remove);
-    }
-
-    //! Test if a key combination has been typed
-    bool is_typed(const unsigned int key1, const unsigned int key2, const unsigned int key3,
-                  const unsigned int key4, const bool remove=true) {
-      const unsigned int seq[4] = { key1, key2, key3, key4 };
-      return is_typed(seq,4,remove);
-    }
-
-    //! Test if a key combination has been typed
-    bool is_typed(const unsigned int key1, const unsigned int key2, const unsigned int key3,
-                  const unsigned int key4, const unsigned int key5, const bool remove=true) {
-      const unsigned int seq[5] = { key1, key2, key3, key4,key5 };
-      return is_typed(seq,5,remove);
-    }
-
-    //! Test if a key combination has been typed
-    bool is_typed(const unsigned int key1, const unsigned int key2, const unsigned int key3,
-                  const unsigned int key4, const unsigned int key5, const unsigned int key6, const bool remove=true) {
-      const unsigned int seq[6] = { key1, key2, key3, key4,key5,key6 };
-      return is_typed(seq,6,remove);
-    }
-
-    //! Test if a key combination has been typed
-    bool is_typed(const unsigned int key1, const unsigned int key2, const unsigned int key3,
-                  const unsigned int key4, const unsigned int key5, const unsigned int key6,
-                  const unsigned int key7, const bool remove=true) {
-      const unsigned int seq[7] = { key1, key2, key3, key4,key5,key6,key7 };
-      return is_typed(seq,7,remove);
-    }
-
-    //! Test if a key combination has been typed
-    bool is_typed(const unsigned int key1, const unsigned int key2, const unsigned int key3,
-                  const unsigned int key4, const unsigned int key5, const unsigned int key6,
-                  const unsigned int key7, const unsigned int key8, const bool remove=true) {
-      const unsigned int seq[8] = { key1, key2, key3, key4,key5,key6,key7,key8 };
-      return is_typed(seq,8,remove);
-    }
-
-    //! Test if a key combination has been typed
-    bool is_typed(const unsigned int key1, const unsigned int key2, const unsigned int key3,
-                  const unsigned int key4, const unsigned int key5, const unsigned int key6,
-                  const unsigned int key7, const unsigned int key8, const unsigned int key9, const bool remove=true) {
-      const unsigned int seq[9] = { key1, key2, key3, key4,key5,key6,key7,key8,key9 };
-      return is_typed(seq,9,remove);
-    }
-
-    // When no display available
-    //---------------------------
-#if cimg_display_type==0
-
-    //! Return the width of the screen resolution.
-    static int screen_dimx() {
-      return 0;
-    }
-
-    //! Return the height of the screen resolution.
-    static int screen_dimy() {
-      return 0;
-    }
-
-    //! In-place version of the previous constructor
-    CImgDisplay& assign(const unsigned int dimw, const unsigned int dimh, const char *title=0,
-                        const unsigned int normalization_type=3, const unsigned int events_type=3,
-                        const bool fullscreen_flag=false, const bool closed_flag=false) {
-      throw CImgDisplayException("CImgDisplay() : Display has been required but is not available (cimg_display_type=0)");
-      fps_timer = 0*(unsigned long)(dimw + dimh + title + normalization_type + events_type + (int)fullscreen_flag + (int)closed_flag);
-      return *this;
-    }
-
-    //! In-place version of the previous constructor
-    template<typename T> CImgDisplay& assign(const CImg<T>& img, const char *title=0,
-                                             const unsigned int normalization_type=3, const unsigned int events_type=3,
-                                             const bool fullscreen_flag=false, const bool closed_flag=false) {
-      fps_timer = 0*(unsigned long)(img.width + title + normalization_type + events_type + (int)fullscreen_flag + (int)closed_flag);
-      return assign(0,0);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename T> CImgDisplay& assign(const CImgList<T>& list, const char *title=0,
-                                             const unsigned int normalization_type=3, const unsigned int events_type=3,
-                                             const bool fullscreen_flag=false, const bool closed_flag=false) {
-      fps_timer = 0*(unsigned long)(list.size + title + normalization_type + events_type + (int)fullscreen_flag + (int)closed_flag);
-      return assign(0,0);
-    }
-
-    //! In-place version of the previous constructor
-    CImgDisplay& assign(const CImgDisplay &disp) {
-      return assign(disp.width,disp.height);
-    }
-
-    // In-place version of the destructor (should not be used by the user).
-    CImgDisplay& _assign() {
-      return *this;
-    }
-
-    //! Display an image in a window.
-    template<typename T> CImgDisplay& display(const CImg<T>& img) {
-      fps_timer = 0*img.width;
-      return *this;
-    }
-
-    //! Resize window
-    CImgDisplay& resize(const int width, const int height, const bool redraw=true) {
-      fps_timer = 0*width*height*(int)redraw;
-      return *this;
-    }
-
-    //! Move window
-    CImgDisplay& move(const int posx, const int posy) {
-      fps_timer = 0*posx*posy;
-      return *this;
-    }
-
-    //! Move mouse pointer to a specific location
-    CImgDisplay& set_mouse(const int posx, const int posy) {
-      fps_timer = 0*posx*posy;
-      return *this;
-    }
-
-    //! Hide mouse pointer
-    CImgDisplay& hide_mouse() {
-      return *this;
-    }
-
-    //! Show mouse pointer
-    CImgDisplay& show_mouse() {
-      return *this;
-    }
-
-    //! Wait for a window event in any CImg window
-    static void wait_all() {}
-
-    //! Show a closed display
-    CImgDisplay& show() {
-      return *this;
-    }
-
-    //! Close a visible display
-    CImgDisplay& close() {
-      return *this;
-    }
-
-    //! Set the window title
-    CImgDisplay& set_title(const char *format,...) {
-      fps_timer = 0*(unsigned long)format;
-      return *this;
-    }
-
-    //! Re-paint image content in window
-    CImgDisplay& paint() {
-      return *this;
-    }
-
-    //! Render image buffer into GDI native image format
-    template<typename T> CImgDisplay& render(const CImg<T>& img) {
-      fps_timer = 0*img.width;
-      return *this;
-    }
-
-    // X11-based display
-    //-------------------
-#elif cimg_display_type==1
-    void *data;
-    Window window;
-    Window background_window;
-    XImage *image;
-    Colormap colormap;
-    Atom wm_delete_window, wm_delete_protocol;
-#ifdef cimg_use_xshm
-    XShmSegmentInfo *shminfo;
-#endif
-
-    static int screen_dimx() {
-      int res = 0;
-      if (!cimg::X11attr().display) {
-        Display *disp = XOpenDisplay((std::getenv("DISPLAY") ? std::getenv("DISPLAY") : ":0.0"));
-        if (!disp) throw CImgDisplayException("CImgDisplay::screen_dimx() : Can't open X11 display");
-        res = DisplayWidth(disp,DefaultScreen(disp));
-        XCloseDisplay(disp);
-      } else {
-#ifdef cimg_use_xrandr
-        if (cimg::X11attr().resolutions && cimg::X11attr().curr_resolution)
-          res = cimg::X11attr().resolutions[cimg::X11attr().curr_resolution].width;
-        else
-#endif
-          res = DisplayWidth(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display));
-      }
-      return res;
-    }
-
-    static int screen_dimy() {
-      int res = 0;
-      if (!cimg::X11attr().display) {
-        Display *disp = XOpenDisplay((std::getenv("DISPLAY") ? std::getenv("DISPLAY") : ":0.0"));
-        if (!disp) throw CImgDisplayException("CImgDisplay::screen_dimy() : Can't open X11 display");
-        res = DisplayHeight(disp,DefaultScreen(disp));
-        XCloseDisplay(disp);
-      } else {
-#ifdef cimg_use_xrandr
-        if (cimg::X11attr().resolutions && cimg::X11attr().curr_resolution)
-          res = cimg::X11attr().resolutions[cimg::X11attr().curr_resolution].height; else
-#endif
-            res = DisplayHeight(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display));
-      }
-      return res;
-    }
-
-    CImgDisplay& assign(const unsigned int dimw, const unsigned int dimh, const char *title=0,
-                        const unsigned int normalization_type=3, const unsigned int events_type=3,
-                        const bool fullscreen_flag=false, const bool closed_flag=false) {
-      if (!dimw || !dimh)
-        throw CImgArgumentException("CImgDisplay::assign() : Specified window size (%u,%u) is not valid.",dimw,dimh);
-      assign_lowlevel(dimw,dimh,title,normalization_type,events_type,fullscreen_flag,closed_flag);
-      min = max = 0;
-      std::memset(data,0,(cimg::X11attr().nb_bits==8?sizeof(unsigned char):
-                          (cimg::X11attr().nb_bits==16?sizeof(unsigned short):sizeof(unsigned int)))*width*height);
-      return paint();
-    }
-
-    template<typename T> CImgDisplay& assign(const CImg<T>& img, const char *title=0,
-                                             const unsigned int normalization_type=3, const unsigned int events_type=3,
-                                             const bool fullscreen_flag=false, const bool closed_flag=false) {
-      if (img.is_empty())
-        throw CImgArgumentException("CImgDisplay::CImgDisplay() : Specified input image (%u,%u,%u,%u,%p) is empty.",
-                                    img.width,img.height,img.depth,img.dim,img.data);
-      CImg<T> tmp;
-      const CImg<T>& nimg = (img.depth==1)?img:(tmp=img.get_projections2d(img.width/2,img.height/2,img.depth/2));
-      assign_lowlevel(nimg.width,nimg.height,title,normalization_type,events_type,fullscreen_flag,closed_flag);
-      if (normalization==2) { const CImgStats st(nimg,false); min = (float)st.min; max = (float)st.max; }
-      return render(nimg).paint();
-    }
-
-    template<typename T> CImgDisplay& assign(const CImgList<T>& list, const char *title=0,
-                                             const unsigned int normalization_type=3, const unsigned int events_type=3,
-                                             const bool fullscreen_flag=false, const bool closed_flag=false) {
-      if (list.is_empty())
-        throw CImgArgumentException("CImgDisplay::CImgDisplay() : Specified input list (%u,%p) is empty.",
-                                    list.size,list.data);
-      CImg<T> tmp;
-      const CImg<T> img = list.get_append('x'),
-        &nimg = (img.depth==1)?img:(tmp=img.get_projections2d(img.width/2,img.height/2,img.depth/2));
-      assign_lowlevel(nimg.width,nimg.height,title,normalization_type,events_type,fullscreen_flag,closed_flag);
-      if (normalization==2) { const CImgStats st(nimg,false); min = (float)st.min; max = (float)st.max; }
-      return render(nimg).paint();
-    }
-
-    CImgDisplay& assign(const CImgDisplay& win) {
-      assign_lowlevel(win.width,win.height,win.title,win.normalization,win.events,win.is_fullscreen,win.is_closed);
-      std::memcpy(data,win.data,(cimg::X11attr().nb_bits==8?sizeof(unsigned char):
-                                 cimg::X11attr().nb_bits==16?sizeof(unsigned short):
-                                 sizeof(unsigned int))*width*height);
-      return paint();
-    }
-
-    CImgDisplay& _assign() {
-      if (width && height) {
-        pthread_mutex_lock(cimg::X11attr().mutex);
-
-        // Remove display window from event thread list
-        unsigned int i;
-        for (i=0; i<cimg::X11attr().nb_wins && cimg::X11attr().wins[i]!=this; i++);
-        for (; i<cimg::X11attr().nb_wins-1; i++) cimg::X11attr().wins[i]=cimg::X11attr().wins[i+1];
-        cimg::X11attr().nb_wins--;
-
-        // Destroy window, image, colormap and title
-        if (is_fullscreen) _desinit_fullscreen();
-        XDestroyWindow(cimg::X11attr().display,window);
-        window = 0;
-#ifdef cimg_use_xshm
-        if (shminfo) {
-          XShmDetach(cimg::X11attr().display, shminfo);
-          XDestroyImage(image);
-          shmdt(shminfo->shmaddr);
-          shmctl(shminfo->shmid,IPC_RMID,0);
-          delete shminfo;
-          shminfo = 0;
-        } else
-#endif
-          XDestroyImage(image);
-        data = 0;
-        image = 0;
-        if (cimg::X11attr().nb_bits==8) XFreeColormap(cimg::X11attr().display,colormap);
-        colormap = 0;
-        XSync(cimg::X11attr().display, False);
-
-        // Reset display variables
-        if (title) delete[] title;
-        width = height = normalization = events = 0;
-        is_fullscreen = is_resized = is_moved = is_event = false;
-        is_closed = true;
-        title = 0;
-        window_x = window_y = window_width = window_height = mouse_x = mouse_y = wheel = 0;
-        std::memset((void*)buttons,0,256*sizeof(unsigned int));
-        std::memset((void*)keys,0,256*sizeof(unsigned int));
-        std::memset((void*)released_keys,0,256*sizeof(unsigned int));
-        min = max = 0;
-
-        // End event thread and close display if necessary
-        if (!cimg::X11attr().nb_wins) {
-
-          // Kill event thread
-          pthread_cancel(*cimg::X11attr().event_thread);
-          pthread_mutex_unlock(cimg::X11attr().mutex);
-          pthread_join(*cimg::X11attr().event_thread,0);
-          delete cimg::X11attr().event_thread;
-          cimg::X11attr().event_thread = 0;
-          pthread_mutex_destroy(cimg::X11attr().mutex);
-          delete cimg::X11attr().mutex;
-          cimg::X11attr().mutex = 0;
-          XSync(cimg::X11attr().display, False);
-          XCloseDisplay(cimg::X11attr().display);
-          cimg::X11attr().display=0;
-          delete cimg::X11attr().gc;
-          cimg::X11attr().gc = 0;
-        } else pthread_mutex_unlock(cimg::X11attr().mutex);
-      }
-      return *this;
-    }
-
-    template<typename T> CImgDisplay& display(const CImg<T>& img) {
-      return render(img).paint(false);
-    }
-
-    CImgDisplay& resize(const int nwidth, const int nheight, const bool redraw=true) {
-      if (!(nwidth && nheight))
-        throw CImgArgumentException("CImgDisplay::resize() : Specified window size (%d,%d) is not valid.",
-                                    nwidth,nheight);
-      const unsigned int
-        tmpdimx=(nwidth>0)?nwidth:(-nwidth*width/100),
-        tmpdimy=(nheight>0)?nheight:(-nheight*height/100),
-        dimx = tmpdimx?tmpdimx:1,
-        dimy = tmpdimy?tmpdimy:1;
-      const bool
-        is_disp_different = (width!=dimx || height!=dimy),
-        is_win_different = (window_width!=dimx || window_height!=dimy);
-      if (is_disp_different || is_win_different) {
-        pthread_mutex_lock(cimg::X11attr().mutex);
-        XResizeWindow(cimg::X11attr().display,window,dimx,dimy);
-        window_width = dimx;
-        window_height = dimy;
-        is_resized = false;
-        if (is_disp_different) {
-          switch (cimg::X11attr().nb_bits) {
-          case 8:  { unsigned char foo=0; _resize(foo,dimx,dimy,redraw);  } break;
-          case 16: { unsigned short foo=0; _resize(foo,dimx,dimy,redraw); } break;
-          default: { unsigned int foo=0; _resize(foo,dimx,dimy,redraw);   } break;
-          }
-          width = dimx;
-          height = dimy;
-        }
-        pthread_mutex_unlock(cimg::X11attr().mutex);
-        if (is_fullscreen) move((screen_dimx()-width)/2,(screen_dimy()-height)/2);
-        if (redraw) return paint();
-      }
-      return *this;
-    }
-
-    CImgDisplay& move(const int posx, const int posy) {
-      show();
-      pthread_mutex_lock(cimg::X11attr().mutex);
-      XMoveWindow(cimg::X11attr().display,window,posx,posy);
-      is_moved = false;
-      window_x = posx;
-      window_y = posy;
-      pthread_mutex_unlock(cimg::X11attr().mutex);
-      return paint();
-    }
-
-    CImgDisplay& set_mouse(const int posx, const int posy) {
-      if (!is_closed && posx>=0 && posy>=0) {
-        pthread_mutex_lock(cimg::X11attr().mutex);
-        XWarpPointer(cimg::X11attr().display,None,window,0,0,0,0,posx,posy);
-        is_moved = false;
-        mouse_x = posx;
-        mouse_y = posy;
-        XSync(cimg::X11attr().display, False);
-        pthread_mutex_unlock(cimg::X11attr().mutex);
-      }
-      return *this;
-    }
-
-    CImgDisplay& hide_mouse() {
-      pthread_mutex_lock(cimg::X11attr().mutex);
-      const char pix_data[8] = { 0 };
-      XColor col;
-      col.red = col.green = col.blue = 0;
-      Pixmap pix = XCreateBitmapFromData(cimg::X11attr().display,window,pix_data,8,8);
-      Cursor cur = XCreatePixmapCursor(cimg::X11attr().display,pix,pix,&col,&col,0,0);
-      XFreePixmap(cimg::X11attr().display,pix);
-      XDefineCursor(cimg::X11attr().display,window,cur);
-      pthread_mutex_unlock(cimg::X11attr().mutex);
-      return *this;
-    }
-
-    CImgDisplay& show_mouse() {
-      pthread_mutex_lock(cimg::X11attr().mutex);
-      XDefineCursor(cimg::X11attr().display,window,None);
-      pthread_mutex_unlock(cimg::X11attr().mutex);
-      return *this;
-    }
-
-    static void wait_all() {
-      pthread_mutex_lock(cimg::X11attr().mutex);
-      bool flag = true;
-      XEvent event;
-      while (flag) {
-        for (unsigned int i=0; i<cimg::X11attr().nb_wins; i++) {
-          cimg::X11attr().wins[i]->is_event = false;
-          const unsigned int xevent_type = (cimg::X11attr().wins[i]->events)&3;
-          const unsigned int emask =
-            ((xevent_type>=1)?ExposureMask|StructureNotifyMask:0)|
-            ((xevent_type>=2)?ButtonPressMask|KeyPressMask|PointerMotionMask|LeaveWindowMask:0)|
-            ((xevent_type>=3)?ButtonReleaseMask|KeyReleaseMask:0);
-          XSelectInput(cimg::X11attr().display,cimg::X11attr().wins[i]->window,emask);
-        }
-        XNextEvent(cimg::X11attr().display, &event);
-        for (unsigned int i=0; i<cimg::X11attr().nb_wins; i++)
-          if (!cimg::X11attr().wins[i]->is_closed && event.xany.window==cimg::X11attr().wins[i]->window) {
-            cimg::X11attr().wins[i]->_handle_events(&event);
-            if (cimg::X11attr().wins[i]->is_event) flag = false;
-          }
-      }
-      pthread_mutex_unlock(cimg::X11attr().mutex);
-    }
-
-    CImgDisplay& show() {
-      if (is_closed) {
-        pthread_mutex_lock(cimg::X11attr().mutex);
-        if (is_fullscreen) _init_fullscreen();
-        _map_window();
-        is_closed = false;
-        pthread_mutex_unlock(cimg::X11attr().mutex);
-      }
-      return paint();
-    }
-
-    CImgDisplay& close() {
-      if (!is_closed) {
-        pthread_mutex_lock(cimg::X11attr().mutex);
-        if (is_fullscreen) _desinit_fullscreen();
-        XUnmapWindow(cimg::X11attr().display,window);
-        window_x = window_y = -1;
-        is_closed = true;
-        pthread_mutex_unlock(cimg::X11attr().mutex);
-      }
-      return *this;
-    }
-
-    CImgDisplay& set_title(const char *format,...) {
-      char tmp[1024]={0};
-      va_list ap;
-      va_start(ap, format);
-      std::vsprintf(tmp,format,ap);
-      va_end(ap);
-      if (title) delete[] title;
-      const int s = cimg::strlen(tmp)+1;
-      title = new char[s];
-      std::memcpy(title,tmp,s*sizeof(char));
-      pthread_mutex_lock(cimg::X11attr().mutex);
-      XStoreName(cimg::X11attr().display,window,tmp);
-      pthread_mutex_unlock(cimg::X11attr().mutex);
-      return *this;
-    }
-
-    CImgDisplay& paint(const bool wait_expose=true) {
-      pthread_mutex_lock(cimg::X11attr().mutex);
-      _paint(wait_expose);
-      pthread_mutex_unlock(cimg::X11attr().mutex);
-      return *this;
-    }
-
-    template<typename T> CImgDisplay& render(const CImg<T>& img, const bool flag8=false) {
-      if (img.is_empty())
-        throw CImgArgumentException("CImgDisplay::_render_image() : Specified input image (%u,%u,%u,%u,%p) is empty.",
-                                    img.width,img.height,img.depth,img.dim,img.data);
-      if (img.depth!=1) return render(img.get_projections2d(img.width/2,img.height/2,img.depth/2));
-      if (cimg::X11attr().nb_bits==8 && (img.width!=width || img.height!=height)) return render(img.get_resize(width,height,1,-100,1));
-      if (cimg::X11attr().nb_bits==8 && !flag8 && img.dim==3) return render(img.get_RGBtoLUT(true),true);
-
-      const unsigned int xymax = img.width*img.height;
-      const T
-        *data1 = img.ptr(),
-        *data2 = (img.dim>=2)?img.ptr(0,0,0,1):data1,
-        *data3 = (img.dim>=3)?img.ptr(0,0,0,2):data1;
-      if (cimg::X11attr().blue_first) cimg::swap(data1,data3);
-      pthread_mutex_lock(cimg::X11attr().mutex);
-
-      if (!normalization || (normalization==3 && cimg::type<T>::id()==cimg::type<unsigned char>::id())) {
-	min = max = 0;
-        switch (cimg::X11attr().nb_bits) {
-        case 8: {
-          _set_colormap(colormap,img.dim);
-          unsigned char *const ndata = (img.width==width && img.height==height)?(unsigned char*)data:new unsigned char[img.width*img.height];
-          unsigned char *ptrd = (unsigned char*)ndata;
-          switch (img.dim) {
-          case 1: for (unsigned int xy=0; xy<xymax; xy++) (*ptrd++) = (unsigned char)*(data1++);
-            break;
-          case 2: for (unsigned int xy=0; xy<xymax; xy++) {
-            const unsigned char R = (unsigned char)*(data1++), G = (unsigned char)*(data2++);
-            (*ptrd++) = (R&0xf0)|(G>>4);
-          } break;
-          default: for (unsigned int xy=0; xy<xymax; xy++) {
-            const unsigned char R = (unsigned char)*(data1++), G = (unsigned char)*(data2++), B = (unsigned char)*(data3++);
-            (*ptrd++) = (R&0xe0) | ((G>>5)<<2) | (B>>6);
-          } break;
-          }
-          if (ndata!=data) { _render_resize(ndata,img.width,img.height,(unsigned char*)data,width,height); delete[] ndata; }
-        } break;
-        case 16: {
-          unsigned short *const ndata = (img.width==width && img.height==height)?(unsigned short*)data:new unsigned short[img.width*img.height];
-          unsigned char *ptrd = (unsigned char*)ndata;
-          const unsigned int M = 248;
-          if (cimg::X11attr().byte_order) for (unsigned int xy=0; xy<xymax; xy++) {
-            const unsigned char G = (unsigned char)*(data2++)>>2;
-            *(ptrd++) = (unsigned char)*(data1++)&M | (G>>3);
-            *(ptrd++) = (G<<5) | ((unsigned char)*(data3++)>>3);
-          } else for (unsigned int xy=0; xy<xymax; xy++) {
-            const unsigned char G = (unsigned char)*(data2++)>>2;
-            *(ptrd++) = (G<<5) | ((unsigned char)*(data3++)>>3);
-            *(ptrd++) = (unsigned char)*(data1++)&M | (G>>3);
-          }
-          if (ndata!=data) { _render_resize(ndata,img.width,img.height,(unsigned short*)data,width,height); delete[] ndata; }
-        } break;
-        default: {
-          unsigned int *const ndata = (img.width==width && img.height==height)?(unsigned int*)data:new unsigned int[img.width*img.height];
-          unsigned char *ptrd = (unsigned char*)ndata;
-          if (cimg::X11attr().byte_order) for (unsigned int xy=0; xy<xymax; xy++) {
-            *(ptrd++) = 0;
-            *(ptrd++) = (unsigned char)*(data1++);
-            *(ptrd++) = (unsigned char)*(data2++);
-            *(ptrd++) = (unsigned char)*(data3++);
-          } else for (unsigned int xy=0; xy<xymax; xy++) {
-            *(ptrd++) = (unsigned char)*(data3++);
-            *(ptrd++) = (unsigned char)*(data2++);
-            *(ptrd++) = (unsigned char)*(data1++);
-            *(ptrd++) = 0;
-          }
-          if (ndata!=data) { _render_resize(ndata,img.width,img.height,(unsigned int*)data,width,height); delete[] ndata; }
-        } break;
-        };
-      } else {
-        if (normalization==3) {
-          if (cimg::type<T>::is_float()) { const CImgStats st(img,false); min = (float)st.min; max = (float)st.max; }
-          else { min = (float)cimg::type<T>::min(); max = (float)cimg::type<T>::max(); }
-        } else if ((min>max) || normalization==1) { const CImgStats st(img,false); min = (float)st.min; max = (float)st.max; }
-        const float delta = max-min, mm = delta?delta:1.0f;
-        switch (cimg::X11attr().nb_bits) {
-        case 8: {
-          _set_colormap(colormap,img.dim);
-          unsigned char *const ndata = (img.width==width && img.height==height)?(unsigned char*)data:new unsigned char[img.width*img.height];
-          unsigned char *ptrd = (unsigned char*)ndata;
-          switch (img.dim) {
-          case 1: for (unsigned int xy=0; xy<xymax; xy++) {
-            const unsigned char R = (unsigned char)(255*(*(data1++)-min)/mm);
-            *(ptrd++) = R;
-          } break;
-          case 2: for (unsigned int xy=0; xy<xymax; xy++) {
-            const unsigned char
-              R = (unsigned char)(255*(*(data1++)-min)/mm),
-              G = (unsigned char)(255*(*(data2++)-min)/mm);
-            (*ptrd++) = (R&0xf0) | (G>>4);
-          } break;
-          default:
-            for (unsigned int xy=0; xy<xymax; xy++) {
-              const unsigned char
-                R = (unsigned char)(255*(*(data1++)-min)/mm),
-                G = (unsigned char)(255*(*(data2++)-min)/mm),
-                B = (unsigned char)(255*(*(data3++)-min)/mm);
-              *(ptrd++) = (R&0xe0) | ((G>>5)<<2) | (B>>6);
-            } break;
-          }
-          if (ndata!=data) { _render_resize(ndata,img.width,img.height,(unsigned char*)data,width,height); delete[] ndata; }
-        } break;
-        case 16: {
-          unsigned short *const ndata = (img.width==width && img.height==height)?(unsigned short*)data:new unsigned short[img.width*img.height];
-          unsigned char *ptrd = (unsigned char*)ndata;
-          const unsigned int M = 248;
-          if (cimg::X11attr().byte_order) for (unsigned int xy=0; xy<xymax; xy++) {
-            const unsigned char G = (unsigned char)(255*(*(data2++)-min)/mm)>>2;
-            *(ptrd++) = (unsigned char)(255*(*(data1++)-min)/mm)&M | (G>>3);
-            *(ptrd++) = (G<<5) | ((unsigned char)(255*(*(data3++)-min)/mm)>>3);
-          } else for (unsigned int xy=0; xy<xymax; xy++) {
-            const unsigned char G = (unsigned char)(255*(*(data2++)-min)/mm)>>2;
-            *(ptrd++) = (G<<5) | ((unsigned char)(255*(*(data3++)-min)/mm)>>3);
-            *(ptrd++) = (unsigned char)(255*(*(data1++)-min)/mm)&M | (G>>3);
-          }
-          if (ndata!=data) { _render_resize(ndata,img.width,img.height,(unsigned short*)data,width,height); delete[] ndata; }
-        } break;
-        default: {
-          unsigned int *const ndata = (img.width==width && img.height==height)?(unsigned int*)data:new unsigned int[img.width*img.height];
-          unsigned char *ptrd = (unsigned char*)ndata;
-          if (cimg::X11attr().byte_order) for (unsigned int xy=0; xy<xymax; xy++) {
-            (*ptrd++) = 0;
-            (*ptrd++) = (unsigned char)(255*(*(data1++)-min)/mm);
-            (*ptrd++) = (unsigned char)(255*(*(data2++)-min)/mm);
-            (*ptrd++) = (unsigned char)(255*(*(data3++)-min)/mm);
-          } else for (unsigned int xy=0; xy<xymax; xy++) {
-            (*ptrd++) = (unsigned char)(255*(*(data3++)-min)/mm);
-            (*ptrd++) = (unsigned char)(255*(*(data2++)-min)/mm);
-            (*ptrd++) = (unsigned char)(255*(*(data1++)-min)/mm);
-            (*ptrd++) = 0;
-          }
-          if (ndata!=data) { _render_resize(ndata,img.width,img.height,(unsigned int*)data,width,height); delete[] ndata; }
-        } break;
-        }
-      }
-
-      pthread_mutex_unlock(cimg::X11attr().mutex);
-      return *this;
-    }
-
-    static int _assign_lowlevel_xshm(Display *dpy, XErrorEvent *error) {
-      dpy = 0; error = 0;
-      cimg::X11attr().shm_enabled = false;
-      return 0;
-    }
-
-    void assign_lowlevel(const unsigned int dimw, const unsigned int dimh, const char *ptitle=0,
-                         const unsigned int normalization_type=3, const unsigned int events_type=3,
-                         const bool fullscreen_flag=false, const bool closed_flag=false) {
-
-      // Allocate space for window title
-      const int s = cimg::strlen(ptitle)+1;
-      char *tmp_title = s?new char[s]:0;
-      if (s) std::memcpy(tmp_title,ptitle,s*sizeof(char));
-
-      // Destroy previous display window if existing
-      if (width && height) _assign();
-
-      // Open X11 display if necessary.
-      if (!cimg::X11attr().display) {
-        cimg::X11attr().nb_wins = 0;
-        cimg::X11attr().mutex = new pthread_mutex_t;
-        pthread_mutex_init(cimg::X11attr().mutex,0);
-
-        cimg::X11attr().display = XOpenDisplay((std::getenv("DISPLAY") ? std::getenv("DISPLAY") : ":0.0"));
-        if (!cimg::X11attr().display)
-          throw CImgDisplayException("CImgDisplay::_create_window() : Can't open X11 display");
-        cimg::X11attr().nb_bits = DefaultDepth(cimg::X11attr().display, DefaultScreen(cimg::X11attr().display));
-        if (cimg::X11attr().nb_bits!=8 && cimg::X11attr().nb_bits!=16 && cimg::X11attr().nb_bits!=24 && cimg::X11attr().nb_bits!=32)
-          throw CImgDisplayException("CImgDisplay::_create_window() : %u bits mode is not supported "
-                                     "(only 8, 16, 24 and 32 bits modes are supported)",cimg::X11attr().nb_bits);
-        cimg::X11attr().gc = new GC;
-        *cimg::X11attr().gc = DefaultGC(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display));
-        Visual *visual = DefaultVisual(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display));
-        XVisualInfo vtemplate;
-        vtemplate.visualid = XVisualIDFromVisual(visual);
-        int nb_visuals;
-        XVisualInfo *vinfo = XGetVisualInfo(cimg::X11attr().display,VisualIDMask,&vtemplate,&nb_visuals);
-        if (vinfo && vinfo->red_mask<vinfo->blue_mask) cimg::X11attr().blue_first = true;
-        cimg::X11attr().byte_order = ImageByteOrder(cimg::X11attr().display);
-
-        pthread_mutex_lock(cimg::X11attr().mutex);
-        cimg::X11attr().event_thread = new pthread_t;
-        pthread_create(cimg::X11attr().event_thread,0,_events_thread,0);
-      } else pthread_mutex_lock(cimg::X11attr().mutex);
-
-      // Set display variables
-      width = dimw;
-      height = dimh;
-      normalization = normalization_type%4;
-      events = events_type%4;
-      is_fullscreen = fullscreen_flag;
-      title = tmp_title;
-      window_x = window_y = wheel = 0;
-      mouse_x = mouse_y = -1;
-      std::memset((void*)buttons,0,256*sizeof(unsigned int));
-      std::memset((void*)keys,0,256*sizeof(unsigned int));
-      std::memset((void*)released_keys,0,256*sizeof(unsigned int));
-      is_resized = is_moved = is_event = false;
-      is_closed = closed_flag;
-      fps_timer = fps_frames = timer = 0;
-      fps_fps = 0;
-
-      // Create X11 window and palette (if 8bits display)
-      if (is_fullscreen) {
-        _init_fullscreen();
-        const unsigned int sx = screen_dimx(), sy = screen_dimy();
-        XSetWindowAttributes winattr;
-        winattr.override_redirect = True;
-        window = XCreateWindow(cimg::X11attr().display,
-                               RootWindow(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display)),
-                               (sx-width)/2,(sy-height)/2,
-                               width,height,0,0,InputOutput,CopyFromParent,CWOverrideRedirect,&winattr);
-      } else
-        window = XCreateSimpleWindow(cimg::X11attr().display,
-                                     RootWindow(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display)),
-                                     0,0,width,height,2,0,0x0L);
-      XStoreName(cimg::X11attr().display,window,title?title:" ");
-      if (cimg::X11attr().nb_bits==8) {
-        colormap = XCreateColormap(cimg::X11attr().display,window,DefaultVisual(cimg::X11attr().display,
-                                                                                DefaultScreen(cimg::X11attr().display)),AllocAll);
-        _set_colormap(colormap,3);
-        XSetWindowColormap(cimg::X11attr().display,window,colormap);
-      }
-      window_width = width;
-      window_height = height;
-
-      // Create XImage
-      const unsigned int bufsize = width*height*(cimg::X11attr().nb_bits==8?1:(cimg::X11attr().nb_bits==16?2:4));
-#ifdef cimg_use_xshm
-      shminfo = 0;
-      if (XShmQueryExtension(cimg::X11attr().display)) {
-        shminfo = new XShmSegmentInfo;
-        image = XShmCreateImage(cimg::X11attr().display,DefaultVisual(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display)),
-                                cimg::X11attr().nb_bits,ZPixmap,0,shminfo,width,height);
-        if (!image) { delete shminfo; shminfo = 0; }
-        else {
-          shminfo->shmid = shmget(IPC_PRIVATE, bufsize, IPC_CREAT | 0777);
-          if (shminfo->shmid==-1) { XDestroyImage(image); delete shminfo; shminfo = 0; }
-          else {
-            shminfo->shmaddr = image->data = (char*)(data = shmat(shminfo->shmid,0,0));
-            if (shminfo->shmaddr==(char*)-1) { XDestroyImage(image); shmctl(shminfo->shmid,IPC_RMID,0); delete shminfo; shminfo = 0; }
-            shminfo->readOnly = False;
-            cimg::X11attr().shm_enabled = true;
-            XErrorHandler oldXErrorHandler = XSetErrorHandler(_assign_lowlevel_xshm);
-            XShmAttach(cimg::X11attr().display, shminfo);
-            XSync(cimg::X11attr().display, False);
-            XSetErrorHandler(oldXErrorHandler);
-            if (!cimg::X11attr().shm_enabled) {
-              XDestroyImage(image);
-              shmdt(shminfo->shmaddr);
-              shmctl(shminfo->shmid,IPC_RMID,0);
-              delete shminfo; shminfo = 0;
-            }
-          }
-        }
-      }
-      if (!shminfo)
-#endif
-        {
-          data = std::malloc(bufsize);
-          image = XCreateImage(cimg::X11attr().display,DefaultVisual(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display)),
-                               cimg::X11attr().nb_bits,ZPixmap,0,(char*)data,width,height,8,0);
-        }
-
-      if (!is_closed) _map_window(); else { window_x = window_y = cimg::type<int>::min(); }
-
-      if (events) {
-        wm_delete_window = XInternAtom(cimg::X11attr().display, "WM_DELETE_WINDOW", False);
-        wm_delete_protocol = XInternAtom(cimg::X11attr().display, "WM_PROTOCOLS", False);
-        XSetWMProtocols(cimg::X11attr().display, window, &wm_delete_window, 1);
-        if (is_fullscreen) XGrabKeyboard(cimg::X11attr().display, window, True, GrabModeAsync, GrabModeAsync, CurrentTime);
-      }
-      cimg::X11attr().wins[cimg::X11attr().nb_wins++]=this;
-      pthread_mutex_unlock(cimg::X11attr().mutex);
-    }
-
-    void _map_window() {
-      XWindowAttributes attr;
-      XEvent event;
-      XSelectInput(cimg::X11attr().display,window,ExposureMask | StructureNotifyMask);
-      bool exposed = false, mapped = false;
-      XMapRaised(cimg::X11attr().display,window);
-      XSync(cimg::X11attr().display,False);
-      do {
-        XWindowEvent(cimg::X11attr().display,window,StructureNotifyMask | ExposureMask,&event);
-        switch (event.type) {
-        case MapNotify: mapped = true; break;
-        case Expose: exposed = true; break;
-        default:  XSync(cimg::X11attr().display, False); cimg::sleep(10);
-        }
-      } while (!(exposed && mapped));
-      do {
-        XGetWindowAttributes(cimg::X11attr().display, window, &attr);
-        if (attr.map_state!=IsViewable) { XSync(cimg::X11attr().display,False); cimg::sleep(10); }
-      } while (attr.map_state != IsViewable);
-      window_x = attr.x;
-      window_y = attr.y;
-    }
-
-    void _set_colormap(Colormap& colormap, const unsigned int dim) {
-      XColor palette[256];
-      switch (dim) {
-      case 1:  // palette for greyscale images
-        for (unsigned int index=0; index<256; index++) {
-          palette[index].pixel = index;
-          palette[index].red = palette[index].green = palette[index].blue = index<<8;
-          palette[index].flags = DoRed | DoGreen | DoBlue;
-        }
-        break;
-      case 2: // palette for RG images
-        for (unsigned int index=0, r=8; r<256; r+=16)
-          for (unsigned int g=8; g<256; g+=16) {
-            palette[index].pixel = index;
-            palette[index].red   = palette[index].blue = r<<8;
-            palette[index].green = g<<8;
-            palette[index++].flags = DoRed | DoGreen | DoBlue;
-          }
-        break;
-      default: // palette for RGB images
-        for (unsigned int index=0, r=16; r<256; r+=32)
-          for (unsigned int g=16; g<256; g+=32)
-            for (unsigned int b=32; b<256; b+=64) {
-              palette[index].pixel = index;
-              palette[index].red   = r<<8;
-              palette[index].green = g<<8;
-              palette[index].blue  = b<<8;
-              palette[index++].flags = DoRed | DoGreen | DoBlue;
-            }
-        break;
-      }
-      XStoreColors(cimg::X11attr().display,colormap,palette,256);
-    }
-
-    void _paint(const bool wait_expose=true) {
-      if (!is_closed) {
-        if (wait_expose) {
-          static XEvent event;
-          event.xexpose.type = Expose;
-          event.xexpose.serial = 0;
-          event.xexpose.send_event = True;
-          event.xexpose.display = cimg::X11attr().display;
-          event.xexpose.window = window;
-          event.xexpose.x = 0;
-          event.xexpose.y = 0;
-          event.xexpose.width = (int)width;
-          event.xexpose.height = (int)height;
-          event.xexpose.count = 0;
-          XSendEvent(cimg::X11attr().display, window, False, 0, &event);
-        } else {
-#if cimg_use_xshm
-          if (shminfo) XShmPutImage(cimg::X11attr().display,window,*cimg::X11attr().gc,image,0,0,0,0,width,height,False);
-          else
-#endif
-            XPutImage(cimg::X11attr().display,window,*cimg::X11attr().gc,image,0,0,0,0,width,height);
-          XSync(cimg::X11attr().display, False);
-        }
-      }
-    }
-
-    template<typename T> void _resize(T foo, const unsigned int ndimx, const unsigned int ndimy, const bool redraw) {
-      foo = 0;
-#ifdef cimg_use_xshm
-      if (shminfo) {
-        XShmSegmentInfo *nshminfo = new XShmSegmentInfo;
-        XImage *nimage = XShmCreateImage(cimg::X11attr().display,DefaultVisual(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display)),
-                                         cimg::X11attr().nb_bits,ZPixmap,0,nshminfo,ndimx,ndimy);
-        nshminfo->shmid = shmget(IPC_PRIVATE, ndimx*ndimy*sizeof(T), IPC_CREAT | 0777);
-        nshminfo->shmaddr = nimage->data = (char*)shmat(nshminfo->shmid,0,0);
-        nshminfo->readOnly = False;
-        XShmAttach(cimg::X11attr().display, nshminfo);
-        XSync(cimg::X11attr().display, False);
-        T *const ndata = (T*)nimage->data;
-        if (redraw) _render_resize((T*)data,width,height,ndata,ndimx,ndimy);
-        else std::memset(ndata,0,sizeof(T)*ndimx*ndimy);
-        XShmDetach(cimg::X11attr().display, shminfo);
-        XDestroyImage(image);
-        shmdt(shminfo->shmaddr);
-        shmctl(shminfo->shmid,IPC_RMID,0);
-        delete shminfo;
-        shminfo = nshminfo;
-        image = nimage;
-        data = (void*)ndata;
-      } else
-#endif
-        {
-          T *ndata = (T*)std::malloc(ndimx*ndimy*sizeof(T));
-          if (redraw) _render_resize((T*)data,width,height,ndata,ndimx,ndimy);
-          else std::memset(ndata,0,sizeof(T)*ndimx*ndimy);
-          data = (void*)ndata;
-          XDestroyImage(image);
-          image = XCreateImage(cimg::X11attr().display,DefaultVisual(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display)),
-                               cimg::X11attr().nb_bits,ZPixmap,0,(char*)data,ndimx,ndimy,8,0);
-        }
-    }
-
-    void _init_fullscreen() {
-      background_window = 0;
-      if (is_fullscreen && !is_closed) {
-#ifdef cimg_use_xrandr
-        int foo;
-        if (XRRQueryExtension(cimg::X11attr().display,&foo,&foo)) {
-          XRRRotations(cimg::X11attr().display, DefaultScreen(cimg::X11attr().display), &cimg::X11attr().curr_rotation);
-          if (!cimg::X11attr().resolutions) {
-            cimg::X11attr().resolutions = XRRSizes(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display),&foo);
-            cimg::X11attr().nb_resolutions = (unsigned int)foo;
-          }
-          if (cimg::X11attr().resolutions) {
-            cimg::X11attr().curr_resolution = 0;
-            for (unsigned int i=0; i<cimg::X11attr().nb_resolutions; i++) {
-              const unsigned int
-                nw = (unsigned int)(cimg::X11attr().resolutions[i].width),
-                nh = (unsigned int)(cimg::X11attr().resolutions[i].height);
-              if (nw>=width && nh>=height &&
-                  nw<=(unsigned int)(cimg::X11attr().resolutions[cimg::X11attr().curr_resolution].width) &&
-                  nh<=(unsigned int)(cimg::X11attr().resolutions[cimg::X11attr().curr_resolution].height))
-                cimg::X11attr().curr_resolution = i;
-            }
-            if (cimg::X11attr().curr_resolution>0) {
-              XRRScreenConfiguration *config = XRRGetScreenInfo(cimg::X11attr().display, DefaultRootWindow(cimg::X11attr().display));
-              XRRSetScreenConfig(cimg::X11attr().display, config, DefaultRootWindow(cimg::X11attr().display),
-                                 cimg::X11attr().curr_resolution, cimg::X11attr().curr_rotation, CurrentTime);
-              XRRFreeScreenConfigInfo(config);
-              XSync(cimg::X11attr().display, False);
-            }
-          }
-        }
-        cimg::warn(!cimg::X11attr().resolutions,"CImgDisplay::_create_window() : Xrandr extension is not supported by the X server.");
-#endif
-        const unsigned int sx = screen_dimx(), sy = screen_dimy();
-        XSetWindowAttributes winattr;
-        winattr.override_redirect = True;
-        if (sx!=width || sy!=height) {
-          background_window = XCreateWindow(cimg::X11attr().display,
-                                            RootWindow(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display)),0,0,
-                                            sx,sy,0,0,InputOutput,CopyFromParent,CWOverrideRedirect,&winattr);
-          const unsigned int bufsize = sx*sy*(cimg::X11attr().nb_bits==8?1:(cimg::X11attr().nb_bits==16?2:4));
-          void *background_data = std::malloc(bufsize);
-          std::memset(background_data,0,bufsize);
-          XImage *background_image = XCreateImage(cimg::X11attr().display,DefaultVisual(cimg::X11attr().display,DefaultScreen(cimg::X11attr().display)),
-                                                  cimg::X11attr().nb_bits,ZPixmap,0,(char*)background_data,sx,sy,8,0);
-          XEvent event;
-          XSelectInput(cimg::X11attr().display,background_window,StructureNotifyMask);
-          XMapRaised(cimg::X11attr().display,background_window);
-          do XWindowEvent(cimg::X11attr().display,background_window,StructureNotifyMask,&event);
-          while (event.type!=MapNotify);
-          XPutImage(cimg::X11attr().display,background_window,*cimg::X11attr().gc,background_image,0,0,0,0,sx,sy);
-          XWindowAttributes attr;
-          XGetWindowAttributes(cimg::X11attr().display, background_window, &attr);
-          while (attr.map_state != IsViewable) XSync(cimg::X11attr().display, False);
-          XDestroyImage(background_image);
-        }
-      }
-    }
-
-    void _desinit_fullscreen() {
-      if (is_fullscreen) {
-        XUngrabKeyboard(cimg::X11attr().display,CurrentTime);
-#if cimg_use_xrandr
-        if (cimg::X11attr().resolutions && cimg::X11attr().curr_resolution) {
-          XRRScreenConfiguration *config = XRRGetScreenInfo(cimg::X11attr().display, DefaultRootWindow(cimg::X11attr().display));
-          XRRSetScreenConfig(cimg::X11attr().display, config, DefaultRootWindow(cimg::X11attr().display),
-                             0, cimg::X11attr().curr_rotation, CurrentTime);
-          XRRFreeScreenConfigInfo(config);
-          XSync(cimg::X11attr().display, False);
-          cimg::X11attr().curr_resolution = 0;
-        }
-#endif
-        if (background_window) XDestroyWindow(cimg::X11attr().display,background_window);
-        background_window = 0;
-        is_fullscreen = false;
-      }
-    }
-
-    void _handle_events(const XEvent *const pevent) {
-      XEvent event=*pevent;
-      switch (event.type) {
-      case ClientMessage:
-        if ((int)event.xclient.message_type==(int)wm_delete_protocol &&
-            (int)event.xclient.data.l[0]==(int)wm_delete_window) {
-          XUnmapWindow(cimg::X11attr().display,window);
-          mouse_x = mouse_y = -1;
-          std::memmove((void*)(buttons+1),(void*)buttons,255);
-          std::memmove((void*)(keys+1),(void*)keys,255);
-          if (key) { std::memmove((void*)(released_keys+1),(void*)released_keys,255); released_key = key; }
-          key = button = 0;
-          is_closed = is_event = true;
-        }
-        break;
-     case ConfigureNotify: {
-        while (XCheckWindowEvent(cimg::X11attr().display,window,StructureNotifyMask,&event));
-        const unsigned int
-          nw = event.xconfigure.width,
-          nh = event.xconfigure.height;
-        const int
-          nx = event.xconfigure.x,
-          ny = event.xconfigure.y;
-        if (nw && nh && (nw!=window_width || nh!=window_height)) {
-          window_width = nw;
-          window_height = nh;
-          mouse_x = mouse_y = -1;
-          XResizeWindow(cimg::X11attr().display,window,window_width,window_height);
-          is_resized = is_event = true;
-        }
-        if (nx!=window_x || ny!=window_y) {
-          window_x = nx;
-          window_y = ny;
-          is_moved = is_event = true;
-        }
-     } break;
-      case Expose: {
-        while (XCheckWindowEvent(cimg::X11attr().display,window,ExposureMask,&event));
-        _paint(false);
-        if (is_fullscreen) {
-          XWindowAttributes attr;
-          XGetWindowAttributes(cimg::X11attr().display, window, &attr);
-          while (attr.map_state != IsViewable) XSync(cimg::X11attr().display, False);
-          XSetInputFocus(cimg::X11attr().display, window, RevertToParent, CurrentTime);
-        }
-      } break;
-      case ButtonPress: {
-        do {
-          switch (event.xbutton.button) {
-          case 1: std::memmove((void*)(buttons+1),(void*)buttons,255); button|=1; is_event = true; break;
-          case 2: std::memmove((void*)(buttons+1),(void*)buttons,255); button|=4; is_event = true; break;
-          case 3: std::memmove((void*)(buttons+1),(void*)buttons,255); button|=2; is_event = true; break;
-          default: break;
-          }
-        } while (XCheckWindowEvent(cimg::X11attr().display,window,ButtonPressMask,&event));
-      } break;
-      case ButtonRelease: {
-        do {
-          switch (event.xbutton.button) {
-          case 1: std::memmove((void*)(buttons+1),(void*)buttons,255); button&=~1U; is_event = true; break;
-          case 2: std::memmove((void*)(buttons+1),(void*)buttons,255); button&=~4U; is_event = true; break;
-          case 3: std::memmove((void*)(buttons+1),(void*)buttons,255); button&=~2U; is_event = true; break;
-          case 4: wheel++; is_event = true; break;
-          case 5: wheel--; is_event = true; break;
-          default: break;
-          }
-        } while (XCheckWindowEvent(cimg::X11attr().display,window,ButtonReleaseMask,&event));
-      } break;
-      case KeyPress: {
-        char tmp;
-        KeySym ksym;
-        XLookupString(&event.xkey,&tmp,1,&ksym,0);
-        std::memmove((void*)(keys+1),(void*)keys,255); key = (unsigned int)ksym;
-        std::memmove((void*)(released_keys+1),(void*)released_keys,255); released_key = 0;
-        is_event = true;
-      } break;
-      case KeyRelease: {
-        char tmp;
-        KeySym ksym;
-        XLookupString(&event.xkey,&tmp,1,&ksym,0);
-        std::memmove((void*)(keys+1),(void*)keys,255); key = 0;
-        std::memmove((void*)(released_keys+1),(void*)released_keys,255); released_key = (unsigned int)ksym;
-        is_event = true;
-        } break;
-      case LeaveNotify:
-        while (XCheckWindowEvent(cimg::X11attr().display,window,LeaveWindowMask,&event));
-        mouse_x = mouse_y =-1;
-        is_event = true;
-        break;
-      case MotionNotify:
-        while (XCheckWindowEvent(cimg::X11attr().display,window,PointerMotionMask,&event));
-        mouse_x = event.xmotion.x;
-        mouse_y = event.xmotion.y;
-        if (mouse_x<0 || mouse_y<0 || mouse_x>=dimx() || mouse_y>=dimy()) mouse_x = mouse_y = -1;
-        is_event = true;
-        break;
-      }
-    }
-
-    static void* _events_thread(void *arg) {
-      arg = 0;
-      XEvent event;
-      pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED,0);
-      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,0);
-      for (;;) {
-        pthread_mutex_lock(cimg::X11attr().mutex);
-        for (unsigned int i=0; i<cimg::X11attr().nb_wins; i++) {
-          const unsigned int xevent_type = (cimg::X11attr().wins[i]->events)&3;
-          const unsigned int emask =
-            ((xevent_type>=1)?ExposureMask|StructureNotifyMask:0)|
-            ((xevent_type>=2)?ButtonPressMask|KeyPressMask|PointerMotionMask|LeaveWindowMask:0)|
-            ((xevent_type>=3)?ButtonReleaseMask|KeyReleaseMask:0);
-          XSelectInput(cimg::X11attr().display,cimg::X11attr().wins[i]->window,emask);
-        }
-        bool event_flag = XCheckTypedEvent(cimg::X11attr().display, ClientMessage, &event);
-        if (!event_flag) event_flag = XCheckMaskEvent(cimg::X11attr().display,
-                                                      ExposureMask|StructureNotifyMask|ButtonPressMask|
-                                                      KeyPressMask|PointerMotionMask|LeaveWindowMask|ButtonReleaseMask|
-                                                      KeyReleaseMask,&event);
-        if (event_flag) {
-          for (unsigned int i=0; i<cimg::X11attr().nb_wins; i++)
-            if (!cimg::X11attr().wins[i]->is_closed && event.xany.window==cimg::X11attr().wins[i]->window)
-              cimg::X11attr().wins[i]->_handle_events(&event);
-        }
-        pthread_mutex_unlock(cimg::X11attr().mutex);
-        pthread_testcancel();
-        cimg::sleep(7);
-      }
-      return 0;
-    }
-
-    // Windows-based display
-    //-----------------------
-#elif cimg_display_type==2
-    CLIENTCREATESTRUCT ccs;
-    BITMAPINFO bmi;
-    unsigned int *data;
-    DEVMODE curr_mode;
-    HWND window;
-    HWND background_window;
-    HDC hdc;
-    HANDLE thread;
-    HANDLE created;
-    HANDLE mutex;
-    bool visible_cursor;
-
-    static int screen_dimx() {
-      DEVMODE mode;
-      mode.dmSize = sizeof(DEVMODE);
-      mode.dmDriverExtra = 0;
-      EnumDisplaySettings(0,ENUM_CURRENT_SETTINGS,&mode);
-      return mode.dmPelsWidth;
-    }
-
-    static int screen_dimy() {
-      DEVMODE mode;
-      mode.dmSize = sizeof(DEVMODE);
-      mode.dmDriverExtra = 0;
-      EnumDisplaySettings(0,ENUM_CURRENT_SETTINGS,&mode);
-      return mode.dmPelsHeight;
-    }
-
-    CImgDisplay& assign(const unsigned int dimw, const unsigned int dimh, const char *title=0,
-                        const unsigned int normalization_type=3, const unsigned int events_type=3,
-                        const bool fullscreen_flag=false, const bool closed_flag=false) {
-      if (!dimw || !dimh)
-        throw CImgArgumentException("CImgDisplay::assign() : Specified window size (%u,%u) is not valid.",dimw,dimh);
-      assign_lowlevel(dimw,dimh,title,normalization_type,events_type,fullscreen_flag,closed_flag);
-      min = max = 0;
-      std::memset(data,0,sizeof(unsigned int)*width*height);
-      return paint();
-    }
-
-    template<typename T> CImgDisplay& assign(const CImg<T>& img, const char *title=0,
-                                             const unsigned int normalization_type=3, const unsigned int events_type=3,
-                                             const bool fullscreen_flag=false, const bool closed_flag=false) {
-      if (img.is_empty())
-        throw CImgArgumentException("CImgDisplay::CImgDisplay() : Specified input image (%u,%u,%u,%u,%p) is empty.",
-                                    img.width,img.height,img.depth,img.dim,img.data);
-      CImg<T> tmp;
-      const CImg<T>& nimg = (img.depth==1)?img:(tmp=img.get_projections2d(img.width/2,img.height/2,img.depth/2));
-      assign_lowlevel(nimg.width,nimg.height,title,normalization_type,events_type,fullscreen_flag,closed_flag);
-      if (normalization==2) { const CImgStats st(nimg,false); min = (float)st.min; max = (float)st.max; }
-      return display(nimg);
-    }
-
-    template<typename T> CImgDisplay& assign(const CImgList<T>& list,const char *title=0,
-                                             const unsigned int normalization_type=3, const unsigned int events_type=3,
-                                             const bool fullscreen_flag=false, const bool closed_flag=false) {
-      if (list.is_empty())
-        throw CImgArgumentException("CImgDisplay::CImgDisplay() : Specified input list (%u,%p) is empty.",
-                                    list.size,list.data);
-      CImg<T> tmp;
-      const CImg<T> img = list.get_append('x'),
-        &nimg = (img.depth==1)?img:(tmp=img.get_projections2d(img.width/2,img.height/2,img.depth/2));
-      assign_lowlevel(nimg.width,nimg.height,title,normalization_type,events_type,fullscreen_flag,closed_flag);
-      if (normalization==2) { const CImgStats st(nimg,false); min = (float)st.min; max = (float)st.max; }
-      return display(nimg);
-    }
-
-    CImgDisplay& assign(const CImgDisplay& win) {
-      assign_lowlevel(win.width,win.height,win.title,win.normalization,win.events,win.is_fullscreen,win.is_closed);
-      std::memcpy(data,win.data,sizeof(unsigned int)*width*height);
-      return paint();
-    }
-
-    CImgDisplay& _assign() {
-      DestroyWindow(window);
-      if (events) TerminateThread(thread,0);
-      if (data) delete[] data;
-      if (title) delete[] title;
-      if (is_fullscreen) _desinit_fullscreen();
-      width = height = normalization = events = 0;
-      is_fullscreen = is_resized = is_moved = is_event = false;
-      is_closed = true;
-      title = 0;
-      window_x = window_y = window_width = window_height = mouse_x = mouse_y = wheel = 0;
-      std::memset((void*)buttons,0,256*sizeof(unsigned int));
-      std::memset((void*)keys,0,256*sizeof(unsigned int));
-      std::memset((void*)released_keys,0,256*sizeof(unsigned int));
-      min = max = 0;
-      return *this;
-    }
-
-   template<typename T> CImgDisplay& display(const CImg<T>& img) {
-      return render(img).paint();
-    }
-
-    CImgDisplay& resize(const int nwidth, const int nheight, const bool redraw=true) {
-      if (!(nwidth && nheight))
-        throw CImgArgumentException("CImgDisplay::resize() : Specified window size (%d,%d) is not valid.",
-                                    nwidth,nheight);
-      const unsigned int
-        tmpdimx=(nwidth>0)?nwidth:(-nwidth*width/100),
-        tmpdimy=(nheight>0)?nheight:(-nheight*height/100),
-        dimx = tmpdimx?tmpdimx:1,
-        dimy = tmpdimy?tmpdimy:1;
-      const bool
-        is_disp_different = (width!=dimx || height!=dimy),
-        is_win_different = (window_width!=dimx || window_height!=dimy);
-
-      if (is_disp_different || is_win_different) {
-        RECT rect; rect.left=rect.top=0; rect.right = dimx-1; rect.bottom = dimy-1;
-        AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false);
-        const int cwidth = rect.right-rect.left+1, cheight = rect.bottom-rect.top+1;
-        SetWindowPos(window,0,0,0,cwidth,cheight,SWP_NOMOVE | SWP_NOZORDER | SWP_NOCOPYBITS);
-        window_width  = dimx;
-        window_height = dimy;
-        is_resized = false;
-        if (is_disp_different) {
-          unsigned int *ndata = new unsigned int[dimx*dimy];
-          if (redraw) _render_resize(data,width,height,ndata,dimx,dimy);
-          else std::memset(ndata,0x80,sizeof(unsigned int)*dimx*dimy);
-          delete[] data;
-          data = ndata;
-          bmi.bmiHeader.biWidth = dimx;
-          bmi.bmiHeader.biHeight = -(int)dimy;
-          width = dimx;
-          height = dimy;
-        }
-        if (is_fullscreen) move((screen_dimx()-width)/2,(screen_dimy()-height)/2);
-        if (redraw) return paint();
-      }
-      return *this;
-    }
-
-    CImgDisplay& move(const int posx,const int posy) {
-      if (!is_fullscreen) {
-        RECT rect; rect.left=rect.top=0; rect.right=window_width-1; rect.bottom=window_height-1;
-        AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false);
-        const int border1 = (rect.right-rect.left+1-width)/2, border2 = rect.bottom-rect.top+1-height-border1;
-        SetWindowPos(window,0,posx-border1,posy-border2,0,0,SWP_NOSIZE | SWP_NOZORDER);
-      } else SetWindowPos(window,0,posx,posy,0,0,SWP_NOSIZE | SWP_NOZORDER);
-      window_x = posx;
-      window_y = posy;
-      is_moved = false;
-      return show();
-    }
-
-    // Internal routine to retrieve the position of the current window.
-    CImgDisplay& _update_window_pos() {
-      if (!is_closed) {
-        RECT rect;
-        rect.left = rect.top = 0; rect.right = width-1; rect.bottom = height-1;
-        AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false);
-        const int border1 = (rect.right-rect.left+1-width)/2, border2 = rect.bottom-rect.top+1-height-border1;
-        GetWindowRect(window,&rect);
-        window_x = rect.left + border1;
-        window_y = rect.top + border2;
-      } else window_x = window_y = -1;
-      return *this;
-    }
-
-    CImgDisplay& set_mouse(const int posx, const int posy) {
-      if (!is_closed && posx>=0 && posy>=0) {
-        _update_window_pos();
-        SetCursorPos(window_x+posx,window_y+posy);
-        mouse_x = posx;
-        mouse_y = posy;
-      }
-      return *this;
-    }
-
-    CImgDisplay& hide_mouse() {
-      visible_cursor = false;
-	  ShowCursor(FALSE);
-	  SendMessage(window,WM_SETCURSOR,0,0);
-      return *this;
-    }
-
-    CImgDisplay& show_mouse() {
-      visible_cursor = true;
-	  ShowCursor(TRUE);
-	  SendMessage(window,WM_SETCURSOR,0,0);
-      return *this;
-    }
-
-    static void wait_all() {
-      WaitForSingleObject(cimg::Win32attr().wait_event,INFINITE);
-    }
-
-    CImgDisplay& show() {
-      if (is_closed) {
-        is_closed = false;
-        if (is_fullscreen) _init_fullscreen();
-        ShowWindow(window,SW_SHOW);
-        _update_window_pos();
-      }
-      return paint();
-    }
-
-    CImgDisplay& close() {
-      if (!is_closed && !is_fullscreen) {
-        if (is_fullscreen) _desinit_fullscreen();
-        ShowWindow(window,SW_HIDE);
-        is_closed = true;
-        window_x = window_y = 0;
-      }
-      return *this;
-    }
-
-    CImgDisplay& set_title(const char *format,...) {
-      char tmp[1024]={0};
-      va_list ap;
-      va_start(ap, format);
-      std::vsprintf(tmp,format,ap);
-      va_end(ap);
-      if (title) delete[] title;
-      const int s = cimg::strlen(tmp)+1;
-      title = new char[s];
-      std::memcpy(title,tmp,s*sizeof(char));
-      SetWindowTextA(window, tmp);
-      return *this;
-    }
-
-    CImgDisplay& paint() {
-      if (!is_closed) {
-        WaitForSingleObject(mutex,INFINITE);
-        SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
-        ReleaseMutex(mutex);
-      }
-      return *this;
-    }
-
-    template<typename T> CImgDisplay& render(const CImg<T>& img) {
-      if (img.is_empty())
-        throw CImgArgumentException("CImgDisplay::_render_image() : Specified input image (%u,%u,%u,%u,%p) is empty.",
-                                    img.width,img.height,img.depth,img.dim,img.data);
-      if (img.depth!=1) return render(img.get_projections2d(img.width/2,img.height/2,img.depth/2));
-
-      const T
-        *data1 = img.ptr(),
-        *data2 = (img.dim>=2)?img.ptr(0,0,0,1):data1,
-        *data3 = (img.dim>=3)?img.ptr(0,0,0,2):data1;
-
-      WaitForSingleObject(mutex,INFINITE);
-      unsigned int
-        *const ndata = (img.width==width && img.height==height)?data:new unsigned int[img.width*img.height],
-        *ptrd = ndata;
-
-      if (!normalization || (normalization==3 && cimg::type<T>::id()==cimg::type<unsigned char>::id())) {
-	min = max = 0;
-        for (unsigned int xy = img.width*img.height; xy>0; xy--)
-          *(ptrd++) = ((unsigned char)*(data1++)<<16) | ((unsigned char)*(data2++)<<8) | (unsigned char)*(data3++);
-      } else {
-        if (normalization==3) {
-          if (cimg::type<T>::is_float()) { const CImgStats st(img,false); min = (float)st.min; max = (float)st.max; }
-          else { min = (float)cimg::type<T>::min(); max = (float)cimg::type<T>::max(); }
-        } else if ((min>max) || normalization==1) { const CImgStats st(img,false); min = (float)st.min; max = (float)st.max; }
-        const float delta = max-min, mm = delta?delta:1.0f;
-        for (unsigned int xy = img.width*img.height; xy>0; xy--) {
-          const unsigned char
-            R = (unsigned char)(255*(*(data1++)-min)/mm),
-            G = (unsigned char)(255*(*(data2++)-min)/mm),
-            B = (unsigned char)(255*(*(data3++)-min)/mm);
-          *(ptrd++) = (R<<16) | (G<<8) | (B);
-        }
-      }
-      if (ndata!=data) { _render_resize(ndata,img.width,img.height,data,width,height); delete[] ndata; }
-      ReleaseMutex(mutex);
-      return *this;
-    }
-
-    CImgDisplay& assign_lowlevel(const unsigned int dimw,const unsigned int dimh,const char *ptitle=0,
-                                 const unsigned int normalization_type=3,const unsigned int events_type=3,
-                                 const bool fullscreen_flag=false,const bool closed_flag=false) {
-
-
-      // Allocate space for window title
-      const int s = cimg::strlen(ptitle)+1;
-      char *tmp_title = s?new char[s]:0;
-      if (s) std::memcpy(tmp_title,ptitle,s*sizeof(char));
-
-      // Destroy previous window if existing
-      if (width && height) _assign();
-
-      // Set display variables
-      width = dimw;
-      height = dimh;
-      normalization = normalization_type%4;
-      events = events_type%4;
-      is_fullscreen = fullscreen_flag;
-      title = tmp_title;
-      window_x = window_y = wheel = 0;
-      mouse_x = mouse_y = -1;
-      std::memset((void*)buttons,0,256*sizeof(unsigned int));
-      std::memset((void*)keys,0,256*sizeof(unsigned int));
-      std::memset((void*)released_keys,0,256*sizeof(unsigned int));
-      is_resized = is_moved = is_event = false;
-      is_closed = closed_flag;
-      fps_timer = fps_frames = timer = 0;
-      fps_fps = 0;
-      visible_cursor = true;
-
-      if (is_fullscreen) _init_fullscreen();
-
-      // Create event thread
-      void *arg = (void*)(new void*[2]);
-      ((void**)arg)[0]=(void*)this;
-      ((void**)arg)[1]=(void*)title;
-      if (events) {
-        unsigned long ThreadID = 0;
-        mutex     = CreateMutex(0,FALSE,0);
-        created   = CreateEvent(0,FALSE,FALSE,0);
-        thread    = CreateThread(0,0,_events_thread,arg,0,&ThreadID);
-        WaitForSingleObject(created,INFINITE);
-      } else _events_thread(arg);
-
-      return *this;
-    }
-
-    static LRESULT APIENTRY _handle_events(HWND window,UINT msg,WPARAM wParam,LPARAM lParam) {
-#ifdef _WIN64
-      CImgDisplay* disp = (CImgDisplay*)GetWindowLongPtr(window,GWLP_USERDATA);
-#else
-      CImgDisplay* disp = (CImgDisplay*)GetWindowLong(window,GWL_USERDATA);
-#endif
-      MSG st_msg;
-
-      switch(msg) {
-      case WM_CLOSE:
-        disp->mouse_x = disp->mouse_y = -1;
-        disp->window_x = disp->window_y = 0;
-        std::memmove((void*)(disp->buttons+1),(void*)disp->buttons,255);
-        std::memmove((void*)(disp->keys+1),(void*)disp->keys,255);
-        if (disp->key) {
-          std::memmove((void*)(disp->released_keys+1),(void*)disp->released_keys,255);
-          disp->released_key = disp->key;
-        }
-        disp->key = disp->button = 0;
-        disp->is_closed=true;
-        ReleaseMutex(disp->mutex);
-        ShowWindow(disp->window,SW_HIDE);
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-        return 0;
-      case WM_SIZE: {
-        while (PeekMessage(&st_msg,window,WM_SIZE,WM_SIZE,PM_REMOVE));
-        WaitForSingleObject(disp->mutex,INFINITE);
-        const unsigned int nw = LOWORD(lParam),nh = HIWORD(lParam);
-        if (nw && nh && (nw!=disp->width || nh!=disp->height)) {
-          disp->window_width  = nw;
-          disp->window_height = nh;
-          disp->mouse_x = disp->mouse_y = -1;
-          disp->is_resized = disp->is_event = true;
-          SetEvent(cimg::Win32attr().wait_event);
-        }
-        ReleaseMutex(disp->mutex);
-      } break;
-      case WM_MOVE: {
-        while (PeekMessage(&st_msg,window,WM_SIZE,WM_SIZE,PM_REMOVE));
-        WaitForSingleObject(disp->mutex,INFINITE);
-        const int nx = (int)(short)(LOWORD(lParam)), ny = (int)(short)(HIWORD(lParam));
-        if (nx!=disp->window_x || ny!=disp->window_y) {
-          disp->window_x = nx;
-          disp->window_y = ny;
-          disp->is_moved = disp->is_event = true;
-          SetEvent(cimg::Win32attr().wait_event);
-        }
-        ReleaseMutex(disp->mutex);
-      } break;
-      case WM_PAINT:
-        disp->paint();
-        break;
-      }
-      if (disp->events>=2) switch(msg) {
-      case WM_KEYDOWN:
-        std::memmove((void*)(disp->keys+1),(void*)disp->keys,255); disp->key = (int)wParam;
-        std::memmove((void*)(disp->released_keys+1),(void*)disp->released_keys,255); disp->released_key = 0;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-        break;
-      case WM_MOUSEMOVE: {
-        while (PeekMessage(&st_msg,window,WM_MOUSEMOVE,WM_MOUSEMOVE,PM_REMOVE));
-        disp->mouse_x = LOWORD(lParam);
-        disp->mouse_y = HIWORD(lParam);
-        if (disp->mouse_x<0 || disp->mouse_y<0 || disp->mouse_x>=disp->dimx() || disp->mouse_y>=disp->dimy())
-          disp->mouse_x=disp->mouse_y=-1;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-      } break;
-      case WM_LBUTTONDOWN:
-        std::memmove((void*)(disp->buttons+1),(void*)disp->buttons,255);
-        disp->button|=1U;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-        break;
-      case WM_RBUTTONDOWN:
-        std::memmove((void*)(disp->buttons+1),(void*)disp->buttons,255);
-        disp->button|=2U;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-        break;
-      case WM_MBUTTONDOWN:
-        std::memmove((void*)(disp->buttons+1),(void*)disp->buttons,255);
-        disp->button|=4U;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-        break;
-      case 0x020A: // WM_MOUSEWHEEL:
-        disp->wheel+=(int)((short)HIWORD(wParam))/120;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-      }
-      if (disp->events>=3) switch(msg) {
-      case WM_KEYUP:
-        std::memmove((void*)(disp->keys+1),(void*)disp->keys,255); disp->key = 0;
-        std::memmove((void*)(disp->released_keys+1),(void*)disp->released_keys,255); disp->released_key = (int)wParam;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-        break;
-      case WM_LBUTTONUP:
-        std::memmove((void*)(disp->buttons+1),(void*)disp->buttons,255);
-        disp->button&=~1U;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-        break;
-      case WM_RBUTTONUP:
-        std::memmove((void*)(disp->buttons+1),(void*)disp->buttons,255);
-        disp->button&=~2U;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-        break;
-      case WM_MBUTTONUP:
-        std::memmove((void*)(disp->buttons+1),(void*)disp->buttons,255);
-        disp->button&=~4U;
-        disp->is_event = true;
-        SetEvent(cimg::Win32attr().wait_event);
-        break;
-      case WM_SETCURSOR:
-        if (disp->visible_cursor) ShowCursor(TRUE);
-        else ShowCursor(FALSE);
-        break;
-      }
-      return DefWindowProc(window,msg,wParam,lParam);
-    }
-
-    static DWORD WINAPI _events_thread(void* arg) {
-      CImgDisplay *disp  = (CImgDisplay*)(((void**)arg)[0]);
-      const char *title = (const char*)(((void**)arg)[1]);
-      MSG msg;
-      delete[] (void**)arg;
-      disp->bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
-      disp->bmi.bmiHeader.biWidth=disp->width;
-      disp->bmi.bmiHeader.biHeight=-(int)disp->height;
-      disp->bmi.bmiHeader.biPlanes=1;
-      disp->bmi.bmiHeader.biBitCount=32;
-      disp->bmi.bmiHeader.biCompression=BI_RGB;
-      disp->bmi.bmiHeader.biSizeImage=0;
-      disp->bmi.bmiHeader.biXPelsPerMeter=1;
-      disp->bmi.bmiHeader.biYPelsPerMeter=1;
-      disp->bmi.bmiHeader.biClrUsed=0;
-      disp->bmi.bmiHeader.biClrImportant=0;
-      disp->data = new unsigned int[disp->width*disp->height];
-      if (!disp->is_fullscreen) { // Normal window
-        RECT rect;
-        rect.left=rect.top=0; rect.right=disp->width-1; rect.bottom=disp->height-1;
-        AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false);
-        const int border1 = (rect.right-rect.left+1-disp->width)/2, border2 = rect.bottom-rect.top+1-disp->height-border1;
-        disp->window = CreateWindowA("MDICLIENT",title?title:" ",
-                                     WS_OVERLAPPEDWINDOW | (disp->is_closed?0:WS_VISIBLE), CW_USEDEFAULT,CW_USEDEFAULT,
-                                     disp->width + 2*border1, disp->height + border1 + border2,
-                                     0,0,0,&(disp->ccs));
-        if (!disp->is_closed) {
-          GetWindowRect(disp->window,&rect);
-          disp->window_x = rect.left + border1;
-          disp->window_y = rect.top + border2;
-        } else disp->window_x = disp->window_y = 0;
-      } else { // Fullscreen window
-        const unsigned int sx = screen_dimx(), sy = screen_dimy();
-        disp->window = CreateWindowA("MDICLIENT",title?title:" ",
-                                     WS_POPUP | (disp->is_closed?0:WS_VISIBLE), (sx-disp->width)/2, (sy-disp->height)/2,
-                                     disp->width,disp->height,0,0,0,&(disp->ccs));
-        disp->window_x = disp->window_y = 0;
-      }
-      SetForegroundWindow(disp->window);
-      disp->hdc = GetDC(disp->window);
-      disp->window_width = disp->width;
-      disp->window_height = disp->height;
-      disp->mouse_x = disp->mouse_y = -1;
-      disp->wheel = 0;
-      std::memset((void*)disp->buttons,0,256*sizeof(unsigned int));
-      std::memset((void*)disp->keys,0,256*sizeof(unsigned int));
-      std::memset((void*)disp->released_keys,0,256*sizeof(unsigned int));
-      disp->is_resized = disp->is_moved = disp->is_event = false;
-      if (disp->events) {
-#ifdef _WIN64
-        SetWindowLongPtr(disp->window,GWLP_USERDATA,(LONG_PTR)disp);
-        SetWindowLongPtr(disp->window,GWLP_WNDPROC,(LONG_PTR)_handle_events);
-#else
-        SetWindowLong(disp->window,GWL_USERDATA,(LONG)disp);
-        SetWindowLong(disp->window,GWL_WNDPROC,(LONG)_handle_events);
-#endif
-        SetEvent(disp->created);
-        while( GetMessage(&msg,0,0,0) ) DispatchMessage( &msg );
-      }
-      return 0;
-    }
-
-    void _init_fullscreen() {
-      background_window = 0;
-      if (is_fullscreen && !is_closed) {
-        DEVMODE mode;
-        unsigned int imode=0, ibest=0, bestbpp=0, bw=~0U, bh=~0U;
-        for (mode.dmSize = sizeof(DEVMODE), mode.dmDriverExtra = 0; EnumDisplaySettings(0,imode,&mode); imode++) {
-          const unsigned int nw = mode.dmPelsWidth, nh = mode.dmPelsHeight;
-          if (nw>=width && nh>=height && mode.dmBitsPerPel>=bestbpp && nw<=bw && nh<=bh) {
-            bestbpp = mode.dmBitsPerPel;
-            ibest = imode;
-            bw = nw; bh = nh;
-          }
-        }
-        if (bestbpp) {
-          curr_mode.dmSize = sizeof(DEVMODE); curr_mode.dmDriverExtra = 0;
-          EnumDisplaySettings(0,ENUM_CURRENT_SETTINGS,&curr_mode);
-          EnumDisplaySettings(0,ibest,&mode);
-          ChangeDisplaySettings(&mode,0);
-        } else curr_mode.dmSize = 0;
-
-        const unsigned int sx = screen_dimx(), sy = screen_dimy();
-        if (sx!=width || sy!=height) {
-          CLIENTCREATESTRUCT background_ccs;
-          background_window = CreateWindowA("MDICLIENT"," ",WS_POPUP | WS_VISIBLE, 0,0,sx,sy,0,0,0,&background_ccs);
-          SetForegroundWindow(background_window);
-        }
-      } else curr_mode.dmSize = 0;
-    }
-
-    void _desinit_fullscreen() {
-      if (is_fullscreen) {
-        if (background_window) DestroyWindow(background_window);
-        background_window = 0;
-        if (curr_mode.dmSize) ChangeDisplaySettings(&curr_mode,0);
-        is_fullscreen = false;
-      }
-    }
-
-#endif
-
-  };
-
-  /*
-   #--------------------------------------
-   #
-   #
-   #
-   # Definition of the CImg<T> structure
-   #
-   #
-   #
-   #--------------------------------------
-   */
-
-  //! Class representing an image (up to 4 dimensions wide), each pixel being of type \c T.
-  /**
-     This is the main class of the %CImg Library. It declares and constructs
-     an image, allows access to its pixel values, and is able to perform various image operations.
-
-     \par Image representation
-
-     A %CImg image is defined as an instance of the container \ref CImg<T>, which contains a regular grid of pixels,
-     each pixel value being of type \c T. The image grid can have up to 4 dimensions : width, height, depth
-     and number of channels.
-     Usually, the three first dimensions are used to describe spatial coordinates <tt>(x,y,z)</tt>, while the number of channels
-     is rather used as a vector-valued dimension (it may describe the R,G,B color channels for instance).
-     If you need a fifth dimension, you can use image lists \ref CImgList<T> rather than simple images \ref CImg<T>.
-
-     Thus, the \ref CImg<T> class is able to represent volumetric images of vector-valued pixels,
-     as well as images with less dimensions (1D scalar signal, 2D color images, ...).
-     Most member functions of the class CImg<T> are designed to handle this maximum case of (3+1) dimensions.
-
-     Concerning the pixel value type \c T :
-     fully supported template types are the basic C++ types : <tt>unsigned char, char, short, unsigned int, int,
-     unsigned long, long, float, double, ... </tt>.
-     Typically, fast image display can be done using <tt>CImg<unsigned char></tt> images,
-     while complex image processing algorithms may be rather coded using <tt>CImg<float></tt> or <tt>CImg<double></tt>
-     images that have floating-point pixel values. The default value for the template T is \c float.
-     Using your own template types may be possible. However, you will certainly have to define the complete set
-     of arithmetic and logical operators for your class.
-
-     \par Image structure
-
-     The \ref CImg<\c T> structure contains \a five fields :
-     - \ref width defines the number of \a columns of the image (size along the X-axis).
-     - \ref height defines the number of \a rows of the image (size along the Y-axis).
-     - \ref depth defines the number of \a slices of the image (size along the Z-axis).
-     - \ref dim defines the number of \a channels of the image (size along the V-axis).
-     - \ref data defines a \a pointer to the \a pixel \a data (of type \c T).
-
-     You can access these fields publicly although it is recommended to use the dedicated functions
-     dimx(), dimy(), dimz(), dimv() and ptr() to do so.
-     Image dimensions are not limited to a specific range (as long as you got enough available memory).
-     A value of \e 1 usually means that the corresponding dimension is \a flat.
-     If one of the dimensions is \e 0, or if the data pointer is null, the image is considered as \e empty.
-     Empty images should not contain any pixel data and thus, will not be processed by CImg member functions
-     (a CImgInstanceException will be thrown instead).
-     Pixel data are stored in memory, in a non interlaced mode (See \ref cimg_storage).
-
-     \par Image declaration and construction
-
-     Declaring an image can be done by using one of the several available constructors.
-     Here is a list of the most used :
-
-     - Construct images from arbitrary dimensions :
-         - <tt>CImg<char> img;</tt> declares an empty image.
-         - <tt>CImg<unsigned char> img(128,128);</tt> declares a 128x128 greyscale image with
-         \c unsigned \c char pixel values.
-         - <tt>CImg<double> img(3,3);</tt> declares a 3x3 matrix with \c double coefficients.
-         - <tt>CImg<unsigned char> img(256,256,1,3);</tt> declares a 256x256x1x3 (color) image
-         (colors are stored as an image with three channels).
-         - <tt>CImg<double> img(128,128,128);</tt> declares a 128x128x128 volumetric and greyscale image
-         (with \c double pixel values).
-         - <tt>CImg<> img(128,128,128,3);</tt> declares a 128x128x128 volumetric color image
-         (with \c float pixels, which is the default value of the template parameter \c T).
-         - \b Note : images pixels are <b>not automatically initialized to 0</b>. You may use the function \ref fill() to
-         do it, or use the specific constructor taking 5 parameters like this :
-         <tt>CImg<> img(128,128,128,3,0);</tt> declares a 128x128x128 volumetric color image with all pixel values to 0.
-
-     - Construct images from filenames :
-         - <tt>CImg<unsigned char> img("image.jpg");</tt> reads a JPEG color image from the file "image.jpg".
-         - <tt>CImg<float> img("analyze.hdr");</tt> reads a volumetric image (ANALYZE7.5 format) from the file "analyze.hdr".
-         - \b Note : You need to install <a href="http://www.imagemagick.org">ImageMagick</a>
-         to be able to read common compressed image formats (JPG,PNG,...) (See \ref cimg_files_io).
-
-     - Construct images from C-style arrays :
-         - <tt>CImg<int> img(data_buffer,256,256);</tt> constructs a 256x256 greyscale image from a \c int* buffer
-         \c data_buffer (of size 256x256=65536).
-         - <tt>CImg<unsigned char> img(data_buffer,256,256,1,3,false);</tt> constructs a 256x256 color image
-         from a \c unsigned \c char* buffer \c data_buffer (where R,G,B channels follow each others).
-         - <tt>CImg<unsigned char> img(data_buffer,256,256,1,3,true);</tt> constructs a 256x256 color image
-         from a \c unsigned \c char* buffer \c data_buffer (where R,G,B channels are multiplexed).
-
-         The complete list of constructors can be found <a href="#constructors">here</a>.
-
-     \par Most useful functions
-
-     The \ref CImg<T> class contains a lot of functions that operates on images.
-     Some of the most useful are :
-
-     - operator()(), operator[]() : allows to access or write pixel values.
-     - display() : displays the image in a new window.
-
-     \sa CImgList, CImgStats, CImgDisplay, CImgException.
-
-  **/
-  template<typename T> struct CImg {
-
-    //! Variable representing the width of the instance image (i.e. dimensions along the X-axis).
-    /**
-       \remark
-       - Prefer using the function CImg<T>::dimx() to get information about the width of an image.
-       - Use function CImg<T>::resize() to set a new width for an image. Setting directly the variable \c width would probably
-       result in a library crash.
-       - Empty images have \c width defined to \c 0.
-    **/
-    unsigned int width;
-
-    //! Variable representing the height of the instance image (i.e. dimensions along the Y-axis).
-    /**
-       \remark
-       - Prefer using the function CImg<T>::dimy() to get information about the height of an image.
-       - Use function CImg<T>::resize() to set a new height for an image. Setting directly the variable \c height would probably
-       result in a library crash.
-       - 1D signals have \c height defined to \c 1.
-       - Empty images have \c height defined to \c 0.
-    **/
-    unsigned int height;
-
-    //! Variable representing the depth of the instance image (i.e. dimensions along the Z-axis).
-    /**
-       \remark
-       - Prefer using the function CImg<T>::dimz() to get information about the depth of an image.
-       - Use function CImg<T>::resize() to set a new depth for an image. Setting directly the variable \c depth would probably
-       result in a library crash.
-       - Classical 2D images have \c depth defined to \c 1.
-       - Empty images have \c depth defined to \c 0.
-    **/
-    unsigned int depth;
-
-    //! Variable representing the number of channels of the instance image (i.e. dimensions along the V-axis).
-    /**
-       \remark
-       - Prefer using the function CImg<T>::dimv() to get information about the depth of an image.
-       - Use function CImg<T>::resize() to set a new vector dimension for an image. Setting directly the variable \c dim would probably
-       result in a library crash.
-       - Scalar-valued images (one value per pixel) have \c dim defined to \c 1.
-       - Empty images have \c depth defined to \c 0.
-    **/
-    unsigned int dim;
-
-    //! Variable telling if pixel buffer of the instance image is shared with another one.
-    bool is_shared;
-
-    //! Pointer to the first pixel of the pixel buffer.
-    T *data;
-
-    //! Iterator type for CImg<T>.
-    /**
-       \remark
-       - An \p iterator is a <tt>T*</tt> pointer (address of a pixel value in the pixel buffer).
-       - Iterators are not directly used in %CImg functions, they have been introduced for compatibility with the STL.
-    **/
-    typedef T* iterator;
-
-    //! Const iterator type for CImg<T>.
-    /**
-       \remark
-       - A \p const_iterator is a <tt>const T*</tt> pointer (address of a pixel value in the pixel buffer).
-       - Iterators are not directly used in %CImg functions, they have been introduced for compatibility with the STL.
-    **/
-    typedef const T* const_iterator;
-
-    //! Get value type
-    typedef T value_type;
-
-    //@}
-    //---------------------------
-    //
-    //! \name Plugins
-    //@{
-    //---------------------------
-#ifdef cimg_plugin
-#include cimg_plugin
-#endif
-    //@}
-
-    //--------------------------------------
-    //
-    //! \name Constructors-Destructor-Copy
-    //@{
-    //--------------------------------------
-
-    //! Default constructor.
-    /**
-       The default constructor creates an empty instance image.
-       \remark
-       - An empty image does not contain any data and has all of its dimensions \ref width, \ref height, \ref depth, \ref dim
-       set to 0 as well as its pointer to the pixel buffer \ref data.
-       - An empty image is non-shared.
-       \see ~CImg(), assign(), is_empty().
-    **/
-    CImg():
-      width(0),height(0),depth(0),dim(0),is_shared(false),data(0) {}
-
-    //! Destructor.
-    /**
-       The destructor destroys the instance image.
-       \remark
-       - Destructing an empty or shared image does nothing.
-       - Otherwise, all memory used to store the pixel data of the instance image is freed.
-       - When destroying a non-shared image, be sure that every shared instances of the same image are
-       also destroyed to avoid further access to desallocated memory buffers.
-       \see CImg(), assign(), is_empty().
-    **/
-    ~CImg() {
-      if (data && !is_shared) delete[] data;
-    }
-
-    //! In-place version of the default constructor.
-    /**
-       This function replaces the instance image by an empty image.
-       \remark
-       - Memory used by the previous content of the instance image is freed if necessary.
-       - If the instance image was initially shared, it is replaced by a (non-shared) empty image.
-       - This function is useful to free memory used by an image that is not of use, but which
-       has been created in the current code scope (i.e. not destroyed yet).
-       \see ~CImg(), assign(), is_empty().
-    **/
-    CImg& assign() {
-      if (data && !is_shared) delete[] data;
-      width = height = depth = dim = 0; is_shared = false; data = 0;
-      return *this;
-    }
-
-    //! In-place version of the default constructor.
-    /**
-       This function is strictly equivalent to \ref assign() and has been
-       introduced for having a STL-compliant function name.
-       \see assign().
-    **/
-    CImg& clear() {
-      return assign();
-    }
-
-    //! Default copy constructor.
-    /**
-       The default copy constructor creates a new instance image having same dimensions
-       (\ref width, \ref height, \ref depth, \ref dim) and same pixel values as the input image \p img.
-       \param img The input image to copy.
-       \remark
-       - If the input image \p img is non-shared or have a different template type \p t != \p T,
-       the default copy constructor allocates a new pixel buffer and copy the pixel data
-       of \p img into it. In this case, the pointers \ref data to the pixel buffers of the two images are different
-       and the resulting instance image is non-shared.
-       - If the input image \p img is shared and has the same template type \p t == \p T,
-       the default copy constructor does not allocate a new pixel buffer and the resulting instance image
-       shares its pixel buffer with the input image \p img, which means that modifying pixels of \p img also modifies
-       the created instance image.
-       - Copying an image having a different template type \p t != \p T performs a crude static cast conversion of each pixel value from
-       type \p t to type \p T.
-       - Copying an image having the same template type \p t == \p T is significantly faster.
-       \see assign(const CImg< t >&), CImg(const CImg< t >&,const bool).
-    **/
-    template<typename t> CImg(const CImg<t>& img):is_shared(false) {
-      const unsigned int siz = img.size();
-      if (img.data && siz) {
-        width = img.width; height = img.height; depth = img.depth; dim = img.dim; data = new T[siz];
-        const t *ptrs = img.data+siz; cimg_for(*this,ptrd,T) *ptrd = (T)*(--ptrs);
-      } else { width = height = depth = dim = 0; data = 0; }
-    }
-
-    CImg(const CImg& img) {
-      const unsigned int siz = img.size();
-      if (img.data && siz) {
-        width = img.width; height = img.height; depth = img.depth; dim = img.dim; is_shared = img.is_shared;
-        if (is_shared) data = const_cast<T*>(img.data);
-        else { data = new T[siz]; std::memcpy(data,img.data,siz*sizeof(T)); }
-      } else { width = height = depth = dim = 0; is_shared = false; data = 0; }
-    }
-
-    //! In-place version of the default copy constructor.
-    /**
-       This function assigns a copy of the input image \p img to the current instance image.
-       \param img The input image to copy.
-       \remark
-       - If the instance image is not shared, the content of the input image \p img is copied into a new buffer
-       becoming the new pixel buffer of the instance image, while the old pixel buffer is freed if necessary.
-       - If the instance image is shared, the content of the input image \p img is copied into the current (shared) pixel buffer
-       of the instance image, modifying then the image referenced by the shared instance image. The instance image still remains shared.
-       \see CImg(const CImg< t >&), operator=(const CImg< t >&).
-    **/
-    template<typename t> CImg& assign(const CImg<t>& img) {
-      return assign(img.data,img.width,img.height,img.depth,img.dim);
-    }
-
-    //! Advanced copy constructor.
-    /**
-       The advanced copy constructor - as the default constructor CImg(const CImg< t >&) - creates a new instance image having same dimensions
-       \ref width, \ref height, \ref depth, \ref dim and same pixel values as the input image \p img.
-       But it also decides if the created instance image shares its memory with the input image \p img (if the input parameter
-       \p shared is set to \p true) or not (if the input parameter \p shared is set to \p false).
-       \param img The input image to copy.
-       \param shared Boolean flag that decides if the copy is shared on non-shared.
-       \remark
-       - It is not possible to create a shared copy if the input image \p img is empty or has a different pixel type \p t != \p T.
-       - If a non-shared copy of the input image \p img is created, a new memory buffer is allocated for pixel data.
-       - If a shared copy of the input image \p img is created, no extra memory is allocated and the pixel buffer of the instance
-       image is the same as the one used by the input image \p img.
-       \see CImg(const CImg< t >&), assign(const CImg< t >&,const bool).
-    **/
-    template<typename t> CImg(const CImg<t>& img, const bool shared):is_shared(false) {
-      if (shared) throw CImgArgumentException("CImg<%s>::CImg() : Cannot construct a shared copy from a CImg<%s> image "
-                                              "(different pixel types).",pixel_type(),CImg<t>::pixel_type());
-      const unsigned int siz = img.size();
-      if (img.data && siz) {
-        width = img.width; height = img.height; depth = img.depth; dim = img.dim; data = new T[siz];
-        const t *ptrs = img.data+siz; cimg_for(*this,ptrd,T) *ptrd = (T)*(--ptrs);
-      } else { width = height = depth = dim = 0; data = 0; }
-    }
-
-    CImg(const CImg& img, const bool shared) {
-      const unsigned int siz = img.size();
-      if (img.data && siz) {
-        width = img.width; height = img.height; depth = img.depth; dim = img.dim; is_shared = shared;
-        if (is_shared) data = const_cast<T*>(img.data);
-        else { data = new T[siz]; std::memcpy(data,img.data,siz*sizeof(T)); }
-      } else { width = height = depth = dim = 0; is_shared = false; data = 0; }
-    }
-
-    //! In-place version of the advanced constructor.
-    /**
-       This function - as the simpler function assign(const CImg< t >&) - assigns a copy of the input image \p img to the
-       current instance image. But it also decides if the copy is shared (if the input parameter \p shared is set to \true) or non-shared
-       (if the input parameter \p shared is set to false).
-       \param img The input image to copy.
-       \param shared Boolean flag that decides if the copy is shared or non-shared.
-       \remark
-       - It is not possible to assign a shared copy if the input image \p img is empty or has a different pixel type \p t != \p T.
-       - If a non-shared copy of the input image \p img is assigned, a new memory buffer is allocated for pixel data.
-       - If a shared copy of the input image \p img is assigned, no extra memory is allocated and the pixel buffer of the instance
-       image is the same as the one used by the input image \p img.
-       \see CImg(const CImg< t >&,const bool), assign(const CImg< t >&).
-    **/
-    template<typename t> CImg& assign(const CImg<t>& img, const bool shared) {
-      return assign(img.data,img.width,img.height,img.depth,img.dim,shared);
-    }
-
-    //! Constructs a new image with given size (\p dx,\p dy,\p dz,\p dv).
-    /**
-       This constructors create an instance image of size (\p dx,\p dy,\p dz,\p dv) with pixels of type \p T.
-       \param dx Desired size along the X-axis, i.e. the \ref width of the image.
-       \param dy Desired size along the Y-axis, i.e. the \ref height of the image.
-       \param dz Desired size along the Z-axis, i.e. the \ref depth of the image.
-       \param dv Desired size along the V-axis, i.e. the number of image channels \ref dim.
-       \remark
-       - If one of the input dimension \p dx,\p dy,\p dz or \p dv is set to 0, the created image is empty
-       and all has its dimensions set to 0. No memory for pixel data is then allocated.
-       - This constructor creates only non-shared images.
-       - Image pixels allocated by this constructor are \b not \b initialized.
-       Use the constructor CImg(const unsigned int,const unsigned int,const unsigned int,const unsigned int,const T&)
-       to get an image of desired size with pixels set to a particular value.
-       \see assign(const unsigned int,const unsigned int,const unsigned int,const unsigned int),
-       CImg(const unsigned int,const unsigned int,const unsigned int,const unsigned int,const T&).
-    **/
-    explicit CImg(const unsigned int dx, const unsigned int dy=1, const unsigned int dz=1, const unsigned int dv=1):
-      is_shared(false) {
-      const unsigned int siz = dx*dy*dz*dv;
-      if (siz) { width = dx; height = dy; depth = dz; dim = dv; data = new T[siz]; }
-      else { width = height = depth = dim = 0; data = 0; }
-    }
-
-    //! In-place version of the previous constructor.
-    /**
-       This function replaces the instance image by a new image of size (\p dx,\p dy,\p dz,\p dv) with pixels of type \p T.
-       \param dx Desired size along the X-axis, i.e. the \ref width of the image.
-       \param dy Desired size along the Y-axis, i.e. the \ref height of the image.
-       \param dz Desired size along the Z-axis, i.e. the \ref depth of the image.
-       \param dv Desired size along the V-axis, i.e. the number of image channels \p dim.
-       - If one of the input dimension \p dx,\p dy,\p dz or \p dv is set to 0, the instance image becomes empty
-       and all has its dimensions set to 0. No memory for pixel data is then allocated.
-       - Memory buffer used to store previous pixel values is freed if necessary.
-       - If the instance image is shared, this constructor actually does nothing more than verifying
-       that new and old image dimensions fit.
-       - Image pixels allocated by this function are \b not \b initialized.
-       Use the function assign(const unsigned int,const unsigned int,const unsigned int,const unsigned int,const T&)
-       to assign an image of desired size with pixels set to a particular value.
-       \see CImg(), assign(const unsigned int,const unsigned int,const unsigned int,const unsigned int).
-    **/
-    CImg& assign(const unsigned int dx, const unsigned int dy=1, const unsigned int dz=1, const unsigned int dv=1) {
-      const unsigned long siz = dx*dy*dz*dv, curr_siz = size();
-      if (is_shared) {
-        if (siz!=curr_siz)
-          throw CImgArgumentException("CImg<%s>::assign() : Cannot assign image (%u,%u,%u,%u) to shared instance image (%u,%u,%u,%u,%p).",
-                                      pixel_type(),dx,dy,dz,dv,width,height,depth,dim,data);
-      } else {
-        if (siz) {
-          if (siz!=curr_siz) { if (data) delete[] data; data = new T[siz]; }
-          width = dx; height = dy; depth = dz; dim = dv;
-        } else {
-          if (data) delete[] data;
-          width = height = depth = dim = 0; data = 0;
-        }
-      }
-      return *this;
-    }
-
-    //! Construct an image with given size (\p dx,\p dy,\p dz,\p dv) and with pixel having a default value \p val.
-    /**
-       This constructor creates an instance image of size (\p dx,\p dy,\p dz,\p dv) with pixels of type \p T and sets all pixel
-       values of the created instance image to \p val.
-       \param dx Desired size along the X-axis, i.e. the \ref width of the image.
-       \param dy Desired size along the Y-axis, i.e. the \ref height of the image.
-       \param dz Desired size along the Z-axis, i.e. the \ref depth of the image.
-       \param dv Desired size along the V-axis, i.e. the number of image channels \p dim.
-       \param val Default value for image pixels.
-       \remark
-       - This constructor has the same properties as CImg(const unsigned int,const unsigned int,const unsigned int,const unsigned int).
-       \see CImg(const unsigned int,const unsigned int,const unsigned int,const unsigned int).
-    **/
-    CImg(const unsigned int dx, const unsigned int dy, const unsigned int dz, const unsigned int dv, const T& val):
-      is_shared(false) {
-      const unsigned int siz = dx*dy*dz*dv;
-      if (siz) { width = dx; height = dy; depth = dz; dim = dv; data = new T[siz]; fill(val); }
-      else { width = height = depth = dim = 0; data = 0; }
-    }
-
-    //! In-place version of the previous constructor.
-    /**
-       This function replaces the instance image by a new image of size (\p dx,\p dy,\p dz,\p dv) with pixels of type \p T
-       and sets all pixel values of the instance image to \p val.
-       \param dx Desired size along the X-axis, i.e. the \ref width of the image.
-       \param dy Desired size along the Y-axis, i.e. the \ref height of the image.
-       \param dz Desired size along the Z-axis, i.e. the \ref depth of the image.
-       \param dv Desired size along the V-axis, i.e. the number of image channels \p dim.
-       \param val Default value for image pixels.
-       \remark
-       - This function has the same properties as assign(const unsigned int,const unsigned int,const unsigned int,const unsigned int).
-       \see assign(const unsigned int,const unsigned int,const unsigned int,const unsigned int).
-    **/
-    CImg& assign(const unsigned int dx, const unsigned int dy, const unsigned int dz, const unsigned int dv, const T& val) {
-      return assign(dx,dy,dz,dv).fill(val);
-    }
-
-    //! Construct an image from an image file.
-    /**
-       This constructor creates an instance image by reading it from a file.
-       \param filename Filename of the image file.
-       \remark
-       - The image format is deduced from the filename only by looking for the filename extension i.e. without
-       analyzing the file itself.
-       - Recognized image formats depend on the tools installed on your system or the external libraries you use to link your code with.
-       More informations on this topic can be found in cimg_files_io.
-       - If the filename is not found, a CImgIOException is thrown by this constructor.
-       \see assign(const char *const), load(const char *const)
-    **/
-    CImg(const char *const filename):width(0),height(0),depth(0),dim(0),is_shared(false),data(0) {
-      assign(filename);
-    }
-
-    //! In-place version of the previous constructor.
-    /**
-       This function replaces the instance image by the one that have been read from the given file.
-       \param filename Filename of the image file.
-       - The image format is deduced from the filename only by looking for the filename extension i.e. without
-       analyzing the file itself.
-       - Recognized image formats depend on the tools installed on your system or the external libraries you use to link your code with.
-       More informations on this topic can be found in cimg_files_io.
-       - If the filename is not found, a CImgIOException is thrown by this constructor.
-    **/
-    CImg& assign(const char *const filename) {
-      return load(filename);
-    }
-
-    //! Construct an image from raw memory buffer.
-    /**
-       This constructor creates an instance image of size (\p dx,\p dy,\p dz,\p dv) and fill its pixel buffer by
-       copying data values from the input raw pixel buffer \p data_buffer.
-    **/
-    template<typename t> CImg(const t *const data_buffer, const unsigned int dx, const unsigned int dy=1,
-                              const unsigned int dz=1, const unsigned int dv=1, const bool shared=false):is_shared(false) {
-      if (shared) throw CImgArgumentException("CImg<%s>::CImg() : Cannot construct a shared copy from a (%s*) buffer "
-                                              "(different pixel types).",pixel_type(),CImg<t>::pixel_type());
-      const unsigned int siz = dx*dy*dz*dv;
-      if (data_buffer && siz) {
-        width = dx; height = dy; depth = dz; dim = dv; data = new T[siz];
-        const t *ptrs = data_buffer+siz; cimg_for(*this,ptrd,T) *ptrd = (T)*(--ptrs);
-      } else { width = height = depth = dim = 0; data = 0; }
-    }
-
-#ifdef cimg_use_visualcpp6
-    CImg(const T *const data_buffer, const unsigned int dx, const unsigned int dy,
-         const unsigned int dz, const unsigned int dv, const bool shared) {
-#else
-    CImg(const T *const data_buffer, const unsigned int dx, const unsigned int dy=1,
-         const unsigned int dz=1, const unsigned int dv=1, const bool shared=false) {
-#endif
-        const unsigned int siz = dx*dy*dz*dv;
-      if (data_buffer && siz) {
-        width = dx; height = dy; depth = dz; dim = dv; is_shared = shared;
-        if (is_shared) data = const_cast<T*>(data_buffer);
-        else { data = new T[siz]; std::memcpy(data,data_buffer,siz*sizeof(T)); }
-      } else { width = height = depth = dim = 0; is_shared = false; data = 0; }
-    }
-
-        template<typename t> CImg(const t *const data_buffer, const unsigned int dx, const unsigned int dy=1, const unsigned int dz=1) {
-
-        }
-
-    //! In-place version of the previous constructor.
-#ifdef cimg_use_visualcpp6
-    template<typename t> CImg& assign(const t *const data_buffer, const unsigned int dx, const unsigned int dy,
-                                      const unsigned int dz, const unsigned int dv) {
-#else
-    template<typename t> CImg& assign(const t *const data_buffer, const unsigned int dx, const unsigned int dy=1,
-                                      const unsigned int dz=1, const unsigned int dv=1) {
-#endif
-      assign(dx,dy,dz,dv);
-      const unsigned int siz = dx*dy*dz*dv;
-      if (data_buffer && siz) { const t *ptrs = data_buffer+siz; cimg_for(*this,ptrd,T) *ptrd = (T)*(--ptrs); }
-      else { width = height = depth = dim = 0; is_shared = false; data = 0; }
-      return *this;
-    }
-
-    CImg& assign(const T *const data_buffer, const unsigned int dx, const unsigned int dy=1,
-                 const unsigned int dz=1, const unsigned int dv=1) {
-      assign(dx,dy,dz,dv);
-      const unsigned int siz = dx*dy*dz*dv;
-      if (data_buffer && siz) std::memcpy(data,data_buffer,siz*sizeof(T));
-      else { width = height = depth = dim = 0; is_shared = false; data = 0; }
-      return *this;
-    }
-
-    //! In-place version of the previous constructor, allowing to force the shared state of the instance image.
-    template<typename t> CImg& assign(const t *const data_buffer, const unsigned int dx, const unsigned int dy,
-                                      const unsigned int dz, const unsigned int dv, const bool shared) {
-      if (shared) throw CImgArgumentException("CImg<%s>::assign() : Cannot define a shared copy from a CImg<%s> image "
-                                              "(different pixel types).",pixel_type(),CImg<t>::pixel_type());
-      if (data && !is_shared) delete[] data;
-      is_shared = false;
-      const unsigned int siz = dx*dy*dz*dv;
-      if (data_buffer && siz) {
-        width = dx; height = dy; depth = dz; dim = dv; data = new T[siz];
-        const t *ptrs = data_buffer+siz; cimg_for(*this,ptrd,T) *ptrd = (T)*(--ptrs);
-      } else { width = height = depth = dim = 0; data = 0; }
-      return *this;
-    }
-
-    CImg& assign(const T *const data_buffer, const unsigned int dx, const unsigned int dy,
-                 const unsigned int dz, const unsigned int dv, const bool shared) {
-      if (data && !is_shared) delete[] data;
-      const unsigned int siz = dx*dy*dz*dv;
-      if (data_buffer && siz) {
-        width = dx; height = dy; depth = dz; dim = dv; is_shared = shared;
-        if (is_shared) data = const_cast<T*>(data_buffer);
-        else { data = new T[siz]; std::memcpy(data,data_buffer,siz*sizeof(T)); }
-      } else { width = height = depth = dim = 0; is_shared = false; data = 0; }
-      return *this;
-    }
-
-    // INNER ROUTINE : Swap fields of an image (use it carefully!)
-    // If one of the image is shared, its content is replaced by the non-shared image (which remains unchanged).
-    CImg& swap(CImg& img) {
-      if (img.is_shared==is_shared) {
-        cimg::swap(width,img.width);
-        cimg::swap(height,img.height);
-        cimg::swap(depth,img.depth);
-        cimg::swap(dim,img.dim);
-        cimg::swap(data,img.data);
-      } else {
-        if (img.is_shared) img.assign(*this);
-        else assign(img);
-      }
-      return img;
-    }
-
-    //@}
-    //-------------------------------------
-    //
-    //! \name Image Informations
-    //@{
-    //-------------------------------------
-
-    //! Return the type of the pixel values.
-    /**
-       \return a string describing the type of the image pixels (template parameter \p T).
-       - The string returned may contains spaces (<tt>"unsigned char"</tt>).
-       - If the template parameter T does not correspond to a registered type, the string <tt>"unknown"</tt> is returned.
-    **/
-    static const char* pixel_type() {
-      return cimg::type<T>::id();
-    }
-
-    //! Return the total number of pixel values in an image.
-    /**
-       - Equivalent to : dimx() * dimy() * dimz() * dimv().
-
-       \par example:
-       \code
-       CImg<> img(100,100,1,3);
-       if (img.size()==100*100*3) std::fprintf(stderr,"This statement is true");
-       \endcode
-       \sa dimx(), dimy(), dimz(), dimv()
-    **/
-    unsigned long size() const {
-      return width*height*depth*dim;
-    }
-
-    //! Return the number of columns of the instance image (size along the X-axis, i.e image width).
-    /**
-       \sa width, dimy(), dimz(), dimv(), size().
-    **/
-    int dimx() const {
-      return (int)width;
-    }
-
-    //! Return the number of rows of the instance image (size along the Y-axis, i.e image height).
-    /**
-       \sa height, dimx(), dimz(), dimv(), size().
-    **/
-    int dimy() const {
-      return (int)height;
-    }
-
-    //! Return the number of slices of the instance image (size along the Z-axis).
-    /**
-       \sa depth, dimx(), dimy(), dimv(), size().
-    **/
-    int dimz() const {
-      return (int)depth;
-    }
-
-    //! Return the number of vector channels of the instance image (size along the V-axis).
-    /**
-       \sa dim, dimx(), dimy(), dimz(), size().
-    **/
-    int dimv() const {
-      return (int)dim;
-    }
-
-    //! Return \c true if images \c (*this) and \c img have same width.
-    template<typename t> bool is_sameX(const CImg<t>& img) const {
-      return (width==img.width);
-    }
-
-    //! Return \c true if images \c (*this) and the display \c disp have same width.
-    bool is_sameX(const CImgDisplay& disp) const {
-      return (width==disp.width);
-    }
-
-    //! Return \c true if images \c (*this) and \c img have same height.
-    template<typename t> bool is_sameY(const CImg<t>& img) const {
-      return (height==img.height);
-    }
-
-    //! Return \c true if images \c (*this) and the display \c disp have same height.
-    bool is_sameY(const CImgDisplay& disp) const {
-      return (height==disp.height);
-    }
-
-    //! Return \c true if images \c (*this) and \c img have same depth.
-    template<typename t> bool is_sameZ(const CImg<t>& img) const {
-      return (depth==img.depth);
-    }
-
-    //! Return \c true if images \c (*this) and \c img have same dim.
-    template<typename t> bool is_sameV(const CImg<t>& img) const {
-      return (dim==img.dim);
-    }
-
-    //! Return \c true if images have same width and same height.
-    template<typename t> bool is_sameXY(const CImg<t>& img) const {
-      return (is_sameX(img) && is_sameY(img));
-    }
-
-    //! Return \c true if image \c (*this) and the display \c disp have same width and same height.
-    bool is_sameXY(const CImgDisplay& disp) const {
-      return (is_sameX(disp) && is_sameY(disp));
-    }
-
-    //! Return \c true if images have same width, same height and same depth.
-    template<typename t> bool is_sameXYZ(const CImg<t>& img) const {
-      return (is_sameXY(img) && is_sameZ(img));
-    }
-
-    //! Return \c true if images \c (*this) and \c img have same width, same height, same depth and same number of channels.
-    template<typename t> bool is_sameXYZV(const CImg<t>& img) const {
-      return (is_sameXYZ(img) && is_sameV(img));
-    }
-
-    //! Return \c true if pixel (x,y,z,v) is inside the image boundaries.
-    bool contains(const int x, const int y=0, const int z=0, const int v=0) const {
-      return data && x>=0 && x<(int)width && y>=0 && y<(int)height && z>=0 && z<(int)depth && v>=0 && v<(int)dim;
-    }
-
-    //! Return \c true if current image is empty.
-    bool is_empty() const {
-      return !(data && width && height && depth && dim);
-    }
-
-    //! Return the offset of the pixel coordinates (\p x,\p y,\p z,\p v) with respect to the data pointer \c data.
-    /**
-       \param x X-coordinate of the pixel.
-       \param y Y-coordinate of the pixel.
-       \param z Z-coordinate of the pixel.
-       \param v V-coordinate of the pixel.
-
-       - No checking is done on the validity of the given coordinates.
-
-       \par example:
-       \code
-       CImg<float> img(100,100,1,3,0);         // Define a 100x100 color image with float-valued black pixels.
-       long off = img.offset(10,10,0,2);       // Get the offset of the blue value of the pixel located at (10,10).
-       float val = img[off];                   // Get the blue value of the pixel.
-       \endcode
-       \sa ptr(), operator()(), operator[](), cimg_storage.
-    **/
-    long offset(const int x=0, const int y=0, const int z=0, const int v=0) const {
-      return x + y*width + z*width*height + v*width*height*depth;
-    }
-
-    //! Return a pointer to the pixel value located at (\p x,\p y,\p z,\p v).
-    /**
-       \param x X-coordinate of the pixel.
-       \param y Y-coordinate of the pixel.
-       \param z Z-coordinate of the pixel.
-       \param v V-coordinate of the pixel.
-
-       - When called without parameters, ptr() returns a pointer to the begining of the pixel buffer.
-       - If the macro \c cimg_debug == 3, boundary checking is performed and warning messages may appear if
-       given coordinates are outside the image range (but function performances decrease).
-
-       \par example:
-       \code
-       CImg<float> img(100,100,1,1,0);   // Define a 100x100 greyscale image with float-valued pixels.
-       float *ptr = ptr(10,10);          // Get a pointer to the pixel located at (10,10).
-       float val = *ptr;                 // Get the pixel value.
-       \endcode
-       \sa data, offset(), operator()(), operator[](), cimg_storage, cimg_environment.
-    **/
-    T* ptr(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0, const unsigned int v=0) {
-      const long off = offset(x,y,z,v);
-#if cimg_debug>=3
-      if (off<0 || off>=(long)size()) {
-        cimg::warn(true,"CImg<%s>::ptr() : Asked for a pointer at coordinates (%u,%u,%u,%u) (offset=%u), "
-                   "outside image range (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),x,y,z,v,off,width,height,depth,dim,size());
-        return data;
-      }
-#endif
-      return data+off;
-    }
-
-    const T* ptr(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0, const unsigned int v=0) const {
-      const long off = offset(x,y,z,v);
-#if cimg_debug>=3
-      if (off<0 || off>=(long)size()) {
-        cimg::warn(true,"CImg<%s>::ptr() : Trying to get a pointer at (%u,%u,%u,%u) (offset=%d) which is"
-                   "outside the data of the image (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),x,y,z,v,off,width,height,depth,dim,size());
-        return data;
-      }
-#endif
-      return data+off;
-    }
-
-    //! Return an iterator to the first image pixel
-    iterator begin() {
-      return data;
-    }
-
-    const_iterator begin() const {
-      return data;
-    }
-
-    //! Return an iterator to the last image pixel
-    iterator end() {
-      return data + size();
-    }
-
-    const_iterator end() const {
-      return data + size();
-    }
-
-    //! Fast access to pixel value for reading or writing.
-    /**
-       \param x X-coordinate of the pixel.
-       \param y Y-coordinate of the pixel.
-       \param z Z-coordinate of the pixel.
-       \param v V-coordinate of the pixel.
-
-       - If one image dimension is equal to 1, it can be omitted in the coordinate list (see example below).
-       - If the macro \c cimg_debug == 3, boundary checking is performed and warning messages may appear
-       (but function performances decrease).
-
-       \par example:
-       \code
-       CImg<float> img(100,100,1,3,0);                       // Define a 100x100 color image with float-valued black pixels.
-       const float valR = img(10,10,0,0);                    // Read the red component at coordinates (10,10).
-       const float valG = img(10,10,0,1);                    // Read the green component at coordinates (10,10)
-       const float valB = img(10,10,2);                      // Read the blue component at coordinates (10,10) (Z-coordinate omitted here).
-       const float avg = (valR + valG + valB)/3;             // Compute average pixel value.
-       img(10,10,0) = img(10,10,1) = img(10,10,2) = avg;     // Replace the pixel (10,10) by the average grey value.
-       \endcode
-
-       \sa operator[](), ptr(), offset(), cimg_storage, cimg_environment.
-    **/
-    T& operator()(const unsigned int x, const unsigned int y=0, const unsigned int z=0, const unsigned int v=0) {
-      const long off = offset(x,y,z,v);
-#if cimg_debug>=3
-      if (!data || off>=(long)size()) {
-        cimg::warn(true,"CImg<%s>::operator() : Pixel access requested at (%u,%u,%u,%u) (offset=%d) "
-                   "outside the image range (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),x,y,z,v,off,width,height,depth,dim,size());
-        return *data;
-      }
-#endif
-      return data[off];
-    }
-
-    const T& operator()(const unsigned int x, const unsigned int y=0, const unsigned int z=0, const unsigned int v=0) const {
-      const long off = offset(x,y,z,v);
-#if cimg_debug>=3
-      if (!data || off>=(long)size()) {
-        cimg::warn(true,"CImg<%s>::operator() : Pixel access requested at (%u,%u,%u,%u) (offset=%d) "
-                   "outside the image range (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),x,y,z,v,off,width,height,depth,dim,size());
-        return *data;
-      }
-#endif
-      return data[off];
-    }
-
-    //! Return pixel value at a given position. Equivalent to operator().
-    T& at(const unsigned int x, const unsigned int y=0, const unsigned int z=0, const unsigned int v=0) {
-      const long off = offset(x,y,z,v);
-      if (!data || off>=(long)size())
-        throw CImgArgumentException("CImg<%s>::at() : Pixel access requested at (%u,%u,%u,%u) (offset=%d) "
-                                    "outside the image range (%u,%u,%u,%u) (size=%u)",
-                                    pixel_type(),x,y,z,v,off,width,height,depth,dim,size());
-      return data[off];
-    }
-
-    const T& at(const unsigned int x, const unsigned int y=0, const unsigned int z=0, const unsigned int v=0) const {
-      const long off = offset(x,y,z,v);
-      if (!data || off>=(long)size())
-        throw CImgArgumentException("CImg<%s>::at() : Pixel access requested at (%u,%u,%u,%u) (offset=%d) "
-                                    "outside the image range (%u,%u,%u,%u) (size=%u)",
-                                    pixel_type(),x,y,z,v,off,width,height,depth,dim,size());
-      return data[off];
-    }
-
-    //! Fast access to pixel value for reading or writing, using an offset to the image pixel.
-    /**
-       \param off Offset of the pixel according to the begining of the pixel buffer, given by ptr().
-
-       - If the macro \c cimg_debug==3, boundary checking is performed and warning messages may appear
-       (but function performances decrease).
-       - As pixel values are aligned in memory, this operator can sometime useful to access values easier than
-       with operator()() (see example below).
-
-       \par example:
-       \code
-       CImg<float> vec(1,10);        // Define a vector of float values (10 lines, 1 row).
-       const float val1 = vec(0,4);  // Get the fifth element using operator()().
-       const float val2 = vec[4];    // Get the fifth element using operator[]. Here, val2==val1.
-       \endcode
-
-       \sa operator()(), ptr(), offset(), cimg_storage, cimg_environment.
-    **/
-    T& operator[](const unsigned long off) {
-      return operator()(off);
-    }
-
-    const T& operator[](const unsigned long off) const {
-      return operator()(off);
-    }
-
-    //! Return a reference to the last image value
-    T& back() {
-      return operator()(size()-1);
-    }
-
-    const T& back() const {
-      return operator()(size()-1);
-    }
-
-    //! Return a reference to the first image value
-    T& front() {
-      return *data;
-    }
-
-    const T& front() const {
-      return *data;
-    }
-
-    //! Read a pixel value with Dirichlet or Neumann boundary conditions.
-    /**
-       \param x X-coordinate of the pixel.
-       \param y Y-coordinate of the pixel.
-       \param z Z-coordinate of the pixel.
-       \param v V-coordinate of the pixel.
-       \param out_val Desired value if pixel coordinates are outside the image range (optional parameter).
-
-       - This function allows to read pixel values with boundary checking on all coordinates.
-       - If given coordinates are outside the image range and the parameter out_val is specified, the value \c out_val is returned.
-       - If given coordinates are outside the image range and the parameter out_val is not specified, the closest pixel value
-       is returned.
-
-       \par example:
-       \code
-       CImg<float> img(100,100,1,1,128);                     // Define a 100x100 images with all pixel values equal to 128.
-       const float val1 = img.pix4d(10,10,0,0,0);  // Equivalent to val1=img(10,10) (but slower).
-       const float val2 = img.pix4d(-4,5,0,0,0);   // Return 0, since coordinates are outside the image range.
-       const float val3 = img.pix4d(10,10,5,0,64); // Return 64, since coordinates are outside the image range.
-       \endcode
-
-       \sa operator()(), linear_pix4d(), cubic_pix2d().
-    **/
-    T pix4d(const int x, const int y, const int z, const int v, const T& out_val) const {
-      return (x<0 || y<0 || z<0 || v<0 || x>=dimx() || y>=dimy() || z>=dimz() || v>=dimv())?out_val:(*this)(x,y,z,v);
-    }
-
-    T pix4d(const int x, const int y, const int z, const int v) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x), y<0?0:(y>=dimy()?dimy()-1:y),
-                     z<0?0:(z>=dimz()?dimz()-1:z), v<0?0:(v>=dimv()?dimv()-1:v));
-    }
-
-    //! Read a pixel value with Dirichlet or Neumann boundary conditions for the three first coordinates (\c x,\c y,\c z).
-    T pix3d(const int x, const int y, const int z, const int v, const T& out_val) const {
-      return (x<0 || y<0 || z<0 || x>=dimx() || y>=dimy() || z>=dimz())?out_val:(*this)(x,y,z,v);
-    }
-
-    const T& pix3d(const int x, const int y, const int z, const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x), y<0?0:(y>=dimy()?dimy()-1:y),
-                     z<0?0:(z>=dimz()?dimz()-1:z),v);
-    }
-
-    //! Read a pixel value with Dirichlet or Neumann boundary conditions for the two first coordinates (\c x,\c y).
-    T pix2d(const int x, const int y, const int z, const int v, const T& out_val) const {
-      return (x<0 || y<0 || x>=dimx() || y>=dimy())?out_val:(*this)(x,y,z,v);
-    }
-
-    const T& pix2d(const int x,const int y,const int z=0,const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x), y<0?0:(y>=dimy()?dimy()-1:y),z,v);
-    }
-
-    //! Read a pixel value with Dirichlet or Neumann boundary conditions for the first coordinate \c x.
-    T pix1d(const int x, const int y, const int z, const int v, const T& out_val) const {
-      return (x<0 || x>=dimx())?out_val:(*this)(x,y,z,v);
-    }
-
-    const T& pix1d(const int x, const int y=0, const int z=0, const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),y,z,v);
-    }
-
-    //! Read a pixel value using linear interpolation.
-    /**
-       \param ffx X-coordinate of the pixel (float-valued).
-       \param ffy Y-coordinate of the pixel (float-valued).
-       \param ffz Z-coordinate of the pixel (float-valued).
-       \param ffv V-coordinate of the pixel (float-valued).
-       \param out_val Out-of-border pixel value
-
-       - This function allows to read pixel values with boundary checking on all coordinates.
-       - If given coordinates are outside the image range, the value of the nearest pixel inside the image is returned
-       (Neumann boundary conditions).
-       - If given coordinates are float-valued, a linear interpolation is performed in order to compute the returned value.
-
-       \par example:
-       \code
-       CImg<float> img(2,2);     // Define a greyscale 2x2 image.
-       img(0,0) = 0;             // Fill image with specified pixel values.
-       img(1,0) = 1;
-       img(0,1) = 2;
-       img(1,1) = 3;
-       const double val = img.linear_pix4d(0.5,0.5);  // Return val=1.5, which is the average intensity of the four pixels values.
-       \endcode
-
-       \sa operator()(), linear_pix3d(), linear_pix2d(), linear_pix1d(), cubic_pix2d().
-    **/
-    typename cimg::largest<T,float>::type linear_pix4d(const float fx,const float fy,const float fz,const float fv,
-                                                       const T& out_val) const {
-      const int x = (int)fx-(fx>=0?0:1), y = (int)fy-(fy>=0?0:1), z = (int)fz-(fz>=0?0:1), v = (int)fv-(fv>=0?0:1),
-        nx = x+1, ny = y+1, nz = z+1, nv = v+1;
-      const float dx = fx-x, dy = fy-y, dz = fz-z, dv = fv-v;
-      const T
-        Icccc = pix4d(x,y,z,v,out_val),    Inccc = pix4d(nx,y,z,v,out_val),
-        Icncc = pix4d(x,ny,z,v,out_val),   Inncc = pix4d(nx,ny,z,v,out_val),
-        Iccnc = pix4d(x,y,nz,v,out_val),   Incnc = pix4d(nx,y,nz,v,out_val),
-        Icnnc = pix4d(x,ny,nz,v,out_val),  Innnc = pix4d(nx,ny,nz,v,out_val),
-        Icccn = pix4d(x,y,z,nv,out_val),   Inccn = pix4d(nx,y,z,nv,out_val),
-        Icncn = pix4d(x,ny,z,nv,out_val),  Inncn = pix4d(nx,ny,z,nv,out_val),
-        Iccnn = pix4d(x,y,nz,nv,out_val),  Incnn = pix4d(nx,y,nz,nv,out_val),
-        Icnnn = pix4d(x,ny,nz,nv,out_val), Innnn = pix4d(nx,ny,nz,nv,out_val);
-      return Icccc +
-        dx*(Inccc-Icccc +
-            dy*(Icccc+Inncc-Icncc-Inccc +
-                dz*(Iccnc+Innnc+Icncc+Inccc-Icnnc-Incnc-Icccc-Inncc +
-                    dv*(Iccnn+Innnn+Icncn+Inccn+Icnnc+Incnc+Icccc+Inncc-Icnnn-Incnn-Icccn-Inncn-Iccnc-Innnc-Icncc-Inccc)) +
-                dv*(Icccn+Inncn+Icncc+Inccc-Icncn-Inccn-Icccc-Inncc)) +
-            dz*(Icccc+Incnc-Iccnc-Inccc +
-                dv*(Icccn+Incnn+Iccnc+Inccc-Iccnn-Inccn-Icccc-Incnc)) +
-            dv*(Icccc+Inccn-Inccc-Icccn)) +
-        dy*(Icncc-Icccc +
-            dz*(Icccc+Icnnc-Iccnc-Icncc +
-                dv*(Icccn+Icnnn+Iccnc+Icncc-Iccnn-Icncn-Icccc-Icnnc)) +
-            dv*(Icccc+Icncn-Icncc-Icccn)) +
-        dz*(Iccnc-Icccc +
-            dv*(Icccc+Iccnn-Iccnc-Icccn)) +
-        dv*(Icccn-Icccc);
-    }
-
-    typename cimg::largest<T,float>::type linear_pix4d(const float ffx,const float ffy=0,const float ffz=0,const float ffv=0) const {
-      const float
-        fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy),
-        fz = ffz<0?0:(ffz>depth-1?depth-1:ffz), fv = ffv<0?0:(ffv>dim-1?dim-1:ffv);
-      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy,  z = (unsigned int)fz, v = (unsigned int)fv;
-      const float dx = fx-x, dy = fy-y, dz = fz-z, dv = fv-v;
-      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y,  nz = dz>0?z+1:z, nv = dv>0?v+1:v;
-      const T
-        &Icccc = (*this)(x,y,z,v),   &Inccc = (*this)(nx,y,z,v),   &Icncc = (*this)(x,ny,z,v),   &Inncc = (*this)(nx,ny,z,v),
-        &Iccnc = (*this)(x,y,nz,v),  &Incnc = (*this)(nx,y,nz,v),  &Icnnc = (*this)(x,ny,nz,v),  &Innnc = (*this)(nx,ny,nz,v),
-        &Icccn = (*this)(x,y,z,nv),  &Inccn = (*this)(nx,y,z,nv),  &Icncn = (*this)(x,ny,z,nv),  &Inncn = (*this)(nx,ny,z,nv),
-        &Iccnn = (*this)(x,y,nz,nv), &Incnn = (*this)(nx,y,nz,nv), &Icnnn = (*this)(x,ny,nz,nv), &Innnn = (*this)(nx,ny,nz,nv);
-      return Icccc +
-        dx*(Inccc-Icccc +
-            dy*(Icccc+Inncc-Icncc-Inccc +
-                dz*(Iccnc+Innnc+Icncc+Inccc-Icnnc-Incnc-Icccc-Inncc +
-                    dv*(Iccnn+Innnn+Icncn+Inccn+Icnnc+Incnc+Icccc+Inncc-Icnnn-Incnn-Icccn-Inncn-Iccnc-Innnc-Icncc-Inccc)) +
-                dv*(Icccn+Inncn+Icncc+Inccc-Icncn-Inccn-Icccc-Inncc)) +
-            dz*(Icccc+Incnc-Iccnc-Inccc +
-                dv*(Icccn+Incnn+Iccnc+Inccc-Iccnn-Inccn-Icccc-Incnc)) +
-            dv*(Icccc+Inccn-Inccc-Icccn)) +
-        dy*(Icncc-Icccc +
-            dz*(Icccc+Icnnc-Iccnc-Icncc +
-                dv*(Icccn+Icnnn+Iccnc+Icncc-Iccnn-Icncn-Icccc-Icnnc)) +
-            dv*(Icccc+Icncn-Icncc-Icccn)) +
-        dz*(Iccnc-Icccc +
-            dv*(Icccc+Iccnn-Iccnc-Icccn)) +
-        dv*(Icccn-Icccc);
-    }
-
-    //! Read a pixel value using linear interpolation for the three first coordinates (\c cx,\c cy,\c cz).
-    /**
-       - Same as linear_pix4d(), except that linear interpolation and boundary checking is performed only on the three first coordinates.
-
-       \sa operator()(), linear_pix4d(), linear_pix2d(), linear_pix1d(), linear_pix3d(), cubic_pix2d().
-    **/
-    typename cimg::largest<T,float>::type linear_pix3d(const float fx,const float fy,const float fz,const int v,
-                                                       const T& out_val) const {
-      const int x = (int)fx-(fx>=0?0:1), y = (int)fy-(fy>=0?0:1), z = (int)fz-(fz>=0?0:1), nx = x+1, ny = y+1, nz = z+1;
-      const float dx = fx-x, dy = fy-y, dz = fz-z;
-      const T
-        Iccc = pix3d(x,y,z,v,out_val),  Incc = pix3d(nx,y,z,v,out_val),  Icnc = pix3d(x,ny,z,v,out_val),  Innc = pix3d(nx,ny,z,v,out_val),
-        Iccn = pix3d(x,y,nz,v,out_val), Incn = pix3d(nx,y,nz,v,out_val), Icnn = pix3d(x,ny,nz,v,out_val), Innn = pix3d(nx,ny,nz,v,out_val);
-      return Iccc +
-        dx*(Incc-Iccc +
-            dy*(Iccc+Innc-Icnc-Incc +
-                dz*(Iccn+Innn+Icnc+Incc-Icnn-Incn-Iccc-Innc)) +
-            dz*(Iccc+Incn-Iccn-Incc)) +
-        dy*(Icnc-Iccc +
-            dz*(Iccc+Icnn-Iccn-Icnc)) +
-        dz*(Iccn-Iccc);
-    }
-
-    typename cimg::largest<T,float>::type linear_pix3d(const float ffx,const float ffy=0,const float ffz=0,const int v=0) const {
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy), fz = ffz<0?0:(ffz>depth-1?depth-1:ffz);
-      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy, z = (unsigned int)fz;
-      const float dx = fx-x, dy = fy-y, dz = fz-z;
-      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y, nz = dz>0?z+1:z;
-      const T
-        &Iccc = (*this)(x,y,z,v),  &Incc = (*this)(nx,y,z,v),  &Icnc = (*this)(x,ny,z,v),  &Innc = (*this)(nx,ny,z,v),
-        &Iccn = (*this)(x,y,nz,v), &Incn = (*this)(nx,y,nz,v), &Icnn = (*this)(x,ny,nz,v), &Innn = (*this)(nx,ny,nz,v);
-      return Iccc +
-        dx*(Incc-Iccc +
-            dy*(Iccc+Innc-Icnc-Incc +
-                dz*(Iccn+Innn+Icnc+Incc-Icnn-Incn-Iccc-Innc)) +
-            dz*(Iccc+Incn-Iccn-Incc)) +
-        dy*(Icnc-Iccc +
-            dz*(Iccc+Icnn-Iccn-Icnc)) +
-        dz*(Iccn-Iccc);
-    }
-
-    //! Read a pixel value using linear interpolation for the two first coordinates (\c cx,\c cy).
-    /**
-       - Same as linear_pix4d(), except that linear interpolation and boundary checking is performed only on the two first coordinates.
-
-       \sa operator()(), linear_pix4d(), linear_pix3d(), linear_pix1d(), linear_pix2d(), cubic_pix2d().
-    **/
-    typename cimg::largest<T,float>::type linear_pix2d(const float fx, const float fy, const int z, const int v,
-                                                       const T& out_val) const {
-      const int x = (int)fx-(fx>0?0:1), y = (int)fy-(fy>0?0:1), nx = x+1, ny = y+1;
-      const float dx = fx-x, dy = fy-y;
-      const T
-        Icc = pix2d(x,y,z,v,out_val),  Inc = pix2d(nx,y,z,v,out_val),
-        Icn = pix2d(x,ny,z,v,out_val), Inn = pix2d(nx,ny,z,v,out_val);
-      return Icc + dx*(Inc-Icc + dy*(Icc+Inn-Icn-Inc)) + dy*(Icn-Icc);
-    }
-
-    typename cimg::largest<T,float>::type linear_pix2d(const float ffx, const float ffy=0, const int z=0, const int v=0) const {
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy);
-      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy;
-      const float dx = fx-x, dy = fy-y;
-      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y;
-      const T &Icc = (*this)(x,y,z,v), &Inc = (*this)(nx,y,z,v), &Icn = (*this)(x,ny,z,v), &Inn = (*this)(nx,ny,z,v);
-      return Icc + dx*(Inc-Icc + dy*(Icc+Inn-Icn-Inc)) + dy*(Icn-Icc);
-    }
-
-    //! Read a pixel value using linear interpolation for the first coordinate \c cx.
-    /**
-       - Same as linear_pix4d(), except that linear interpolation and boundary checking is performed only on the first coordinate.
-
-       \sa operator()(), linear_pix4d(), linear_pix3d(), linear_pix2d(), linear_pix1d(), cubic_pix1d().
-    **/
-    typename cimg::largest<T,float>::type linear_pix1d(const float fx,const int y,const int z,const int v,
-                                                       const T& out_val) const {
-      const int x = (int)fx-(fx>0?0:1), nx = x+1;
-      const float dx = fx-x;
-      const T Ic = pix1d(x,y,z,v,out_val), In = pix2d(nx,y,z,v,out_val);
-      return Ic + dx*(In-Ic);
-    }
-
-    typename cimg::largest<T,float>::type linear_pix1d(const float ffx,const int y=0,const int z=0,const int v=0) const {
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx);
-      const unsigned int x = (unsigned int)fx;
-      const float dx = fx-x;
-      const unsigned int nx = dx>0?x+1:x;
-      const T &Ic = (*this)(x,y,z,v), &In = (*this)(nx,y,z,v);
-      return Ic + dx*(In-Ic);
-    }
-
-    // This function is used as a subroutine for cubic interpolation
-    static float _cubic_R(const float x) {
-      const float xp2 = x+2, xp1 = x+1, xm1 = x-1,
-        nxp2 = xp2>0?xp2:0, nxp1 = xp1>0?xp1:0, nx = x>0?x:0, nxm1 = xm1>0?xm1:0;
-      return (nxp2*nxp2*nxp2 - 4*nxp1*nxp1*nxp1 + 6*nx*nx*nx - 4*nxm1*nxm1*nxm1)/6.0f;
-    }
-
-    //! Read a pixel value using cubic interpolation for the first coordinate \c cx.
-    /**
-       - Same as cubic_pix2d(), except that cubic interpolation and boundary checking is performed only on the first coordinate.
-
-       \sa operator()(), cubic_pix2d(), linear_pix1d().
-    **/
-    typename cimg::largest<T,float>::type cubic_pix1d(const float fx, const int y, const int z, const int v,
-                                                      const T& out_val) const {
-      const int x = (int)fx-(fx>=0?0:1), px = x-1, nx = x+1, ax = nx+1;
-      const float dx = fx-x;
-      const T a = pix2d(px,y,z,v,out_val), b = pix2d(x,y,z,v,out_val), c = pix2d(nx,y,z,v,out_val), d = pix2d(ax,y,z,v,out_val);
-      const float Rxp = _cubic_R(-1-dx), Rxc = _cubic_R(dx), Rxn = _cubic_R(1-dx), Rxa = _cubic_R(2-dx);
-      return Rxp*a + Rxc*b + Rxn*c + Rxa*d;
-    }
-
-    typename cimg::largest<T,float>::type cubic_pix1d(const float pfx, const int y=0, const int z=0, const int v=0) const {
-      const float fx = pfx<0?0:(pfx>width-1?width-1:pfx);
-      const unsigned int x = (unsigned int)fx, px = (int)x-1>=0?x-1:0, nx = x+1<width?x+1:width-1, ax = nx+1<width?nx+1:width-1;
-      const float dx = fx-x;
-      const T& a = (*this)(px,y,z,v), b = (*this)(x,y,z,v), c = (*this)(nx,y,z,v), d = (*this)(ax,y,z,v);
-      const float Rxp = _cubic_R(-1-dx), Rxc = _cubic_R(dx), Rxn = _cubic_R(1-dx), Rxa = _cubic_R(2-dx);
-      return Rxp*a + Rxc*b + Rxn*c + Rxa*d;
-    }
-
-    //! Read a pixel value using bicubic interpolation.
-    /**
-       \param pfx X-coordinate of the pixel (float-valued).
-       \param pfy Y-coordinate of the pixel (float-valued).
-       \param z   Z-coordinate of the pixel.
-       \param v   V-coordinate of the pixel.
-
-       - This function allows to read pixel values with boundary checking on the two first coordinates.
-       - If given coordinates are outside the image range, the value of the nearest pixel inside the image is returned
-       (Neumann boundary conditions).
-       - If given coordinates are float-valued, a cubic interpolation is performed in order to compute the returned value.
-
-       \sa operator()(), cubic_pix1d(), linear_pix2d().
-    **/
-    typename cimg::largest<T,float>::type cubic_pix2d(const float fx, const float fy, const int z, const int v,
-                                                      const T& out_val) const {
-      const int
-        x = (int)fx-(fx>=0?0:1), y = (int)fy-(fy>=0?0:1),
-        px = x-1, nx = x+1, ax = nx+1, py = y-1, ny = y+1, ay = ny+1;
-      const float dx = fx-x, dy = fy-y;
-      const T
-        a = pix2d(px,py,z,v,out_val), b = pix2d(x,py,z,v,out_val), c = pix2d(nx,py,z,v,out_val), d = pix2d(ax,py,z,v,out_val),
-        e = pix2d(px, y,z,v,out_val), f = pix2d(x, y,z,v,out_val), g = pix2d(nx, y,z,v,out_val), h = pix2d(ax, y,z,v,out_val),
-        i = pix2d(px,ny,z,v,out_val), j = pix2d(x,ny,z,v,out_val), k = pix2d(nx,ny,z,v,out_val), l = pix2d(ax,ny,z,v,out_val),
-        m = pix2d(px,ay,z,v,out_val), n = pix2d(x,ay,z,v,out_val), o = pix2d(nx,ay,z,v,out_val), p = pix2d(ax,ay,z,v,out_val);
-      const float
-        Rxp = _cubic_R(-1-dx), Rxc = _cubic_R(dx), Rxn = _cubic_R(1-dx), Rxa = _cubic_R(2-dx),
-        Ryp = _cubic_R(dy+1),  Ryc = _cubic_R(dy), Ryn = _cubic_R(dy-1), Rya = _cubic_R(dy-2);
-      return
-        Rxp*Ryp*a + Rxc*Ryp*b + Rxn*Ryp*c + Rxa*Ryp*d +
-        Rxp*Ryc*e + Rxc*Ryc*f + Rxn*Ryc*g + Rxa*Ryc*h +
-        Rxp*Ryn*i + Rxc*Ryn*j + Rxn*Ryn*k + Rxa*Ryn*l +
-        Rxp*Rya*m + Rxc*Rya*n + Rxn*Rya*o + Rxa*Rya*p;
-    }
-
-    typename cimg::largest<T,float>::type cubic_pix2d(const float pfx, const float pfy=0, const int z=0, const int v=0) const {
-      const float fx = pfx<0?0:(pfx>width-1?width-1:pfx), fy = pfy<0?0:(pfy>height-1?height-1:pfy);
-      const unsigned int
-        x = (unsigned int)fx,  px = (int)x-1>=0?x-1:0, nx = x+1<width?x+1:width-1, ax = nx+1<width?nx+1:width-1,
-        y = (unsigned int)fy,  py = (int)y-1>=0?y-1:0, ny = y+1<height?y+1:height-1, ay = ny+1<height?ny+1:height-1;
-      const float dx = fx-x, dy = fy-y;
-      const T&
-        a = (*this)(px,py,z,v), b = (*this)(x,py,z,v), c = (*this)(nx,py,z,v), d = (*this)(ax,py,z,v),
-        e = (*this)(px, y,z,v), f = (*this)(x, y,z,v), g = (*this)(nx, y,z,v), h = (*this)(ax, y,z,v),
-        i = (*this)(px,ny,z,v), j = (*this)(x,ny,z,v), k = (*this)(nx,ny,z,v), l = (*this)(ax,ny,z,v),
-        m = (*this)(px,ay,z,v), n = (*this)(x,ay,z,v), o = (*this)(nx,ay,z,v), p = (*this)(ax,ay,z,v);
-      const float
-        Rxp = _cubic_R(-1-dx), Rxc = _cubic_R(dx), Rxn = _cubic_R(1-dx), Rxa = _cubic_R(2-dx),
-        Ryp = _cubic_R(dy+1),  Ryc = _cubic_R(dy), Ryn = _cubic_R(dy-1), Rya = _cubic_R(dy-2);
-      return
-        Rxp*Ryp*a + Rxc*Ryp*b + Rxn*Ryp*c + Rxa*Ryp*d +
-        Rxp*Ryc*e + Rxc*Ryc*f + Rxn*Ryc*g + Rxa*Ryc*h +
-        Rxp*Ryn*i + Rxc*Ryn*j + Rxn*Ryn*k + Rxa*Ryn*l +
-        Rxp*Rya*m + Rxc*Rya*n + Rxn*Rya*o + Rxa*Rya*p;
-    }
-
-    //! Display informations about the image on the standard error output.
-    /**
-       \param title Name for the considered image (optional).
-       \param print_flag Level of informations to be printed.
-
-       - The possible values for \c print_flag are :
-           - 0 : print only informations about image size and pixel buffer.
-           - 1 : print also statistics on the image pixels.
-           - 2 : print also the content of the pixel buffer, in a matlab-style.
-
-       \par example:
-       \code
-       CImg<float> img("foo.jpg");      // Load image from a JPEG file.
-       img.print("Image : foo.jpg",1);  // Print image informations and statistics.
-       \endcode
-
-       \sa CImgStats
-    **/
-    const CImg& print(const char *title=0, const unsigned int print_flag=1) const {
-      std::fprintf(stderr,"%-8s(this=%p): { size=(%u,%u,%u,%u), data=(%s*)%p (%s)",
-                   title?title:"CImg",(void*)this,
-                   width,height,depth,dim,pixel_type(),(void*)data,
-                   is_shared?"shared":"not shared");
-      if (is_empty()) { std::fprintf(stderr,", [Undefined pixel data] }\n"); return *this; }
-      if (print_flag>=1) {
-        const CImgStats st(*this);
-        std::fprintf(stderr,", min=%g, mean=%g [var=%g], max=%g, pmin=(%d,%d,%d,%d), pmax=(%d,%d,%d,%d)",
-                     st.min,st.mean,st.variance,st.max,st.xmin,st.ymin,st.zmin,st.vmin,st.xmax,st.ymax,st.zmax,st.vmax);
-      }
-      if (print_flag>=2 || size()<=16) {
-        std::fprintf(stderr," }\n%s = [ ",title?title:"data");
-        cimg_forXYZV(*this,x,y,z,k)
-          std::fprintf(stderr,"%g%s",(double)(*this)(x,y,z,k),
-                       ((x+1)*(y+1)*(z+1)*(k+1)==(int)size()?" ]\n":(((x+1)%width==0)?" ; ":" ")));
-      } else std::fprintf(stderr," }\n");
-      return *this;
-    }
-
-    //! Display informations about the image on the standart output.
-    const CImg& print(const unsigned int print_flag) const {
-      return print(0,print_flag);
-    }
-
-    //@}
-    //------------------------------------------
-    //
-    //! \name Arithmetic and Boolean Operators
-    //@{
-    //------------------------------------------
-
-    //! Assignement operator.
-    /**
-       This operator assigns a copy of the input image \p img to the current instance image.
-       \param img The input image to copy.
-       \remark
-       - This operator is strictly equivalent to the function assign(const CImg< t >&) and has exactly the same properties.
-       \see assign(const CImg< t >&).
-    **/
-    template<typename t> CImg<T>& operator=(const CImg<t>& img) {
-      return assign(img);
-    }
-
-    CImg& operator=(const CImg& img) {
-      return assign(img);
-    }
-
-    //! Assign values of a C-array to the instance image.
-    /**
-       \param buf Pointer to a C-style array having a size of (at least) <tt>this->size()</tt>.
-
-       - Replace pixel values by the content of the array \c buf.
-       - Warning : the value types in the array and in the image must be the same.
-
-       \par example:
-       \code
-       float tab[4*4] = { 1,2,3,4, 5,6,7,8, 9,10,11,12, 13,14,15,16 };  // Define a 4x4 matrix in C-style.
-       CImg<float> matrice(4,4);                                        // Define a 4x4 greyscale image.
-       matrice = tab;                                                   // Fill the image by the values in tab.
-       \endcode
-    **/
-    CImg& operator=(const T *buf) {
-      if (buf) std::memcpy(data,buf,size()*sizeof(T));
-      else assign();
-      return *this;
-    }
-
-    //! Assign a value to each image pixel of the instance image.
-    CImg& operator=(const T& val) {
-      return fill(val);
-    }
-
-    //! Operator+
-    /**
-       \remark
-       - This operator can be used to get a non-shared copy of an image.
-    **/
-    CImg operator+() const {
-      return CImg<T>(*this,false);
-    }
-
-    //! Operator+=;
-#ifdef cimg_use_visualcpp6
-    CImg& operator+=(const T& val) {
-#else
-        template<typename t> CImg& operator+=(const t& val) {
-#endif
-      cimg_for(*this,ptr,T) (*ptr)=(T)((*ptr)+val);
-      return *this;
-    }
-
-    //! Operator+=
-    template<typename t> CImg& operator+=(const CImg<t>& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      t *ptrs = img.data+smin;
-      for (T *ptrd = data+smin; ptrd>data; --ptrd, (*ptrd)=(T)((*ptrd)+(*(--ptrs))));
-      return *this;
-    }
-
-    //! Operator++;
-    CImg& operator++() {
-      cimg_for(*this,ptr,T) (*ptr)++;
-      return *this;
-    }
-
-    //! Operator-.
-    CImg operator-() const {
-      return CImg<T>(width,height,depth,dim,0)-=*this;
-    }
-
-    //! Operator-=.
-#ifdef cimg_use_visualcpp6
-        CImg& operator-=(const T& val) {
-#else
-        template<typename t> CImg& operator-=(const t& val) {
-#endif
-                cimg_for(*this,ptr,T) (*ptr)=(T)((*ptr)-val);
-      return *this;
-    }
-
-    //! Operator-=.
-    template<typename t> CImg& operator-=(const CImg<t>& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      t *ptrs = img.data+smin;
-      for (T *ptrd = data+smin; ptrd>data; --ptrd, (*ptrd)=(T)((*ptrd)-(*(--ptrs))));
-      return *this;
-    }
-
-    //! Operator--.
-    CImg& operator--() {
-      cimg_for(*this,ptr,T) (*ptr)--;
-      return *this;
-    }
-
-    //! Operator*=.
-#ifdef cimg_use_visualcpp6
-    CImg& operator*=(const double val) {
-#else
-        template<typename t> CImg& operator*=(const t& val) {
-#endif
-                cimg_for(*this,ptr,T) (*ptr)=(T)((*ptr)*val);
-      return *this;
-    }
-
-    //! Operator*=.
-    template<typename t> CImg& operator*=(const CImg<t>& img) {
-      return ((*this)*img).swap(*this);
-    }
-
-    //! Operator/=.
-#ifdef cimg_use_visualcpp6
-    CImg& operator/=(const double val) {
-#else
-    template<typename t> CImg& operator/=(const t& val) {
-#endif
-                cimg_for(*this,ptr,T) (*ptr)=(T)((*ptr)/val);
-      return *this;
-    }
-
-    //! Operator/=.
-    template<typename t> CImg& operator/=(const CImg<t>& img) {
-      return assign(*this*img.get_inverse());
-    }
-
-    //! Modulo.
-    CImg operator%(const CImg& img) const {
-      return (+*this)%=img;
-    }
-
-    //! Modulo.
-    CImg operator%(const T& val) const {
-      return (+*this)%=val;
-    }
-
-    //! In-place modulo.
-    CImg& operator%=(const T& val) {
-      cimg_for(*this,ptr,T) (*ptr)%=val;
-      return *this;
-    }
-
-    //! In-place modulo.
-    CImg& operator%=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)%=*(--ptrs));
-      return *this;
-    }
-
-    //! Bitwise AND.
-    CImg operator&(const CImg& img) const {
-      return (+*this)&=img;
-    }
-
-    //! Bitwise AND.
-    CImg operator&(const T& val) const {
-      return (+*this)&=val;
-    }
-
-    //! In-place bitwise AND.
-    CImg& operator&=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)&=*(--ptrs));
-      return *this;
-    }
-
-    //! In-place bitwise AND.
-    CImg& operator&=(const T& val) {
-      cimg_for(*this,ptr,T) (*ptr)&=val;
-      return *this;
-    }
-
-    //! Bitwise OR.
-    CImg operator|(const CImg& img) const {
-      return (+*this)|=img;
-    }
-
-    //! Bitwise OR.
-    CImg operator|(const T& val) const {
-      return (+*this)|=val;
-    }
-
-    //! In-place bitwise OR.
-    CImg& operator|=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)|=*(--ptrs));
-      return *this;
-    }
-
-    //! In-place bitwise OR.
-    CImg& operator|=(const T& val) {
-      cimg_for(*this,ptr,T) (*ptr)|=val;
-      return *this;
-    }
-
-    //! Bitwise XOR.
-    CImg operator^(const CImg& img) const {
-      return (+*this)^=img;
-    }
-
-    //! Bitwise XOR.
-    CImg operator^(const T& val) const {
-      return (+*this)^=val;
-    }
-
-    //! In-place bitwise XOR.
-    CImg& operator^=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)^=*(--ptrs));
-      return *this;
-    }
-
-    //! In-place bitwise XOR.
-    CImg& operator^=(const T& val) {
-      cimg_for(*this,ptr,T) (*ptr)^=val;
-      return *this;
-    }
-
-    //! Boolean NOT.
-    CImg operator!() const {
-      CImg<T> res(width,height,depth,dim);
-      const T *ptrs = end();
-      cimg_for(res,ptrd,T) *ptrd=!(*(--ptrs));
-      return res;
-    }
-
-    //! Bitwise NOT.
-    CImg operator~() const {
-      CImg<T> res(width,height,depth,dim);
-      const T *ptrs = end();
-      cimg_for(res,ptrd,T) *ptrd=~(*(--ptrs));
-      return res;
-    }
-
-    //! Bitwise shift
-    CImg& operator<<=(const unsigned int n) {
-      cimg_for(*this,ptr,T) (*ptr)<<=n;
-      return *this;
-    }
-
-    //! Bitwise shift
-    CImg operator<<(const unsigned int n) const {
-      return (+*this)<<=n;
-    }
-
-    //! Bitwise shift
-    CImg& operator>>=(const unsigned int n) {
-      cimg_for(*this,ptr,T) (*ptr)>>=n;
-      return *this;
-    }
-
-    //! Bitwise shift
-    CImg operator>>(const unsigned int n) const {
-      return (+*this)>>=n;
-    }
-
-    //! Boolean equality.
-    template<typename t> bool operator==(const CImg<t>& img) const {
-      const unsigned int siz = size();
-      bool vequal = true;
-      if (siz!=img.size()) return false;
-      t *ptrs=img.data+siz;
-      for (T *ptrd=data+siz; vequal && ptrd>data; vequal=vequal&&((*(--ptrd))==(*(--ptrs))));
-      return vequal;
-    }
-
-    //! Boolean difference.
-    template<typename t> bool operator!=(const CImg<t>& img) const {
-      return !((*this)==img);
-    }
-
-    //! Get a new list
-    template<typename t> CImgList<typename cimg::largest<T,t>::type> operator<<(const CImg<t>& img) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImgList<restype>(*this,img);
-    }
-
-    //@}
-    //---------------------------------------
-    //
-    //! \name Usual Mathematics
-    //@{
-    //---------------------------------------
-
-    //! Apply a R->R function on all image value.
-    template<typename ts, typename td> CImg& apply(td (*func)(ts)) {
-      cimg_for(*this,ptr,T) *ptr = (T)func(*ptr);
-      return *this;
-    }
-
-    //! Return an image where each pixel value is equal to func(x).
-    template<typename ts, typename td> CImg<typename cimg::largest<T,td>::type> get_apply(td (*func)(ts)) {
-      typedef typename cimg::largest<T,td>::type restype;
-      return CImg<restype>(*this,false).apply(func);
-    }
-
-    //! In-place pointwise multiplication between \c *this and \c img.
-    /**
-       This is the in-place version of get_mul().
-       \sa get_mul().
-    **/
-    template<typename t> CImg& mul(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=(T)(*ptrd*(*(ptrs++)));
-      return *this;
-    }
-
-    //! Pointwise multiplication between \c *this and \c img.
-    /**
-       \param img Argument of the multiplication.
-       - if \c *this and \c img have different size, the multiplication is applied on the maximum possible range.
-       \sa get_div(),mul(),div()
-    **/
-    template<typename t> CImg<typename cimg::largest<T,t>::type> get_mul(const CImg<t>& img) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImg<restype>(*this,false).mul(img);
-    }
-
-    //! Replace the image by the pointwise division between \p *this and \p img.
-    /**
-       This is the in-place version of get_div().
-       \see get_div().
-    **/
-    template<typename t> CImg& div(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=(T)(*ptrd/(*(ptrs++)));
-      return *this;
-    }
-
-    //! Return an image from a pointwise division between \p *this and \p img.
-    /**
-       \param img = argument of the division.
-       \note if \c *this and \c img have different size, the division is applied
-       only on possible values.
-       \see get_mul(),mul(),div()
-    **/
-    template<typename t> CImg<typename cimg::largest<T,t>::type> get_div(const CImg<t>& img) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImg<restype>(*this,false).div(img);
-    }
-
-    //! Replace the image by the pointwise max operator between \p *this and \p img
-    /**
-       This is the in-place version of get_max().
-       \see get_max().
-    **/
-    template<typename t> CImg& max(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=cimg::max((T)*(ptrs++),*ptrd);
-      return *this;
-    }
-
-    //! Return the image corresponding to the max value for each pixel.
-    /**
-       \param img = second argument of the max operator (the first one is *this).
-       \see max(), min(), get_min()
-    **/
-    template<typename t> CImg<typename cimg::largest<T,t>::type> get_max(const CImg<t>& img) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImg<restype>(*this,false).max(img);
-    }
-
-    //! Replace the image by the pointwise max operator between \p *this and \p val
-    /**
-       This is the in-place version of get_max().
-       \see get_max().
-    **/
-#ifdef cimg_use_visualcpp6
-    CImg& max(const T val) {
-#else
-        CImg& max(const T& val) {
-#endif
-      cimg_for(*this,ptr,T) (*ptr)=cimg::max(*ptr,val);
-      return *this;
-    }
-
-    //! Return the image corresponding to the max value for each pixel.
-    /**
-       \param val = second argument of the max operator (the first one is *this).
-       \see max(), min(), get_min()
-    **/
-#ifdef cimg_use_visualcpp6
-    CImg get_max(const T val) const {
-#else
-        CImg get_max(const T& val) const {
-#endif
-      return (+*this).max(val);
-    }
-
-    //! Replace the image by the pointwise min operator between \p *this and \p img
-    /**
-       This is the in-place version of get_min().
-       \see get_min().
-    **/
-    template<typename t> CImg& min(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=cimg::min((T)*(ptrs++),*ptrd);
-      return *this;
-    }
-    //! Return the image corresponding to the min value for each pixel.
-    /**
-       \param img = second argument of the min operator (the first one is *this).
-       \see min(), max(), get_max()
-    **/
-    template<typename t> CImg<typename cimg::largest<T,t>::type> get_min(const CImg<t>& img) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImg<restype>(*this,false).min(img);
-    }
-
-    //! Replace the image by the pointwise min operator between \p *this and \p val
-    /**
-       This is the in-place version of get_min().
-       \see get_min().
-    **/
-#ifdef cimg_use_visualcpp6
-    CImg& min(const T val) {
-#else
-        CImg& min(const T& val) {
-#endif
-      cimg_for(*this,ptr,T) (*ptr)=cimg::min(*ptr,val);
-      return *this;
-    }
-
-    //! Return the image corresponding to the min value for each pixel.
-    /**
-       \param val = second argument of the min operator (the first one is *this).
-       \see min(), max(), get_max()
-    **/
-#ifdef cimg_use_visualcpp6
-    CImg get_min(const T val) const {
-#else
-        CImg get_min(const T& val) const {
-#endif
-      return (+*this).min(val);
-    }
-
-    //! Replace each image pixel by its square root.
-    /**
-       \see get_sqrt()
-    **/
-    CImg& sqrt() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::sqrt((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the square root of the pixel values.
-    /**
-       \see sqrt()
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_sqrt() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).sqrt();
-    }
-
-    //! Replace each image pixel by its exponential.
-    CImg& exp() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::exp((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the exponential of the pixel values.
-    CImg<typename cimg::largest<T,float>::type> get_exp() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).exp();
-    }
-
-    //! Replace each image pixel by its log.
-    /**
-       \see get_log(), log10(), get_log10()
-    **/
-    CImg& log() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::log((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the log of the pixel values.
-    /**
-       \see log(), log10(), get_log10()
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_log() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).log();
-    }
-
-    //! Replace each image pixel by its log10.
-    /**
-       \see get_log10(), log(), get_log()
-    **/
-    CImg& log10() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::log10((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the log10 of the pixel values.
-    /**
-       \see log10(), log(), get_log()
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_log10() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).log10();
-    }
-
-    //! Replace each image pixel by its power by \p p.
-    /**
-       \param p = power
-       \see get_pow(), sqrt(), get_sqrt()
-    **/
-    CImg& pow(const double p) {
-      if (p==0) return fill(1);
-      if (p==1) return *this;
-      if (p==2) { cimg_for(*this,ptr,T) { const T& val = *ptr; *ptr=val*val; } return *this; }
-      if (p==3) { cimg_for(*this,ptr,T) { const T& val = *ptr; *ptr=val*val*val; } return *this; }
-      if (p==4) { cimg_for(*this,ptr,T) { const T& val = *ptr; *ptr=val*val*val*val; } return *this; }
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::pow((double)(*ptr),p);
-      return *this;
-    }
-
-    //! Return the image of the square root of the pixel values.
-    /**
-       \param p = power
-       \see pow(), sqrt(), get_sqrt()
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_pow(const double p) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).pow(p);
-    }
-
-    //! Return each image pixel (*this)(x,y,z,k) by its power by \p img(x,y,z,k)
-    /**
-       In-place version
-    **/
-    template<typename t> CImg& pow(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=(T)std::pow((double)*ptrd,(double)(*(ptrs++)));
-      return *this;
-    }
-
-    //! Return each image pixel (*this)(x,y,z,k) by its power by \p img(x,y,z,k)
-    template<typename t> CImg<typename cimg::largest<T,float>::type> get_pow(const CImg<t>& img) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).pow(img);
-    }
-
-    //! Replace each pixel value by its absolute value.
-    /**
-       \see get_abs()
-    **/
-    CImg& abs() {
-      cimg_for(*this,ptr,T) (*ptr)=cimg::abs(*ptr);
-      return *this;
-    }
-
-    //! Return the image of the absolute value of the pixel values.
-    /**
-       \see abs()
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_abs() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).abs();
-    }
-
-    //! Replace each image pixel by its cosinus.
-    /**
-       \see get_cos(), sin(), get_sin(), tan(), get_tan()
-    **/
-    CImg& cos() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::cos((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the cosinus of the pixel values.
-    /**
-       \see cos(), sin(), get_sin(), tan(), get_tan()
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_cos() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).cos();
-    }
-
-    //! Replace each image pixel by its sinus.
-    /**
-       \see get_sin(), cos(), get_cos(), tan(), get_tan()
-    **/
-    CImg& sin() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::sin((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the sinus of the pixel values.
-    /**
-       \see sin(), cos(), get_cos(), tan(), get_tan()
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_sin() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).sin();
-    }
-
-    //! Replace each image pixel by its tangent.
-    /**
-       \see get_tan(), cos(), get_cos(), sin(), get_sin()
-    **/
-    CImg& tan() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::tan((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the tangent of the pixel values.
-    /**
-       \see tan(), cos(), get_cos(), sin(), get_sin()
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_tan() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).tan();
-    }
-
-    //! Replace each image pixel by its arc-cosinus.
-    CImg& acos() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::acos((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the arc-cosinus of the pixel values.
-    CImg<typename cimg::largest<T,float>::type> get_acos() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).acos();
-    }
-
-    //! Replace each image pixel by its arc-sinus.
-    CImg& asin() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::asin((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the arc-sinus of the pixel values.
-    CImg<typename cimg::largest<T,float>::type> get_asin() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).asin();
-    }
-
-    //! Replace each image pixel by its arc-tangent.
-    CImg& atan() {
-      cimg_for(*this,ptr,T) (*ptr)=(T)std::atan((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the arc-tangent of the pixel values.
-    CImg<typename cimg::largest<T,float>::type> get_atan() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).atan();
-    }
-
-    //! Return the MSE (Mean-Squared Error) between two images.
-    template<typename t> double MSE(const CImg<t>& img) const {
-      if (img.size()!=size())
-        throw CImgArgumentException("CImg<%s>::MSE() : Instance image (%u,%u,%u,%u) and given image (%u,%u,%u,%u) have different dimensions.",
-                                    pixel_type(),width,height,depth,dim,img.width,img.height,img.depth,img.dim);
-
-      double vMSE = 0;
-      const t* ptr2 = img.end();
-      cimg_for(*this,ptr1,T) {
-        const double diff = (double)*ptr1 - (double)*(--ptr2);
-        vMSE += diff*diff;
-      }
-      vMSE/=img.size();
-      return vMSE;
-    }
-
-    //! Return the PSNR between two images.
-    template<typename t> double PSNR(const CImg<t>& img, const double valmax=255.0) const {
-      const double vMSE = std::sqrt(MSE(img));
-      return (vMSE!=0)?(20*std::log10(valmax/vMSE)):(cimg::type<double>::max());
-    }
-
-    //@}
-    //-----------------------------------
-    //
-    //! \name Usual Image Transformations
-    //@{
-    //-----------------------------------
-
-    //! Fill an image by a value \p val.
-    /**
-       \param val = fill value
-       \note All pixel values of the instance image will be initialized by \p val.
-       \see operator=().
-    **/
-    CImg& fill(const T& val) {
-      if (!is_empty()) {
-        if (val!=0 && sizeof(T)!=1) cimg_for(*this,ptr,T) *ptr=val;
-        else std::memset(data,(int)val,size()*sizeof(T));
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val) const {
-      return (+*this).fill(val);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 respectively.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-    **/
-    CImg& fill(const T& val0,const T& val1) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-1;
-        for (ptr=data; ptr<ptr_end; ) { *(ptr++)=val0; *(ptr++)=val1; }
-        if (ptr!=ptr_end+1) *(ptr++)=val0;
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1) const {
-      return (+*this).fill(val0,val1);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-2;
-        for (ptr=data; ptr<ptr_end; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; }
-        ptr_end+=2;
-        switch (ptr_end-ptr) {
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2) const {
-      return (+*this).fill(val0,val1,val2);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-3;
-        for (ptr=data; ptr<ptr_end; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; }
-        ptr_end+=3;
-        switch (ptr_end-ptr) {
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3) const {
-      return (+*this).fill(val0,val1,val2,val3);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a val4.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-4;
-        for (ptr=data; ptr<ptr_end; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; }
-        ptr_end+=4;
-        switch (ptr_end-ptr) {
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4) const {
-      return (+*this).fill(val0,val1,val2,val3,val4);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a val4 and \a val5
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-5;
-        for (ptr=data; ptr<ptr_end; ) {
-          *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5;
-        }
-        ptr_end+=5;
-        switch (ptr_end-ptr) {
-        case 5: *(--ptr_end)=val4;
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4, const T& val5) const {
-      return (+*this).fill(val0,val1,val2,val3,val4,val5);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a val4 and \a val5
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,
-               const T& val4,const T& val5,const T& val6) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-6;
-        for (ptr=data; ptr<ptr_end; ) {
-          *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; *(ptr++)=val6;
-        }
-        ptr_end+=6;
-        switch (ptr_end-ptr) {
-        case 6: *(--ptr_end)=val5;
-        case 5: *(--ptr_end)=val4;
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4, const T& val5,
-                  const T& val6) const {
-      return (+*this).fill(val0,val1,val2,val3,val4,val5,val6);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val7.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,
-               const T& val4,const T& val5,const T& val6,const T& val7) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-7;
-        for (ptr=data; ptr<ptr_end; ) {
-          *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3;
-          *(ptr++)=val4; *(ptr++)=val5; *(ptr++)=val6; *(ptr++)=val7;
-        }
-        ptr_end+=7;
-        switch (ptr_end-ptr) {
-        case 7: *(--ptr_end)=val6;
-        case 6: *(--ptr_end)=val5;
-        case 5: *(--ptr_end)=val4;
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4, const T& val5,
-                  const T& val6, const T& val7) const {
-      return (+*this).fill(val0,val1,val2,val3,val4,val5,val6,val7);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val8.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,
-               const T& val3,const T& val4,const T& val5,
-               const T& val6,const T& val7,const T& val8) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-8;
-        for (ptr=data; ptr<ptr_end; ) {
-          *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2;
-          *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5;
-          *(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8;
-        }
-        ptr_end+=8;
-        switch (ptr_end-ptr) {
-        case 8: *(--ptr_end)=val7;
-        case 7: *(--ptr_end)=val6;
-        case 6: *(--ptr_end)=val5;
-        case 5: *(--ptr_end)=val4;
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4, const T& val5,
-                  const T& val6, const T& val7, const T& val8) const {
-      return (+*this).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val9.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,
-               const T& val5,const T& val6,const T& val7,const T& val8,const T& val9) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-9;
-        for (ptr=data; ptr<ptr_end; ) {
-          *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4;
-          *(ptr++)=val5; *(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9;
-        }
-        ptr_end+=9;
-        switch (ptr_end-ptr) {
-        case 9: *(--ptr_end)=val8;
-        case 8: *(--ptr_end)=val7;
-        case 7: *(--ptr_end)=val6;
-        case 6: *(--ptr_end)=val5;
-        case 5: *(--ptr_end)=val4;
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4, const T& val5,
-                  const T& val6, const T& val7, const T& val8, const T& val9) const {
-      return (+*this).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val11.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-       \param val10 = fill value 11
-       \param val11 = fill value 12
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,
-               const T& val4,const T& val5,const T& val6,const T& val7,
-               const T& val8,const T& val9,const T& val10,const T& val11) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-11;
-        for (ptr=data; ptr<ptr_end; ) {
-          *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5;
-          *(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9; *(ptr++)=val10; *(ptr++)=val11;
-        }
-        ptr_end+=11;
-        switch (ptr_end-ptr) {
-        case 11: *(--ptr_end)=val10;
-        case 10: *(--ptr_end)=val9;
-        case 9: *(--ptr_end)=val8;
-        case 8: *(--ptr_end)=val7;
-        case 7: *(--ptr_end)=val6;
-        case 6: *(--ptr_end)=val5;
-        case 5: *(--ptr_end)=val4;
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4, const T& val5,
-                  const T& val6, const T& val7, const T& val8, const T& val9, const T& val10, const T& val11) const {
-      return (+*this).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,val11);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val11.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-       \param val10 = fill value 11
-       \param val11 = fill value 12
-       \param val12 = fill value 13
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,
-               const T& val4,const T& val5,const T& val6,const T& val7,
-               const T& val8,const T& val9,const T& val10,const T& val11,
-               const T& val12) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-12;
-        for (ptr=data; ptr<ptr_end; ) {
-          *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5;
-          *(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9; *(ptr++)=val10; *(ptr++)=val11;
-          *(ptr++)=val12;
-        }
-        ptr_end+=12;
-        switch (ptr_end-ptr) {
-        case 12: *(--ptr_end)=val11;
-        case 11: *(--ptr_end)=val10;
-        case 10: *(--ptr_end)=val9;
-        case 9: *(--ptr_end)=val8;
-        case 8: *(--ptr_end)=val7;
-        case 7: *(--ptr_end)=val6;
-        case 6: *(--ptr_end)=val5;
-        case 5: *(--ptr_end)=val4;
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4, const T& val5,
-                  const T& val6, const T& val7, const T& val8, const T& val9, const T& val10, const T& val11,
-                  const T& val12, const T& val13) const {
-      return (+*this).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,val11,val12,val13);
-    }
-
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val15.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-       \param val10 = fill value 11
-       \param val11 = fill value 12
-       \param val12 = fill value 13
-       \param val13 = fill value 14
-       \param val14 = fill value 15
-       \param val15 = fill value 16
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,
-               const T& val4,const T& val5,const T& val6,const T& val7,
-               const T& val8,const T& val9,const T& val10,const T& val11,
-               const T& val12,const T& val13,const T& val14,const T& val15) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-15;
-        for (ptr=data; ptr<ptr_end; ) {
-          *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5;
-          *(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9; *(ptr++)=val10; *(ptr++)=val11;
-          *(ptr++)=val12; *(ptr++)=val13; *(ptr++)=val14; *(ptr++)=val15;
-        }
-        ptr_end+=15;
-        switch (ptr_end-ptr) {
-        case 15: *(--ptr_end)=val14;
-        case 14: *(--ptr_end)=val13;
-        case 13: *(--ptr_end)=val12;
-        case 12: *(--ptr_end)=val11;
-        case 11: *(--ptr_end)=val10;
-        case 10: *(--ptr_end)=val9;
-        case 9: *(--ptr_end)=val8;
-        case 8: *(--ptr_end)=val7;
-        case 7: *(--ptr_end)=val6;
-        case 6: *(--ptr_end)=val5;
-        case 5: *(--ptr_end)=val4;
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4, const T& val5,
-                  const T& val6, const T& val7, const T& val8, const T& val9, const T& val10, const T& val11,
-                  const T& val12, const T& val13, const T& val14, const T& val15) const {
-      return (+*this).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,val11,val12,val13,val14,val15);
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val24.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-       \param val10 = fill value 11
-       \param val11 = fill value 12
-       \param val12 = fill value 13
-       \param val13 = fill value 14
-       \param val14 = fill value 15
-       \param val15 = fill value 16
-       \param val16 = fill value 17
-       \param val17 = fill value 18
-       \param val18 = fill value 19
-       \param val19 = fill value 20
-       \param val20 = fill value 21
-       \param val21 = fill value 22
-       \param val22 = fill value 23
-       \param val23 = fill value 24
-       \param val24 = fill value 25
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,
-               const T& val5,const T& val6,const T& val7,const T& val8,const T& val9,
-               const T& val10,const T& val11,const T& val12,const T& val13,const T& val14,
-               const T& val15,const T& val16,const T& val17,const T& val18,const T& val19,
-               const T& val20,const T& val21,const T& val22,const T& val23,const T& val24) {
-      if (!is_empty()) {
-        T *ptr, *ptr_end = end()-24;
-        for (ptr=data; ptr<ptr_end; ) {
-          *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4;
-          *(ptr++)=val5; *(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9;
-          *(ptr++)=val10; *(ptr++)=val11; *(ptr++)=val12; *(ptr++)=val13; *(ptr++)=val14;
-          *(ptr++)=val15; *(ptr++)=val16; *(ptr++)=val17; *(ptr++)=val18; *(ptr++)=val19;
-          *(ptr++)=val20; *(ptr++)=val21; *(ptr++)=val22; *(ptr++)=val23; *(ptr++)=val24;
-        }
-        ptr_end+=24;
-        switch (ptr_end-ptr) {
-        case 24: *(--ptr_end)=val23;
-        case 23: *(--ptr_end)=val22;
-        case 22: *(--ptr_end)=val21;
-        case 21: *(--ptr_end)=val20;
-        case 20: *(--ptr_end)=val19;
-        case 19: *(--ptr_end)=val18;
-        case 18: *(--ptr_end)=val17;
-        case 17: *(--ptr_end)=val16;
-        case 16: *(--ptr_end)=val15;
-        case 15: *(--ptr_end)=val14;
-        case 14: *(--ptr_end)=val13;
-        case 13: *(--ptr_end)=val12;
-        case 12: *(--ptr_end)=val11;
-        case 11: *(--ptr_end)=val10;
-        case 10: *(--ptr_end)=val9;
-        case 9: *(--ptr_end)=val8;
-        case 8: *(--ptr_end)=val7;
-        case 7: *(--ptr_end)=val6;
-        case 6: *(--ptr_end)=val5;
-        case 5: *(--ptr_end)=val4;
-        case 4: *(--ptr_end)=val3;
-        case 3: *(--ptr_end)=val2;
-        case 2: *(--ptr_end)=val1;
-        case 1: *(--ptr_end)=val0;
-        }
-      }
-      return *this;
-    }
-
-    CImg get_fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,
-                  const T& val5,const T& val6,const T& val7,const T& val8,const T& val9,
-                  const T& val10,const T& val11,const T& val12,const T& val13,const T& val14,
-                  const T& val15,const T& val16,const T& val17,const T& val18,const T& val19,
-                  const T& val20,const T& val21,const T& val22,const T& val23,const T& val24) const {
-      return (+*this).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,
-                                 val10,val11,val12,val13,val14,val15,val16,val17,val18,val19,
-                                 val20,val21,val22,val23,val24);
-    }
-
-    //! Linear normalization of the pixel values between \a a and \a b.
-    /**
-       \param a = minimum pixel value after normalization.
-       \param b = maximum pixel value after normalization.
-       \see get_normalize(), cut(), get_cut().
-    **/
-    CImg& normalize(const T& a, const T& b) {
-      if (!is_empty()) {
-        const CImgStats st(*this,false);
-        if (st.min==st.max) return fill(0);
-        if (st.min!=a || st.max!=b) cimg_for(*this,ptr,T) *ptr=(T)((*ptr-st.min)/(st.max-st.min)*(b-a)+a);
-      }
-      return *this;
-    }
-
-    //! Return the image of normalized values.
-    /**
-       \param a = minimum pixel value after normalization.
-       \param b = maximum pixel value after normalization.
-       \see normalize(), cut(), get_cut().
-    **/
-    CImg get_normalize(const T& a, const T& b) const {
-      return (+*this).normalize(a,b);
-    }
-
-    //! Cut pixel values between \a a and \a b.
-    /**
-       \param a = minimum pixel value after cut.
-       \param b = maximum pixel value after cut.
-       \see get_cut(), normalize(), get_normalize().
-    **/
-    CImg& cut(const T& a, const T& b) {
-      if (!is_empty())
-        cimg_for(*this,ptr,T) *ptr = (*ptr<a)?a:((*ptr>b)?b:*ptr);
-      return *this;
-    }
-
-    //! Return the image of cutted values.
-    /**
-       \param a = minimum pixel value after cut.
-       \param b = maximum pixel value after cut.
-       \see cut(), normalize(), get_normalize().
-    **/
-    CImg get_cut(const T& a, const T& b) const {
-      return (+*this).cut(a,b);
-    }
-
-    //! Quantize pixel values into \n levels.
-    /**
-       \param n = number of quantification levels
-       \see get_quantize().
-    **/
-    CImg& quantize(const unsigned int n=256) {
-      if (!is_empty()) {
-        if (!n) throw CImgArgumentException("CImg<%s>::quantize() : Cannot quantize image to 0 values.",
-                                            pixel_type());
-        const CImgStats st(*this,false);
-        const double range = st.max-st.min;
-        if (range>0) cimg_for(*this,ptr,T) {
-          const unsigned int val = (unsigned int)((*ptr-st.min)*n/range);
-          *ptr = (T)(st.min + cimg::min(val,n-1)*range);
-        }
-      }
-      return *this;
-    }
-
-    //! Return a quantified image, with \n levels.
-    /**
-       \param n = number of quantification levels
-       \see quantize().
-    **/
-    CImg get_quantize(const unsigned int n=256) const {
-      return (+*this).quantize(n);
-    }
-
-    //! Threshold the image.
-    /**
-       \param thres = threshold
-       \see get_threshold().
-    **/
-    CImg& threshold(const T& thres) {
-      if (!is_empty()) cimg_for(*this,ptr,T) *ptr = *ptr<=thres?(T)0:(T)1;
-      return *this;
-    }
-
-    //! Return a thresholded image.
-    /**
-       \param thres = threshold.
-       \see threshold().
-    **/
-    CImg get_threshold(const T& thres) const {
-      return (+*this).threshold(thres);
-    }
-
-    //! Return a rotated image.
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \note Returned image will probably have a different size than the instance image *this.
-       \see rotate()
-    **/
-    CImg get_rotate(const float angle, const unsigned int cond=3) const {
-      if (is_empty()) return CImg<T>();
-      CImg dest;
-      const float nangle = cimg::mod(angle,360.0f), rad = (float)((nangle*cimg::PI)/180.0),
-        ca=(float)std::cos(rad), sa=(float)std::sin(rad);
-      if (cond!=1 && cimg::mod(nangle,90.0f)==0) { // optimized version for orthogonal angles
-        const int wm1 = dimx()-1, hm1 = dimy()-1;
-        const int iangle = (int)nangle/90;
-        switch (iangle) {
-        case 1: {
-          dest.assign(height,width,depth,dim);
-          cimg_forXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(y,hm1-x,z,v);
-        } break;
-        case 2: {
-          dest.assign(width,height,depth,dim);
-          cimg_forXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(wm1-x,hm1-y,z,v);
-        } break;
-        case 3: {
-          dest.assign(height,width,depth,dim);
-          cimg_forXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(wm1-y,x,z,v);
-        } break;
-        default:
-          return *this;
-        }
-      } else { // generic version
-        const float
-          ux  = (float)(cimg::abs(width*ca)),  uy  = (float)(cimg::abs(width*sa)),
-          vx  = (float)(cimg::abs(height*sa)), vy  = (float)(cimg::abs(height*ca)),
-          w2  = 0.5f*width,           h2  = 0.5f*height,
-          dw2 = 0.5f*(ux+vx),         dh2 = 0.5f*(uy+vy);
-        dest.assign((int)(ux+vx), (int)(uy+vy),depth,dim);
-        switch (cond) {
-        case 0: {
-          cimg_forXY(dest,x,y)
-            cimg_forZV(*this,z,v)
-            dest(x,y,z,v) = pix2d((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),(int)(h2 - (x-dw2)*sa + (y-dh2)*ca),z,v,0);
-        } break;
-        case 1: {
-          cimg_forXY(dest,x,y)
-            cimg_forZV(*this,z,v)
-            dest(x,y,z,v) = (*this)(cimg::mod((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),width),
-                                    cimg::mod((int)(h2 - (x-dw2)*sa + (y-dh2)*ca),height),z,v);
-        } break;
-        case 2: {
-          cimg_forXY(dest,x,y) {
-            const float X = w2 + (x-dw2)*ca + (y-dh2)*sa, Y = h2 - (x-dw2)*sa + (y-dh2)*ca;
-            cimg_forZV(*this,z,v) dest(x,y,z,v) = (T)linear_pix2d(X,Y,z,v,0);
-          }
-        } break;
-        default: {
-          cimg_forXY(dest,x,y) {
-            const float X = w2 + (x-dw2)*ca + (y-dh2)*sa, Y = h2 - (x-dw2)*sa + (y-dh2)*ca;
-            cimg_forZV(*this,z,v) dest(x,y,z,v) = (T)cubic_pix2d(X,Y,z,v,0);
-          }
-        } break;
-        }
-      }
-      return dest;
-    }
-
-    //! Rotate the image
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \see get_rotate()
-    **/
-    CImg& rotate(const float angle,const unsigned int cond=3) { return get_rotate(angle,cond).swap(*this); }
-
-    //! Return a rotated image around the point (\c cx,\c cy).
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cx = X-coordinate of the rotation center.
-       \param cy = Y-coordinate of the rotation center.
-       \param zoom = zoom.
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \see rotate()
-    **/
-    CImg get_rotate(const float angle,const float cx,const float cy,const float zoom=1,const unsigned int cond=3) const {
-      if (is_empty()) return CImg<T>();
-      CImg dest(width,height,depth,dim);
-      const float nangle = cimg::mod(angle,360.0f), rad = (float)((nangle*cimg::PI)/180.0),
-        ca=(float)std::cos(rad)/zoom, sa=(float)std::sin(rad)/zoom;
-      if (cond!=1 && zoom==1 && cimg::mod(nangle,90.0f)==0) { // optimized version for orthogonal angles
-        const int iangle = (int)nangle/90;
-        switch (iangle) {
-        case 1: {
-          dest.fill(0);
-          const unsigned int
-            xmin = cimg::max(0,(dimx()-dimy())/2), xmax = cimg::min(width,xmin+height),
-            ymin = cimg::max(0,(dimy()-dimx())/2), ymax = cimg::min(height,ymin+width),
-            xoff = xmin + cimg::min(0,(dimx()-dimy())/2),
-            yoff = ymin + cimg::min(0,(dimy()-dimx())/2);
-          cimg_forZV(dest,z,v) for (unsigned int y=ymin; y<ymax; y++) for (unsigned int x=xmin; x<xmax; x++)
-            dest(x,y,z,v) = (*this)(y-yoff,height-1-x+xoff,z,v);
-        } break;
-        case 2: {
-          cimg_forXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-x,height-1-y,z,v);
-        } break;
-        case 3: {
-          dest.fill(0);
-          const unsigned int
-            xmin = cimg::max(0,(dimx()-dimy())/2), xmax = cimg::min(width,xmin+height),
-            ymin = cimg::max(0,(dimy()-dimx())/2), ymax = cimg::min(height,ymin+width),
-            xoff = xmin + cimg::min(0,(dimx()-dimy())/2),
-            yoff = ymin + cimg::min(0,(dimy()-dimx())/2);
-          cimg_forZV(dest,z,v) for (unsigned int y=ymin; y<ymax; y++) for (unsigned int x=xmin; x<xmax; x++)
-            dest(x,y,z,v) = (*this)(width-1-y+yoff,x-xoff,z,v);
-        } break;
-        default:
-          return *this;
-        }
-      } else
-        switch (cond) { // generic version
-        case 0: {
-          cimg_forXY(dest,x,y)
-            cimg_forZV(*this,z,v)
-            dest(x,y,z,v) = pix2d((int)(cx + (x-cx)*ca + (y-cy)*sa),(int)(cy - (x-cx)*sa + (y-cy)*ca),z,v,0);
-        } break;
-        case 1: {
-          cimg_forXY(dest,x,y)
-            cimg_forZV(*this,z,v)
-            dest(x,y,z,v) = (*this)(cimg::mod((int)(cx + (x-cx)*ca + (y-cy)*sa),width),
-                                    cimg::mod((int)(cy - (x-cx)*sa + (y-cy)*ca),height),z,v);
-        } break;
-        case 2: {
-          cimg_forXY(dest,x,y) {
-            const float X = cx + (x-cx)*ca + (y-cy)*sa, Y = cy - (x-cx)*sa + (y-cy)*ca;
-            cimg_forZV(*this,z,v) dest(x,y,z,v) = (T)linear_pix2d(X,Y,z,v,0);
-          }
-        } break;
-        default: {
-          cimg_forXY(dest,x,y) {
-            const float X = cx + (x-cx)*ca + (y-cy)*sa, Y = cy - (x-cx)*sa + (y-cy)*ca;
-            cimg_forZV(*this,z,v) dest(x,y,z,v) = (T)cubic_pix2d(X,Y,z,v,0);
-          }
-        } break;
-        }
-      return dest;
-    }
-
-    //! Rotate the image around the point (\c cx,\c cy).
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cx = X-coordinate of the rotation center.
-       \param cy = Y-coordinate of the rotation center.
-       \param zoom = zoom.
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \note Rotation does not change the image size. If you want to get an image with a new size, use get_rotate() instead.
-       \see get_rotate()
-    **/
-    CImg& rotate(const float angle,const float cx,const float cy,const float zoom=1,const unsigned int cond=3) {
-      return get_rotate(angle,cx,cy,zoom,cond).swap(*this);
-    }
-
-    //! Return a resized image.
-    /**
-       \param pdx = Number of columns (new size along the X-axis).
-       \param pdy = Number of rows (new size along the Y-axis).
-       \param pdz = Number of slices (new size along the Z-axis).
-       \param pdv = Number of vector-channels (new size along the V-axis).
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg get_resize(const int pdx=-100, const int pdy=-100, const int pdz=-100, const int pdv=-100,
-                    const unsigned int interp=1, const int border_condition=-1) const {
-      if (!pdx || !pdy || !pdz || !pdv) return CImg<T>();
-      const unsigned int
-        tdx = pdx<0?-pdx*width/100:pdx,
-        tdy = pdy<0?-pdy*height/100:pdy,
-        tdz = pdz<0?-pdz*depth/100:pdz,
-        tdv = pdv<0?-pdv*dim/100:pdv,
-        dx = tdx?tdx:1,
-        dy = tdy?tdy:1,
-        dz = tdz?tdz:1,
-        dv = tdv?tdv:1;
-      if (is_empty()) return CImg<T>(dx,dy,dz,dv,0);
-      if (width==dx && height==dy && depth==dz && dim==dv) return *this;
-      CImg res;
-
-      switch (interp) {
-      case 0:  // Zero filling
-        res.assign(dx,dy,dz,dv,0).draw_image(*this,0,0,0,0);
-        break;
-
-      case 1: { // Nearest-neighbor interpolation
-        res.assign(dx,dy,dz,dv);
-        unsigned int
-          *const offx = new unsigned int[dx],
-          *const offy = new unsigned int[dy+1],
-          *const offz = new unsigned int[dz+1],
-          *const offv = new unsigned int[dv+1],
-          *poffx, *poffy, *poffz, *poffv,
-          curr, old;
-        const unsigned int wh = width*height, whd = width*height*depth, rwh = dx*dy, rwhd = dx*dy*dz;
-        poffx = offx; curr=0; { cimg_forX(res,x) { old=curr; curr=(x+1)*width/dx;  *(poffx++) = (unsigned int)curr-(unsigned int)old; }}
-        poffy = offy; curr=0; { cimg_forY(res,y) { old=curr; curr=(y+1)*height/dy; *(poffy++) = width*((unsigned int)curr-(unsigned int)old); }} *poffy=0;
-        poffz = offz; curr=0; { cimg_forZ(res,z) { old=curr; curr=(z+1)*depth/dz;  *(poffz++) = wh*((unsigned int)curr-(unsigned int)old); }} *poffz=0;
-        poffv = offv; curr=0; { cimg_forV(res,k) { old=curr; curr=(k+1)*dim/dv;    *(poffv++) = whd*((unsigned int)curr-(unsigned int)old); }} *poffv=0;
-        T *ptrd = res.ptr();
-        const T* ptrv = ptr();
-        poffv = offv;
-        for (unsigned int k=0; k<dv; ) {
-          const T *ptrz = ptrv;
-          poffz = offz;
-          for (unsigned int z=0; z<dz; ) {
-            const T *ptry = ptrz;
-            poffy = offy;
-            for (unsigned int y=0; y<dy; ) {
-              const T *ptrx = ptry;
-              poffx = offx;
-              cimg_forX(res,x) { *(ptrd++)=*ptrx; ptrx+=*(poffx++); }
-              y++;
-              unsigned int dy=*(poffy++);
-              for (;!dy && y<dy; std::memcpy(ptrd, ptrd-dx, sizeof(T)*dx), y++, ptrd+=dx, dy=*(poffy++));
-              ptry+=dy;
-            }
-            z++;
-            unsigned int dz=*(poffz++);
-            for (;!dz && z<dz; std::memcpy(ptrd, ptrd-rwh, sizeof(T)*rwh), z++, ptrd+=rwh, dz=*(poffz++));
-            ptrz+=dz;
-          }
-          k++;
-          unsigned int dv=*(poffv++);
-          for (;!dv && k<dv; std::memcpy(ptrd, ptrd-rwhd, sizeof(T)*rwhd), k++, ptrd+=rwhd, dv=*(poffv++));
-          ptrv+=dv;
-        }
-        delete[] offx; delete[] offy; delete[] offz; delete[] offv;
-      } break;
-
-      case 2: { // Mosaic filling
-        res.assign(dx,dy,dz,dv);
-        for (unsigned int k=0; k<dv; k+=dim)
-          for (unsigned int z=0; z<dz; z+=depth)
-            for (unsigned int y=0; y<dy; y+=height)
-              for (unsigned int x=0; x<dx; x+=width) res.draw_image(*this,x,y,z,k);
-      } break;
-
-      case 3: { // Linear interpolation
-        const unsigned int dimmax = cimg::max(dx,dy,dz,dv);
-        const bool bborder = (interp>1 && border_condition<0);
-        const float
-          sx = bborder?(dx>0?(width-1.0f)/(dx-1) :0):(float)width/dx,
-          sy = bborder?(dy>0?(height-1.0f)/(dy-1):0):(float)height/dy,
-          sz = bborder?(dz>0?(depth-1.0f)/(dz-1) :0):(float)depth/dz,
-          sv = bborder?(dv>0?(dim-1.0f)/(dv-1)   :0):(float)dim/dv;
-        unsigned int *const off = new unsigned int[dimmax], *poff;
-        float *const foff = new float[dimmax], *pfoff, old, curr;
-        CImg resx, resy, resz, resv;
-        T *ptrd;
-
-        if (dx!=width) {
-          if (width==1) resx = get_resize(dx,height,depth,dim,1,0);
-          else {
-            resx.assign(dx,height,depth,dim);
-            curr = old = 0; poff = off; pfoff = foff;
-            cimg_forX(resx,x) { *(pfoff++) = curr-(unsigned int)curr; old = curr; curr+=sx; *(poff++) = (unsigned int)curr-(unsigned int)old; }
-            ptrd = resx.ptr();
-            const T *ptrs0 = ptr();
-            cimg_forYZV(resx,y,z,k) {
-              poff = off; pfoff = foff;
-              const T *ptrs = ptrs0, *const ptrsmax = ptrs0 + (width-1);
-              cimg_forX(resx,x) {
-                const float alpha = *(pfoff++);
-                const T val1 = *ptrs, val2 = ptrs<ptrsmax?*(ptrs+1):(border_condition?val1:0);
-                *(ptrd++) = (T)((1-alpha)*val1 + alpha*val2);
-                ptrs+=*(poff++);
-              }
-              ptrs0+=width;
-            }
-          }
-        } else resx.assign(*this,true);
-
-        if (dy!=height) {
-          if (height==1) resy = resx.get_resize(dx,dy,depth,dim,1,0);
-          else {
-            resy.assign(dx,dy,depth,dim);
-            curr = old = 0; poff = off; pfoff = foff;
-            cimg_forY(resy,y) { *(pfoff++) = curr-(unsigned int)curr; old = curr; curr+=sy; *(poff++) = dx*((unsigned int)curr-(unsigned int)old); }
-            cimg_forXZV(resy,x,z,k) {
-              ptrd = resy.ptr(x,0,z,k);
-              const T *ptrs = resx.ptr(x,0,z,k), *const ptrsmax = ptrs + (height-1)*dx;
-              poff = off; pfoff = foff;
-              cimg_forY(resy,y) {
-                const float alpha = *(pfoff++);
-                const T val1 = *ptrs, val2 = ptrs<ptrsmax?*(ptrs+dx):(border_condition?val1:0);
-                *ptrd = (T)((1-alpha)*val1 + alpha*val2);
-                ptrd+=dx;
-                ptrs+=*(poff++);
-              }
-            }
-          }
-          resx.assign();
-        } else resy.assign(resx,true);
-
-        if (dz!=depth) {
-          if (depth==1) resz = resy.get_resize(dx,dy,dz,dim,1,0);
-          else {
-            const unsigned int wh = dx*dy;
-            resz.assign(dx,dy,dz,dim);
-            curr = old = 0; poff = off; pfoff = foff;
-            cimg_forZ(resz,z) { *(pfoff++) = curr-(unsigned int)curr; old = curr; curr+=sz; *(poff++) = wh*((unsigned int)curr-(unsigned int)old); }
-            cimg_forXYV(resz,x,y,k) {
-              ptrd = resz.ptr(x,y,0,k);
-              const T *ptrs = resy.ptr(x,y,0,k), *const ptrsmax = ptrs + (depth-1)*wh;
-              poff = off; pfoff = foff;
-              cimg_forZ(resz,z) {
-                const float alpha = *(pfoff++);
-                const T val1 = *ptrs, val2 = ptrs<ptrsmax?*(ptrs+wh):(border_condition?val1:0);
-                *ptrd = (T)((1-alpha)*val1 + alpha*val2);
-                ptrd+=wh;
-                ptrs+=*(poff++);
-              }
-            }
-          }
-          resy.assign();
-        } else resz.assign(resy,true);
-
-        if (dv!=dim) {
-          if (dim==1) resv = resz.get_resize(dx,dy,dz,dv,1,0);
-          else {
-            const unsigned int whd = dx*dy*dz;
-            resv.assign(dx,dy,dz,dv);
-            curr = old = 0; poff = off; pfoff = foff;
-            cimg_forV(resv,k) { *(pfoff++) = curr-(unsigned int)curr; old = curr; curr+=sv; *(poff++) = whd*((unsigned int)curr-(unsigned int)old); }
-            cimg_forXYZ(resv,x,y,z) {
-              ptrd = resv.ptr(x,y,z,0);
-              const T *ptrs = resz.ptr(x,y,z,0), *const ptrsmax = ptrs + (dim-1)*whd;
-              poff = off; pfoff = foff;
-              cimg_forV(resv,k) {
-                const float alpha = *(pfoff++);
-                const T val1 = *ptrs, val2 = ptrs<ptrsmax?*(ptrs+whd):(border_condition?val1:0);
-                *ptrd = (T)((1-alpha)*val1 + alpha*val2);
-                ptrd+=whd;
-                ptrs+=*(poff++);
-              }
-            }
-          }
-          resz.assign();
-        } else resv.assign(resz,true);
-
-        delete[] off; delete[] foff;
-        return resv.is_shared?(resz.is_shared?(resy.is_shared?(resx.is_shared?(+(*this)):resx):resy):resz):resv;
-      } break;
-
-      case 4: { // Grid filling
-        res.assign(dx,dy,dz,dv,0);
-        cimg_forXYZV(*this,x,y,z,k) res(x*dx/width,y*dy/height,z*dz/depth,k*dv/dim) = (*this)(x,y,z,k);
-      } break;
-
-      case 5: { // Cubic interpolation
-        const bool bborder = (interp>1 && border_condition<0);
-        const float
-          sx = bborder?(dx>0?(width-1.0f)/(dx-1) :0):(float)width/dx,
-          sy = bborder?(dy>0?(height-1.0f)/(dy-1):0):(float)height/dy,
-          sz = bborder?(dz>0?(depth-1.0f)/(dz-1) :0):(float)depth/dz,
-          sv = bborder?(dv>0?(dim-1.0f)/(dv-1)   :0):(float)dim/dv;
-        res.assign(dx,dy,dz,dv);
-        float cx, cy, cz, ck = 0;
-        cimg_forV(res,k) { cz = 0;
-        cimg_forZ(res,z) { cy = 0;
-        cimg_forY(res,y) { cx = 0;
-        cimg_forX(res,x) { res(x,y,z,k) = (T)(border_condition?cubic_pix2d(cx,cy,(int)cz,(int)ck):cubic_pix2d(cx,cy,(int)cz,(int)ck,0));
-        cx+=sx;
-        } cy+=sy;
-        } cz+=sz;
-        } ck+=sv;
-        }
-      } break;
-
-      }
-
-      return res;
-    }
-
-    //! Return a resized image.
-    /**
-       \param src = Image giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    template<typename t> CImg get_resize(const CImg<t>& src, const unsigned int interp=1, const int border_condition=-1) const {
-      return get_resize(src.width,src.height,src.depth,src.dim,interp,border_condition);
-    }
-
-    //! Return a resized image.
-    /**
-       \param disp = Display giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg get_resize(const CImgDisplay& disp,const unsigned int interp=1, const int border_condition=-1) const {
-      return get_resize(disp.width,disp.height,depth,dim,interp,border_condition);
-    }
-
-    //! Resize the image.
-    /**
-       \param pdx = Number of columns (new size along the X-axis).
-       \param pdy = Number of rows (new size along the Y-axis).
-       \param pdz = Number of slices (new size along the Z-axis).
-       \param pdv = Number of vector-channels (new size along the V-axis).
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg& resize(const int pdx=-100, const int pdy=-100, const int pdz=-100, const int pdv=-100,
-                 const unsigned int interp=1, const int border_condition=-1) {
-      if (!pdx || !pdy || !pdz || !pdv) return assign();
-      const unsigned int
-        dx = pdx<0?-pdx*width/100:pdx,
-        dy = pdy<0?-pdy*height/100:pdy,
-        dz = pdz<0?-pdz*depth/100:pdz,
-        dv = pdv<0?-pdv*dim/100:pdv;
-      if (width==dx && height==dy && depth==dz && dim==dv) return *this;
-      return get_resize(dx,dy,dz,dv,interp,border_condition).swap(*this);
-    }
-
-    //! Resize the image.
-    /**
-       \param src = Image giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    template<typename t> CImg& resize(const CImg<t>& src, const unsigned int interp=1, const int border_condition=-1) {
-      return resize(src.width,src.height,src.depth,src.dim,interp,border_condition);
-    }
-
-    //! Resize the image
-    /**
-       \param disp = Display giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg& resize(const CImgDisplay& disp, const unsigned int interp=1, const int border_condition=-1) {
-      return resize(disp.width,disp.height,depth,dim,interp,border_condition);
-    }
-
-    //! Return an half-resized image, using a special filter.
-    /**
-       \see resize_halfXY(), resize(), get_resize().
-    **/
-    CImg get_resize_halfXY() const {
-      typedef typename cimg::largest<T,float>::type ftype;
-      if (is_empty()) return CImg<T>();
-      CImg<ftype> mask = CImg<ftype>::matrix(0.07842776544f, 0.1231940459f, 0.07842776544f,
-                                             0.1231940459f,  0.1935127547f, 0.1231940459f,
-                                             0.07842776544f, 0.1231940459f, 0.07842776544f);
-      CImg_3x3(I,ftype);
-      CImg dest(width/2,height/2,depth,dim);
-      cimg_forZV(*this,z,k) cimg_for3x3(*this,x,y,z,k,I)
-        if (x%2 && y%2) dest(x/2,y/2,z,k) = (T)cimg_conv3x3(I,mask);
-      return dest;
-    }
-
-    //! Half-resize the image, using a special filter
-    /**
-       \see get_resize_halfXY(), resize(), get_resize().
-    **/
-    CImg& resize_halfXY() {
-      return get_resize_halfXY().swap(*this);
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param v0 = V-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \param v1 = V-coordinate of the lower-right crop rectangle corner.
-       \param border_condition = Dirichlet (false) or Neumann border conditions.
-       \see crop()
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,const unsigned int v0,
-                  const unsigned int x1,const unsigned int y1,const unsigned int z1,const unsigned int v1,
-                  const bool border_condition = false) const {
-      if (is_empty())
-        throw CImgInstanceException("CImg<%s>::get_crop() : Instance image (%u,%u,%u,%u,%p) is empty.",
-                                    pixel_type(),width,height,depth,dim,data);
-      const unsigned int dx=x1-x0+1, dy=y1-y0+1, dz=z1-z0+1, dv=v1-v0+1;
-      CImg dest(dx,dy,dz,dv);
-      if (x0>=width || x1>=width || y0>=height || y1>=height || z0>=depth || z1>=depth ||
-          v0>=dim || v1>=dim || x1<x0 || y1<y0 || z1<z0 || v1<v0)
-        switch (border_condition) {
-        case false: { cimg_forXYZV(dest,x,y,z,v) dest(x,y,z,v) = pix4d(x0+x,y0+y,z0+z,v0+v,0); } break;
-        default: { cimg_forXYZV(dest,x,y,z,v) dest(x,y,z,v) = pix4d(x0+x,y0+y,z0+z,v0+v); } break;
-        } else {
-          const T *psrc = ptr(x0,y0,z0,v0);
-          T *pdest = dest.ptr(0,0,0,0);
-          if (dx!=width)
-            for (unsigned int k=0; k<dv; k++) {
-              for (unsigned int z=0; z<dz; z++) {
-                for (unsigned int y=0; y<dy; y++) {
-                  std::memcpy(pdest,psrc,dx*sizeof(T));
-                  pdest+=dx;
-                  psrc+=width;
-                }
-                psrc+=width*(height-dy);
-              }
-              psrc+=width*height*(depth-dz);
-            }
-          else {
-            if (dy!=height)
-              for (unsigned int k=0; k<dv; k++) {
-                for (unsigned int z=0; z<dz; z++) {
-                  std::memcpy(pdest,psrc,dx*dy*sizeof(T));
-                  pdest+=dx*dy;
-                  psrc+=width*height;
-                }
-                psrc+=width*height*(depth-dz);
-              }
-            else {
-              if (dz!=depth)
-                for (unsigned int k=0; k<dv; k++) {
-                  std::memcpy(pdest,psrc,dx*dy*dz*sizeof(T));
-                  pdest+=dx*dy*dz;
-                  psrc+=width*height*depth;
-                }
-              else std::memcpy(pdest,psrc,dx*dy*dz*dv*sizeof(T));
-            }
-          }
-        }
-      return dest;
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \param border_condition = determine the type of border condition if
-       some of the desired region is outside the image.
-       \see crop()
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,
-                  const unsigned int x1,const unsigned int y1,const unsigned int z1,
-                  const bool border_condition=false) const {
-      return get_crop(x0,y0,z0,0,x1,y1,z1,dim-1,border_condition);
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param border_condition = determine the type of border condition if
-       some of the desired region is outside the image.
-       \see crop()
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int y0,
-                  const unsigned int x1,const unsigned int y1,
-                  const bool border_condition=false) const {
-      return get_crop(x0,y0,0,0,x1,y1,depth-1,dim-1,border_condition);
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param border_condition = determine the type of border condition if
-       some of the desired region is outside the image.
-       \see crop()
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int x1,const bool border_condition=false) const {
-      return get_crop(x0,0,0,0,x1,height-1,depth-1,dim-1,border_condition);
-    }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param v0 = V-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \param v1 = V-coordinate of the lower-right crop rectangle corner.
-       \param border_condition = determine the type of border condition if
-       some of the desired region is outside the image.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,const unsigned int v0,
-               const unsigned int x1,const unsigned int y1,const unsigned int z1,const unsigned int v1,
-               const bool border_condition=false) {
-      return get_crop(x0,y0,z0,v0,x1,y1,z1,v1,border_condition).swap(*this);
-    }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \param border_condition = determine the type of border condition if
-       some of the desired region is outside the image.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,
-               const unsigned int x1,const unsigned int y1,const unsigned int z1,
-               const bool border_condition=false) {
-      return crop(x0,y0,z0,0,x1,y1,z1,dim-1,border_condition);
-    }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param border_condition = determine the type of border condition if
-       some of the desired region is outside the image.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int y0,
-               const unsigned int x1,const unsigned int y1,
-               const bool border_condition=false) {
-      return crop(x0,y0,0,0,x1,y1,depth-1,dim-1,border_condition);
-    }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param border_condition = determine the type of border condition if
-       some of the desired region is outside the image.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int x1,const bool border_condition=false) {
-      return crop(x0,0,0,0,x1,height-1,depth-1,dim-1,border_condition);
-    }
-
-    //! Return a set of columns
-    CImg get_columns(const unsigned int x0, const unsigned int x1) const {
-      return get_crop(x0,0,0,0,x1,height-1,depth-1,dim-1);
-    }
-
-    //! Replace the instance image by a set of its columns
-    CImg& columns(const unsigned int x0, const unsigned int x1) {
-      return get_columns(x0,x1).swap(*this);
-    }
-
-    //! Return one column
-    CImg get_column(const unsigned int x0) const {
-      return get_columns(x0,x0);
-    }
-
-    //! Replace the instance image by one of its column
-    CImg& column(const unsigned int x0) {
-      return columns(x0,x0);
-    }
-
-    //! Get a copy of a set of lines of the instance image.
-    CImg get_lines(const unsigned int y0, const unsigned int y1) const {
-      return get_crop(0,y0,0,0,width-1,y1,depth-1,dim-1);
-    }
-
-    //! Replace the instance image by a set of lines of the instance image.
-    CImg& lines(const unsigned int y0, const unsigned int y1) {
-      return get_lines(y0,y1).swap(*this);
-    }
-
-    //! Get a copy of a line of the instance image.
-    CImg get_line(const unsigned int y0) const {
-      return get_lines(y0,y0);
-    }
-
-    //! Replace the instance image by one of its line.
-    CImg& line(const unsigned int y0) {
-      return lines(y0,y0);
-    }
-
-    //! Get a set of slices
-    CImg get_slices(const unsigned int z0, const unsigned int z1) const {
-      return get_crop(0,0,z0,0,width-1,height-1,z1,dim-1);
-    }
-
-    // Replace the image by a set of its z-slices
-    CImg& slices(const unsigned int z0, const unsigned int z1) {
-      return get_slices(z0,z1).swap(*this);
-    }
-
-    //! Get the z-slice \a z of *this, as a new image.
-    CImg get_slice(const unsigned int z0) const {
-      return get_slices(z0,z0);
-    }
-
-    //! Replace the image by one of its slice.
-    CImg& slice(const unsigned int z0) {
-      return slices(z0,z0);
-    }
-
-    //! Return a copy of a set of channels of the instance image.
-    CImg get_channels(const unsigned int v0, const unsigned int v1) const {
-      return get_crop(0,0,0,v0,width-1,height-1,depth-1,v1);
-    }
-
-    //! Replace the instance image by a set of channels of the instance image.
-    CImg& channels(const unsigned int v0, const unsigned int v1) {
-      return get_channels(v0,v1).swap(*this);
-    }
-
-    //! Return a copy of a channel of the instance image.
-    CImg get_channel(const unsigned int v0) const {
-      return get_channels(v0,v0);
-    }
-
-    //! Replace the instance image by one of its channel.
-    CImg& channel(const unsigned int v0) {
-      return channels(v0,v0);
-    }
-
-    //! Get a shared-memory image referencing a set of points of the instance image.
-    CImg get_shared_points(const unsigned int x0, const unsigned int x1,
-                           const unsigned int y0=0, const unsigned int z0=0, const unsigned int v0=0) {
-      const unsigned long beg = offset(x0,y0,z0,v0), end = offset(x1,y0,z0,v0);
-      if (beg>end || beg>=size() || end>=size())
-        throw CImgArgumentException("CImg<%s>::get_shared_points() : Cannot return a shared-memory subset (%u->%u,%u,%u,%u) from "
-                                    "a (%u,%u,%u,%u) image.",pixel_type(),x0,x1,y0,z0,v0,width,height,depth,dim);
-      return CImg<T>(data+beg,x1-x0+1,1,1,1,true);
-    }
-
-    //! Get a shared-memory image referencing a set of points of the instance image (const version).
-    const CImg get_shared_points(const unsigned int x0, const unsigned int x1,
-                                 const unsigned int y0=0, const unsigned int z0=0, const unsigned int v0=0) const {
-      const unsigned long beg = offset(x0,y0,z0,v0), end = offset(x1,y0,z0,v0);
-      if (beg>end || beg>=size() || end>=size())
-        throw CImgArgumentException("CImg<%s>::get_shared_points() : Cannot return a shared-memory subset (%u->%u,%u,%u,%u) from "
-                                    "a (%u,%u,%u,%u) image.",pixel_type(),x0,x1,y0,z0,v0,width,height,depth,dim);
-      return CImg<T>(data+beg,x1-x0+1,1,1,1,true);
-    }
-
-    //! Return a shared-memory image referencing a set of lines of the instance image.
-    CImg get_shared_lines(const unsigned int y0, const unsigned int y1,
-                          const unsigned int z0=0, const unsigned int v0=0) {
-      const unsigned long beg = offset(0,y0,z0,v0), end = offset(0,y1,z0,v0);
-      if (beg>end || beg>=size() || end>=size())
-        throw CImgArgumentException("CImg<%s>::get_shared_lines() : Cannot return a shared-memory subset (0->%u,%u->%u,%u,%u) from "
-                                    "a (%u,%u,%u,%u) image.",pixel_type(),width-1,y0,y1,z0,v0,width,height,depth,dim);
-      return CImg<T>(data+beg,width,y1-y0+1,1,1,true);
-    }
-
-    //! Return a shared-memory image referencing a set of lines of the instance image (const version).
-    const CImg get_shared_lines(const unsigned int y0, const unsigned int y1,
-                                const unsigned int z0=0, const unsigned int v0=0) const {
-      const unsigned long beg = offset(0,y0,z0,v0), end = offset(0,y1,z0,v0);
-      if (beg>end || beg>=size() || end>=size())
-        throw CImgArgumentException("CImg<%s>::get_shared_lines() : Cannot return a shared-memory subset (0->%u,%u->%u,%u,%u) from "
-                                    "a (%u,%u,%u,%u) image.",pixel_type(),width-1,y0,y1,z0,v0,width,height,depth,dim);
-      return CImg<T>(data+beg,width,y1-y0+1,1,1,true);
-    }
-
-    //! Return a shared-memory image referencing one particular line (y0,z0,v0) of the instance image.
-    CImg get_shared_line(const unsigned int y0, const unsigned int z0=0, const unsigned int v0=0) {
-      return get_shared_lines(y0,y0,z0,v0);
-    }
-
-    //! Return a shared-memory image referencing one particular line (y0,z0,v0) of the instance image (const version).
-    const CImg get_shared_line(const unsigned int y0,const unsigned int z0=0,const unsigned int v0=0) const {
-      return get_shared_lines(y0,y0,z0,v0);
-    }
-
-    //! Return a shared memory image referencing a set of planes (z0->z1,v0) of the instance image.
-    CImg get_shared_planes(const unsigned int z0, const unsigned int z1, const unsigned int v0=0) {
-      const unsigned long beg = offset(0,0,z0,v0), end = offset(0,0,z1,v0);
-      if (beg>end || beg>=size() || end>=size())
-        throw CImgArgumentException("CImg<%s>::get_shared_planes() : Cannot return a shared-memory subset (0->%u,0->%u,%u->%u,%u) from "
-                                    "a (%u,%u,%u,%u) image.",pixel_type(),width-1,height-1,z0,z1,v0,width,height,depth,dim);
-      return CImg<T>(data+beg,width,height,z1-z0+1,1,true);
-    }
-
-    //! Return a shared-memory image referencing a set of planes (z0->z1,v0) of the instance image (const version).
-    const CImg get_shared_planes(const unsigned int z0, const unsigned int z1, const unsigned int v0=0) const {
-      const unsigned long beg = offset(0,0,z0,v0), end = offset(0,0,z1,v0);
-      if (beg>end || beg>=size() || end>=size())
-        throw CImgArgumentException("CImg<%s>::get_shared_planes() : Cannot return a shared-memory subset (0->%u,0->%u,%u->%u,%u) from "
-                                    "a (%u,%u,%u,%u) image.",pixel_type(),width-1,height-1,z0,z1,v0,width,height,depth,dim);
-      return CImg<T>(data+beg,width,height,z1-z0+1,1,true);
-    }
-
-    //! Return a shared-memory image referencing one plane (z0,v0) of the instance image.
-    CImg get_shared_plane(const unsigned int z0, const unsigned int v0=0) {
-      return get_shared_planes(z0,z0,v0);
-    }
-
-    //! Return a shared-memory image referencing one plane (z0,v0) of the instance image (const version).
-    const CImg get_shared_plane(const unsigned int z0, const unsigned int v0=0) const {
-      return get_shared_planes(z0,z0,v0);
-    }
-
-    //! Return a shared-memory image referencing a set of channels (v0->v1) of the instance image.
-    CImg get_shared_channels(const unsigned int v0, const unsigned int v1) {
-      const unsigned long beg = offset(0,0,0,v0), end = offset(0,0,0,v1);
-      if (beg>end || beg>=size() || end>=size())
-        throw CImgArgumentException("CImg<%s>::get_shared_channels() : Cannot return a shared-memory subset (0->%u,0->%u,0->%u,%u->%u) from "
-                                    "a (%u,%u,%u,%u) image.",pixel_type(),width-1,height-1,depth-1,v0,v1,width,height,depth,dim);
-      return CImg<T>(data+beg,width,height,depth,v1-v0+1,true);
-    }
-
-    //! Return a shared-memory image referencing a set of channels (v0->v1) of the instance image (const version).
-    const CImg get_shared_channels(const unsigned int v0, const unsigned int v1) const {
-      const unsigned long beg = offset(0,0,0,v0), end = offset(0,0,0,v1);
-      if (beg>end || beg>=size() || end>=size())
-        throw CImgArgumentException("CImg<%s>::get_shared_channels() : Cannot return a shared-memory subset (0->%u,0->%u,0->%u,%u->%u) from "
-                                    "a (%u,%u,%u,%u) image.",pixel_type(),width-1,height-1,depth-1,v0,v1,width,height,depth,dim);
-      return CImg<T>(data+beg,width,height,depth,v1-v0+1,true);
-    }
-
-    //! Return a shared-memory image referencing one channel v0 of the instance image.
-    CImg get_shared_channel(const unsigned int v0) {
-      return get_shared_channels(v0,v0);
-    }
-
-    //! Return a shared-memory image referencing one channel v0 of the instance image (const version).
-    const CImg get_shared_channel(const unsigned int v0) const {
-      return get_shared_channels(v0,v0);
-    }
-
-    //! Return a shared version of the instance image.
-    CImg get_shared() {
-      return CImg<T>(data,width,height,depth,dim,true);
-    }
-
-    //! Return a shared version of the instance image (const version).
-    const CImg get_shared() const {
-      return CImg<T>(data,width,height,depth,dim,true);
-    }
-
-    //! Mirror an image along the specified axis.
-    /**
-       This is the in-place version of get_mirror().
-       \sa get_mirror().
-    **/
-    CImg& mirror(const char axe='x') {
-      if (!is_empty()) {
-        T *pf,*pb,*buf=0;
-        switch (cimg::uncase(axe)) {
-        case 'x': {
-          pf = ptr(); pb = ptr(width-1);
-          for (unsigned int yzv=0; yzv<height*depth*dim; yzv++) {
-            for (unsigned int x=0; x<width/2; x++) { const T val = *pf; *(pf++)=*pb; *(pb--)=val; }
-            pf+=width-width/2;
-            pb+=width+width/2;
-          }
-        } break;
-        case 'y': {
-          buf = new T[width];
-          pf = ptr(); pb = ptr(0,height-1);
-          for (unsigned int zv=0; zv<depth*dim; zv++) {
-            for (unsigned int y=0; y<height/2; y++) {
-              std::memcpy(buf,pf,width*sizeof(T));
-              std::memcpy(pf,pb,width*sizeof(T));
-              std::memcpy(pb,buf,width*sizeof(T));
-              pf+=width;
-              pb-=width;
-            }
-            pf+=width*(height-height/2);
-            pb+=width*(height+height/2);
-          }
-        } break;
-        case 'z': {
-          buf = new T[width*height];
-          pf = ptr(); pb = ptr(0,0,depth-1);
-          cimg_forV(*this,v) {
-            for (unsigned int z=0; z<depth/2; z++) {
-              std::memcpy(buf,pf,width*height*sizeof(T));
-              std::memcpy(pf,pb,width*height*sizeof(T));
-              std::memcpy(pb,buf,width*height*sizeof(T));
-              pf+=width*height;
-              pb-=width*height;
-            }
-            pf+=width*height*(depth-depth/2);
-            pb+=width*height*(depth+depth/2);
-          }
-        } break;
-        case 'v': {
-          buf = new T[width*height*depth];
-          pf = ptr(); pb = ptr(0,0,0,dim-1);
-          for (unsigned int v=0; v<dim/2; v++) {
-            std::memcpy(buf,pf,width*height*depth*sizeof(T));
-            std::memcpy(pf,pb,width*height*depth*sizeof(T));
-            std::memcpy(pb,buf,width*height*depth*sizeof(T));
-            pf+=width*height*depth;
-            pb-=width*height*depth;
-          }
-        } break;
-        default:
-          throw CImgArgumentException("CImg<%s>::mirror() : unknow axe '%c', must be 'x','y','z' or 'v'",pixel_type(),axe);
-        }
-        if (buf) delete[] buf;
-      }
-      return *this;
-    }
-
-    //! Get a mirrored version of the image, along the specified axis.
-    /**
-       \param axe Axe used to mirror the image. Can be \c 'x', \c 'y', \c 'z' or \c 'v'.
-       \sa mirror().
-    **/
-    CImg get_mirror(const char axe='x') {
-      return (+*this).mirror(axe);
-    }
-
-    //! Translate the image
-    /**
-       This is the in-place version of get_translate().
-       \sa get_translate().
-    **/
-    CImg& translate(const int deltax,const int deltay=0,const int deltaz=0,const int deltav=0,const int border_condition=0) {
-      if (!is_empty()) {
-
-        if (deltax) // Translate along X-axis
-          switch (border_condition) {
-          case 0:
-            if (cimg::abs(deltax)>=(int)width) return fill(0);
-            if (deltax>0) cimg_forYZV(*this,y,z,k) {
-              std::memmove(ptr(0,y,z,k),ptr(deltax,y,z,k),(width-deltax)*sizeof(T));
-              std::memset(ptr(width-deltax,y,z,k),0,deltax*sizeof(T));
-            } else cimg_forYZV(*this,y,z,k) {
-              std::memmove(ptr(-deltax,y,z,k),ptr(0,y,z,k),(width+deltax)*sizeof(T));
-              std::memset(ptr(0,y,z,k),0,-deltax*sizeof(T));
-            }
-            break;
-          case 1:
-            if (deltax>0) {
-              const int ndeltax = (deltax>=(int)width)?width-1:deltax;
-              if (!ndeltax) return *this;
-              cimg_forYZV(*this,y,z,k) {
-                std::memmove(ptr(0,y,z,k),ptr(ndeltax,y,z,k),(width-ndeltax)*sizeof(T));
-                T *ptrd = ptr(width-1,y,z,k);
-                const T &val = *ptrd;
-                for (int l=0; l<ndeltax-1; l++) *(--ptrd) = val;
-              }
-            } else {
-              const int ndeltax = (-deltax>=(int)width)?width-1:-deltax;
-              if (!ndeltax) return *this;
-              cimg_forYZV(*this,y,z,k) {
-                std::memmove(ptr(ndeltax,y,z,k),ptr(0,y,z,k),(width-ndeltax)*sizeof(T));
-                T *ptrd = ptr(0,y,z,k);
-                const T &val = *ptrd;
-                for (int l=0; l<ndeltax-1; l++) *(++ptrd) = val;
-              }
-            }
-            break;
-          case 2: {
-            const int ml = cimg::mod(deltax,width), ndeltax = (ml<=(int)width/2)?ml:(ml-(int)width);
-            if (!ndeltax) return *this;
-            T* buf = new T[cimg::abs(ndeltax)];
-            if (ndeltax>0) cimg_forYZV(*this,y,z,k) {
-              std::memcpy(buf,ptr(0,y,z,k),ndeltax*sizeof(T));
-              std::memmove(ptr(0,y,z,k),ptr(ndeltax,y,z,k),(width-ndeltax)*sizeof(T));
-              std::memcpy(ptr(width-ndeltax,y,z,k),buf,ndeltax*sizeof(T));
-            } else cimg_forYZV(*this,y,z,k) {
-              std::memcpy(buf,ptr(width+ndeltax,y,z,k),-ndeltax*sizeof(T));
-              std::memmove(ptr(-ndeltax,y,z,k),ptr(0,y,z,k),(width+ndeltax)*sizeof(T));
-              std::memcpy(ptr(0,y,z,k),buf,-ndeltax*sizeof(T));
-            }
-            delete[] buf;
-          } break;
-          }
-
-        if (deltay) // Translate along Y-axis
-          switch (border_condition) {
-          case 0:
-            if (cimg::abs(deltay)>=(int)height) return fill(0);
-            if (deltay>0) cimg_forZV(*this,z,k) {
-              std::memmove(ptr(0,0,z,k),ptr(0,deltay,z,k),width*(height-deltay)*sizeof(T));
-              std::memset(ptr(0,height-deltay,z,k),0,width*deltay*sizeof(T));
-            } else cimg_forZV(*this,z,k) {
-              std::memmove(ptr(0,-deltay,z,k),ptr(0,0,z,k),width*(height+deltay)*sizeof(T));
-              std::memset(ptr(0,0,z,k),0,-deltay*width*sizeof(T));
-            }
-            break;
-          case 1:
-            if (deltay>0) {
-              const int ndeltay = (deltay>=(int)height)?height-1:deltay;
-              if (!ndeltay) return *this;
-              cimg_forZV(*this,z,k) {
-                std::memmove(ptr(0,0,z,k),ptr(0,ndeltay,z,k),width*(height-ndeltay)*sizeof(T));
-                T *ptrd = ptr(0,height-ndeltay,z,k), *ptrs = ptr(0,height-1,z,k);
-                for (int l=0; l<ndeltay-1; l++) { std::memcpy(ptrd,ptrs,width*sizeof(T)); ptrd+=width; }
-              }
-            } else {
-              const int ndeltay = (-deltay>=(int)height)?height-1:-deltay;
-              if (!ndeltay) return *this;
-              cimg_forZV(*this,z,k) {
-                std::memmove(ptr(0,ndeltay,z,k),ptr(0,0,z,k),width*(height-ndeltay)*sizeof(T));
-                T *ptrd = ptr(0,1,z,k), *ptrs = ptr(0,0,z,k);
-                for (int l=0; l<ndeltay-1; l++) { std::memcpy(ptrd,ptrs,width*sizeof(T)); ptrd+=width; }
-              }
-            }
-            break;
-          case 2: {
-            const int ml = cimg::mod(deltay,height), ndeltay = (ml<=(int)height/2)?ml:(ml-(int)height);
-            if (!ndeltay) return *this;
-            T* buf = new T[width*cimg::abs(ndeltay)];
-            if (ndeltay>0) cimg_forZV(*this,z,k) {
-              std::memcpy(buf,ptr(0,0,z,k),width*ndeltay*sizeof(T));
-              std::memmove(ptr(0,0,z,k),ptr(0,ndeltay,z,k),width*(height-ndeltay)*sizeof(T));
-              std::memcpy(ptr(0,height-ndeltay,z,k),buf,width*ndeltay*sizeof(T));
-            } else cimg_forZV(*this,z,k) {
-              std::memcpy(buf,ptr(0,height+ndeltay,z,k),-ndeltay*width*sizeof(T));
-              std::memmove(ptr(0,-ndeltay,z,k),ptr(0,0,z,k),width*(height+ndeltay)*sizeof(T));
-              std::memcpy(ptr(0,0,z,k),buf,-ndeltay*width*sizeof(T));
-            }
-            delete[] buf;
-          } break;
-          }
-
-        if (deltaz) // Translate along Z-axis
-          switch (border_condition) {
-          case 0:
-            if (cimg::abs(deltaz)>=(int)depth) return fill(0);
-            if (deltaz>0) cimg_forV(*this,k) {
-              std::memmove(ptr(0,0,0,k),ptr(0,0,deltaz,k),width*height*(depth-deltaz)*sizeof(T));
-              std::memset(ptr(0,0,depth-deltaz,k),0,width*height*deltaz*sizeof(T));
-            } else cimg_forV(*this,k) {
-              std::memmove(ptr(0,0,-deltaz,k),ptr(0,0,0,k),width*height*(depth+deltaz)*sizeof(T));
-              std::memset(ptr(0,0,0,k),0,-deltaz*width*height*sizeof(T));
-            }
-            break;
-          case 1:
-            if (deltaz>0) {
-              const int ndeltaz = (deltaz>=(int)depth)?depth-1:deltaz;
-              if (!ndeltaz) return *this;
-              cimg_forV(*this,k) {
-                std::memmove(ptr(0,0,0,k),ptr(0,0,ndeltaz,k),width*height*(depth-ndeltaz)*sizeof(T));
-                T *ptrd = ptr(0,0,depth-ndeltaz,k), *ptrs = ptr(0,0,depth-1,k);
-                for (int l=0; l<ndeltaz-1; l++) { std::memcpy(ptrd,ptrs,width*height*sizeof(T)); ptrd+=width*height; }
-              }
-            } else {
-              const int ndeltaz = (-deltaz>=(int)depth)?depth-1:-deltaz;
-              if (!ndeltaz) return *this;
-              cimg_forV(*this,k) {
-                std::memmove(ptr(0,0,ndeltaz,k),ptr(0,0,0,k),width*height*(depth-ndeltaz)*sizeof(T));
-                T *ptrd = ptr(0,0,1,k), *ptrs = ptr(0,0,0,k);
-                for (int l=0; l<ndeltaz-1; l++) { std::memcpy(ptrd,ptrs,width*height*sizeof(T)); ptrd+=width*height; }
-              }
-            }
-            break;
-          case 2: {
-            const int ml = cimg::mod(deltaz,depth), ndeltaz = (ml<=(int)depth/2)?ml:(ml-(int)depth);
-            if (!ndeltaz) return *this;
-            T* buf = new T[width*height*cimg::abs(ndeltaz)];
-            if (ndeltaz>0) cimg_forV(*this,k) {
-              std::memcpy(buf,ptr(0,0,0,k),width*height*ndeltaz*sizeof(T));
-              std::memmove(ptr(0,0,0,k),ptr(0,0,ndeltaz,k),width*height*(depth-ndeltaz)*sizeof(T));
-              std::memcpy(ptr(0,0,depth-ndeltaz,k),buf,width*height*ndeltaz*sizeof(T));
-            } else cimg_forV(*this,k) {
-              std::memcpy(buf,ptr(0,0,depth+ndeltaz,k),-ndeltaz*width*height*sizeof(T));
-              std::memmove(ptr(0,0,-ndeltaz,k),ptr(0,0,0,k),width*height*(depth+ndeltaz)*sizeof(T));
-              std::memcpy(ptr(0,0,0,k),buf,-ndeltaz*width*height*sizeof(T));
-            }
-            delete[] buf;
-          } break;
-          }
-
-        if (deltav) // Translate along V-axis
-          switch (border_condition) {
-          case 0:
-            if (cimg::abs(deltav)>=(int)dim) return fill(0);
-            if (deltav>0) {
-              std::memmove(data,ptr(0,0,0,deltav),width*height*depth*(dim-deltav)*sizeof(T));
-              std::memset(ptr(0,0,0,dim-deltav),0,width*height*depth*deltav*sizeof(T));
-            } else cimg_forV(*this,k) {
-              std::memmove(ptr(0,0,0,-deltav),data,width*height*depth*(dim+deltav)*sizeof(T));
-              std::memset(data,0,-deltav*width*height*depth*sizeof(T));
-            }
-            break;
-          case 1:
-            if (deltav>0) {
-              const int ndeltav = (deltav>=(int)dim)?dim-1:deltav;
-              if (!ndeltav) return *this;
-              std::memmove(data,ptr(0,0,0,ndeltav),width*height*depth*(dim-ndeltav)*sizeof(T));
-              T *ptrd = ptr(0,0,0,dim-ndeltav), *ptrs = ptr(0,0,0,dim-1);
-              for (int l=0; l<ndeltav-1; l++) { std::memcpy(ptrd,ptrs,width*height*depth*sizeof(T)); ptrd+=width*height*depth; }
-            } else {
-              const int ndeltav = (-deltav>=(int)dim)?dim-1:-deltav;
-              if (!ndeltav) return *this;
-              std::memmove(ptr(0,0,0,ndeltav),data,width*height*depth*(dim-ndeltav)*sizeof(T));
-              T *ptrd = ptr(0,0,0,1);
-              for (int l=0; l<ndeltav-1; l++) { std::memcpy(ptrd,data,width*height*depth*sizeof(T)); ptrd+=width*height*depth; }
-            }
-            break;
-          case 2: {
-            const int ml = cimg::mod(deltav,dim), ndeltav = (ml<=(int)dim/2)?ml:(ml-(int)dim);
-            if (!ndeltav) return *this;
-            T* buf = new T[width*height*depth*cimg::abs(ndeltav)];
-            if (ndeltav>0) {
-              std::memcpy(buf,data,width*height*depth*ndeltav*sizeof(T));
-              std::memmove(data,ptr(0,0,0,ndeltav),width*height*depth*(dim-ndeltav)*sizeof(T));
-              std::memcpy(ptr(0,0,0,dim-ndeltav),buf,width*height*depth*ndeltav*sizeof(T));
-            } else {
-              std::memcpy(buf,ptr(0,0,0,dim+ndeltav),-ndeltav*width*height*depth*sizeof(T));
-              std::memmove(ptr(0,0,0,-ndeltav),data,width*height*depth*(dim+ndeltav)*sizeof(T));
-              std::memcpy(data,buf,-ndeltav*width*height*depth*sizeof(T));
-            }
-            delete[] buf;
-          } break;
-          }
-      }
-      return *this;
-    }
-
-    //! Return a translated image.
-    /**
-       \param deltax Amount of displacement along the X-axis.
-       \param deltay Amount of displacement along the Y-axis.
-       \param deltaz Amount of displacement along the Z-axis.
-       \param deltav Amount of displacement along the V-axis.
-       \param border_condition Border condition.
-
-       - \c border_condition can be :
-          - 0 : Zero border condition (Dirichlet).
-          - 1 : Nearest neighbors (Neumann).
-          - 2 : Repeat Pattern (Fourier style).
-    **/
-    CImg get_translate(const int deltax,const int deltay=0,const int deltaz=0,const int deltav=0,
-                    const int border_condition=0) const {
-      return (+*this).translate(deltax,deltay,deltaz,deltav,border_condition);
-    }
-
-    //! Return a 2D representation of a 3D image, with three slices.
-    CImg get_projections2d(const unsigned int px0,const unsigned int py0,const unsigned int pz0) const {
-      if (is_empty()) return CImg<T>();
-      const unsigned int
-        x0=(px0>=width)?width-1:px0,
-        y0=(py0>=height)?height-1:py0,
-        z0=(pz0>=depth)?depth-1:pz0;
-      CImg res(width+depth,height+depth,1,dim);
-      res.fill((*this)[0]);
-      { cimg_forXYV(*this,x,y,k) res(x,y,0,k)        = (*this)(x,y,z0,k); }
-      { cimg_forYZV(*this,y,z,k) res(width+z,y,0,k)  = (*this)(x0,y,z,k); }
-      { cimg_forXZV(*this,x,z,k) res(x,height+z,0,k) = (*this)(x,y0,z,k); }
-      return res;
-    }
-
-    //! Return the image histogram.
-    /**
-       The histogram H of an image I is a 1D-function where H(x) is the number of
-       occurences of the value x in I.
-       \param nblevels = Number of different levels of the computed histogram.
-       For classical images, this value is 256 (default value). You should specify more levels
-       if you are working with CImg<float> or images with high range of pixel values.
-       \param val_min = Minimum value considered for the histogram computation. All pixel values lower than val_min
-       won't be counted.
-       \param val_max = Maximum value considered for the histogram computation. All pixel values higher than val_max
-       won't be counted.
-       \note If val_min==val_max==0 (default values), the function first estimates the minimum and maximum
-       pixel values of the current image, then uses these values for the histogram computation.
-       \result The histogram is returned as a 1D CImg<float> image H, having a size of (nblevels,1,1,1) such that
-       H(0) and H(nblevels-1) are respectively equal to the number of occurences of the values val_min and val_max in I.
-       \note Histogram computation always returns a 1D function. Histogram of multi-valued (such as color) images
-       are not multi-dimensional.
-       \see get_equalize_histogram(), equalize_histogram()
-    **/
-    CImg<float> get_histogram(const unsigned int nblevels=256,const T val_min=(T)0,const T val_max=(T)0) const {
-      if (is_empty()) return CImg<float>();
-      if (nblevels<1)
-        throw CImgArgumentException("CImg<%s>::get_histogram() : Can't compute an histogram with %u levels",
-                                    pixel_type(),nblevels);
-      T vmin=val_min, vmax=val_max;
-      CImg<float> res(nblevels,1,1,1,0);
-      if (vmin==vmax && vmin==0) { const CImgStats st(*this,false); vmin = (T)st.min; vmax = (T)st.max; }
-      cimg_for(*this,ptr,T) {
-        const int pos = (int)((*ptr-vmin)*(nblevels-1)/(vmax-vmin));
-        if (pos>=0 && pos<(int)nblevels) res[pos]++;
-      }
-      return res;
-    }
-
-    //! Equalize the image histogram
-    /** This is the in-place version of \ref get_equalize_histogram() **/
-    CImg& equalize_histogram(const unsigned int nblevels=256,const T val_min=(T)0,const T val_max=(T)0) {
-      if (!is_empty()) {
-        T vmin=val_min, vmax=val_max;
-        if (vmin==vmax && vmin==0) { const CImgStats st(*this,false); vmin = (T)st.min; vmax = (T)st.max; }
-        CImg<float> hist = get_histogram(nblevels,vmin,vmax);
-        float cumul=0;
-        cimg_forX(hist,pos) { cumul+=hist[pos]; hist[pos]=cumul; }
-        cimg_for(*this,ptr,T) {
-          const int pos = (unsigned int)((*ptr-vmin)*(nblevels-1)/(vmax-vmin));
-          if (pos>=0 && pos<(int)nblevels) *ptr = (T)(vmin + (vmax-vmin)*hist[pos]/size());
-        }
-      }
-      return *this;
-    }
-
-    //! Return the histogram-equalized version of the current image.
-    /**
-       The histogram equalization is a classical image processing algorithm that enhances the image contrast
-       by expanding its histogram.
-       \param nblevels = Number of different levels of the computed histogram.
-       For classical images, this value is 256 (default value). You should specify more levels
-       if you are working with CImg<float> or images with high range of pixel values.
-       \param val_min = Minimum value considered for the histogram computation. All pixel values lower than val_min
-       won't be changed.
-       \param val_max = Maximum value considered for the histogram computation. All pixel values higher than val_max
-       won't be changed.
-       \note If val_min==val_max==0 (default values), the function acts on all pixel values of the image.
-       \return A new image with same size is returned, where pixels have been equalized.
-       \see get_histogram(), equalize_histogram()
-    **/
-    CImg get_equalize_histogram(const unsigned int nblevels=256,const T val_min=(T)0,const T val_max=(T)0) const {
-      return (+*this).equalize_histogram(nblevels,val_min,val_max);
-    }
-
-    //! Return the scalar image of vector norms.
-    /**
-       When dealing with vector-valued images (i.e images with dimv()>1), this function computes the L1,L2 or Linf norm of each
-       vector-valued pixel.
-       \param norm_type = Type of the norm being computed (1 = L1, 2 = L2, -1 = Linf).
-       \return A scalar-valued image CImg<float> with size (dimx(),dimy(),dimz(),1), where each pixel is the norm
-       of the corresponding pixels in the original vector-valued image.
-       \see get_orientation_pointwise, orientation_pointwise, norm_pointwise.
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_norm_pointwise(int norm_type=2) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      if (is_empty()) return CImg<restype>();
-      CImg<restype> res(width,height,depth);
-      switch(norm_type) {
-      case -1: {             // Linf norm
-        cimg_forXYZ(*this,x,y,z) {
-          restype n=0; cimg_forV(*this,v) {
-            const restype tmp = (restype)cimg::abs((*this)(x,y,z,v));
-            if (tmp>n) n=tmp; res(x,y,z) = n;
-          }
-        }
-      } break;
-      case 1: {              // L1 norm
-        cimg_forXYZ(*this,x,y,z) {
-          restype n=0; cimg_forV(*this,v) n+=cimg::abs((*this)(x,y,z,v)); res(x,y,z) = n;
-        }
-      } break;
-      default: {             // L2 norm
-        cimg_forXYZ(*this,x,y,z) {
-          restype n=0; cimg_forV(*this,v) n+=(*this)(x,y,z,v)*(*this)(x,y,z,v); res(x,y,z) = (restype)std::sqrt((double)n);
-        }
-      } break;
-      }
-      return res;
-    }
-
-    //! Replace each pixel value with its vector norm.
-    /**
-       This is the in-place version of \ref get_norm_pointwise().
-       \note Be careful when using this function on CImg<T> with T=char, unsigned char,unsigned int or int. The vector norm
-       is usually a floating point value, and a rough cast will be done here.
-    **/
-    CImg& norm_pointwise() {
-      return CImg<T>(get_norm_pointwise()).swap(*this);
-    }
-
-    //! Return the image of normalized vectors
-    /**
-       When dealing with vector-valued images (i.e images with dimv()>1), this function return the image of normalized vectors
-       (unit vectors). Null vectors are unchanged. The L2-norm is computed for the normalization.
-       \return A new vector-valued image with same size, where each vector-valued pixels have been normalized.
-       \see get_norm_pointwise, norm_pointwise, orientation_pointwise.
-    **/
-    CImg<typename cimg::largest<T,float>::type> get_orientation_pointwise() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      if (is_empty()) return CImg<restype>();
-      return CImg<restype>(*this,false).orientation_pointwise();
-    }
-
-    //! Replace each pixel value by its normalized vector
-    /** This is the in-place version of \ref get_orientation_pointwise() **/
-    CImg& orientation_pointwise() {
-      cimg_forXYZ(*this,x,y,z) {
-        float n = 0.0f;
-        cimg_forV(*this,v) n+=(float)((*this)(x,y,z,v)*(*this)(x,y,z,v));
-        n = (float)std::sqrt(n);
-        if (n>0) cimg_forV(*this,v) (*this)(x,y,z,v)=(T)((*this)(x,y,z,v)/n);
-        else cimg_forV(*this,v) (*this)(x,y,z,v)=0;
-      }
-      return *this;
-    }
-
-    //! Split image into a list CImgList<>.
-    CImgList<T> get_split(const char axe='x', const unsigned int nb=0) const {
-      if (is_empty()) return CImgList<T>();
-      CImgList<T> res;
-      switch (cimg::uncase(axe)) {
-      case 'x': {
-        if (nb>width)
-          throw CImgArgumentException("CImg<%s>::get_split() : Cannot split instance image (%u,%u,%u,%u,%p) along 'x' into %u images.",
-                                      pixel_type(),width,height,depth,dim,data,nb);
-        res.assign(nb?nb:width);
-        const unsigned int delta = width/res.size + ((width%res.size)?1:0);
-        unsigned int l,x;
-        for (l=0, x=0; l<res.size-1; l++, x+=delta) res[l] = get_crop(x,0,0,0,x+delta-1,height-1,depth-1,dim-1);
-        res[res.size-1] = get_crop(x,0,0,0,width-1,height-1,depth-1,dim-1);
-      } break;
-      case 'y': {
-        if (nb>height)
-          throw CImgArgumentException("CImg<%s>::get_split() : Cannot split instance image (%u,%u,%u,%u,%p) along 'y' into %u images.",
-                                      pixel_type(),width,height,depth,dim,data,nb);
-        res.assign(nb?nb:height);
-        const unsigned int delta = height/res.size + ((height%res.size)?1:0);
-        unsigned int l,x;
-        for (l=0, x=0; l<res.size-1; l++, x+=delta) res[l] = get_crop(0,x,0,0,width-1,x+delta-1,depth-1,dim-1);
-        res[res.size-1] = get_crop(0,x,0,0,width-1,height-1,depth-1,dim-1);
-      } break;
-      case 'z': {
-        if (nb>depth)
-          throw CImgArgumentException("CImg<%s>::get_split() : Cannot split instance image (%u,%u,%u,%u,%p) along 'z' into %u images.",
-                                      pixel_type(),width,height,depth,dim,data,nb);
-        res.assign(nb?nb:depth);
-        const unsigned int delta = depth/res.size + ((depth%res.size)?1:0);
-        unsigned int l,x;
-        for (l=0, x=0; l<res.size-1; l++, x+=delta) res[l] = get_crop(0,0,x,0,width-1,height-1,x+delta-1,dim-1);
-        res[res.size-1] = get_crop(0,0,x,0,width-1,height-1,depth-1,dim-1);
-      } break;
-      case 'v': {
-        if (nb>dim)
-          throw CImgArgumentException("CImg<%s>::get_split() : Cannot split instance image (%u,%u,%u,%u,%p) along 'v' into %u images.",
-                                      pixel_type(),width,height,depth,dim,data,nb);
-        res.assign(nb?nb:dim);
-        const unsigned int delta = dim/res.size + ((dim%res.size)?1:0);
-        unsigned int l,x;
-        for (l=0, x=0; l<res.size-1; l++, x+=delta) res[l] = get_crop(0,0,0,x,width-1,height-1,depth-1,x+delta-1);
-        res[res.size-1] = get_crop(0,0,0,x,width-1,height-1,depth-1,dim-1);
-      } break;
-      default:
-        throw CImgArgumentException("CImg<%s>::get_split() : Unknow axe '%c', must be 'x','y','z' or 'v'",pixel_type(),axe);
-        break;
-      }
-      return res;
-    }
-
-    //! Append an image to another one
-    CImg get_append(const CImg<T>& img, const char axis='x', const char align='c') const {
-      if (img.is_empty()) return *this;
-      if (is_empty()) return img;
-      CImgList<T> temp(2);
-      temp[0].width = width; temp[0].height = height; temp[0].depth = depth;
-      temp[0].dim = dim; temp[0].data = data;
-      temp[1].width = img.width; temp[1].height = img.height; temp[1].depth = img.depth;
-      temp[1].dim = img.dim; temp[1].data = img.data;
-      const CImg<T> res = temp.get_append(axis,align);
-      temp[0].width = temp[0].height = temp[0].depth = temp[0].dim = 0; temp[0].data = 0;
-      temp[1].width = temp[1].height = temp[1].depth = temp[1].dim = 0; temp[1].data = 0;
-      return res;
-    }
-
-    //! Append an image to another one (in-place version)
-    CImg& append(const CImg<T>& img, const char axis='x', const char align='c') {
-      if (img.is_empty()) return *this;
-      if (is_empty()) return (*this=img);
-      return get_append(img,axis,align).swap(*this);
-    }
-
-    //! Return a list of images, corresponding to the XY-gradients of an image.
-    /**
-       \param scheme = Numerical scheme used for the gradient computation :
-       - -1 = Backward finite differences
-       - 0 = Centered finite differences
-       - 1 = Forward finite differences
-       - 2 = Using Sobel masks
-       - 3 = Using rotation invariant masks
-       - 4 = Using Deriche recusrsive filter.
-    **/
-    CImgList<typename cimg::largest<T,float>::type> get_gradientXY(const int scheme=0) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      if (is_empty()) return CImgList<restype>(2);
-      CImgList<restype> res(2,width,height,depth,dim);
-      switch(scheme) {
-      case -1: { // backward finite differences
-        CImg_3x3(I,restype);
-        cimg_forZV(*this,z,k) cimg_for3x3(*this,x,y,z,k,I) { res[0](x,y,z,k) = Icc-Ipc; res[1](x,y,z,k) = Icc-Icp; }
-      } break;
-      case 1: { // forward finite differences
-        CImg_2x2(I,restype);
-        cimg_forZV(*this,z,k) cimg_for2x2(*this,x,y,z,k,I) { res[0](x,y,0,k) = Inc-Icc; res[1](x,y,z,k) = Icn-Icc; }
-      } break;
-      case 2: { // using Sobel mask
-        CImg_3x3(I,restype);
-        const float a = 1, b = 2;
-        cimg_forZV(*this,z,k) cimg_for3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = -a*Ipp-b*Ipc-a*Ipn+a*Inp+b*Inc+a*Inn;
-          res[1](x,y,z,k) = -a*Ipp-b*Icp-a*Inp+a*Ipn+b*Icn+a*Inn;
-        }
-      } break;
-      case 3: { // using rotation invariant mask
-        CImg_3x3(I,restype);
-        const float a = (float)(0.25*(2-std::sqrt(2.0))), b = (float)(0.5f*(std::sqrt(2.0)-1));
-        cimg_forZV(*this,z,k) cimg_for3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = -a*Ipp-b*Ipc-a*Ipn+a*Inp+b*Inc+a*Inn;
-          res[1](x,y,z,k) = -a*Ipp-b*Icp-a*Inp+a*Ipn+b*Icn+a*Inn;
-        }
-      } break;
-      case 4: { // using Deriche filter with low standard variation
-        res[0] = get_deriche(0,1,'x');
-        res[1] = get_deriche(0,1,'y');
-      } break;
-      default: { // central finite differences
-        CImg_3x3(I,restype);
-        cimg_forZV(*this,z,k) cimg_for3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = 0.5f*(Inc-Ipc);
-          res[1](x,y,z,k) = 0.5f*(Icn-Icp);
-        }
-      } break;
-      }
-      return res;
-    }
-
-    //! Return a list of images, corresponding to the XYZ-gradients of an image.
-    /**
-       \see get_gradientXY().
-    **/
-    CImgList<typename cimg::largest<T,float>::type> get_gradientXYZ(const int scheme=0) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      if (is_empty()) return CImgList<restype>(3);
-      CImgList<restype> res(3,width,height,depth,dim);
-      CImg_3x3x3(I,restype);
-      switch(scheme) {
-      case -1: { // backward finite differences
-        cimg_forV(*this,k) cimg_for3x3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = Iccc-Ipcc;
-          res[1](x,y,z,k) = Iccc-Icpc;
-          res[2](x,y,z,k) = Iccc-Iccp;
-        }
-      } break;
-      case 1: { // forward finite differences
-        cimg_forV(*this,k) cimg_for3x3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = Incc-Iccc;
-          res[1](x,y,z,k) = Icnc-Iccc;
-          res[2](x,y,z,k) = Iccn-Iccc;
-        }
-      } break;
-      case 4: { // using Deriche filter with low standard variation
-        res[0] = get_deriche(0,1,'x');
-        res[1] = get_deriche(0,1,'y');
-        res[2] = get_deriche(0,1,'z');
-      } break;
-      default: { // central finite differences
-        cimg_forV(*this,k) cimg_for3x3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = 0.5f*(Incc-Ipcc);
-          res[1](x,y,z,k) = 0.5f*(Icnc-Icpc);
-          res[2](x,y,z,k) = 0.5f*(Iccn-Iccp);
-        }
-      } break;
-      }
-      return res;
-    }
-
-    //! Return the 2D structure tensor field of an image
-    CImg<typename cimg::largest<T,float>::type> get_structure_tensorXY(const int scheme=1) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      if (is_empty()) return CImg<restype>();
-      CImg<restype> res(width,height,depth,3,0);
-      CImg_3x3(I,restype);
-      switch (scheme) {
-      case 0: { // classical central finite differences
-        cimg_forZV(*this,z,k) cimg_for3x3(*this,x,y,0,k,I) {
-          const restype
-            ix = 0.5f*(Inc-Ipc),
-            iy = 0.5f*(Icn-Icp);
-          res(x,y,z,0)+=ix*ix;
-          res(x,y,z,1)+=ix*iy;
-          res(x,y,z,2)+=iy*iy;
-        }
-      } break;
-      default: { // Precise forward/backward finite differences
-        cimg_forZV(*this,z,k) cimg_for3x3(*this,x,y,0,k,I) {
-          const restype
-            ixf = Inc-Icc, ixb = Icc-Ipc,
-            iyf = Icn-Icc, iyb = Icc-Icp;
-          res(x,y,z,0) += 0.5f*(ixf*ixf+ixb*ixb);
-          res(x,y,z,1) += 0.25f*(ixf*iyf+ixf*iyb+ixb*iyf+ixb*iyb);
-          res(x,y,z,2) += 0.5f*(iyf*iyf+iyb*iyb);
-        }
-      } break;
-      }
-      return res;
-    }
-
-    //! In-place version of the previous function
-    CImg& structure_tensorXY(const int scheme=1) {
-      return get_structure_tensorXY(scheme).swap(*this);
-    }
-
-    //! Return the 3D structure tensor field of an image
-    CImg<typename cimg::largest<T,float>::type> get_structure_tensorXYZ(const int scheme=1) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      if (is_empty()) return CImg<restype>();
-      CImg<restype> res(width,height,depth,6,0);
-      CImg_3x3x3(I,restype);
-      switch (scheme) {
-      case 0: { // classical central finite differences
-        cimg_forV(*this,k) cimg_for3x3x3(*this,x,y,z,k,I) {
-          const restype
-            ix = 0.5f*(Incc-Ipcc),
-            iy = 0.5f*(Icnc-Icpc),
-            iz = 0.5f*(Iccn-Iccp);
-          res(x,y,z,0)+=ix*ix;
-          res(x,y,z,1)+=ix*iy;
-          res(x,y,z,2)+=ix*iz;
-          res(x,y,z,3)+=iy*iy;
-          res(x,y,z,4)+=iy*iz;
-          res(x,y,z,5)+=iz*iz;
-        }
-      } break;
-      default: { // Precise forward/backward finite differences
-        cimg_forV(*this,k) cimg_for3x3x3(*this,x,y,z,k,I) {
-          const restype
-            ixf = Incc-Iccc, ixb = Iccc-Ipcc,
-            iyf = Icnc-Iccc, iyb = Iccc-Icpc,
-            izf = Iccn-Iccc, izb = Iccc-Iccp;
-          res(x,y,z,0) += 0.5f*(ixf*ixf + ixb*ixb);
-          res(x,y,z,1) += 0.25f*(ixf*iyf + ixf*iyb + ixb*iyf + ixb*iyb);
-          res(x,y,z,2) += 0.25f*(ixf*izf + ixf*izb + ixb*izf + ixb*izb);
-          res(x,y,z,3) += 0.5f*(iyf*iyf + iyb*iyb);
-          res(x,y,z,4) += 0.25f*(iyf*izf + iyf*izb + iyb*izf + iyb*izb);
-          res(x,y,z,5) += 0.5f*(izf*izf + izb*izb);
-        }
-      } break;
-      }
-      return res;
-    }
-
-    //! In-place version of the previous function
-    CImg& structure_tensorXYZ(const int scheme=1) {
-      return get_structure_tensorXYZ(scheme).swap(*this);
-    }
-
-    //@}
-    //-------------------------------------
-    //
-    //! \name Meshes and Triangulations
-    //@{
-    //-------------------------------------
-
-    struct _marching_squares_func {
-      const CImg<T>& ref;
-      _marching_squares_func(const CImg<T>& pref):ref(pref) {}
-      float operator()(const float x, const float y) const {
-        return (float)ref((int)x,(int)y);
-      }
-    };
-
-    struct _marching_cubes_func {
-      const CImg<T>& ref;
-      _marching_cubes_func(const CImg<T>& pref):ref(pref) {}
-      float operator()(const float x, const float y, const float z) const {
-        return (float)ref((int)x,(int)y,(int)z);
-      }
-    };
-
-    struct _marching_squares_func_float {
-      const CImg<T>& ref;
-      _marching_squares_func_float(const CImg<T>& pref):ref(pref) {}
-      float operator()(const float x, const float y) const {
-        return (float)ref.linear_pix2d(x,y);
-      }
-    };
-
-    struct _marching_cubes_func_float {
-      const CImg<T>& ref;
-      _marching_cubes_func_float(const CImg<T>& pref):ref(pref) {}
-      float operator()(const float x, const float y, const float z) const {
-        return (float)ref.linear_pix3d(x,y,z);
-      }
-    };
-
-    //! Get a vectorization of an implicit function defined by the instance image.
-    template<typename tp, typename tf>
-    const CImg& marching_squares(const float isovalue,CImgList<tp>& points, CImgList<tf>& primitives) const {
-      if (height<=1 || depth>1 || dim>1)
-        throw CImgInstanceException("CImg<%s>::marching_squares() : Instance image (%u,%u,%u,%u,%p) is not a 2D scalar image.",
-                                    pixel_type(),width,height,depth,dim,data);
-      const _marching_squares_func func(*this);
-      cimg::marching_squares(func,isovalue,0.0f,0.0f,dimx()-1.0f,dimy()-1.0f,1.0f,1.0f,points,primitives);
-      return *this;
-    }
-
-    //! Get a vectorization of an implicit function defined by the instance image.
-    /**
-       This version allows to specify the marching squares resolution along x,y, and z.
-    **/
-    template<typename tp, typename tf>
-    const CImg& marching_squares(const float isovalue,
-                                 const float resx, const float resy,
-                                 CImgList<tp>& points, CImgList<tf>& primitives) const {
-      if (height<=1 || depth>1 || dim>1)
-        throw CImgInstanceException("CImg<%s>::marching_squares() : Instance image (%u,%u,%u,%u,%p) is not a 2D scalar image.",
-                                    pixel_type(),width,height,depth,dim,data);
-      const _marching_squares_func_float func(*this);
-      cimg::marching_squares(func,isovalue,0.0f,0.0f,dimx()-1.0f,dimy()-1.0f,resx,resy,points,primitives);
-      return *this;
-    }
-
-    //! Get a triangulation of an implicit function defined by the instance image
-    template<typename tp, typename tf>
-    const CImg& marching_cubes(const float isovalue,CImgList<tp>& points, CImgList<tf>& primitives,
-                               const bool invert_faces = false) const {
-      if (depth<=1 || dim>1)
-        throw CImgInstanceException("CImg<%s>::marching_cubes() : Instance image (%u,%u,%u,%u,%p) is not a 3D scalar image.",
-                                    pixel_type(),width,height,depth,dim,data);
-      const _marching_cubes_func func(*this);
-      cimg::marching_cubes(func,isovalue,0.0f,0.0f,0.0f,dimx()-1.0f,dimy()-1.0f,dimz()-1.0f,
-                           1.0f,1.0f,1.0f,points,primitives,invert_faces);
-      return *this;
-    }
-
-    //! Get a triangulation of an implicit function defined by the instance image
-    /**
-       This version allows to specify the marching cube resolution along x,y and z.
-    **/
-    template<typename tp, typename tf>
-    const CImg& marching_cubes(const float isovalue,
-                               const float resx, const float resy, const float resz,
-                               CImgList<tp>& points, CImgList<tf>& primitives,
-                               const bool invert_faces = false) const {
-      if (depth<=1 || dim>1)
-        throw CImgInstanceException("CImg<%s>::marching_cubes() : Instance image (%u,%u,%u,%u,%p) is not a 3D scalar image.",
-                                    pixel_type(),width,height,depth,dim,data);
-      const _marching_cubes_func_float func(*this);
-      cimg::marching_cubes(func,isovalue,0.0f,0.0f,0.0f,dimx()-1.0f,dimy()-1.0f,dimz()-1.0f,
-                           resx,resy,resz,points,primitives,invert_faces);
-      return *this;
-    }
-
-    //@}
-    //----------------------------
-    //
-    //! \name Color conversions
-    //@{
-    //----------------------------
-
-    //! Return the default 256 colors palette.
-    /**
-       The default color palette is used by %CImg when displaying images on 256 colors displays.
-       It consists in the quantification of the (R,G,B) color space using 3:3:2 bits for color coding
-       (i.e 8 levels for the Red and Green and 4 levels for the Blue).
-       \return A 256x1x1x3 color image defining the palette entries.
-    **/
-    static CImg<T> get_default_LUT8() {
-      static CImg<T> palette;
-      if (!palette.data) {
-        palette.assign(256,1,1,3);
-        for (unsigned int index=0, r=16; r<256; r+=32)
-          for (unsigned int g=16; g<256; g+=32)
-            for (unsigned int b=32; b<256; b+=64) {
-              palette(index,0) = r;
-              palette(index,1) = g;
-              palette(index++,2) = b;
-            }
-      }
-      return palette;
-    }
-
-    //! Convert color pixels from (R,G,B) to match a specified palette.
-    /**
-       This function return a (R,G,B) image where colored pixels are constrained to match entries
-       of the specified color \c palette.
-       \param palette User-defined palette that will constraint the color conversion.
-       \param dithering Enable/Disable Floyd-Steinberg dithering.
-       \param indexing If \c true, each resulting image pixel is an index to the given color palette.
-       Otherwise, (R,G,B) values of the palette are copied instead.
-    **/
-    template<typename t> CImg<t> get_RGBtoLUT(const CImg<t>& palette, const bool dithering=true,const bool indexing=false) const {
-      if (is_empty()) return CImg<t>();
-      if (dim!=3) throw CImgInstanceException("CImg<%s>::RGBtoLUT() : Input image dimension is dim=%u, "
-                                              "should be a (R,G,B) image.",pixel_type(),dim);
-      if (palette.data && palette.dim!=3)
-        throw CImgArgumentException("CImg<%s>::RGBtoLUT() : Given palette dimension is dim=%u, "
-                                    "should be a (R,G,B) palette",pixel_type(),palette.dim);
-      CImg<t> res(width,height,depth,indexing?1:3), pal = palette.data?palette:CImg<t>::get_default_LUT8();
-      float *line1 = new float[3*width], *line2 = new float[3*width], *pline1 = line1, *pline2 = line2;
-      cimg_forZ(*this,z) {
-        float *ptr=pline2; cimg_forX(*this,x) { *(ptr++)=(*this)(x,0,z,0); *(ptr++)=(*this)(x,0,z,1); *(ptr++)=(*this)(x,0,z,2); }
-        cimg_forY(*this,y) {
-          cimg::swap(pline1,pline2);
-          if (y<dimy()-1) {
-            const int ny = y+1;
-            float *ptr=pline2; cimg_forX(*this,x) { *(ptr++)=(*this)(x,ny,z,0); *(ptr++)=(*this)(x,ny,z,1); *(ptr++)=(*this)(x,ny,z,2); }
-          }
-          float *ptr1=pline1, *ptr2=pline2;
-          cimg_forX(*this,x) {
-            float R = *(ptr1++), G = *(ptr1++), B = *(ptr1++);
-            R = R<0?0:(R>255?255:R); G = G<0?0:(G>255?255:G); B = B<0?0:(B>255?255:B);
-            int best_index = 0;
-            t Rbest=0,Gbest=0,Bbest=0;
-            if (palette.data) { // find best match in given color palette
-              float min = cimg::type<float>::max();
-              cimg_forX(palette,off) {
-                const t Rp = palette(off,0), Gp = palette(off,1), Bp = palette(off,2);
-                const float error = (float)((Rp-R)*(Rp-R) + (Gp-G)*(Gp-G) + (Bp-B)*(Bp-B));
-                if (error<min) { min=error; best_index=off; Rbest=Rp; Gbest=Gp; Bbest=Bp; }
-              }
-            } else {
-              Rbest = (t)((unsigned char)R&0xe0); Gbest = (t)((unsigned char)G&0xe0); Bbest = (t)((unsigned char)B&0xc0);
-              best_index = (unsigned char)Rbest | ((unsigned char)Gbest>>3) | ((unsigned char)Bbest>>6);
-            }
-            if (indexing) res(x,y,z) = best_index;
-            else { res(x,y,z,0) = Rbest; res(x,y,z,1) = Gbest; res(x,y,z,2) = Bbest; }
-            if (dithering) { // apply dithering to neighborhood pixels if needed
-              const float dR = (float)(R-Rbest), dG = (float)(G-Gbest), dB = (float)(B-Bbest);
-              if (x<dimx()-1) { *(ptr1++)+= dR*7/16; *(ptr1++)+= dG*7/16; *(ptr1++)+= dB*7/16; ptr1-=3; }
-              if (y<dimy()-1) {
-                *(ptr2++)+= dR*5/16; *(ptr2++)+= dG*5/16; *ptr2+= dB*5/16; ptr2-=2;
-                if (x>0) { *(--ptr2)+= dB*3/16; *(--ptr2)+= dG*3/16; *(--ptr2)+= dR*3/16; ptr2+=3; }
-                if (x<dimx()-1) { ptr2+=3; *(ptr2++)+= dR/16; *(ptr2++)+= dG/16; *ptr2+= dB/16; ptr2-=5; }
-              }
-            }
-            ptr2+=3;
-          }
-        }
-      }
-      delete[] line1; delete[] line2;
-      return res;
-    }
-
-    //! Convert color pixels from (R,G,B) to match the default 256 colors palette.
-    /**
-       Same as get_RGBtoLUT() with the default color palette given by get_default_LUT8().
-    **/
-    CImg<T> get_RGBtoLUT(const bool dithering=true, const bool indexing=false) const {
-      CImg<T> foo;
-      return get_RGBtoLUT(foo,dithering,indexing);
-    }
-
-    //! Convert color pixels from (R,G,B) to match the specified color palette.
-    /** This is the in-place version of get_RGBtoLUT(). **/
-    CImg& RGBtoLUT(const CImg<T>& palette,const bool dithering=true,const bool indexing=false) {
-      return get_RGBtoLUT(palette,dithering,indexing).swap(*this);
-    }
-
-    //! Convert color pixels from (R,G,B) to match the specified color palette.
-    /** This is the in-place version of get_RGBtoLUT(). **/
-    CImg& RGBtoLUT(const bool dithering=true,const bool indexing=false) {
-      CImg<T> foo;
-      return get_RGBtoLUT(foo,dithering,indexing).swap(*this);
-    }
-
-    //! Convert an indexed image to a (R,G,B) image using the specified color palette.
-    template<typename t> CImg<t> get_LUTtoRGB(const CImg<t>& palette) const {
-      if (is_empty()) return CImg<t>();
-      if (dim!=1) throw CImgInstanceException("CImg<%s>::LUTtoRGB() : Input image dimension is dim=%u, "
-                                              "should be a LUT image",pixel_type(),dim);
-      if (palette.data && palette.dim!=3)
-        throw CImgArgumentException("CImg<%s>::LUTtoRGB() : Given palette dimension is dim=%u, "
-                                    "should be a (R,G,B) palette",pixel_type(),palette.dim);
-      CImg<t> res(width,height,depth,3);
-      CImg<t> pal = palette.data?palette:get_default_LUT8();
-      cimg_forXYZ(*this,x,y,z) {
-        const unsigned int index = (unsigned int)(*this)(x,y,z);
-        res(x,y,z,0) = pal(index,0);
-        res(x,y,z,1) = pal(index,1);
-        res(x,y,z,2) = pal(index,2);
-      }
-      return res;
-    }
-
-    //! Convert an indexed image (with the default palette) to a (R,G,B) image.
-    CImg<T> get_LUTtoRGB() const {
-      CImg<T> foo;
-      return get_LUTtoRGB(foo);
-    }
-
-    //! In-place version of get_LUTtoRGB().
-    CImg& LUTtoRGB(const CImg<T>& palette) {
-      return get_LUTtoRGB(palette).swap(*this);
-    }
-
-    //! In-place version of get_LUTroRGB().
-    CImg& LUTtoRGB() {
-      CImg<T> foo;
-      return get_LUTtoRGB(foo).swap(*this);
-    }
-
-    //! Convert color pixels from (R,G,B) to (H,S,V).
-    CImg& RGBtoHSV() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::RGBtoHSV() : Input image dimension is dim=%u, "
-                                                "should be a (R,G,B) image.",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          const float
-            R = (float)((*this)(x,y,z,0)/255.0f),
-            G = (float)((*this)(x,y,z,1)/255.0f),
-            B = (float)((*this)(x,y,z,2)/255.0f);
-          const float m = cimg::min(R,G,B), v = cimg::max(R,G,B);
-          float h,s;
-          if (v==m) { h=-1; s=0; } else {
-            const float
-              f = (R==m)?(G-B):((G==m)?(B-R):(R-G)),
-              i = (R==m)?3.0f:((G==m)?5.0f:1.0f);
-            h = (i-f/(v-m));
-            s = (v-m)/v;
-            if (h>=6.0f) h-=6.0f;
-            h*=(float)cimg::PI/3.0f;
-          }
-          (*this)(x,y,z,0) = (T)h;
-          (*this)(x,y,z,1) = (T)s;
-          (*this)(x,y,z,2) = (T)v;
-        }
-      }
-      return *this;
-    }
-
-    //! Convert color pixels from (H,S,V) to (R,G,B).
-    CImg& HSVtoRGB() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::HSVtoRGB() : Input image dimension is dim=%u, "
-                                                "should be a (H,S,V) image",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          float
-            H = (float)((*this)(x,y,z,0)),
-            S = (float)((*this)(x,y,z,1)),
-            V = (float)((*this)(x,y,z,2));
-          float R=0,G=0,B=0;
-          if (H<0) R=G=B=V;
-          else {
-            H/=(float)cimg::PI/3.0f;
-            const int i = (int)std::floor(H);
-            const float
-              f = (i&1)?(H-i):(1.0f-H+i),
-              m = V*(1.0f-S),
-              n = V*(1.0f-S*f);
-            switch(i) {
-            case 6:
-            case 0: R=V; G=n; B=m; break;
-            case 1: R=n; G=V; B=m; break;
-            case 2: R=m; G=V; B=n; break;
-            case 3: R=m; G=n; B=V; break;
-            case 4: R=n; G=m; B=V; break;
-            case 5: R=V; G=m; B=n; break;
-            }
-          }
-          (*this)(x,y,z,0) = (T)(R*255.0f);
-          (*this)(x,y,z,1) = (T)(G*255.0f);
-          (*this)(x,y,z,2) = (T)(B*255.0f);
-        }
-      }
-      return *this;
-    }
-
-    //! Convert color pixels from (R,G,B) to (Y,Cb,Cr)_8 (Thanks to Chen Wang).
-    CImg& RGBtoYCbCr() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::RGBtoYCbCr() : Input image dimension is dim=%u, "
-                                                "should be a (R,G,B) image (dim=3)",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          const int
-            R = (int)((*this)(x,y,z,0)),
-            G = (int)((*this)(x,y,z,1)),
-            B = (int)((*this)(x,y,z,2));
-          const int
-            Y  = ((66*R+129*G+25*B+128)>>8) + 16,
-            Cb = ((-38*R-74*G+112*B+128)>>8) + 128,
-            Cr = ((112*R-94*G-18*B+128)>>8) + 128;
-          (*this)(x,y,z,0) = (T)(Y<0?0:(Y>255?255:Y));
-          (*this)(x,y,z,1) = (T)(Cb<0?0:(Cb>255?255:Cb));
-          (*this)(x,y,z,2) = (T)(Cr<0?0:(Cr>255?255:Cr));
-        }
-      }
-      return *this;
-    }
-
-    //! Convert color pixels from (Y,Cb,Cr)_8 to (R,G,B).
-    CImg& YCbCrtoRGB() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::YCbCrtoRGB() : Input image dimension is dim=%u, "
-                                                "should be a (Y,Cb,Cr)_8 image (dim=3)",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          const int
-            Y  = (int)((*this)(x, y, z, 0)-16),
-            Cb = (int)((*this)(x, y, z, 1)-128),
-            Cr = (int)((*this)(x, y, z, 2)-128);
-          const int
-            R = ((298*Y + 409*Cr + 128) >> 8 ),
-            G = ((298*Y - 100*Cb - 208*Cr + 128) >> 8 ),
-            B = ((298*Y + 516*Cb + 128) >> 8 );
-          (*this)(x,y,z,0) = (T)(R<0?0:(R>255?255:R));
-          (*this)(x,y,z,1) = (T)(G<0?0:(G>255?255:G));
-          (*this)(x,y,z,2) = (T)(B<0?0:(B>255?255:B));
-        }
-      }
-      return *this;
-    }
-
-    //! Convert color pixels from (R,G,B) to (Y,U,V).
-    CImg& RGBtoYUV() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::RGBtoYUV() : Input image dimension is dim=%u, "
-                                                "should be a (R,G,B) image (dim=3)",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          const float
-            R = (*this)(x,y,z,0)/255.0f,
-            G = (*this)(x,y,z,1)/255.0f,
-            B = (*this)(x,y,z,2)/255.0f,
-            Y = (T)(0.299*R + 0.587*G + 0.114*B);
-          (*this)(x,y,z,0) = Y;
-          (*this)(x,y,z,1) = (T)(0.492*(B-Y));
-          (*this)(x,y,z,2) = (T)(0.877*(R-Y));
-        }
-      }
-      return *this;
-    }
-
-    //! Convert color pixels from (Y,U,V) to (R,G,B).
-    CImg& YUVtoRGB() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::YUVtoRGB() : Input image dimension is dim=%u, "
-                                                "should be a (Y,U,V) image (dim=3)",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          const T Y = (*this)(x,y,z,0), U = (*this)(x,y,z,1), V = (*this)(x,y,z,2);
-          (*this)(x,y,z,0) = (T)((Y + 1.140*V)*255.0f);
-          (*this)(x,y,z,1) = (T)((Y - 0.395*U - 0.581*V)*255.0f);
-          (*this)(x,y,z,2) = (T)((Y + 2.032*U)*255.0f);
-        }
-      }
-      return *this;
-    }
-
-    //! Convert color pixels from (R,G,B) to (X,Y,Z)_709.
-    CImg& RGBtoXYZ() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::RGBtoXYZ() : Input image dimension is dim=%u, "
-                                                "should be a (R,G,B) image (dim=3)",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          const float
-            R = (float)((*this)(x,y,z,0)/255.0f),
-            G = (float)((*this)(x,y,z,1)/255.0f),
-            B = (float)((*this)(x,y,z,2)/255.0f);
-          (*this)(x,y,z,0) = (T)(0.412453*R + 0.357580*G + 0.180423*B);
-          (*this)(x,y,z,1) = (T)(0.212671*R + 0.715160*G + 0.072169*B);
-          (*this)(x,y,z,2) = (T)(0.019334*R + 0.119193*G + 0.950227*B);
-        }
-      }
-      return *this;
-    }
-
-    //! Convert (X,Y,Z)_709 pixels of a color image into the (R,G,B) color space.
-    CImg& XYZtoRGB() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::XYZtoRGB() : Input image dimension is dim=%u, "
-                                                "should be a (X,Y,Z) image (dim=3)",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          const float
-            X = (float)(255.0f*(*this)(x,y,z,0)),
-            Y = (float)(255.0f*(*this)(x,y,z,1)),
-            Z = (float)(255.0f*(*this)(x,y,z,2));
-          (*this)(x,y,z,0) = (T)(3.240479*X  - 1.537150*Y - 0.498535*Z);
-          (*this)(x,y,z,1) = (T)(-0.969256*X + 1.875992*Y + 0.041556*Z);
-          (*this)(x,y,z,2) = (T)(0.055648*X  - 0.204043*Y + 1.057311*Z);
-        }
-      }
-      return *this;
-    }
-
-    //! Convert (X,Y,Z)_709 pixels of a color image into the (L*,a*,b*) color space.
-#define cimg_Labf(x)  ((x)>=0.008856?(std::pow(x,1/3.0)):(7.787*(x)+16.0/116.0))
-#define cimg_Labfi(x) ((x)>=0.206893?((x)*(x)*(x)):(((x)-16.0/116.0)/7.787))
-
-    CImg& XYZtoLab() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::XYZtoLab() : Input image dimension is dim=%u, "
-                                                "should be a (X,Y,Z) image (dim=3)",pixel_type(),dim);
-        const double
-          Xn = 0.412453 + 0.357580 + 0.180423,
-          Yn = 0.212671 + 0.715160 + 0.072169,
-          Zn = 0.019334 + 0.119193 + 0.950227;
-        cimg_forXYZ(*this,x,y,z) {
-          const T X = (*this)(x,y,z,0), Y = (*this)(x,y,z,1), Z = (*this)(x,y,z,2);
-          const double
-            XXn = X/Xn, YYn = Y/Yn, ZZn = Z/Zn,
-            fX = cimg_Labf(XXn), fY = cimg_Labf(YYn), fZ = cimg_Labf(ZZn);
-          (*this)(x,y,z,0) = (T)(116*fY-16);
-          (*this)(x,y,z,1) = (T)(500*(fX-fY));
-          (*this)(x,y,z,2) = (T)(200*(fY-fZ));
-        }
-      }
-      return *this;
-    }
-
-    //! Convert (L,a,b) pixels of a color image into the (X,Y,Z) color space.
-    CImg& LabtoXYZ() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::LabtoXYZ() : Input image dimension is dim=%u, "
-                                                "should be a (X,Y,Z) image (dim=3)",pixel_type(),dim);
-        const double
-          Xn = 0.412453 + 0.357580 + 0.180423,
-          Yn = 0.212671 + 0.715160 + 0.072169,
-          Zn = 0.019334 + 0.119193 + 0.950227;
-        cimg_forXYZ(*this,x,y,z) {
-          const T L = (*this)(x,y,z,0), a = (*this)(x,y,z,1), b = (*this)(x,y,z,2);
-          const double
-            cY = (L+16)/116.0,
-            Y = Yn*cimg_Labfi(cY),
-            pY = std::pow(Y/Yn,1.0/3),
-            cX = a/500+pY,
-            X = Xn*cX*cX*cX,
-            cZ = pY-b/200,
-            Z = Zn*cZ*cZ*cZ;
-          (*this)(x,y,z,0) = (T)(X);
-          (*this)(x,y,z,1) = (T)(Y);
-          (*this)(x,y,z,2) = (T)(Z);
-        }
-      }
-      return *this;
-    }
-
-    //! Convert (X,Y,Z)_709 pixels of a color image into the (x,y,Y) color space.
-    CImg& XYZtoxyY() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::XYZtoxyY() : Input image dimension is dim=%u, "
-                                                "should be a (X,Y,Z) image (dim=3)",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          const T X = (*this)(x,y,z,0), Y = (*this)(x,y,z,1), Z = (*this)(x,y,z,2), sum = (X+Y+Z), nsum = sum>0?sum:1;
-          (*this)(x,y,z,0) = X/nsum;
-          (*this)(x,y,z,1) = Y/nsum;
-          (*this)(x,y,z,2) = Y;
-        }
-      }
-      return *this;
-    }
-
-    //! Convert (x,y,Y) pixels of a color image into the (X,Y,Z)_709 color space.
-    CImg& xyYtoXYZ() {
-      if (!is_empty()) {
-        if (dim!=3) throw CImgInstanceException("CImg<%s>::xyYtoXYZ() : Input image dimension is dim=%u, "
-                                                "should be a (x,y,Y) image (dim=3)",pixel_type(),dim);
-        cimg_forXYZ(*this,x,y,z) {
-          const T px = (*this)(x,y,z,0), py = (*this)(x,y,z,1), Y = (*this)(x,y,z,2), ny = py>0?py:1;
-          (*this)(x,y,z,0) = (T)(px*Y/ny);
-          (*this)(x,y,z,1) = Y;
-          (*this)(x,y,z,2) = (T)((1-px-py)*Y/ny);
-        }
-      }
-      return *this;
-    }
-
-    //! In-place version of get_RGBtoLab().
-    CImg& RGBtoLab() {
-      return RGBtoXYZ().XYZtoLab();
-    }
-
-    //! In-place version of get_LabtoRGb().
-    CImg& LabtoRGB() {
-      return LabtoXYZ().XYZtoRGB();
-    }
-
-    //! In-place version of get_RGBtoxyY().
-    CImg& RGBtoxyY() {
-      return RGBtoXYZ().XYZtoxyY();
-    }
-
-    //! In-place version of get_xyYtoRGB().
-    CImg& xyYtoRGB() {
-      return xyYtoXYZ().XYZtoRGB();
-    }
-
-    //! Convert a (R,G,B) image to a (H,S,V) one.
-    CImg get_RGBtoHSV() const {
-      return (+*this).RGBtoHSV();
-    }
-
-    //! Convert a (H,S,V) image to a (R,G,B) one.
-    CImg get_HSVtoRGB() const {
-      return (+*this).HSVtoRGB();
-    }
-
-    //! Convert a (R,G,B) image to a (Y,Cb,Cr) one.
-    CImg get_RGBtoYCbCr() const {
-      return (+*this).RGBtoYCbCr();
-    }
-
-    //! Convert a (Y,Cb,Cr) image to a (R,G,B) one.
-    CImg get_YCbCrtoRGB() const {
-      return (+*this).YCbCrtoRGB();
-    }
-
-    //! Convert a (R,G,B) image into a (Y,U,V) one.
-    CImg<typename cimg::largest<T,float>::type> get_RGBtoYUV() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).RGBtoYUV();
-    }
-
-    //! Convert a (Y,U,V) image into a (R,G,B) one.
-    CImg get_YUVtoRGB() const {
-      return (+*this).YUVtoRGB();
-    }
-
-    //! Convert a (R,G,B) image to a (X,Y,Z) one.
-    CImg<typename cimg::largest<T,float>::type> get_RGBtoXYZ() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).RGBtoXYZ();
-    }
-
-    //! Convert a (X,Y,Z) image to a (R,G,B) one.
-    CImg get_XYZtoRGB() const {
-      return (+*this).XYZtoRGB();
-    }
-
-    //! Convert a (X,Y,Z) image to a (L,a,b) one.
-    CImg get_XYZtoLab() const {
-      return (+*this).XYZtoLab();
-    }
-
-    //! Convert a (L,a,b) image to a (X,Y,Z) one.
-    CImg get_LabtoXYZ() const {
-      return (+*this).LabtoXYZ();
-    }
-
-    //! Convert a (X,Y,Z) image to a (x,y,Y) one.
-    CImg get_XYZtoxyY() const {
-      return (+*this).XYZtoxyY();
-    }
-
-    //! Convert a (x,y,Y) image to a (X,Y,Z) one.
-    CImg get_xyYtoXYZ() const {
-      return (+*this).xyYtoXYZ();
-    }
-
-    //! Convert a (R,G,B) image to a (L,a,b) one.
-    CImg get_RGBtoLab() const {
-      return (+*this).RGBtoLab();
-    }
-
-    //! Convert a (L,a,b) image to a (R,G,B) one.
-    CImg get_LabtoRGB() const {
-      return (+*this).LabtoRGB();
-    }
-
-    //! Convert a (R,G,B) image to a (x,y,Y) one.
-    CImg get_RGBtoxyY() const {
-      return (+*this).RGBtoxyY();
-    }
-
-    //! Convert a (x,y,Y) image to a (R,G,B) one.
-    CImg get_xyYtoRGB() const {
-      return (+*this).xyYtoRGB();
-    }
-
-    //@}
-    //-------------------
-    //
-    //! \name Drawing
-    //@{
-    //-------------------
-
-    // Should be used only by member functions. Not an user-friendly function.
-    // Pre-requisites : x0<x1, y-coordinate is valid, col is valid.
-    CImg& draw_scanline(const int x0, const int x1, const int y, const T *const color,
-                        const float opacity=1, const float brightness=1, const bool init=false) {
-      static float nopacity=0, copacity=0;
-      static unsigned int whz=0;
-      static const T* col = 0;
-      if (init) {
-        nopacity = cimg::abs(opacity);
-        copacity = 1-cimg::max(opacity,0.0f);
-        whz = width*height*depth;
-        col = color;
-      } else {
-        const int nx0 = cimg::max(x0,0), nx1 = cimg::min(x1,(int)width-1), dx = nx1-nx0;
-        T *ptrd = ptr(0,y) + nx0;
-        if (dx>=0) {
-          if (opacity>=1) {
-            int off = whz-dx-1;
-            if (sizeof(T)!=1) cimg_forV(*this,k) {
-              const T val = (T)(*(col++)*brightness);
-              for (int x=dx; x>=0; x--) *(ptrd++)=val;
-              ptrd+=off;
-            } else cimg_forV(*this,k) { std::memset(ptrd,(int)(*(col++)*brightness),dx+1); ptrd+=whz; }
-            col-=dim;
-          } else {
-            int off = whz-dx-1;
-            cimg_forV(*this,k) {
-              const T val = (T)(*(col++)*brightness);
-              for (int x=dx; x>=0; x--) { *ptrd = (T)(val*nopacity + *ptrd*copacity); ptrd++; }
-              ptrd+=off;
-            }
-            col-=dim;
-          }
-        }
-      }
-      return *this;
-    }
-
-    CImg& draw_scanline(const T *const color,const float opacity=1) { return draw_scanline(0,0,0,color,opacity,1.0f,true); }
-
-    //! Draw a colored point in the instance image, at coordinates (\c x0,\c y0,\c z0).
-    /**
-       \param x0 = X-coordinate of the vector-valued pixel to plot.
-       \param y0 = Y-coordinate of the vector-valued pixel to plot.
-       \param z0 = Z-coordinate of the vector-valued pixel to plot.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_point(const int x0,const int y0,const int z0,
-                     const T *const color,const float opacity=1) {
-      if (!is_empty()) {
-        if (!color) throw CImgArgumentException("CImg<%s>::draw_point() : Specified color is (null)",pixel_type());
-        if (x0>=0 && y0>=0 && z0>=0 && x0<dimx() && y0<dimy() && z0<dimz()) {
-          const T *col=color;
-          const unsigned int whz = width*height*depth;
-          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-          T *ptrd = ptr(x0,y0,z0,0);
-          if (opacity>=1) cimg_forV(*this,k) { *ptrd = *(col++); ptrd+=whz; }
-          else cimg_forV(*this,k) { *ptrd=(T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whz; }
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a colored point in the instance image, at coordinates (\c x0,\c y0).
-    /**
-       \param x0 = X-coordinate of the vector-valued pixel to plot.
-       \param y0 = Y-coordinate of the vector-valued pixel to plot.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_point(const int x0,const int y0,const T *const color,const float opacity=1) {
-      return draw_point(x0,y0,0,color,opacity);
-    }
-
-    //! Draw a 2D colored line in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the starting point of the line.
-       \param y0 = Y-coordinate of the starting point of the line.
-       \param x1 = X-coordinate of the ending point of the line.
-       \param y1 = Y-coordinate of the ending point of the line.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = An integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_line(const int x0,const int y0,const int x1,const int y1,
-                    const T *const color,const unsigned int pattern=~0L,const float opacity=1) {
-      if (!is_empty()) {
-        if (!color) throw CImgArgumentException("CImg<%s>::draw_line() : Specified color is (null)",pixel_type());
-        const T* col=color;
-        int nx0 = x0, nx1 = x1, ny0 = y0, ny1 = y1;
-
-        if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1);
-        if (nx1<0 || nx0>=dimx()) return *this;
-        if (nx0<0) { ny0-=nx0*(ny1-ny0)/(nx1-nx0); nx0=0; }
-        if (nx1>=dimx()) { ny1+=(nx1-dimx())*(ny0-ny1)/(nx1-nx0); nx1=dimx()-1;}
-        if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1);
-        if (ny1<0 || ny0>=dimy()) return *this;
-        if (ny0<0) { nx0-=ny0*(nx1-nx0)/(ny1-ny0); ny0=0; }
-        if (ny1>=dimy()) { nx1+=(ny1-dimy())*(nx0-nx1)/(ny1-ny0); ny1=dimy()-1;}
-
-        const bool steep = (ny1-ny0)>cimg::abs(nx1-nx0);
-        if (steep)   cimg::swap(nx0,ny0,nx1,ny1);
-        if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1);
-        const int
-          dx = nx1-nx0, dy = cimg::abs(ny1-ny0),
-          offx = steep?width:1,
-          offy = (ny0<ny1?1:-1)*(steep?1:width);
-
-        if (opacity>=1) cimg_forV(*this,k) {
-          unsigned int hatch=1;
-          T *ptrd = steep?ptr(ny0,nx0,0,k):ptr(nx0,ny0,0,k);
-          const T c = *(col++);
-          for (int error=0, x=nx0; x<=nx1; x++) {
-            if (!(~pattern) || (~pattern && pattern&hatch)) *ptrd=c;
-            ptrd+=offx;
-            if (((error+=dy)<<1)>=dx) { ptrd+=offy; error-=dx; }
-            if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned int)*8-1));
-          }
-        } else {
-          const float nopacity = cimg::abs(opacity), copacity=1-cimg::max(opacity,0.0f);
-          cimg_forV(*this,k) {
-            unsigned int hatch=1;
-            T *ptrd = steep?ptr(ny0,nx0,0,k):ptr(nx0,ny0,0,k);
-            const T c = *(col++);
-            for (int error=0, x=nx0; x<=nx1; x++) {
-              if (!(~pattern) || (~pattern && pattern&hatch)) *ptrd = (T)(c*nopacity + copacity*(*ptrd));
-              ptrd+=offx;
-              if (((error+=dy)<<1)>=dx) { ptrd+=offy; error-=dx; }
-              if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned int)*8-1));
-            }
-          }
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 3D colored line in the instance image, at coordinates (\c x0,\c y0,\c z0)-(\c x1,\c y1,\c z1).
-    /**
-       \param x0 = X-coordinate of the starting point of the line.
-       \param y0 = Y-coordinate of the starting point of the line.
-       \param z0 = Z-coordinate of the starting point of the line.
-       \param x1 = X-coordinate of the ending point of the line.
-       \param y1 = Y-coordinate of the ending point of the line.
-       \param z1 = Z-coordinate of the ending point of the line.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = An integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_line(const int x0, const int y0, const int z0, const int x1, const int y1, const int z1,
-                    const T *const color, const unsigned int pattern=~0L, const float opacity=1) {
-      if (!is_empty()) {
-        if (!color) throw CImgArgumentException("CImg<%s>::draw_line() : Specified color is (null)",pixel_type());
-        const T* col=color;
-        unsigned int hatch=1;
-        int nx0 = x0, ny0 = y0, nz0 = z0, nx1 = x1, ny1 = y1, nz1 = z1;
-        if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
-        if (nx1<0 || nx0>=dimx()) return *this;
-        if (nx0<0) { const int D=1+nx1-nx0; ny0-=nx0*(1+ny1-ny0)/D; nz0-=nx0*(1+nz1-nz0)/D; nx0=0; }
-        if (nx1>=dimx()) { const int d=nx1-dimx(), D=1+nx1-nx0; ny1+=d*(1+ny0-ny1)/D; nz1+=d*(1+nz0-nz1)/D; nx1=dimx()-1;}
-        if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
-        if (ny1<0 || ny0>=dimy()) return *this;
-        if (ny0<0) { const int D=1+ny1-ny0; nx0-=ny0*(1+nx1-nx0)/D; nz0-=ny0*(1+nz1-nz0)/D; ny0=0; }
-        if (ny1>=dimy()) { const int d=ny1-dimy(), D=1+ny1-ny0; nx1+=d*(1+nx0-nx1)/D; nz1+=d*(1+nz0-nz1)/D; ny1=dimy()-1;}
-        if (nz0>nz1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
-        if (nz1<0 || nz0>=dimz()) return *this;
-        if (nz0<0) { const int D=1+nz1-nz0; nx0-=nz0*(1+nx1-nx0)/D; ny0-=nz0*(1+ny1-ny0)/D; nz0=0; }
-        if (nz1>=dimz()) { const int d=nz1-dimz(), D=1+nz1-nz0; nx1+=d*(1+nx0-nx1)/D; ny1+=d*(1+ny0-ny1)/D; nz1=dimz()-1;}
-        const unsigned int dmax = cimg::max(cimg::abs(nx1-nx0),cimg::abs(ny1-ny0),nz1-nz0), whz = width*height*depth;
-        const float px = (nx1-nx0)/(float)dmax, py = (ny1-ny0)/(float)dmax, pz = (nz1-nz0)/(float)dmax;
-        float x = (float)nx0, y = (float)ny0, z = (float)nz0;
-        if (opacity>=1) for (unsigned int t=0; t<=dmax; t++) {
-          if (!(~pattern) || (~pattern && pattern&hatch)) {
-            T* ptrd = ptr((unsigned int)x,(unsigned int)y,(unsigned int)z,0);
-            cimg_forV(*this,k) { *ptrd=*(col++); ptrd+=whz; }
-            col-=dim;
-          }
-          x+=px; y+=py; z+=pz; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned int)*8-1));
-        } else {
-          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-          for (unsigned int t=0; t<=dmax; t++) {
-            if (!(~pattern) || (~pattern && pattern&hatch)) {
-              T* ptrd = ptr((unsigned int)x,(unsigned int)y,(unsigned int)z,0);
-              cimg_forV(*this,k) { *ptrd = (T)(*(col++)*nopacity + copacity*(*ptrd)); ptrd+=whz; }
-              col-=dim;
-            }
-            x+=px; y+=py; z+=pz; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned int)*8-1));
-          }
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 2D textured line in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the starting point of the line.
-       \param y0 = Y-coordinate of the starting point of the line.
-       \param x1 = X-coordinate of the ending point of the line.
-       \param y1 = Y-coordinate of the ending point of the line.
-       \param texture = a colored texture image used to draw the line color.
-       \param tx0 = X-coordinate of the starting point of the texture.
-       \param ty0 = Y-coordinate of the starting point of the texture.
-       \param tx1 = X-coordinate of the ending point of the texture.
-       \param ty1 = Y-coordinate of the ending point of the texture.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported, but texture coordinates do not support clipping.
-    **/
-    template<typename t> CImg& draw_line(const int x0,const int y0,const int x1,const int y1,
-                                         const CImg<t>& texture,
-                                         const int tx0,const int ty0,const int tx1,const int ty1,
-                                         const float opacity=1) {
-      if (!is_empty()) {
-        if (texture.is_empty() || texture.dim<dim)
-          throw CImgArgumentException("CImg<%s>::draw_line() : specified texture (%u,%u,%u,%u,%p) has wrong dimensions.",
-                                      pixel_type(),texture.width,texture.height,texture.depth,texture.dim,texture.data);
-        int nx0=x0, ny0=y0, nx1=x1, ny1=y1, ntx0=tx0, nty0=ty0, ntx1=tx1, nty1=ty1;
-        if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
-        if (nx1<0 || nx0>=dimx()) return *this;
-        if (nx0<0) { const int D=nx1-nx0; ny0-=nx0*(ny1-ny0)/D; ntx0-=nx0*(ntx1-ntx0)/D; nty0-=nx0*(nty1-nty0)/D; nx0=0; }
-        if (nx1>=dimx()) { const int d=nx1-dimx(),D=nx1-nx0; ny1+=d*(ny0-ny1)/D; ntx1+=d*(ntx0-ntx1)/D; nty1+=d*(nty0-nty1)/D; nx1=dimx()-1; }
-        if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
-        if (ny1<0 || ny0>=dimy()) return *this;
-        if (ny0<0) { const int D=ny1-ny0; nx0-=ny0*(nx1-nx0)/D; ntx0-=ny0*(ntx1-ntx0)/D; nty0-=ny0*(nty1-nty0)/D; ny0=0; }
-        if (ny1>=dimy()) { const int d=ny1-dimy(),D=ny1-ny0; nx1+=d*(nx0-nx1)/D; ntx1+=d*(ntx0-ntx1)/D; nty1+=d*(nty0-nty1)/D; ny1=dimy()-1; }
-        const unsigned int dmax = (unsigned int)cimg::max(cimg::abs(nx1-nx0),ny1-ny0),
-          whz = width*height*depth, twhz = texture.width*texture.height*texture.depth;
-        const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0,
-          tpx = dmax?(ntx1-ntx0)/(float)dmax:0, tpy = dmax?(nty1-nty0)/(float)dmax:0;
-        float x = (float)nx0, y = (float)ny0, tx = (float)ntx0, ty = (float)nty0;
-        if (opacity>=1) for (unsigned int tt=0; tt<=dmax; tt++) {
-          T *ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
-          const t *ptrs = texture.ptr((unsigned int)tx,(unsigned int)ty,0,0);
-          cimg_forV(*this,k) { *ptrd = (T)*ptrs; ptrd+=whz; ptrs+=twhz; }
-          x+=px; y+=py; tx+=tpx; ty+=tpy;
-        } else {
-          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-          for (unsigned int tt=0; tt<=dmax; tt++) {
-            T *ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
-            const t *ptrs = texture.ptr((unsigned int)tx,(unsigned int)ty,0,0);
-            cimg_forV(*this,k) { *ptrd = (T)(nopacity*(*ptrs) + copacity*(*ptrd)); ptrd+=whz; ptrs+=twhz; }
-            x+=px; y+=py; tx+=tpx; ty+=tpy;
-          }
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 2D colored arrow in the instance image, at coordinates (\c x0,\c y0)->(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the starting point of the arrow (tail).
-       \param y0 = Y-coordinate of the starting point of the arrow (tail).
-       \param x1 = X-coordinate of the ending point of the arrow (head).
-       \param y1 = Y-coordinate of the ending point of the arrow (head).
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param angle = aperture angle of the arrow head
-       \param length = length of the arrow head. If <0, described as a percentage of the arrow length.
-       \param pattern = An integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_arrow(const int x0,const int y0,const int x1,const int y1,
-                     const T *const color,
-                     const float angle=30,const float length=-10,const unsigned int pattern=~0L,const float opacity=1) {
-      if (!is_empty()) {
-        const float u = (float)(x0-x1), v = (float)(y0-y1), sq = u*u+v*v,
-          deg = (float)(angle*cimg::PI/180), ang = (sq>0)?(float)std::atan2(v,u):0.0f,
-          l = (length>=0)?length:-length*(float)std::sqrt(sq)/100;
-        if (sq>0) {
-          const double cl = std::cos(ang-deg), sl = std::sin(ang-deg), cr = std::cos(ang+deg), sr = std::sin(ang+deg);
-          const int
-            xl = x1+(int)(l*cl), yl = y1+(int)(l*sl),
-            xr = x1+(int)(l*cr), yr = y1+(int)(l*sr),
-            xc = x1+(int)((l+1)*(cl+cr))/2, yc = y1+(int)((l+1)*(sl+sr))/2;
-          draw_line(x0,y0,xc,yc,color,pattern,opacity).draw_triangle(x1,y1,xl,yl,xr,yr,color,opacity);
-        } else draw_point(x0,y0,color,opacity);
-      }
-      return *this;
-    }
-
-    //! Draw a sprite image in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0).
-    /**
-       \param sprite = sprite image.
-       \param x0 = X-coordinate of the sprite position in the instance image.
-       \param y0 = Y-coordinate of the sprite position in the instance image.
-       \param z0 = Z-coordinate of the sprite position in the instance image.
-       \param v0 = V-coordinate of the sprite position in the instance image.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    template<typename t> CImg& draw_image(const CImg<t>& sprite,
-                                          const int x0=0,const int y0=0,const int z0=0,const int v0=0,const float opacity=1) {
-      if (!is_empty()) {
-        if (sprite.is_empty())
-          throw CImgArgumentException("CImg<%s>::draw_image() : Specified sprite image (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),sprite.width,sprite.height,sprite.depth,sprite.dim,sprite.data);
-        const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
-        const int
-          lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
-          lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
-          lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),
-          lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);
-        const t *ptrs = sprite.ptr()-(bx?x0:0)-(by?y0*sprite.dimx():0)+(bz?z0*sprite.dimx()*sprite.dimy():0)+
-          (bv?v0*sprite.dimx()*sprite.dimy()*sprite.dimz():0);
-        const unsigned int
-          offX = width-lX, soffX = sprite.width-lX,
-          offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
-          offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ);
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
-        if (lX>0 && lY>0 && lZ>0 && lV>0)
-          for (int v=0; v<lV; v++) {
-            for (int z=0; z<lZ; z++) {
-              for (int y=0; y<lY; y++) {
-                if (opacity>=1) for (int x=0; x<lX; x++) *(ptrd++) = (T)*(ptrs++);
-                else for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*(*(ptrs++)) + copacity*(*ptrd)); ptrd++; }
-                ptrd+=offX; ptrs+=soffX;
-              }
-              ptrd+=offY; ptrs+=soffY;
-            }
-            ptrd+=offZ; ptrs+=soffZ;
-          }
-      }
-      return *this;
-    }
-
-#ifndef cimg_use_visualcpp6
-    CImg& draw_image(const CImg& sprite,const int x0=0,const int y0=0,const int z0=0,const int v0=0,const float opacity=1) {
-      if (!is_empty()) {
-        if (sprite.is_empty())
-          throw CImgArgumentException("CImg<%s>::draw_image() : Specified sprite image (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),sprite.width,sprite.height,sprite.depth,sprite.dim,sprite.data);
-        if (this==&sprite) return draw_image(CImg<T>(sprite),x0,y0,z0,v0,opacity);
-        const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
-        const int
-          lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
-          lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
-          lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),
-          lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);
-        const T *ptrs = sprite.ptr()-(bx?x0:0)-(by?y0*sprite.dimx():0)+(bz?z0*sprite.dimx()*sprite.dimy():0)+
-          (bv?v0*sprite.dimx()*sprite.dimy()*sprite.dimz():0);
-        const unsigned int
-          offX = width-lX, soffX = sprite.width-lX,
-          offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
-          offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ),
-          slX = lX*sizeof(T);
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
-        if (lX>0 && lY>0 && lZ>0 && lV>0)
-          for (int v=0; v<lV; v++) {
-            for (int z=0; z<lZ; z++) {
-              if (opacity>=1) for (int y=0; y<lY; y++) { std::memcpy(ptrd,ptrs,slX); ptrd+=width; ptrs+=sprite.width; }
-              else for (int y=0; y<lY; y++) {
-                for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*(*(ptrs++)) + copacity*(*ptrd)); ptrd++; }
-                ptrd+=offX; ptrs+=soffX;
-              }
-              ptrd+=offY; ptrs+=soffY;
-            }
-            ptrd+=offZ; ptrs+=soffZ;
-          }
-      }
-      return *this;
-    }
-#endif
-
-    //! Draw a masked sprite image in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0).
-    /**
-       \param sprite = sprite image.
-       \param mask = mask image.
-       \param x0 = X-coordinate of the sprite position in the instance image.
-       \param y0 = Y-coordinate of the sprite position in the instance image.
-       \param z0 = Z-coordinate of the sprite position in the instance image.
-       \param v0 = V-coordinate of the sprite position in the instance image.
-       \param mask_valmax = Maximum pixel value of the mask image \c mask.
-       \param opacity = opacity of the drawing.
-       \note Pixel values of \c mask set the opacity of the corresponding pixels in \c sprite.
-       \note Clipping is supported.
-       \note Dimensions along x,y and z of \c sprite and \c mask must be the same.
-    **/
-    template<typename ti,typename tm> CImg& draw_image(const CImg<ti>& sprite, const CImg<tm>& mask,
-                                                       const int x0=0, const int y0=0, const int z0=0, const int v0=0,
-                                                       const tm mask_valmax='\1', const float opacity=1) {
-      if (!is_empty()) {
-        if (sprite.is_empty())
-          throw CImgArgumentException("CImg<%s>::draw_image() : Specified sprite image (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),sprite.width,sprite.height,sprite.depth,sprite.dim,sprite.data);
-        if (mask.is_empty())
-          throw CImgArgumentException("CImg<%s>::draw_image() : Specified mask image (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),mask.width,mask.height,mask.depth,mask.dim,mask.data);
-        if ((void*)this==(void*)&sprite) return draw_image(CImg<T>(sprite),mask,x0,y0,z0,v0);
-        if(mask.width!=sprite.width || mask.height!=sprite.height || mask.depth!=sprite.depth)
-          throw CImgArgumentException("CImg<%s>::draw_image() : Mask dimension is (%u,%u,%u,%u), while sprite is (%u,%u,%u,%u)",
-                                      pixel_type(),mask.width,mask.height,mask.depth,mask.dim,sprite.width,sprite.height,sprite.depth,sprite.dim);
-        const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
-        const int
-          lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
-          lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
-          lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),
-          lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);
-        const int coff = -(bx?x0:0)-(by?y0*mask.dimx():0)-(bz?z0*mask.dimx()*mask.dimy():0)-
-          (bv?v0*mask.dimx()*mask.dimy()*mask.dimz():0),
-          ssize = mask.dimx()*mask.dimy()*mask.dimz();
-        const ti *ptrs = sprite.ptr() + coff;
-        const tm *ptrm = mask.ptr() + coff;
-        const unsigned int
-          offX = width-lX, soffX = sprite.width-lX,
-          offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
-          offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ);
-        T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
-        if (lX>0 && lY>0 && lZ>0 && lV>0)
-          for (int v=0; v<lV; v++) {
-            ptrm = mask.data + (ptrm - mask.data)%ssize;
-            for (int z=0; z<lZ; z++) {
-              for (int y=0; y<lY; y++) {
-                for (int x=0; x<lX; x++) {
-                  const float mopacity = *(ptrm++)*opacity,
-                    nopacity = cimg::abs(mopacity), copacity = mask_valmax-cimg::max(mopacity,0.0f);
-                  *ptrd = (T)((nopacity*(*(ptrs++))+copacity*(*ptrd))/mask_valmax);
-                  ptrd++;
-                }
-                ptrd+=offX; ptrs+=soffX; ptrm+=soffX;
-              }
-              ptrd+=offY; ptrs+=soffY; ptrm+=soffY;
-            }
-            ptrd+=offZ; ptrs+=soffZ; ptrm+=soffZ;
-          }
-      }
-      return *this;
-    }
-
-    //! Draw a 4D filled rectangle in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0)-(\c x1,\c y1,\c z1,\c v1).
-    /**
-       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
-       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
-       \param z0 = Z-coordinate of the upper-left rectangle corner in the instance image.
-       \param v0 = V-coordinate of the upper-left rectangle corner in the instance image.
-       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
-       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
-       \param z1 = Z-coordinate of the lower-right rectangle corner in the instance image.
-       \param v1 = V-coordinate of the lower-right rectangle corner in the instance image.
-       \param val = scalar value used to fill the rectangle area.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_rectangle(const int x0,const int y0,const int z0,const int v0,
-                         const int x1,const int y1,const int z1,const int v1,
-                         const T& val,const float opacity=1.0f) {
-      if (!is_empty()) {
-        const bool bx=(x0<x1), by=(y0<y1), bz=(z0<z1), bv=(v0<v1);
-        const int nx0=bx?x0:x1, nx1=bx?x1:x0, ny0=by?y0:y1, ny1=by?y1:y0, nz0=bz?z0:z1, nz1=bz?z1:z0, nv0=bv?v0:v1, nv1=bv?v1:v0;
-        const int
-          lX = (1+nx1-nx0) + (nx1>=dimx()?dimx()-1-nx1:0) + (nx0<0?nx0:0),
-          lY = (1+ny1-ny0) + (ny1>=dimy()?dimy()-1-ny1:0) + (ny0<0?ny0:0),
-          lZ = (1+nz1-nz0) + (nz1>=dimz()?dimz()-1-nz1:0) + (nz0<0?nz0:0),
-          lV = (1+nv1-nv0) + (nv1>=dimv()?dimv()-1-nv1:0) + (nv0<0?nv0:0);
-        const unsigned int offX = width-lX, offY = width*(height-lY), offZ = width*height*(depth-lZ);
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        T *ptrd = ptr(nx0<0?0:nx0,ny0<0?0:ny0,nz0<0?0:nz0,nv0<0?0:nv0);
-        if (lX>0 && lY>0 && lZ>0 && lV>0)
-          for (int v=0; v<lV; v++) {
-            for (int z=0; z<lZ; z++) {
-              for (int y=0; y<lY; y++) {
-                if (opacity>=1) {
-                  if (sizeof(T)!=1) { for (int x=0; x<lX; x++) *(ptrd++) = val; ptrd+=offX; }
-                  else { std::memset(ptrd,(int)val,lX); ptrd+=width; }
-                } else { for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*val+copacity*(*ptrd)); ptrd++; } ptrd+=offX; }
-              }
-              ptrd+=offY;
-            }
-            ptrd+=offZ;
-          }
-      }
-      return *this;
-    }
-
-    //! Draw a 3D filled colored rectangle in the instance image, at coordinates (\c x0,\c y0,\c z0)-(\c x1,\c y1,\c z1).
-    /**
-       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
-       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
-       \param z0 = Z-coordinate of the upper-left rectangle corner in the instance image.
-       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
-       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
-       \param z1 = Z-coordinate of the lower-right rectangle corner in the instance image.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_rectangle(const int x0,const int y0,const int z0,
-                         const int x1,const int y1,const int z1,
-                         const T *const color,const float opacity=1) {
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_rectangle : specified color is (null)",pixel_type());
-      cimg_forV(*this,k) draw_rectangle(x0,y0,z0,k,x1,y1,z1,k,color[k],opacity);
-      return *this;
-    }
-
-    //! Draw a 2D filled colored rectangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
-       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
-       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
-       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_rectangle(const int x0,const int y0,const int x1,const int y1,
-                         const T *const color,const float opacity=1) {
-      draw_rectangle(x0,y0,0,x1,y1,depth-1,color,opacity);
-      return *this;
-    }
-
-    //! Draw a 2D filled colored triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing (<1)
-       \param brightness = brightness of the drawing (in [0,1])
-       \note Clipping is supported.
-    **/
-    CImg& draw_triangle(const int x0,const int y0,
-                        const int x1,const int y1,
-                        const int x2,const int y2,
-                        const T *const color,
-                        const float opacity=1,
-                        const float brightness=1) {
-      draw_scanline(color,opacity);
-      int nx0 = x0, ny0 = y0, nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2;
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1);
-      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2);
-      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2);
-      if (ny0>=dimy() || ny2<0) return *this;
-      const float
-        p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-        p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-        p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1);
-      float xleft = (float)nx0, xright = xleft, pleft = (p1<p2)?p1:p2, pright = (p1<p2)?p2:p1;
-      if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; }
-      const int ya = ny1>dimy()?height:ny1;
-      for (int y=ny0<0?0:ny0; y<ya; y++) {
-        draw_scanline((int)xleft,(int)xright,y,color,opacity,brightness);
-        xleft+=pleft; xright+=pright;
-      }
-      if (p1<p2) { xleft=(float)nx1;  pleft=p3;  if (ny1<0) xleft-=ny1*pleft; }
-      else       { xright=(float)nx1; pright=p3; if (ny1<0) xright-=ny1*pright; }
-      const int yb = ny2>=dimy()?height-1:ny2;
-      for (int yy=ny1<0?0:ny1; yy<=yb; yy++) {
-        draw_scanline((int)xleft,(int)xright,yy,color,opacity,brightness);
-        xleft+=pleft; xright+=pright;
-      }
-      return *this;
-    }
-
-    //! Draw a 2D Gouraud-filled triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param color = array of dimv() values of type \c T, defining the global drawing color.
-       \param c0 = brightness of the first corner.
-       \param c1 = brightness of the second corner.
-       \param c2 = brightness of the third corner.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_triangle(const int x0, const int y0,
-                        const int x1, const int y1,
-                        const int x2, const int y2,
-                        const T *const color,
-                        const float c0, const float c1, const float c2,
-                        const float opacity=1) {
-      if (!is_empty()) {
-        int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,whz=width*height*depth;
-        float nc0=c0,nc1=c1,nc2=c2;
-        if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nc0,nc1);
-        if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,nc0,nc2);
-        if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,nc1,nc2);
-        if (ny0>=dimy() || ny2<0) return *this;
-        const float
-          p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-          p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-          p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1),
-          cp1 = (ny1-ny0)?(nc1-nc0)/(float)(ny1-ny0):0,
-          cp2 = (ny2-ny0)?(nc2-nc0)/(float)(ny2-ny0):0,
-          cp3 = (ny2-ny1)?(nc2-nc1)/(float)(ny2-ny1):0;
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        float pleft,pright,cpleft,cpright,xleft=(float)nx0,xright=xleft,cleft=nc0,cright=cleft;
-        if (p1<p2) { pleft=p1; pright=p2; cpleft=cp1; cpright=cp2; }
-        else       { pleft=p2; pright=p1; cpleft=cp2; cpright=cp1; }
-        if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; cleft-=ny0*cpleft; cright-=ny0*cpright; }
-        const int ya = ny1<dimy()?ny1:height;
-        for (int y=(ny0<0?0:ny0); y<ya; y++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            cp = dx?(cright-cleft)/dx:0,
-            ci = (xleft>=0)?cleft:(cleft-xleft*cp);
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,y,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              const T col = color[k];
-              float c=ci;
-              for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)(c*col); c+=cp; }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              const T col = color[k];
-              float c=ci;
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*c*col+copacity*(*ptrd)); ptrd++; c+=cp; }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright; cleft+=cpleft; cright+=cpright;
-        }
-
-        if (p1<p2) {
-          xleft=(float)nx1; pleft=p3; cleft=nc1; cpleft=cp3;
-          if (ny1<0) { xleft-=ny1*pleft; cleft-=ny1*cpleft; }
-        } else {
-          xright=(float)nx1; pright=p3; cright=nc1; cpright=cp3;
-          if (ny1<0) { xright-=ny1*pright; cright-=ny1*cpright; }
-        }
-        const int yb = ny2>=dimy()?(height-1):ny2;
-        for (int yy=(ny1<0?0:ny1); yy<=yb; yy++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            cp = dx?(cright-cleft)/dx:0,
-            ci = (xleft>=0)?cleft:(cleft-xleft*cp);
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,yy,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              const T col = color[k];
-              float c=ci;
-              for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)(c*col); c+=cp; }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              const T col = color[k];
-              float c=ci;
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*c*col+copacity*(*ptrd)); ptrd++; c+=cp; }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright; cleft+=cpleft; cright+=cpright;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 2D phong-shaded triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param color = array of dimv() values of type \c T, defining the global drawing color.
-       \param light = light image.
-       \param lx0 = X-coordinate of the first corner in the light image.
-       \param ly0 = Y-coordinate of the first corner in the light image.
-       \param lx1 = X-coordinate of the second corner in the light image.
-       \param ly1 = Y-coordinate of the second corner in the light image.
-       \param lx2 = X-coordinate of the third corner in the light image.
-       \param ly2 = Y-coordinate of the third corner in the light image.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported, but texture coordinates do not support clipping.
-    **/
-    template<typename t> CImg& draw_triangle(const int x0,const int y0,
-                                             const int x1,const int y1,
-                                             const int x2,const int y2,
-                                             const T *const color,
-                                             const CImg<t>& light,
-                                             const int lx0,const int ly0,
-                                             const int lx1,const int ly1,
-                                             const int lx2,const int ly2,
-                                             const float opacity=1.0f) {
-      if (!is_empty()) {
-        if (light.is_empty())
-          throw CImgArgumentException("CImg<%s>::draw_triangle() : Specified light texture (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),light.width,light.height,light.depth,light.dim,light.data);
-        int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,nlx0=lx0,nly0=ly0,nlx1=lx1,nly1=ly1,nlx2=lx2,nly2=ly2,whz=width*height*depth;
-        if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nlx0,nlx1,nly0,nly1);
-        if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,nlx0,nlx2,nly0,nly2);
-        if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,nlx1,nlx2,nly1,nly2);
-        if (ny0>=dimy() || ny2<0) return *this;
-        const float
-          p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-          p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-          p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1),
-          lpx1 = (ny1-ny0)?(nlx1-nlx0)/(float)(ny1-ny0):0,
-          lpy1 = (ny1-ny0)?(nly1-nly0)/(float)(ny1-ny0):0,
-          lpx2 = (ny2-ny0)?(nlx2-nlx0)/(float)(ny2-ny0):0,
-          lpy2 = (ny2-ny0)?(nly2-nly0)/(float)(ny2-ny0):0,
-          lpx3 = (ny2-ny1)?(nlx2-nlx1)/(float)(ny2-ny1):0,
-          lpy3 = (ny2-ny1)?(nly2-nly1)/(float)(ny2-ny1):0;
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        float pleft,pright,lpxleft,lpyleft,lpxright,lpyright,
-          xleft=(float)nx0,xright=xleft,lxleft=(float)nlx0,lyleft=(float)nly0,lxright=lxleft,lyright=lyleft;
-        if (p1<p2) { pleft=p1; pright=p2; lpxleft=lpx1; lpyleft=lpy1; lpxright=lpx2; lpyright=lpy2; }
-        else       { pleft=p2; pright=p1; lpxleft=lpx2; lpyleft=lpy2; lpxright=lpx1; lpyright=lpy1; }
-        if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; lxleft-=ny0*lpxleft; lyleft-=ny0*lpyleft;
-        lxright-=ny0*lpxright; lyright-=ny0*lpyright; }
-        const int ya = ny1<dimy()?ny1:height;
-        for (int y=(ny0<0?0:ny0); y<ya; y++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            lpx = dx?((int)lxright-(int)lxleft)/(float)dx:0,
-            lpy = dx?((int)lyright-(int)lyleft)/(float)dx:0,
-            lxi = (float)((xleft>=0)?(int)lxleft:(int)(lxleft-(int)xleft*lpx)),
-            lyi = (float)((xleft>=0)?(int)lyleft:(int)(lyleft-(int)xleft*lpy));
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,y,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              float lx=lxi, ly=lyi;
-              for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)(light((unsigned int)lx,(unsigned int)ly)*color[k]); lx+=lpx; ly+=lpy; }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              float lx=lxi, ly=lyi;
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*light((unsigned int)lx,(unsigned int)ly)*color[k]+copacity*(*ptrd)); ptrd++; lx+=lpx; ly+=lpy; }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright; lxleft+=lpxleft; lyleft+=lpyleft; lxright+=lpxright; lyright+=lpyright;
-        }
-
-        if (p1<p2) {
-          xleft=(float)nx1; pleft=p3; lxleft=(float)nlx1; lyleft=(float)nly1; lpxleft=lpx3; lpyleft=lpy3;
-          if (ny1<0) { xleft-=ny1*pleft; lxleft-=ny1*lpxleft; lyleft-=ny1*lpyleft; }
-        } else {
-          xright=(float)nx1; pright=p3; lxright=(float)nlx1; lyright=(float)nly1; lpxright=lpx3; lpyright=lpy3;
-          if (ny1<0) { xright-=ny1*pright; lxright-=ny1*lpxright; lyright-=ny1*lpyright; }
-        }
-        const int yb = ny2>=dimy()?(height-1):ny2;
-        for (int yy=(ny1<0?0:ny1); yy<=yb; yy++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            lpx = dx?((int)lxright-(int)lxleft)/(float)dx:0,
-            lpy = dx?((int)lyright-(int)lyleft)/(float)dx:0,
-            lxi = (float)((xleft>=0)?(int)lxleft:(int)(lxleft-(int)xleft*lpx)),
-            lyi = (float)((xleft>=0)?(int)lyleft:(int)(lyleft-(int)xleft*lpy));
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,yy,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              float lx=lxi, ly=lyi;
-              for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)(light((unsigned int)lx,(unsigned int)ly)*color[k]); lx+=lpx; ly+=lpy; }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              float lx=lxi, ly=lyi;
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*light((unsigned int)lx,(unsigned int)ly)*color[k]+copacity*(*ptrd)); ptrd++; lx+=lpx; ly+=lpy; }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright; lxleft+=lpxleft; lyleft+=lpyleft; lxright+=lpxright; lyright+=lpyright;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 2D textured triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param texture = texture image used to fill the triangle.
-       \param tx0 = X-coordinate of the first corner in the texture image.
-       \param ty0 = Y-coordinate of the first corner in the texture image.
-       \param tx1 = X-coordinate of the second corner in the texture image.
-       \param ty1 = Y-coordinate of the second corner in the texture image.
-       \param tx2 = X-coordinate of the third corner in the texture image.
-       \param ty2 = Y-coordinate of the third corner in the texture image.
-       \param opacity = opacity of the drawing.
-       \param brightness = brightness of the drawing.
-       \note Clipping is supported, but texture coordinates do not support clipping.
-    **/
-    template<typename t> CImg& draw_triangle(const int x0,const int y0,
-                                             const int x1,const int y1,
-                                             const int x2,const int y2,
-                                             const CImg<t>& texture,
-                                             const int tx0,const int ty0,
-                                             const int tx1,const int ty1,
-                                             const int tx2,const int ty2,
-                                             const float opacity=1.0f, const float brightness=1.0f) {
-      if (!is_empty()) {
-        if (texture.is_empty())
-          throw CImgArgumentException("CImg<%s>::draw_triangle() : Specified texture (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),texture.width,texture.height,texture.depth,texture.dim,texture.data);
-        int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,ntx0=tx0,nty0=ty0,ntx1=tx1,nty1=ty1,ntx2=tx2,nty2=ty2,whz=width*height*depth;
-        if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
-        if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2);
-        if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2);
-        if (ny0>=dimy() || ny2<0) return *this;
-        const float
-          p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-          p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-          p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1),
-          tpx1 = (ny1-ny0)?(ntx1-ntx0)/(float)(ny1-ny0):0,
-          tpy1 = (ny1-ny0)?(nty1-nty0)/(float)(ny1-ny0):0,
-          tpx2 = (ny2-ny0)?(ntx2-ntx0)/(float)(ny2-ny0):0,
-          tpy2 = (ny2-ny0)?(nty2-nty0)/(float)(ny2-ny0):0,
-          tpx3 = (ny2-ny1)?(ntx2-ntx1)/(float)(ny2-ny1):0,
-          tpy3 = (ny2-ny1)?(nty2-nty1)/(float)(ny2-ny1):0;
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        float pleft,pright,tpxleft,tpyleft,tpxright,tpyright,
-          xleft=(float)nx0,xright=xleft,txleft=(float)ntx0,tyleft=(float)nty0,txright=txleft,tyright=tyleft;
-        if (p1<p2) { pleft=p1; pright=p2; tpxleft=tpx1; tpyleft=tpy1; tpxright=tpx2; tpyright=tpy2; }
-        else       { pleft=p2; pright=p1; tpxleft=tpx2; tpyleft=tpy2; tpxright=tpx1; tpyright=tpy1; }
-        if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; txleft-=ny0*tpxleft; tyleft-=ny0*tpyleft;
-        txright-=ny0*tpxright; tyright-=ny0*tpyright; }
-        const int ya = ny1<dimy()?ny1:height;
-        for (int y=(ny0<0?0:ny0); y<ya; y++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-            tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,
-            txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-            tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy));
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,y,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              float tx=txi, ty=tyi;
-              for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)(brightness*texture((unsigned int)tx,(unsigned int)ty,0,k)); tx+=tpx; ty+=tpy; }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              float tx=txi, ty=tyi;
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*brightness*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
-        }
-
-        if (p1<p2) {
-          xleft=(float)nx1; pleft=p3; txleft=(float)ntx1; tyleft=(float)nty1; tpxleft=tpx3; tpyleft=tpy3;
-          if (ny1<0) { xleft-=ny1*pleft; txleft-=ny1*tpxleft; tyleft-=ny1*tpyleft; }
-        } else {
-          xright=(float)nx1; pright=p3; txright=(float)ntx1; tyright=(float)nty1; tpxright=tpx3; tpyright=tpy3;
-          if (ny1<0) { xright-=ny1*pright; txright-=ny1*tpxright; tyright-=ny1*tpyright; }
-        }
-        const int yb = ny2>=dimy()?(height-1):ny2;
-        for (int yy=(ny1<0?0:ny1); yy<=yb; yy++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-            tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,
-            txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-            tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy));
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,yy,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              float tx=txi, ty=tyi;
-              for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)(brightness*texture((unsigned int)tx,(unsigned int)ty,0,k)); tx+=tpx; ty+=tpy; }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              float tx=txi, ty=tyi;
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*brightness*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 2D textured triangle with Gouraud-Shading in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param texture = texture image used to fill the triangle.
-       \param tx0 = X-coordinate of the first corner in the texture image.
-       \param ty0 = Y-coordinate of the first corner in the texture image.
-       \param tx1 = X-coordinate of the second corner in the texture image.
-       \param ty1 = Y-coordinate of the second corner in the texture image.
-       \param tx2 = X-coordinate of the third corner in the texture image.
-       \param ty2 = Y-coordinate of the third corner in the texture image.
-       \param c0 = brightness value of the first corner.
-       \param c1 = brightness value of the second corner.
-       \param c2 = brightness value of the third corner.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported, but texture coordinates do not support clipping.
-    **/
-    template<typename t> CImg& draw_triangle(const int x0,const int y0,
-                                             const int x1,const int y1,
-                                             const int x2,const int y2,
-                                             const CImg<t>& texture,
-                                             const int tx0,const int ty0,
-                                             const int tx1,const int ty1,
-                                             const int tx2,const int ty2,
-                                             const float c0,const float c1,const float c2,
-                                             const float opacity=1) {
-      if (!is_empty()) {
-        if (texture.is_empty())
-          throw CImgArgumentException("CImg<%s>::draw_triangle() : Specified texture (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),texture.width,texture.height,texture.depth,texture.dim,texture.data);
-        int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,ntx0=tx0,nty0=ty0,ntx1=tx1,nty1=ty1,ntx2=tx2,nty2=ty2,whz=width*height*depth;
-        float nc0=c0,nc1=c1,nc2=c2;
-        if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nc0,nc1);
-        if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nc0,nc2);
-        if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nc1,nc2);
-        if (ny0>=dimy() || ny2<0) return *this;
-        const float
-          p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-          p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-          p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1),
-          tpx1 = (ny1-ny0)?(ntx1-ntx0)/(float)(ny1-ny0):0,
-          tpy1 = (ny1-ny0)?(nty1-nty0)/(float)(ny1-ny0):0,
-          tpx2 = (ny2-ny0)?(ntx2-ntx0)/(float)(ny2-ny0):0,
-          tpy2 = (ny2-ny0)?(nty2-nty0)/(float)(ny2-ny0):0,
-          tpx3 = (ny2-ny1)?(ntx2-ntx1)/(float)(ny2-ny1):0,
-          tpy3 = (ny2-ny1)?(nty2-nty1)/(float)(ny2-ny1):0,
-          cp1 = (ny1-ny0)?(nc1-nc0)/(float)(ny1-ny0):0,
-          cp2 = (ny2-ny0)?(nc2-nc0)/(float)(ny2-ny0):0,
-          cp3 = (ny2-ny1)?(nc2-nc1)/(float)(ny2-ny1):0;
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        float pleft,pright,tpxleft,tpyleft,tpxright,tpyright,cpleft,cpright,
-          xleft=(float)nx0,xright=xleft,txleft=(float)ntx0,tyleft=(float)nty0,txright=txleft,tyright=tyleft,cleft=nc0,cright=cleft;
-        if (p1<p2) { pleft=p1; pright=p2; tpxleft=tpx1; tpyleft=tpy1; tpxright=tpx2; tpyright=tpy2; cpleft=cp1; cpright=cp2; }
-        else       { pleft=p2; pright=p1; tpxleft=tpx2; tpyleft=tpy2; tpxright=tpx1; tpyright=tpy1; cpleft=cp2, cpright=cp1; }
-        if (ny0<0) {
-          xleft-=ny0*pleft; xright-=ny0*pright; txleft-=ny0*tpxleft; tyleft-=ny0*tpyleft; cleft-=ny0*cpleft;
-          txright-=ny0*tpxright; tyright-=ny0*tpyright; cright-=ny0*cpright;
-        }
-        const int ya = ny1<dimy()?ny1:height;
-        for (int y=(ny0<0?0:ny0); y<ya; y++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-            tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,
-            cp = dx?(cright-cleft)/dx:0,
-            txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-            tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy)),
-            ci = (xleft>=0)?cleft:(cleft-xleft*cp);
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,y,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              float tx=txi, ty=tyi, c=ci;
-              for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)(c*texture((unsigned int)tx,(unsigned int)ty,0,k)); tx+=tpx; ty+=tpy; c+=cp; }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              float tx=txi, ty=tyi, c=ci;
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*c*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; c+=cp; }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright; cleft+=cpleft; cright+=cpright;
-        }
-
-        if (p1<p2) {
-          xleft=(float)nx1; pleft=p3; txleft=(float)ntx1; tyleft=(float)nty1; tpxleft=tpx3; tpyleft=tpy3; cleft=nc1; cpleft=cp3;
-          if (ny1<0) { xleft-=ny1*pleft; txleft-=ny1*tpxleft; tyleft-=ny1*tpyleft; cleft-=ny1*cpleft; }
-        } else {
-          xright=(float)nx1; pright=p3; txright=(float)ntx1; tyright=(float)nty1; tpxright=tpx3; tpyright=tpy3; cright=nc1; cpright=cp3;
-          if (ny1<0) { xright-=ny1*pright; txright-=ny1*tpxright; tyright-=ny1*tpyright; cright-=ny1*cpright; }
-        }
-        const int yb = ny2>=dimy()?(height-1):ny2;
-        for (int yy=(ny1<0?0:ny1); yy<=yb; yy++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-            tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,
-            cp = dx?(cright-cleft)/dx:0,
-            txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-            tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy)),
-            ci = (xleft>=0)?cleft:(cleft-xleft*cp);
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,yy,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              float tx=txi, ty=tyi, c=ci;
-              for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)(c*texture((unsigned int)tx,(unsigned int)ty,0,k)); tx+=tpx; ty+=tpy; c+=cp; }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              float tx=txi, ty=tyi, c=ci;
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*c*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; c+=ci; }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright; cleft+=cpleft; cright+=cpright;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a phong-shaded 2D textured triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param texture = texture image used to fill the triangle.
-       \param tx0 = X-coordinate of the first corner in the texture image.
-       \param ty0 = Y-coordinate of the first corner in the texture image.
-       \param tx1 = X-coordinate of the second corner in the texture image.
-       \param ty1 = Y-coordinate of the second corner in the texture image.
-       \param tx2 = X-coordinate of the third corner in the texture image.
-       \param ty2 = Y-coordinate of the third corner in the texture image.
-       \param light = light image.
-       \param lx0 = X-coordinate of the first corner in the light image.
-       \param ly0 = Y-coordinate of the first corner in the light image.
-       \param lx1 = X-coordinate of the second corner in the light image.
-       \param ly1 = Y-coordinate of the second corner in the light image.
-       \param lx2 = X-coordinate of the third corner in the light image.
-       \param ly2 = Y-coordinate of the third corner in the light image.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported, but texture coordinates do not support clipping.
-    **/
-    template<typename t, typename tl> CImg& draw_triangle(const int x0,const int y0,
-                                                          const int x1,const int y1,
-                                                          const int x2,const int y2,
-                                                          const CImg<t>& texture,
-                                                          const int tx0,const int ty0,
-                                                          const int tx1,const int ty1,
-                                                          const int tx2,const int ty2,
-                                                          const CImg<tl>& light,
-                                                          const int lx0,const int ly0,
-                                                          const int lx1,const int ly1,
-                                                          const int lx2,const int ly2,
-                                                          const float opacity=1.0f) {
-      if (!is_empty()) {
-        if (texture.is_empty())
-          throw CImgArgumentException("CImg<%s>::draw_triangle() : Specified texture (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),texture.width,texture.height,texture.depth,texture.dim,texture.data);
-        if (light.is_empty())
-          throw CImgArgumentException("CImg<%s>::draw_triangle() : Specified light (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),light.width,light.height,light.depth,light.dim,light.data);
-        int
-          nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,
-          ntx0=tx0,nty0=ty0,ntx1=tx1,nty1=ty1,ntx2=tx2,nty2=ty2,
-          nlx0=lx0,nly0=ly0,nlx1=lx1,nly1=ly1,nlx2=lx2,nly2=ly2,
-          whz=width*height*depth;
-        if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1,nlx0,nlx1,nly0,nly1);
-        if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2,nlx0,nlx2,nly0,nly2);
-        if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2,nlx1,nlx2,nly1,nly2);
-        if (ny0>=dimy() || ny2<0) return *this;
-        const float
-          p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-          p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-          p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1),
-          tpx1 = (ny1-ny0)?(ntx1-ntx0)/(float)(ny1-ny0):0,
-          tpy1 = (ny1-ny0)?(nty1-nty0)/(float)(ny1-ny0):0,
-          tpx2 = (ny2-ny0)?(ntx2-ntx0)/(float)(ny2-ny0):0,
-          tpy2 = (ny2-ny0)?(nty2-nty0)/(float)(ny2-ny0):0,
-          tpx3 = (ny2-ny1)?(ntx2-ntx1)/(float)(ny2-ny1):0,
-          tpy3 = (ny2-ny1)?(nty2-nty1)/(float)(ny2-ny1):0,
-          lpx1 = (ny1-ny0)?(nlx1-nlx0)/(float)(ny1-ny0):0,
-          lpy1 = (ny1-ny0)?(nly1-nly0)/(float)(ny1-ny0):0,
-          lpx2 = (ny2-ny0)?(nlx2-nlx0)/(float)(ny2-ny0):0,
-          lpy2 = (ny2-ny0)?(nly2-nly0)/(float)(ny2-ny0):0,
-          lpx3 = (ny2-ny1)?(nlx2-nlx1)/(float)(ny2-ny1):0,
-          lpy3 = (ny2-ny1)?(nly2-nly1)/(float)(ny2-ny1):0;
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        float pleft,pright,tpxleft,tpyleft,tpxright,tpyright,lpxleft,lpyleft,lpxright,lpyright,
-          xleft=(float)nx0,xright=xleft,
-          txleft=(float)ntx0,tyleft=(float)nty0,txright=txleft,tyright=tyleft,
-          lxleft=(float)nlx0,lyleft=(float)nly0,lxright=lxleft,lyright=lyleft;
-        if (p1<p2) {
-          pleft=p1; pright=p2;
-          tpxleft=tpx1; tpyleft=tpy1; tpxright=tpx2; tpyright=tpy2;
-          lpxleft=lpx1; lpyleft=lpy1; lpxright=lpx2; lpyright=lpy2;
-        } else {
-          pleft=p2; pright=p1;
-          tpxleft=tpx2; tpyleft=tpy2; tpxright=tpx1; tpyright=tpy1;
-          lpxleft=tpx2; lpyleft=tpy2; lpxright=tpx1; lpyright=tpy1;
-        }
-        if (ny0<0) {
-          xleft-=ny0*pleft; xright-=ny0*pright;
-          txleft-=ny0*tpxleft; tyleft-=ny0*tpyleft; txright-=ny0*tpxright; tyright-=ny0*tpyright;
-          lxleft-=ny0*lpxleft; lyleft-=ny0*lpyleft; lxright-=ny0*lpxright; lyright-=ny0*lpyright;
-        }
-        const int ya = ny1<dimy()?ny1:height;
-        for (int y=(ny0<0?0:ny0); y<ya; y++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-            tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,
-            txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-            tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy)),
-            lpx = dx?((int)lxright-(int)lxleft)/(float)dx:0,
-            lpy = dx?((int)lyright-(int)lyleft)/(float)dx:0,
-            lxi = (float)((xleft>=0)?(int)lxleft:(int)(lxleft-(int)xleft*lpx)),
-            lyi = (float)((xleft>=0)?(int)lyleft:(int)(lyleft-(int)xleft*lpy));
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,y,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              float tx=txi, ty=tyi, lx=lxi, ly=lyi;
-              for (int x=xmin; x<=xmax; x++) {
-                *(ptrd++)=(T)(light((unsigned int)lx,(unsigned int)ly)*texture((unsigned int)tx,(unsigned int)ty,0,k));
-                tx+=tpx; ty+=tpy; lx+=lpx; ly+=lpy;
-              }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              float tx=txi, ty=tyi, lx=lxi, ly=lyi;
-              for (int x=xmin; x<=xmax; x++) {
-                *ptrd=(T)(nopacity*light((unsigned int)lx,(unsigned int)ly)*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++;
-                tx+=tpx; ty+=tpy; lx+=lpx; ly+=lpy;
-              }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright;
-          txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
-          lxleft+=lpxleft; lyleft+=lpyleft; lxright+=lpxright; lyright+=lpyright;
-        }
-
-        if (p1<p2) {
-          xleft=(float)nx1; pleft=p3;
-          txleft=(float)ntx1; tyleft=(float)nty1; tpxleft=tpx3; tpyleft=tpy3;
-          lxleft=(float)nlx1; lyleft=(float)nly1; lpxleft=lpx3; lpyleft=lpy3;
-          if (ny1<0) { xleft-=ny1*pleft; txleft-=ny1*tpxleft; tyleft-=ny1*tpyleft; lxleft-=ny1*lpxleft; lyleft-=ny1*lpyleft; }
-        } else {
-          xright=(float)nx1; pright=p3;
-          txright=(float)ntx1; tyright=(float)nty1; tpxright=tpx3; tpyright=tpy3;
-          lxright=(float)nlx1; lyright=(float)nly1; lpxright=lpx3; lpyright=lpy3;
-          if (ny1<0) { xright-=ny1*pright; txright-=ny1*tpxright; tyright-=ny1*tpyright; lxright-=ny1*lpxright; lyright-=ny1*lpyright; }
-        }
-        const int yb = ny2>=dimy()?(height-1):ny2;
-        for (int yy=(ny1<0?0:ny1); yy<=yb; yy++) {
-          const int dx = (int)xright-(int)xleft;
-          const float
-            tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-            tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,
-            txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-            tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy)),
-            lpx = dx?((int)lxright-(int)lxleft)/(float)dx:0,
-            lpy = dx?((int)lyright-(int)lyleft)/(float)dx:0,
-            lxi = (float)((xleft>=0)?(int)lxleft:(int)(lxleft-(int)xleft*lpx)),
-            lyi = (float)((xleft>=0)?(int)lyleft:(int)(lyleft-(int)xleft*lpy));
-          const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-          if (xmin<=xmax) {
-            const int offx=whz-xmax+xmin-1;
-            T* ptrd = ptr(xmin,yy,0,0);
-            if (opacity>=1) cimg_forV(*this,k) {
-              float tx=txi, ty=tyi, lx=lxi, ly=lyi;
-              for (int x=xmin; x<=xmax; x++) {
-                *(ptrd++)=(T)(light((unsigned int)lx,(unsigned int)ly)*texture((unsigned int)tx,(unsigned int)ty,0,k));
-                tx+=tpx; ty+=tpy; lx+=lpx; ly+=lpy;
-              }
-              ptrd+=offx;
-            } else cimg_forV(*this,k) {
-              float tx=txi, ty=tyi, lx=lxi, ly=lyi;
-              for (int x=xmin; x<=xmax; x++) {
-                *ptrd=(T)(nopacity*light((unsigned int)lx,(unsigned int)ly)*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++;
-                tx+=tpx; ty+=tpy; lx+=lpx; ly+=lpy;
-              }
-              ptrd+=offx;
-            }
-          }
-          xleft+=pleft; xright+=pright;
-          txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
-          lxleft+=lpxleft; lyleft+=lpyleft; lxright+=lpxright; lyright+=lpyright;
-        }
-      }
-      return *this;
-    }
-
-
-    //! Draw an ellipse on the instance image
-    /**
-       \param x0 = X-coordinate of the ellipse center.
-       \param y0 = Y-coordinate of the ellipse center.
-       \param r1 = First radius of the ellipse.
-       \param r2 = Second radius of the ellipse.
-       \param ru = X-coordinate of the orientation vector related to the first radius.
-       \param rv = Y-coordinate of the orientation vector related to the first radius.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = If zero, the ellipse is filled, else pattern is an integer whose bits describe the outline pattern.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_ellipse(const int x0,const int y0,const float r1,const float r2,const float ru,const float rv,
-                       const T *const color,const unsigned int pattern=0L, const float opacity=1) {
-      if (!is_empty()) {
-        draw_scanline(color,opacity);
-        if (!color) throw CImgArgumentException("CImg<%s>::draw_ellipse : Specified color is (null).",pixel_type());
-        unsigned int hatch=1;
-        const float
-          nr1 = cimg::abs(r1), nr2 = cimg::abs(r2),
-          norm = (float)std::sqrt(ru*ru+rv*rv),
-          u = norm>0?ru/norm:1,
-          v = norm>0?rv/norm:0,
-          rmax = cimg::max(nr1,nr2),
-          l1 = (float)std::pow(rmax/(nr1>0?nr1:1e-6),2),
-          l2 = (float)std::pow(rmax/(nr2>0?nr2:1e-6),2),
-          a = l1*u*u + l2*v*v,
-          b = u*v*(l1-l2),
-          c = l1*v*v + l2*u*u;
-        const int
-          yb = (int)std::sqrt(a*rmax*rmax/(a*c-b*b)),
-          ymin = (y0-yb<0)?0:(y0-yb),
-          ymax = (1+y0+yb>=dimy())?height-1:(1+y0+yb);
-        int oxmin=0, oxmax=0;
-        bool first_line = true;
-        for (int y=ymin; y<ymax; y++) {
-          const float
-            Y = (float)(y-y0)+0.25f,
-            delta = b*b*Y*Y-a*(c*Y*Y-rmax*rmax),
-            sdelta = (float)((delta>0?std::sqrt(delta):0)),
-            fxmin = x0-(b*Y+sdelta)/a,
-            fxmax = x0-(b*Y-sdelta)/a;
-          const int xmin = (int)fxmin, xmax = (int)fxmax;
-          if (!pattern) draw_scanline(xmin,xmax,y,color,opacity);
-          else {
-            if (!(~pattern) || (~pattern && pattern&hatch)) {
-              if (first_line) { draw_scanline(xmin,xmax,y,color,opacity); first_line = false; }
-              else {
-                if (xmin<oxmin) draw_scanline(xmin,oxmin-1,y,color,opacity);
-                else draw_scanline(oxmin+(oxmin==xmin?0:1),xmin,y,color,opacity);
-                if (xmax<oxmax) draw_scanline(xmax,oxmax-1,y,color,opacity);
-                else draw_scanline(oxmax+(oxmax==xmax?0:1),xmax,y,color,opacity);
-              }
-            }
-          }
-          oxmin = xmin; oxmax = xmax;
-          if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned int)*8-1));
-        }
-      }
-      return *this;
-    }
-
-    //! Draw an ellipse on the instance image
-    /**
-       \param x0 = X-coordinate of the ellipse center.
-       \param y0 = Y-coordinate of the ellipse center.
-       \param tensor = Diffusion tensor describing the ellipse.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = If zero, the ellipse is filled, else pattern is an integer whose bits describe the outline pattern.
-       \param opacity = opacity of the drawing.
-    **/
-    template<typename t> CImg& draw_ellipse(const int x0,const int y0,const CImg<t> &tensor,
-                                            const T *color,const unsigned int pattern=0L,const float opacity=1) {
-      CImgList<t> eig = tensor.get_symmetric_eigen();
-      const CImg<t> &val = eig[0], &vec = eig[1];
-      return draw_ellipse(x0,y0,val(0),val(1),vec(0,0),vec(0,1),color,pattern,opacity);
-    }
-
-    //! Draw a circle on the instance image
-    /**
-       \param x0 = X-coordinate of the circle center.
-       \param y0 = Y-coordinate of the circle center.
-       \param r = radius of the circle.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = If zero, the circle is filled, else pattern is an integer whose bits describe the outline pattern.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_circle(const int x0,const int y0,float r,const T *const color,const unsigned int pattern=0L,const float opacity=1) {
-      return draw_ellipse(x0,y0,r,r,1,0,color,pattern,opacity);
-    }
-
-    //! Draw a text into the instance image.
-    /**
-       \param text = a C-string containing the text to display.
-       \param x0 = X-coordinate of the text in the instance image.
-       \param y0 = Y-coordinate of the text in the instance image.
-       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (0 means 'transparent').
-       \param bgcolor = an array of dimv() values of type \c T, defining the background color (0 means 'transparent').
-       \param font = List of font characters used for the drawing.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-       \see get_font().
-    **/
-    template<typename t> CImg& draw_text(const char *const text,
-                                         const int x0,const int y0,
-                                         const T *const fgcolor,const T *const bgcolor,
-                                         const CImgList<t>& font,const float opacity=1) {
-      if (!text)
-        throw CImgArgumentException("CImg<%s>::draw_text() : Specified input string is (null).",pixel_type());
-      if (font.is_empty())
-        throw CImgArgumentException("CImg<%s>::draw_text() : Specified font (%u,%p) is empty.",
-                                    pixel_type(),font.size,font.data);
-
-      if (is_empty()) {
-        // If needed, pre-compute needed size of the image
-        int x=0, y=0, w=0;
-        for (int i=0; i<cimg::strlen(text); i++) {
-          const unsigned char c = text[i];
-          switch (c) {
-          case '\n': y+=font[' '].height; if (x>w) w=x; x=0; break;
-          case '\t': x+=4*font[' '].width; break;
-          default: if (c<font.size) x+=font[c].width;
-          }
-        }
-        if (x!=0) {
-          if (x>w) w=x;
-          y+=font[' '].height;
-        }
-        assign(x0+w,y0+y,1,font[' '].dim,0);
-        if (bgcolor) cimg_forV(*this,k) get_shared_channel(k).fill(bgcolor[k]);
-      }
-
-      int x = x0, y = y0;
-      CImg<T> letter;
-      for (int i=0; i<cimg::strlen(text); i++) {
-        const unsigned char c = text[i];
-        switch (c) {
-        case '\n': y+=font[' '].height; x=x0; break;
-        case '\t': x+=4*font[' '].width; break;
-        default: if (c<font.size) {
-          letter = font[c];
-          const CImg& mask = (c+256)<(int)font.size?font[c+256]:font[c];
-          if (fgcolor) for (unsigned int p=0; p<letter.width*letter.height; p++)
-            if (mask(p)) cimg_forV(*this,k) letter(p,0,0,k) = (T)(letter(p,0,0,k)*fgcolor[k]);
-          if (bgcolor) for (unsigned int p=0; p<letter.width*letter.height; p++)
-            if (!mask(p)) cimg_forV(*this,k) letter(p,0,0,k) = bgcolor[k];
-          if (!bgcolor && font.size>=512) draw_image(letter,mask,x,y,0,0,(T)1,opacity);
-          else draw_image(letter,x,y,0,0,opacity);
-          x+=letter.width;
-        }
-          break;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a text into the instance image.
-    /**
-       \param text = a C-string containing the text to display.
-       \param x0 = X-coordinate of the text in the instance image.
-       \param y0 = Y-coordinate of the text in the instance image.
-       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (0 means 'transparent').
-       \param bgcolor = an array of dimv() values of type \c T, defining the background color (0 means 'transparent').
-       \param font_size = Height of the desired font (11,13,24,38 or 57)
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-       \see get_font().
-    **/
-    CImg& draw_text(const char *const text,
-                    const int x0,const int y0,
-                    const T *const fgcolor,const T *const bgcolor=0,
-                    const unsigned int font_size=11,const float opacity=1.0f) {
-      return draw_text(text,x0,y0,fgcolor,bgcolor,CImgList<T>::get_font(font_size),opacity);
-    }
-
-
-    //! Draw a text into the instance image.
-    /**
-       \param x0 = X-coordinate of the text in the instance image.
-       \param y0 = Y-coordinate of the text in the instance image.
-       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (0 means 'transparent').
-       \param bgcolor = an array of dimv() values of type \c T, defining the background color (0 means 'transparent').
-       \param opacity = opacity of the drawing.
-       \param format = a 'printf'-style format, followed by arguments.
-       \note Clipping is supported.
-    **/
-    CImg& draw_text(const int x0,const int y0,
-                    const T *const fgcolor,const T *const bgcolor, const unsigned int font_size,
-                    const float opacity,const char *format,...) {
-      char tmp[2048]={0};
-      std::va_list ap;
-      va_start(ap,format);
-      std::vsprintf(tmp,format,ap);
-      va_end(ap);
-      return draw_text(tmp,x0,y0,fgcolor,bgcolor,font_size,opacity);
-    }
-
-    template<typename t> CImg& draw_text(const int x0,const int y0,
-                                         const T *const fgcolor,const T *const bgcolor,
-                                         const CImgList<t>& font, const float opacity, const char *format,...) {
-      char tmp[2048]={0};
-      std::va_list ap;
-      va_start(ap,format);
-      std::vsprintf(tmp,format,ap);
-      va_end(ap);
-      return draw_text(tmp,x0,y0,fgcolor,bgcolor,font,opacity);
-    }
-
-
-    //! Draw a vector field in the instance image.
-    /**
-       \param flow = a 2d image of 2d vectors used as input data.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param sampling = length (in pixels) between each arrow.
-       \param factor = length factor of each arrow (if <0, computed as a percentage of the maximum length).
-       \param quiver_type = type of plot. Can be 0 (arrows) or 1 (segments).
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    template<typename t>
-    CImg& draw_quiver(const CImg<t>& flow, const T *const color,
-                      const unsigned int sampling=25, const float factor=-20,
-                      const int quiver_type=0, const float opacity=1) {
-      if (!is_empty()) {
-        if (flow.is_empty() || flow.dim!=2)
-          throw CImgArgumentException("CImg<%s>::draw_quiver() : Specified flow (%u,%u,%u,%u,%p) has wrong dimensions.",
-                                      pixel_type(),flow.width,flow.height,flow.depth,flow.dim,flow.data);
-        if (!color)
-          throw CImgArgumentException("CImg<%s>::draw_quiver() : Specified color is (null)",
-                                      pixel_type());
-        if (sampling<=0)
-          throw CImgArgumentException("CImg<%s>::draw_quiver() : Incorrect sampling value = %g",
-                                      pixel_type(),sampling);
-
-        float vmax,fact;
-        if (factor<=0) {
-          const CImgStats st(flow.get_norm_pointwise(2),false);
-          vmax = (float)cimg::max(cimg::abs(st.min),cimg::abs(st.max));
-          fact = -factor;
-        } else { fact = factor; vmax = 1; }
-
-        for (unsigned int y=sampling/2; y<height; y+=sampling)
-          for (unsigned int x=sampling/2; x<width; x+=sampling) {
-            const unsigned int X = x*flow.width/width, Y = y*flow.height/height;
-            float u = (float)flow(X,Y,0,0)*fact/vmax, v = (float)flow(X,Y,0,1)*fact/vmax;
-            if (!quiver_type) {
-              const int xx = x+(int)u, yy = y+(int)v;
-              draw_arrow(x,y,xx,yy,color,45.0f,sampling/5.0f,~0L,opacity);
-            } else draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),color,~0L,opacity);
-          }
-      }
-      return *this;
-    }
-
-    //! Draw a vector field in the instance image, using a colormap.
-    /**
-       \param flow = a 2d image of 2d vectors used as input data.
-       \param color = a 2d image of dimv()-D vectors corresponding to the color of each arrow.
-       \param sampling = length (in pixels) between each arrow.
-       \param factor = length factor of each arrow (if <0, computed as a percentage of the maximum length).
-       \param quiver_type = type of plot. Can be 0 (arrows) or 1 (segments).
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    template<typename t1,typename t2>
-      CImg& draw_quiver(const CImg<t1>& flow, const CImg<t2>& color,
-                        const unsigned int sampling=25, const float factor=-20,
-                        const int quiver_type=0, const float opacity=1) {
-      if (!is_empty()) {
-        if (flow.is_empty() || flow.dim!=2)
-          throw CImgArgumentException("CImg<%s>::draw_quiver() : Specified flow (%u,%u,%u,%u,%p) has wrong dimensions.",
-                                      pixel_type(),flow.width,flow.height,flow.depth,flow.dim,flow.data);
-        if (color.is_empty() || color.width!=flow.width || color.height!=flow.height)
-          throw CImgArgumentException("CImg<%s>::draw_quiver() : Specified color (%u,%u,%u,%u,%p) has wrong dimensions.",
-                                      pixel_type(),color.width,color.height,color.depth,color.dim,color.data);
-        if (sampling<=0)
-          throw CImgArgumentException("CImg<%s>::draw_quiver() : Incorrect sampling value = %g",pixel_type(),sampling);
-
-        float vmax,fact;
-        if (factor<=0) {
-          const CImgStats st(flow.get_norm_pointwise(2),false);
-          vmax = (float)cimg::max(cimg::abs(st.min),cimg::abs(st.max));
-          fact = -factor;
-        } else { fact = factor; vmax = 1; }
-
-        for (unsigned int y=sampling/2; y<height; y+=sampling)
-          for (unsigned int x=sampling/2; x<width; x+=sampling) {
-            const unsigned int X = x*flow.width/width, Y = y*flow.height/height;
-            float u = (float)flow(X,Y,0,0)*fact/vmax, v = (float)flow(X,Y,0,1)*fact/vmax;
-            if (!quiver_type) {
-              const int xx = x+(int)u, yy = y+(int)v;
-              draw_arrow(x,y,xx,yy,color.get_vector_at(X,Y).data,45.0f,sampling/5.0f,~0L,opacity);
-            } else draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),color.get_vector_at(X,Y).data,~0L,opacity);
-          }
-      }
-      return *this;
-    }
-
-    //! Draw a 1D graph on the instance image.
-    /**
-       \param data = an image containing the graph values I = f(x).
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param gtype = define the type of the plot :
-                      - 0 = Plot using linear interpolation (segments).
-                      - 1 = Plot with bars.
-                      - 2 = Plot using cubic interpolation (3-polynomials).
-       \param ymin = lower bound of the y-range.
-       \param ymax = upper bound of the y-range.
-       \param opacity = opacity of the drawing.
-       \note
-         - if \c ymin==ymax==0, the y-range is computed automatically from the input sample.
-       \see draw_axis().
-    **/
-    template<typename t>
-    CImg& draw_graph(const CImg<t>& data, const T *const color, const unsigned int gtype=0,
-                     const double ymin=0, const double ymax=0, const float opacity=1) {
-      if (!is_empty()) {
-        if (!color) throw CImgArgumentException("CImg<%s>::draw_graph() : Specified color is (null)",pixel_type());
-        T *color1 = new T[dim], *color2 = new T[dim];
-        cimg_forV(*this,k) { color1[k]=(T)(color[k]*0.6f); color2[k]=(T)(color[k]*0.3f); }
-        CImgStats st;
-        if (ymin==ymax) { st = CImgStats(data,false); cimg::swap(st.min,st.max); } else { st.min = ymin; st.max = ymax; }
-        if (st.min==st.max) { st.min--; st.max++; }
-        const float ca = height>1?(float)(st.max-st.min)/(height-1):0, cb = (float)st.min;
-        const int Y0 = (int)(-cb/ca);
-        int pY=0;
-        cimg_foroff(data,off) {
-          const int Y = (int)((data[off]-cb)/ca);
-          switch (gtype) {
-          case 0: // plot with segments
-            if (off>0) draw_line((int)((off-1)*width/data.size()),pY,(int)(off*width/data.size()),Y,color,~0L,opacity);
-            break;
-          case 1: { // plot with bars
-            const unsigned int X = off*width/data.size(), nX = (off+1)*width/data.size()-1;
-            draw_rectangle(X,(int)Y0,nX,Y,color1,opacity);
-            draw_line(X,Y,X,(int)Y0,color2,~0L,opacity);
-            draw_line(X,(int)Y0,nX,(int)Y0,Y<=Y0?color2:color,~0L,opacity);
-            draw_line(nX,Y,nX,(int)Y0,color,~0L,opacity);
-            draw_line(X,Y,nX,Y,Y<=Y0?color:color2,~0L,opacity);
-          } break;
-          }
-          pY=Y;
-        }
-        if (gtype==2) { // plot with cubic interpolation
-          const CImg<t> ndata = data.get_shared_points(0,data.size()-1);
-          cimg_forX(*this,x) {
-            const int Y = (int)((ndata.cubic_pix1d((float)x*ndata.width/width)-cb)/ca);
-            if (x>0) draw_line(x,pY,x+1,Y,color,~0L,opacity);
-            pY=Y;
-          }
-        }
-        delete[] color1; delete[] color2;
-      }
-      return *this;
-    }
-
-    //! Draw a labelled horizontal axis on the instance image.
-    /**
-       \param x0 = lower bound of the x-range.
-       \param x1 = upper bound of the x-range.
-       \param y = Y-coordinate of the horizontal axis in the instance image.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param precision = precision of the labels.
-       \param grid_pattern = pattern of the grid
-       \param opacity = opacity of the drawing.
-       \note if \c precision==0, precision of the labels is automatically computed.
-       \see draw_graph().
-    **/
-    template<typename t> CImg& draw_axis(const CImg<t>& xvalues, const int y, const T *const color,
-                                         const int precision=-1, const float opacity=1.0f) {
-      if (!is_empty()) {
-        int siz = (int)xvalues.size()-1;
-        if (siz<=0) draw_line(0,y,width-1,y,color,~0L,opacity);
-        else {
-          if (xvalues[0]<xvalues[siz]) draw_arrow(0,y,width-1,y,color,30,5,~0L,opacity);
-          else draw_arrow(width-1,y,0,y,color,30,5,~0L,opacity);
-          const int yt = (y+14)<dimy()?(y+3):(y-14);
-          char txt[32];
-          cimg_foroff(xvalues,x) {
-            if (precision>=0) std::sprintf(txt,"%.*g",precision,(double)xvalues(x));
-            else std::sprintf(txt,"%g",(double)xvalues(x));
-            const int xi=(int)(x*(width-1)/siz), xt = xi-(int)std::strlen(txt)*3;
-            draw_point(xi,y-1,color,opacity).draw_point(xi,y+1,color,opacity).
-              draw_text(txt,xt<0?0:xt,yt,color,0,11,opacity);
-          }
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a labelled vertical axis on the instance image.
-    template<typename t> CImg& draw_axis(const int x, const CImg<t>& yvalues, const T *const color,
-                                         const int precision=-1, const float opacity=1.0f) {
-      if (!is_empty()) {
-        int siz = (int)yvalues.size()-1;
-        if (siz<=0) draw_line(x,0,x,height-1,color,~0L,opacity);
-        else {
-          if (yvalues[0]<yvalues[siz]) draw_arrow(x,0,x,height-1,color,30,5,~0L,opacity);
-          else draw_arrow(x,height-1,x,0,color,30,5,~0L,opacity);
-          char txt[32];
-          cimg_foroff(yvalues,y) {
-            if (precision>=0) std::sprintf(txt,"%.*g",precision,(double)yvalues(y));
-            else std::sprintf(txt,"%g",(double)yvalues(y));
-            const int
-              yi = (int)(y*(height-1)/siz),
-              tmp = yi-5,
-              nyi = tmp<0?0:(tmp>=(int)height-11?(int)height-11:tmp),
-              xt = x-(int)std::strlen(txt)*7;
-            draw_point(x-1,yi,color,opacity).draw_point(x+1,yi,color,opacity);
-            if (xt>0) draw_text(txt,xt,nyi,color,0,11,opacity);
-            else draw_text(txt,x+3,nyi,color,0,11,opacity);
-          }
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a labelled horizontal+vertical axis on the instance image.
-    template<typename tx, typename ty> CImg& draw_axis(const CImg<tx>& xvalues, const CImg<ty>& yvalues, const T *const color,
-                                                       const int precisionx=-1, const int precisiony=-1,
-                                                       const float opacity=1.0f) {
-      if (!is_empty()) {
-        const CImg<tx> nxvalues(xvalues.data,xvalues.size(),1,1,1,true);
-        const int sizx = (int)xvalues.size()-1, wm1 = (int)(width)-1;
-        if (sizx>0) {
-          float ox = (float)nxvalues[0];
-          for (unsigned int x=1; x<width; x++) {
-            const float nx = (float)nxvalues.linear_pix1d((float)x*sizx/wm1);
-            if (nx*ox<=0) { draw_axis(nx==0?x:x-1,yvalues,color,precisiony,opacity); break; }
-            ox = nx;
-          }
-        }
-        const CImg<ty> nyvalues(yvalues.data,yvalues.size(),1,1,1,true);
-        const int sizy = (int)yvalues.size()-1, hm1 = (int)(height)-1;
-        if (sizy>0) {
-          float oy = (float)nyvalues[0];
-          for (unsigned int y=1; y<height; y++) {
-            const float ny = (float)nyvalues.linear_pix1d((float)y*sizy/hm1);
-            if (ny*oy<=0) { draw_axis(xvalues,ny==0?y:y-1,color,precisionx,opacity); break; }
-            oy = ny;
-          }
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a labelled horizontal+vertical axis on the instance image.
-    template<typename tx, typename ty> CImg& draw_axis(const tx& x0, const tx& x1, const ty& y0, const ty& y1,
-                                                       const T *const color,
-                                                       const int subdivisionx=-60, const int subdivisiony=-60,
-                                                       const int precisionx=-1, const int precisiony=-1,
-                                                       const float opacity=1.0f) {
-      return draw_axis(CImg<tx>::sequence(subdivisionx>0?subdivisionx:1-(int)width/subdivisionx,x0,x1),
-                       CImg<ty>::sequence(subdivisiony>0?subdivisiony:1-(int)height/subdivisiony,y0,y1),
-                       color,precisionx,precisiony,opacity);
-    }
-
-    //! Draw grid on the instance image
-    template<typename tx, typename ty>
-      CImg& draw_grid(const CImg<tx>& xvalues, const CImg<ty>& yvalues, const T *const color,
-                      const unsigned int patternx=~0U, const unsigned int patterny=~0U,
-                      const float opacity=1.0f) {
-      if (!is_empty()) {
-        if (!xvalues.is_empty()) cimg_foroff(xvalues,x) {
-          const int xi = (int)xvalues[x];
-          if (xi>=0 && xi<(int)width) draw_line(xi,0,xi,height-1,color,patternx,opacity);
-        }
-        if (!yvalues.is_empty()) cimg_foroff(yvalues,y) {
-          const int yi = (int)yvalues[y];
-          if (yi>=0 && yi<(int)height) draw_line(0,yi,width-1,yi,color,patterny,opacity);
-        }
-      }
-      return *this;
-    }
-
-    //! Draw grid on the instance image
-    CImg& draw_grid(const float deltax,  const float deltay,
-                    const float offsetx, const float offsety,
-                    const T *const color,
-                    const unsigned int patternx=~0U, const unsigned int patterny=~0U,
-                    const bool invertx=false, const bool inverty=false,
-                    const float opacity=1.0f) {
-
-      CImg<unsigned int> seqx, seqy;
-
-      if (deltax!=0) {
-        const float dx = deltax>0?deltax:width*-deltax/100;
-        const unsigned int nx = (unsigned int)(width/dx);
-        seqx = CImg<unsigned int>::sequence(1+nx,0,(unsigned int)(dx*nx));
-        if (offsetx) cimg_foroff(seqx,x) seqx(x) = (unsigned int)cimg::mod(seqx(x)+offsetx,(float)width);
-        if (invertx) cimg_foroff(seqx,x) seqx(x) = width-1-seqx(x);
-      }
-
-      if (deltay!=0) {
-        const float dy = deltay>0?deltay:height*-deltay/100;
-        const unsigned int ny = (unsigned int)(height/dy);
-        seqy = CImg<unsigned int>::sequence(1+ny,0,(unsigned int)(dy*ny));
-        if (offsety) cimg_foroff(seqy,y) seqy(y) = (unsigned int)cimg::mod(seqy(y)+offsety,(float)height);
-        if (inverty) cimg_foroff(seqy,y) seqy(y) = height-1-seqy(y);
-     }
-
-      return draw_grid(seqx,seqy,color,patternx,patterny,opacity);
-    }
-
-    // INNER CLASS used by function CImg<>::draw_fill()
-    template<typename T1,typename T2> struct _draw_fill {
-      const T1 *const color;
-      const float sigma,opacity;
-      const CImg<T1> value;
-      CImg<T2> region;
-
-      _draw_fill(const CImg<T1>& img,const int x,const int y,const int z,
-                 const T *const pcolor,const float psigma,const float popacity):
-        color(pcolor),sigma(psigma),opacity(popacity),
-        value(img.get_vector_at(x,y,z)), region(CImg<T2>(img.width,img.height,img.depth,1,(T2)false)) {
-      }
-
-      _draw_fill& operator=(const _draw_fill& d) {
-        color = d.color;
-        sigma = d.sigma;
-        opacity = d.opacity;
-        value = d.value;
-        region = d.region;
-        return *this;
-      }
-
-      bool comp(const CImg<T1>& A,const CImg<T1>& B) const {
-        bool res=true;
-        const T *pA=A.data+A.size();
-        for (const T *pB=B.data+B.size(); res && pA>A.data; res=(cimg::abs(*(--pA)-(*(--pB)))<=sigma) );
-        return res;
-      }
-
-      void fill(CImg<T1>& img,const int x,const int y,const int z) {
-        if (x<0 || x>=img.dimx() || y<0 || y>=img.dimy() || z<0 || z>=img.dimz()) return;
-        if (!region(x,y,z) && comp(value,img.get_vector_at(x,y,z))) {
-          const T *col=color;
-          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-          int xmin,xmax;
-          if (opacity>=1) cimg_forV(img,k) img(x,y,z,k)=*(col++);
-          else cimg_forV(img,k) img(x,y,z,k)=(T1)(*(col++)*opacity+copacity*img(x,y,z,k));
-          col-=img.dim;
-          region(x,y,z) = (T2)true;
-          for (xmin=x-1; xmin>=0 && comp(value,img.get_vector_at(xmin,y,z)); xmin--) {
-            if (opacity>=1) cimg_forV(img,k) img(xmin,y,z,k) = *(col++);
-            else cimg_forV(img,k) img(xmin,y,z,k)=(T1)(*(col++)*nopacity+copacity*img(xmin,y,z,k));
-            col-=img.dim;
-            region(xmin,y,z)=(T2)true;
-          }
-          for (xmax=x+1; xmax<img.dimx() && comp(value,img.get_vector_at(xmax,y,z)); xmax++) {
-            if (opacity>=1) cimg_forV(img,k) img(xmax,y,z,k) = *(col++);
-            else cimg_forV(img,k) img(xmax,y,z,k)=(T1)(*(col++)*nopacity+copacity*img(xmax,y,z,k));
-            col-=img.dim;
-            region(xmax,y,z)=(T2)true;
-          }
-          xmin++; xmax--;
-          for (; xmin<=xmax; xmin++) {
-            fill(img,xmin,y-1,z);
-            fill(img,xmin,y+1,z);
-            fill(img,xmin,y,z-1);
-            fill(img,xmin,y,z+1);
-          }
-        }
-      }
-    };
-
-    //! Draw a 3D filled region starting from a point (\c x,\c y,\ z) in the instance image.
-    /**
-       \param x = X-coordinate of the starting point of the region to fill.
-       \param y = Y-coordinate of the starting point of the region to fill.
-       \param z = Z-coordinate of the starting point of the region to fill.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param region = image that will contain the mask of the filled region mask, as an output.
-       \param sigma = tolerance concerning neighborhood values.
-       \param opacity = opacity of the drawing.
-
-       \return \p region is initialized with the binary mask of the filled region.
-    **/
-    template<typename t> CImg& draw_fill(const int x,const int y,const int z,
-                                         const T *const color, CImg<t>& region,const float sigma=0,
-                                         const float opacity=1) {
-      _draw_fill<T,t> F(*this,x,y,z,color,sigma,opacity);
-      F.fill(*this,x,y,z);
-      region = F.region;
-      return *this;
-    }
-
-    //! Draw a 3D filled region starting from a point (\c x,\c y,\ z) in the instance image.
-    /**
-       \param x = X-coordinate of the starting point of the region to fill.
-       \param y = Y-coordinate of the starting point of the region to fill.
-       \param z = Z-coordinate of the starting point of the region to fill.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param sigma = tolerance concerning neighborhood values.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_fill(const int x,const int y,const int z,const T *const color,const float sigma=0,const float opacity=1) {
-      CImg<bool> tmp;
-      return draw_fill(x,y,z,color,tmp,sigma,opacity);
-    }
-
-    //! Draw a 2D filled region starting from a point (\c x,\c y) in the instance image.
-    /**
-       \param x = X-coordinate of the starting point of the region to fill.
-       \param y = Y-coordinate of the starting point of the region to fill.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param sigma = tolerance concerning neighborhood values.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_fill(const int x,const int y,const T *const color,const float sigma=0,const float opacity=1) {
-      CImg<bool> tmp;
-      return draw_fill(x,y,0,color,tmp,sigma,opacity);
-    }
-
-    //! Draw a plasma square in the instance image.
-    /**
-       \param x0 = X-coordinate of the upper-left corner of the plasma.
-       \param y0 = Y-coordinate of the upper-left corner of the plasma.
-       \param x1 = X-coordinate of the lower-right corner of the plasma.
-       \param y1 = Y-coordinate of the lower-right corner of the plasma.
-       \param alpha = Alpha-parameter of the plasma.
-       \param beta = Beta-parameter of the plasma.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_plasma(const int x0, const int y0, const int x1, const int y1,
-                      const double alpha=1.0, const double beta=1.0, const float opacity=1) {
-      if (!is_empty()) {
-        int nx0=x0,nx1=x1,ny0=y0,ny1=y1;
-        if (nx1<nx0) cimg::swap(nx0,nx1);
-        if (ny1<ny0) cimg::swap(ny0,ny1);
-        if (nx0<0) nx0=0;
-        if (nx1>=dimx()) nx1=width-1;
-        if (ny0<0) ny0=0;
-        if (ny1>=dimy()) ny1=height-1;
-        const int xc = (nx0+nx1)/2, yc = (ny0+ny1)/2, dx=(xc-nx0), dy=(yc-ny0);
-        const double dc = std::sqrt((double)(dx*dx+dy*dy))*alpha + beta;
-        float val = 0;
-        cimg_forV(*this,k) {
-          if (opacity>=1) {
-            (*this)(xc,ny0,0,k) = (T)(0.5f*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k)));
-            (*this)(xc,ny1,0,k) = (T)(0.5f*((*this)(nx0,ny1,0,k)+(*this)(nx1,ny1,0,k)));
-            (*this)(nx0,yc,0,k) = (T)(0.5f*((*this)(nx0,ny0,0,k)+(*this)(nx0,ny1,0,k)));
-            (*this)(nx1,yc,0,k) = (T)(0.5f*((*this)(nx1,ny0,0,k)+(*this)(nx1,ny1,0,k)));
-            do {
-              val = (float)(0.25f*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k) +
-                                   (*this)(nx1,ny1,0,k)+(*this)(nx0,ny1,0,k)) + dc*cimg::grand());
-            } while (val<(float)cimg::type<T>::min() || val>(float)cimg::type<T>::max());
-            (*this)(xc,yc,0,k)  = (T)val;
-          } else {
-            const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-            (*this)(xc,ny0,0,k) = (T)(0.5f*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k))*nopacity + copacity*(*this)(xc,ny0,0,k));
-            (*this)(xc,ny1,0,k) = (T)(0.5f*((*this)(nx0,ny1,0,k)+(*this)(nx1,ny1,0,k))*nopacity + copacity*(*this)(xc,ny1,0,k));
-            (*this)(nx0,yc,0,k) = (T)(0.5f*((*this)(nx0,ny0,0,k)+(*this)(nx0,ny1,0,k))*nopacity + copacity*(*this)(nx0,yc,0,k));
-            (*this)(nx1,yc,0,k) = (T)(0.5f*((*this)(nx1,ny0,0,k)+(*this)(nx1,ny1,0,k))*nopacity + copacity*(*this)(nx1,yc,0,k));
-            do {
-              val = (float)(0.25f*(((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k) +
-                                             (*this)(nx1,ny1,0,k)+(*this)(nx0,ny1,0,k)) + dc*cimg::grand())*nopacity
-                            + copacity*(*this)(xc,yc,0,k));
-            } while (val<(float)cimg::type<T>::min() || val>(float)cimg::type<T>::max());
-            (*this)(xc,yc,0,k)  = (T)val;
-          }
-        }
-        if (xc!=nx0 || yc!=ny0) {
-          draw_plasma(nx0,ny0,xc,yc,alpha,beta,opacity);
-          draw_plasma(xc,ny0,nx1,yc,alpha,beta,opacity);
-          draw_plasma(nx0,yc,xc,ny1,alpha,beta,opacity);
-          draw_plasma(xc,yc,nx1,ny1,alpha,beta,opacity);
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a plasma in the instance image.
-    /**
-       \param alpha = Alpha-parameter of the plasma.
-       \param beta = Beta-parameter of the plasma.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_plasma(const double alpha=1.0,const double beta=1.0,const float opacity=1) {
-      return draw_plasma(0,0,width-1,height-1,alpha,beta,opacity);
-    }
-
-    //! Draw a 1D gaussian function in the instance image.
-    /**
-       \param xc = X-coordinate of the gaussian center.
-       \param sigma = Standard variation of the gaussian distribution.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_gaussian(const float xc,const double sigma,const T *const color,const float opacity=1) {
-      if (!is_empty()) {
-        if (!color) throw CImgArgumentException("CImg<%s>::draw_gaussian() : Specified color is (null)",pixel_type());
-        const double sigma2 = 2*sigma*sigma;
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        const unsigned int whz = width*height*depth;
-        const T *col = color;
-        cimg_forX(*this,x) {
-          const float dx = (x-xc);
-          const double val = std::exp( -dx*dx/sigma2 );
-          T *ptrd = ptr(x,0,0,0);
-          if (opacity>=1) cimg_forV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
-          else cimg_forV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; }
-          col-=dim;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw an anisotropic 2D gaussian function in the instance image.
-    /**
-       \param xc = X-coordinate of the gaussian center.
-       \param yc = Y-coordinate of the gaussian center.
-       \param tensor = 2x2 covariance matrix.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-    **/
-    template<typename t> CImg& draw_gaussian(const float xc,const float yc,const CImg<t>& tensor,
-                                             const T *const color,const float opacity=1) {
-      if (!is_empty()) {
-        if (tensor.width!=2 || tensor.height!=2 || tensor.depth!=1 || tensor.dim!=1)
-          throw CImgArgumentException("CImg<%s>::draw_gaussian() : Tensor parameter (%u,%u,%u,%u,%p) is not a 2x2 matrix.",
-                                      pixel_type(),tensor.width,tensor.height,tensor.depth,tensor.dim,tensor.data);
-        if (!color) throw CImgArgumentException("CImg<%s>::draw_gaussian() : Specified color is (null)",pixel_type());
-        const CImg<t> invT = tensor.get_inverse(), invT2 = (invT*invT)/(-2.0);
-        const t &a=invT2(0,0), &b=2*invT2(1,0), &c=invT2(1,1);
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        const unsigned int whz = width*height*depth;
-        const T *col = color;
-        float dy = -yc;
-        cimg_forY(*this,y) {
-          float dx = -xc;
-          cimg_forX(*this,x) {
-            const float val = (float)std::exp(a*dx*dx + b*dx*dy + c*dy*dy);
-            T *ptrd = ptr(x,y,0,0);
-            if (opacity>=1) cimg_forV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
-            else cimg_forV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; }
-            col-=dim;
-            dx++;
-          }
-          dy++;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw an isotropic 2D gaussian function in the instance image
-    /**
-       \param xc = X-coordinate of the gaussian center.
-       \param yc = Y-coordinate of the gaussian center.
-       \param sigma = standard variation of the gaussian distribution.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_gaussian(const float xc,const float yc,const float sigma,const T *const color,const float opacity=1) {
-      return draw_gaussian(xc,yc,CImg<float>::diagonal(sigma,sigma),color,opacity);
-    }
-
-    //! Draw an anisotropic 3D gaussian function in the instance image.
-    /**
-       \param xc = X-coordinate of the gaussian center.
-       \param yc = Y-coordinate of the gaussian center.
-       \param zc = Z-coordinate of the gaussian center.
-       \param tensor = 3x3 covariance matrix.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-    **/
-    template<typename t> CImg& draw_gaussian(const float xc,const float yc,const float zc,const CImg<t>& tensor,
-                                             const T *const color,const float opacity=1) {
-      if (!is_empty()) {
-        if (tensor.width!=3 || tensor.height!=3 || tensor.depth!=1 || tensor.dim!=1)
-          throw CImgArgumentException("CImg<%s>::draw_gaussian() : Tensor parameter (%u,%u,%u,%u,%p) is not a 3x3 matrix.",
-                                      pixel_type(),tensor.width,tensor.height,tensor.depth,tensor.dim,tensor.data);
-        const CImg<t> invT = tensor.get_inverse(), invT2 = (invT*invT)/(-2.0);
-        const t a=invT(0,0), b=2*invT(1,0), c=2*invT(2,0), d=invT(1,1), e=2*invT(2,1), f=invT(2,2);
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        const unsigned int whz = width*height*depth;
-        const T *col = color;
-        cimg_forXYZ(*this,x,y,z) {
-          const float dx = (x-xc), dy = (y-yc), dz = (z-zc);
-          const double val = std::exp(a*dx*dx + b*dx*dy + c*dx*dz + d*dy*dy + e*dy*dz + f*dz*dz);
-          T *ptrd = ptr(x,y,z,0);
-          if (opacity>=1) cimg_forV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
-          else cimg_forV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; }
-          col-=dim;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw an isotropic 3D gaussian function in the instance image
-   /**
-       \param xc = X-coordinate of the gaussian center.
-       \param yc = Y-coordinate of the gaussian center.
-       \param zc = Z-coordinate of the gaussian center.
-       \param sigma = standard variation of the gaussian distribution.
-       \param color = array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_gaussian(const float xc,const float yc,const float zc,
-                        const double sigma,const T *const color,const float opacity=1) {
-      return draw_gaussian(xc,yc,zc,CImg<float>::diagonal(sigma,sigma,sigma),color,opacity);
-    }
-
-    //! Draw a 3D object in the instance image
-    /**
-       \param X = X-coordinate of the 3d object position
-       \param Y = Y-coordinate of the 3d object position
-       \param Z = Z-coordinate of the 3d object position
-       \param points = Image N*3 describing 3D point coordinates
-       \param primitives = List of P primitives
-       \param colors = List of P color (or textures)
-       \param opacities = Image of P opacities
-       \param render_type = Render type (0=Points, 1=Lines, 2=Faces (no light), 3=Faces (flat), 4=Faces(Gouraud)
-       \param double_sided = Tell if object faces have two sides or are oriented.
-       \param focale = length of the focale
-       \param lightx = X-coordinate of the light
-       \param lighty = Y-coordinate of the light
-       \param lightz = Z-coordinate of the light
-       \param ambiant_light = Brightness (between 0..1) of the ambiant light
-    **/
-    template<typename tp, typename tf, typename to>
-      CImg& draw_object3d(const float X, const float Y, const float Z,
-                          const CImg<tp>& points, const CImgList<tf>& primitives,
-                          const CImgList<T>& colors, const CImgList<to>& opacities,
-                          const unsigned int render_type=4,
-                          const bool double_sided=false, const float focale=500,
-                          const float lightx=0, const float lighty=0, const float lightz=-5000,
-                          const float ambiant_light = 0.05f) {
-
-      static CImg<float> light_texture;
-      if (is_empty() || points.is_empty() || primitives.is_empty()) return *this;
-      if (colors.is_empty() || opacities.is_empty())
-        throw CImgArgumentException("CImg<%s>::draw_object3d() : Undefined colors or opacities",pixel_type());
-
-      if (points.height<3)
-        return draw_object3d(X,Y,Z,points.get_resize(-100,3,1,1,0),primitives,colors,opacities,
-                             render_type,double_sided,focale,lightx,lighty,lightz,ambiant_light);
-
-      // Create light texture for phong-like rendering
-      if (render_type==5) {
-        if (colors.size>primitives.size) light_texture = colors[primitives.size];
-        else {
-          static float olightx=0, olighty=0, olightz=0, oambiant_light=0;
-          if (light_texture.is_empty() || lightx!=olightx || lighty!=olighty || lightz!=olightz || ambiant_light!=oambiant_light) {
-            light_texture.assign(512,512);
-            const float white[1]={ 1.0f },
-              dlx = lightx-X, dly = lighty-Y, dlz = lightz-Z,
-                nl = (float)std::sqrt(dlx*dlx+dly*dly+dlz*dlz),
-                nlx = light_texture.width/2*(1+dlx/nl),
-                nly = light_texture.height/2*(1+dly/nl);
-              (light_texture.draw_gaussian(nlx,nly,light_texture.width/3.0f,white)+=ambiant_light).cut(0.0f,1.0f);
-              olightx = lightx; olighty = lighty; olightz = lightz; oambiant_light = ambiant_light;
-          }
-        }
-      }
-
-      // Compute 3D to 2D projection
-      CImg<float> projections(points.width,2);
-      cimg_forX(points,l) {
-        const float
-          x = (float)points(l,0),
-          y = (float)points(l,1),
-          z = (float)points(l,2);
-        const float projectedz = z + Z + focale;
-        projections(l,1) = Y + focale*y/projectedz;
-        projections(l,0) = X + focale*x/projectedz;
-      }
-
-      // Compute and sort visible primitives
-      CImg<unsigned int> visibles(primitives.size);
-      CImg<float> zrange(primitives.size);
-      unsigned int nb_visibles = 0;
-      const float zmin = -focale+1.5f;
-      { cimglist_for(primitives,l) {
-        const CImg<tf>& primitive = primitives[l];
-        switch (primitive.size()) {
-        case 1: { // Point
-          const unsigned int i0 = (unsigned int)primitive(0);
-          const float x0 = projections(i0,0), y0 = projections(i0,1), z0 = (float)(Z+points(i0,2));
-          if (z0>zmin && x0>=0 && x0<width && y0>=0 && y0<height) {
-            visibles(nb_visibles) = (unsigned int)l;
-            zrange(nb_visibles++) = z0;
-          }
-        } break;
-        case 2: // Line or textured line
-        case 6: {
-          const unsigned int
-            i0 = (unsigned int)primitive(0),
-            i1 = (unsigned int)primitive(1);
-          const float
-            x0 = projections(i0,0), y0 = projections(i0,1), z0 = (float)(Z+points(i0,2)),
-            x1 = projections(i1,0), y1 = projections(i1,1), z1 = (float)(Z+points(i1,2));
-          float xm, xM, ym, yM;
-          if (x0<x1) { xm = x0; xM = x1; } else { xm = x1; xM = x0; }
-          if (y0<y1) { ym = y0; yM = y1; } else { ym = y1; yM = y0; }
-          if (z0>zmin && z1>zmin && xM>=0 && xm<width && yM>=0 && ym<height) {
-            visibles(nb_visibles) = (unsigned int)l;
-            zrange(nb_visibles++) = 0.5f*(z0+z1);
-          }
-        } break;
-        case 3:  // Triangle or textured triangle
-        case 9: {
-          const unsigned int
-            i0 = (unsigned int)primitive(0),
-            i1 = (unsigned int)primitive(1),
-            i2 = (unsigned int)primitive(2);
-          const float
-            x0 = projections(i0,0), y0 = projections(i0,1), z0 = (float)(Z+points(i0,2)),
-            x1 = projections(i1,0), y1 = projections(i1,1), z1 = (float)(Z+points(i1,2)),
-            x2 = projections(i2,0), y2 = projections(i2,1), z2 = (float)(Z+points(i2,2));
-          float xm, xM, ym, yM;
-          if (x0<x1) { xm = x0; xM = x1; } else { xm = x1; xM = x0; }
-          if (x2<xm) xm = x2;
-          if (x2>xM) xM = x2;
-          if (y0<y1) { ym = y0; yM = y1; } else { ym = y1; yM = y0; }
-          if (y2<ym) ym = y2;
-          if (y2>yM) yM = y2;
-          if (z0>zmin && z1>zmin && z2>zmin && xM>=0 && xm<width && yM>=0 && ym<height) {
-            if (double_sided || (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0)<0) {
-              visibles(nb_visibles) = (unsigned int)l;
-              zrange(nb_visibles++) = (z0+z1+z2)/3;
-            }
-          }
-        } break;
-        case 4: // Rectangle or textured rectangle
-        case 12: {
-          const unsigned int
-            i0 = (unsigned int)primitive(0),
-            i1 = (unsigned int)primitive(1),
-            i2 = (unsigned int)primitive(2),
-            i3 = (unsigned int)primitive(3);
-          const float
-            x0 = projections(i0,0), y0 = projections(i0,1), z0 = (float)(Z+points(i0,2)),
-            x1 = projections(i1,0), y1 = projections(i1,1), z1 = (float)(Z+points(i1,2)),
-            x2 = projections(i2,0), y2 = projections(i2,1), z2 = (float)(Z+points(i2,2)),
-            x3 = projections(i3,0), y3 = projections(i3,1), z3 = (float)(Z+points(i3,2));
-          float xm, xM, ym, yM;
-          if (x0<x1) { xm = x0; xM = x1; } else { xm = x1; xM = x0; }
-          if (x2<xm) xm = x2;
-          if (x2>xM) xM = x2;
-          if (x3<xm) xm = x3;
-          if (x3>xM) xM = x3;
-          if (y0<y1) { ym = y0; yM = y1; } else { ym = y1; yM = y0; }
-          if (y2<ym) ym = y2;
-          if (y2>yM) yM = y2;
-          if (y3<ym) ym = y3;
-          if (y3>yM) yM = y3;
-          if (z0>zmin && z1>zmin && z2>zmin && z3>zmin && xM>=0 && xm<width && yM>=0 && ym<height) {
-            if (double_sided || (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0)<0) {
-              visibles(nb_visibles) = (unsigned int)l;
-              zrange(nb_visibles++) = (z0+z1+z2+z3)/4;
-            }
-          }
-        } break;
-        default:
-          throw CImgArgumentException("CImg<%s>::draw_object3d() : Primitive %u is invalid (size = %u, can be 1,2,3,4,6,9 or 12)",
-                                      pixel_type(),l,primitive.size());
-        }}
-      }
-      if (nb_visibles<=0) return *this;
-      CImg<unsigned int> permutations;
-      CImg<float>(zrange.data,nb_visibles,1,1,1,true).sort(permutations,false);
-
-      // Compute light properties
-      CImg<float> lightprops;
-      switch (render_type) {
-      case 3: { // Flat Shading
-        lightprops.assign(nb_visibles);
-        cimg_forX(lightprops,l) {
-          const CImg<tf>& primitive = primitives(visibles(permutations(l)));
-          const unsigned int psize = primitive.size();
-          if (psize==3 || psize==4 || psize==9 || psize==12) {
-            const unsigned int
-              i0 = (unsigned int)primitive(0),
-              i1 = (unsigned int)primitive(1),
-              i2 = (unsigned int)primitive(2);
-            const float
-              x0 = (float)points(i0,0), y0 = (float)points(i0,1), z0 = (float)points(i0,2),
-              x1 = (float)points(i1,0), y1 = (float)points(i1,1), z1 = (float)points(i1,2),
-              x2 = (float)points(i2,0), y2 = (float)points(i2,1), z2 = (float)points(i2,2),
-              dx1 = x1-x0, dy1 = y1-y0, dz1 = z1-z0,
-              dx2 = x2-x0, dy2 = y2-y0, dz2 = z2-z0,
-              nx = dy1*dz2-dz1*dy2,
-              ny = dz1*dx2-dx1*dz2,
-              nz = dx1*dy2-dy1*dx2,
-              norm = (float)std::sqrt(1e-5f+nx*nx+ny*ny+nz*nz),
-              lx = X+(x0+x1+x2)/3-lightx,
-              ly = Y+(y0+y1+y2)/3-lighty,
-              lz = Z+(z0+z1+z2)/3-lightz,
-              nl = (float)std::sqrt(1e-5f+lx*lx+ly*ly+lz*lz),
-              factor = (-lx*nx-ly*ny-lz*nz)/(norm*nl),
-              nfactor = double_sided?cimg::abs(factor):cimg::max(factor,0.0f);
-            lightprops[l] = cimg::min(nfactor+ambiant_light,1.0f);
-          } else lightprops[l] = 1.0f;
-        }
-      } break;
-
-      case 4: // Gouraud Shading
-      case 5: { // Phong-Shading
-        CImg<float> points_normals(points.width,3,1,1,0);
-        cimglist_for(primitives,l) {
-          const CImg<tf>& primitive = primitives[l];
-          const unsigned int psize = primitive.size();
-          const bool
-            triangle_flag = (psize==3) || (psize==9),
-            rectangle_flag = (psize==4) || (psize==12);
-          if (triangle_flag || rectangle_flag) {
-            const unsigned int
-              i0 = (unsigned int)primitive(0),
-              i1 = (unsigned int)primitive(1),
-              i2 = (unsigned int)primitive(2),
-              i3 = rectangle_flag?(unsigned int)primitive(3):0;
-            const float
-              x0 = (float)points(i0,0), y0 = (float)points(i0,1), z0 = (float)points(i0,2),
-              x1 = (float)points(i1,0), y1 = (float)points(i1,1), z1 = (float)points(i1,2),
-              x2 = (float)points(i2,0), y2 = (float)points(i2,1), z2 = (float)points(i2,2),
-              dx1 = x1-x0, dy1 = y1-y0, dz1 = z1-z0,
-              dx2 = x2-x0, dy2 = y2-y0, dz2 = z2-z0,
-              nx = dy1*dz2-dz1*dy2,
-              ny = dz1*dx2-dx1*dz2,
-              nz = dx1*dy2-dy1*dx2,
-              norm = (float)std::sqrt(1e-5f+nx*nx+ny*ny+nz*nz),
-              nnx = nx/norm,
-              nny = ny/norm,
-              nnz = nz/norm;
-            points_normals(i0,0)+=nnx; points_normals(i0,1)+=nny; points_normals(i0,2)+=nnz;
-            points_normals(i1,0)+=nnx; points_normals(i1,1)+=nny; points_normals(i1,2)+=nnz;
-            points_normals(i2,0)+=nnx; points_normals(i2,1)+=nny; points_normals(i2,2)+=nnz;
-            if (rectangle_flag) {
-              points_normals(i3,0)+=nnx; points_normals(i3,1)+=nny; points_normals(i3,2)+=nnz;
-            }
-          }
-        }
-
-        if (render_type==4) {
-          lightprops.assign(points.width);
-          cimg_forX(points,ll) {
-            const float
-              nx = points_normals(ll,0),
-              ny = points_normals(ll,1),
-              nz = points_normals(ll,2),
-              norm = (float)std::sqrt(1e-5f+nx*nx+ny*ny+nz*nz),
-              lx = (float)(X+points(ll,0)-lightx),
-              ly = (float)(Y+points(ll,1)-lighty),
-              lz = (float)(Z+points(ll,2)-lightz),
-              nl = (float)std::sqrt(1e-5f+lx*lx+ly*ly+lz*lz),
-              factor = (-lx*nx-ly*ny-lz*nz)/(norm*nl),
-              nfactor = double_sided?cimg::abs(factor):cimg::max(factor,0.0f);
-            lightprops[ll] = cimg::min(nfactor+ambiant_light,1.0f);
-          }
-        } else {
-          lightprops.assign(points.width,2);
-          cimg_forX(points,ll) {
-            const float
-              nx = points_normals(ll,0),
-              ny = points_normals(ll,1),
-              nz = points_normals(ll,2),
-              norm = (float)std::sqrt(1e-5f+nx*nx+ny*ny+nz*nz),
-              nnx = nx/norm, nny = ny/norm;
-            lightprops(ll,0) = (light_texture.width/2-1)*(1+nnx);
-            lightprops(ll,1) = (light_texture.height/2-1)*(1+nny);
-          }
-        }
-      } break;
-      }
-
-      // Draw visible primitives
-      const unsigned int opacsize = opacities.size;
-      { for (unsigned int l=0; l<nb_visibles; l++) {
-        const unsigned int n_primitive = visibles(permutations(l));
-        const CImg<tf>& primitive = primitives[n_primitive];
-        const CImg<T>& color = colors[n_primitive%colors.size];
-        const CImg<to>& opacity = opacities[n_primitive%opacsize];
-        const float opac = opacity.size()?(float)opacity(0):1.0f;
-
-        switch (primitive.size()) {
-        case 1: { // colored point or sprite
-          const unsigned int n0 = (unsigned int)primitive[0];
-          const int x0 = (int)projections(n0,0), y0 = (int)projections(n0,1);
-          if (color.size()==dim) draw_point(x0,y0,color.ptr(),opac);
-          else {
-            const float z = Z + points(n0,2);
-            const int factor = (int)(focale*100/(z+focale));
-            const int sw = color.width*factor/200, sh = color.height*factor/200;
-            if (x0+sw>=0 && x0-sw<(int)width && y0+sh>=0 && y0-sh<(int)height) {
-              const CImg<T> sprite = color.get_resize(-factor,-factor,1,-100,render_type<=3?1:3);
-              if (opacity.width==color.width && opacity.height==color.height)
-                draw_image(sprite,opacity.get_resize(sprite.width,sprite.height,1,sprite.dim,1),x0-sw,y0-sh,0,0);
-              else draw_image(sprite,x0-sw,y0-sh,0,0,opac);
-            }
-          }
-        } break;
-        case 2: { // colored line
-          const unsigned int
-            n0 = (unsigned int)primitive[0],
-            n1 = (unsigned int)primitive[1];
-          const int
-            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
-            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1);
-          if (render_type) draw_line(x0,y0,x1,y1,color.ptr(),~0L,opac);
-          else draw_point(x0,y0,color.ptr(),opac).draw_point(x1,y1,color.ptr(),opac);
-        } break;
-        case 6: { // textured line
-          const unsigned int
-            n0 = (unsigned int)primitive[0],
-            n1 = (unsigned int)primitive[1],
-            tx0 = (unsigned int)primitive[2],
-            ty0 = (unsigned int)primitive[3],
-            tx1 = (unsigned int)primitive[4],
-            ty1 = (unsigned int)primitive[5];
-          const int
-            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
-            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1);
-          if (render_type) draw_line(x0,y0,x1,y1,color,tx0,ty0,tx1,ty1,opac);
-          else draw_point(x0,y0,color.get_vector_at(tx0,ty0).ptr(),opac).
-                 draw_point(x1,y1,color.get_vector_at(tx1,ty1).ptr(),opac);
-        } break;
-        case 3: { // colored triangle
-          const unsigned int
-            n0 = (unsigned int)primitive[0],
-            n1 = (unsigned int)primitive[1],
-            n2 = (unsigned int)primitive[2];
-          const int
-            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
-            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1),
-            x2 = (int)projections(n2,0), y2 = (int)projections(n2,1);
-          switch(render_type) {
-          case 0:
-            draw_point(x0,y0,color.ptr(),opac).draw_point(x1,y1,color.ptr(),opac).draw_point(x2,y2,color.ptr(),opac);
-            break;
-          case 1:
-            draw_line(x0,y0,x1,y1,color.ptr(),~0L,opac).draw_line(x0,y0,x2,y2,color.ptr(),~0L,opac).
-              draw_line(x1,y1,x2,y2,color.ptr(),~0L,opac);
-            break;
-          case 2:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color.ptr(),opac);
-            break;
-          case 3:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color.ptr(),opac,lightprops(l));
-            break;
-          case 4:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color.ptr(),lightprops(n0),lightprops(n1),lightprops(n2),opac);
-            break;
-          case 5:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color.ptr(),light_texture,
-                          (unsigned int)lightprops(n0,0), (unsigned int)lightprops(n0,1),
-                          (unsigned int)lightprops(n1,0), (unsigned int)lightprops(n1,1),
-                          (unsigned int)lightprops(n2,0), (unsigned int)lightprops(n2,1),
-                          opac);
-            break;
-          }
-        } break;
-        case 4: { // colored rectangle
-          const unsigned int
-            n0 = (unsigned int)primitive[0],
-            n1 = (unsigned int)primitive[1],
-            n2 = (unsigned int)primitive[2],
-            n3 = (unsigned int)primitive[3];
-          const int
-            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
-            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1),
-            x2 = (int)projections(n2,0), y2 = (int)projections(n2,1),
-            x3 = (int)projections(n3,0), y3 = (int)projections(n3,1);
-          switch(render_type) {
-          case 0:
-            draw_point(x0,y0,color.ptr(),opac).draw_point(x1,y1,color.ptr(),opac).
-              draw_point(x2,y2,color.ptr(),opac).draw_point(x3,y3,color.ptr(),opac);
-            break;
-          case 1:
-            draw_line(x0,y0,x1,y1,color.ptr(),~0L,opac).draw_line(x1,y1,x2,y2,color.ptr(),~0L,opac).
-              draw_line(x2,y2,x3,y3,color.ptr(),~0L,opac).draw_line(x3,y3,x0,y0,color.ptr(),~0L,opac);
-            break;
-          case 2:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color.ptr(),opac).draw_triangle(x0,y0,x2,y2,x3,y3,color.ptr(),opac);
-            break;
-          case 3:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color.ptr(),opac,lightprops(l)).
-              draw_triangle(x0,y0,x2,y2,x3,y3,color.ptr(),opac,lightprops(l));
-            break;
-          case 4: {
-            const float
-              lightprop0 = lightprops(n0), lightprop1 = lightprops(n1),
-              lightprop2 = lightprops(n2), lightprop3 = lightprops(n3);
-            draw_triangle(x0,y0,x1,y1,x2,y2,color.ptr(),lightprop0,lightprop1,lightprop2,opac).
-              draw_triangle(x0,y0,x2,y2,x3,y3,color.ptr(),lightprop0,lightprop2,lightprop3,opac);
-          } break;
-          case 5: {
-            const unsigned int
-              lx0 = (unsigned int)lightprops(n0,0), ly0 = (unsigned int)lightprops(n0,1),
-              lx1 = (unsigned int)lightprops(n1,0), ly1 = (unsigned int)lightprops(n1,1),
-              lx2 = (unsigned int)lightprops(n2,0), ly2 = (unsigned int)lightprops(n2,1),
-              lx3 = (unsigned int)lightprops(n3,0), ly3 = (unsigned int)lightprops(n3,1);
-            draw_triangle(x0,y0,x1,y1,x2,y2,color.ptr(),light_texture,lx0,ly0,lx1,ly1,lx2,ly2,opac).
-              draw_triangle(x0,y0,x2,y2,x3,y3,color.ptr(),light_texture,lx0,ly0,lx2,ly2,lx3,ly3,opac);
-          } break;
-          }
-        } break;
-        case 9: { // Textured triangle
-          const unsigned int
-            n0 = (unsigned int)primitive[0],
-            n1 = (unsigned int)primitive[1],
-            n2 = (unsigned int)primitive[2],
-            tx0 = (unsigned int)primitive[3],
-            ty0 = (unsigned int)primitive[4],
-            tx1 = (unsigned int)primitive[5],
-            ty1 = (unsigned int)primitive[6],
-            tx2 = (unsigned int)primitive[7],
-            ty2 = (unsigned int)primitive[8];
-          const int
-            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
-            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1),
-            x2 = (int)projections(n2,0), y2 = (int)projections(n2,1);
-          switch(render_type) {
-          case 0:
-            draw_point(x0,y0,color.get_vector_at(tx0,ty0).ptr(),opac).
-              draw_point(x1,y1,color.get_vector_at(tx1,ty1).ptr(),opac).
-              draw_point(x2,y2,color.get_vector_at(tx2,ty2).ptr(),opac);
-            break;
-          case 1:
-            draw_line(x0,y0,x1,y1,color,tx0,ty0,tx1,ty1,opac).
-              draw_line(x0,y0,x2,y2,color,tx0,ty0,tx2,ty2,opac).
-              draw_line(x1,y1,x2,y2,color,tx1,ty1,tx2,ty2,opac);
-            break;
-          case 2:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color,tx0,ty0,tx1,ty1,tx2,ty2,opac);
-            break;
-          case 3:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color,tx0,ty0,tx1,ty1,tx2,ty2,opac,lightprops(l));
-            break;
-          case 4:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color,tx0,ty0,tx1,ty1,tx2,ty2,lightprops(n0),lightprops(n1),lightprops(n2),opac);
-            break;
-          case 5:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color,tx0,ty0,tx1,ty1,tx2,ty2,light_texture,
-                          (unsigned int)lightprops(n0,0), (unsigned int)lightprops(n0,1),
-                          (unsigned int)lightprops(n1,0), (unsigned int)lightprops(n1,1),
-                          (unsigned int)lightprops(n2,0), (unsigned int)lightprops(n2,1),
-                          opac);
-            break;
-          }
-        } break;
-        case 12: { // Textured rectangle
-          const unsigned int
-            n0 = (unsigned int)primitive[0],
-            n1 = (unsigned int)primitive[1],
-            n2 = (unsigned int)primitive[2],
-            n3 = (unsigned int)primitive[3],
-            tx0 = (unsigned int)primitive[4],
-            ty0 = (unsigned int)primitive[5],
-            tx1 = (unsigned int)primitive[6],
-            ty1 = (unsigned int)primitive[7],
-            tx2 = (unsigned int)primitive[8],
-            ty2 = (unsigned int)primitive[9],
-            tx3 = (unsigned int)primitive[10],
-            ty3 = (unsigned int)primitive[11];
-          const int
-            x0 = (int)projections(n0,0), y0 = (int)projections(n0,1),
-            x1 = (int)projections(n1,0), y1 = (int)projections(n1,1),
-            x2 = (int)projections(n2,0), y2 = (int)projections(n2,1),
-            x3 = (int)projections(n3,0), y3 = (int)projections(n3,1);
-          switch(render_type) {
-          case 0:
-            draw_point(x0,y0,color.get_vector_at(tx0,ty0).ptr(),opac).
-              draw_point(x1,y1,color.get_vector_at(tx1,ty1).ptr(),opac).
-              draw_point(x2,y2,color.get_vector_at(tx2,ty2).ptr(),opac).
-              draw_point(x3,y3,color.get_vector_at(tx3,ty3).ptr(),opac);
-            break;
-          case 1:
-            draw_line(x0,y0,x1,y1,color,tx0,ty0,tx1,ty1,opac).
-              draw_line(x1,y1,x2,y2,color,tx1,ty1,tx2,ty2,opac).
-              draw_line(x2,y2,x3,y3,color,tx2,ty2,tx3,ty3,opac).
-              draw_line(x3,y3,x0,y0,color,tx3,ty3,tx0,ty0,opac);
-            break;
-          case 2:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color,tx0,ty0,tx1,ty1,tx2,ty2,opac).
-              draw_triangle(x0,y0,x2,y2,x3,y3,color,tx0,ty0,tx2,ty2,tx3,ty3,opac);
-            break;
-          case 3:
-            draw_triangle(x0,y0,x1,y1,x2,y2,color,tx0,ty0,tx1,ty1,tx2,ty2,opac,lightprops(l)).
-              draw_triangle(x0,y0,x2,y2,x3,y3,color,tx0,ty0,tx2,ty2,tx3,ty3,opac,lightprops(l));
-            break;
-          case 4: {
-            const float
-              lightprop0 = lightprops(n0), lightprop1 = lightprops(n1),
-              lightprop2 = lightprops(n2), lightprop3 = lightprops(n3);
-            draw_triangle(x0,y0,x1,y1,x2,y2,color,tx0,ty0,tx1,ty1,tx2,ty2,lightprop0,lightprop1,lightprop2,opac).
-              draw_triangle(x0,y0,x2,y2,x3,y3,color,tx0,ty0,tx2,ty2,tx3,ty3,lightprop0,lightprop2,lightprop3,opac);
-          } break;
-          case 5: {
-            const unsigned int
-              lx0 = (unsigned int)lightprops(n0,0), ly0 = (unsigned int)lightprops(n0,1),
-              lx1 = (unsigned int)lightprops(n1,0), ly1 = (unsigned int)lightprops(n1,1),
-              lx2 = (unsigned int)lightprops(n2,0), ly2 = (unsigned int)lightprops(n2,1),
-              lx3 = (unsigned int)lightprops(n3,0), ly3 = (unsigned int)lightprops(n3,1);
-            draw_triangle(x0,y0,x1,y1,x2,y2,color,tx0,ty0,tx1,ty1,tx2,ty2,light_texture,lx0,ly0,lx1,ly1,lx2,ly2,opac).
-              draw_triangle(x0,y0,x2,y2,x3,y3,color,tx0,ty0,tx1,ty1,tx2,ty2,light_texture,lx0,ly0,lx2,ly2,lx3,ly3,opac);
-          } break;
-          }
-        } break;
-      }
-      }
-      }
-      return *this;
-    }
-
-    //! Draw a 3D object in the instance image
-    template<typename tp, typename tf, typename to>
-    CImg& draw_object3d(const float X, const float Y, const float Z,
-                        const CImgList<tp>& points, const CImgList<tf>& primitives,
-                        const CImgList<T>& colors, const CImgList<to>& opacities,
-                        const unsigned int render_type=4,
-                        const bool double_sided=false, const float focale=500,
-                        const float lightx=0, const float lighty=0, const float lightz=-5000,
-                        const float ambiant_light = 0.05f) {
-      if (points.is_empty()) return *this;
-      CImg<tp> npoints(points.size,3,1,1,0);
-      tp *ptrX = npoints.ptr(), *ptrY = npoints.ptr(0,1), *ptrZ = npoints.ptr(0,2);
-      cimg_forX(npoints,l) {
-        const CImg<tp>& point = points[l];
-        const unsigned int siz = point.size();
-        if (!siz)
-          throw CImgArgumentException("CImg<%s>::draw_object3d() : Given points (size=%u) contains a null element at "
-                                      "position %u.",pixel_type(),points.size,l);
-        *(ptrZ++) = (siz>2)?point(2):0;
-        *(ptrY++) = (siz>1)?point(1):0;
-        *(ptrX++) = point(0);
-      }
-      return draw_object3d(X,Y,Z,npoints,primitives,colors,opacities,
-                           render_type,double_sided,focale,lightx,lighty,lightz,ambiant_light);
-    }
-
-    //! Draw a 3D object in the instance image
-      template<typename tp, typename tf, typename to>
-    CImg& draw_object3d(const float X, const float Y, const float Z,
-                        const CImg<tp>& points, const CImgList<tf>& primitives,
-                        const CImgList<T>& colors, const CImg<to>& opacities,
-                        const unsigned int render_type=4,
-                        const bool double_sided=false, const float focale=500,
-                        const float lightx=0, const float lighty=0, const float lightz=-5000,
-                        const float ambiant_light = 0.05f) {
-      CImgList<to> nopacities(opacities.size(),1);
-      cimglist_for(nopacities,l) nopacities(l,0) = opacities(l);
-      return draw_object3d(X,Y,Z,points,primitives,colors,nopacities,
-                           render_type,double_sided,focale,lightx,lighty,lightz,ambiant_light);
-    }
-
-    //! Draw a 3D object in the instance image
-    template<typename tp, typename tf, typename to>
-    CImg& draw_object3d(const float X, const float Y, const float Z,
-                        const CImgList<tp>& points, const CImgList<tf>& primitives,
-                        const CImgList<T>& colors, const CImg<to>& opacities,
-                        const unsigned int render_type=4,
-                        const bool double_sided=false, const float focale=500,
-                        const float lightx=0, const float lighty=0, const float lightz=-5000,
-                        const float ambiant_light = 0.05f) {
-      CImgList<to> nopacities(opacities.size(),1);
-      { cimglist_for(nopacities,l) nopacities(l,0) = opacities(l); }
-      if (points.is_empty()) return *this;
-      CImg<tp> npoints(points.size,3,1,1,0);
-      tp *ptrX = npoints.ptr(), *ptrY = npoints.ptr(0,1), *ptrZ = npoints.ptr(0,2);
-      cimg_forX(npoints,l) {
-        const CImg<tp>& point = points[l];
-        const unsigned int siz = point.size();
-        if (!siz)
-          throw CImgArgumentException("CImg<%s>::draw_object3d() : Given points (size=%u) contains a null element at "
-                                      "position %u.",pixel_type(),points.size,l);
-        *(ptrZ++) = (siz>2)?point(2):0;
-        *(ptrY++) = (siz>1)?point(1):0;
-        *(ptrX++) = point(0);
-      }
-      return draw_object3d(X,Y,Z,npoints,primitives,colors,nopacities,
-                           render_type,double_sided,focale,lightx,lighty,lightz,ambiant_light);
-    }
-
-   //! Draw a 3D object in the instance image
-    template<typename tp, typename tf>
-    CImg& draw_object3d(const float X, const float Y, const float Z,
-                        const tp& points, const CImgList<tf>& primitives,
-                        const CImgList<T>& colors,
-                        const unsigned int render_type=4,
-                        const bool double_sided=false, const float focale=500,
-                        const float lightx=0, const float lighty=0, const float lightz=-5000,
-                        const float ambiant_light = 0.05f, const float opacity=1.0f) {
-      return draw_object3d(X,Y,Z,points,primitives,colors,
-                           CImg<float>(primitives.size,1,1,1,opacity),
-                           render_type,double_sided,focale,lightx,lighty,lightz,
-                           ambiant_light);
-    }
-
-    //! Rescale and center a 3D object
-    CImg& resize_object3d(const float siz=100, const bool centering=true) {
-      T *ptrx = ptr(0,0), *ptry = ptr(0,1), *ptrz = ptr(0,2);
-      float xm = (float)*(ptrx++), ym = (float)*(ptry++), zm = (float)*(ptrz++), xM = xm, yM = ym, zM = zm;
-      for (unsigned int p=1; p<width; p++) {
-         const float x = (float)*(ptrx++), y = (float)*(ptry++), z = (float)*(ptrz++);
-         if (x<xm) xm = x;
-         if (y<ym) ym = y;
-         if (z<zm) zm = z;
-         if (x>xM) xM = x;
-         if (y>yM) yM = y;
-         if (z>zM) zM = z;
-      }
-      const float
-        cx = 0.5f*(xm+xM),
-        cy = 0.5f*(ym+yM),
-        cz = 0.5f*(zm+zM),
-        delta = cimg::max(xM-xm,yM-ym,zM-zm),
-        ratio = (siz>=0)?(delta<=0?0:(siz/delta)):-siz/100;
-      ptrx = ptr(0,0);
-      ptry = ptr(0,1);
-      ptrz = ptr(0,2);
-      if (centering) cimg_forX(*this,l) {
-        T &x = *(ptrx++), &y = *(ptry++), &z = *(ptrz++);
-        x = (T)((x-cx)*ratio);
-        y = (T)((y-cy)*ratio);
-        z = (T)((z-cz)*ratio);
-      } else cimg_forX(*this,l) {
-        T &x = *(ptrx++), &y = *(ptry++), &z = *(ptrz++);
-        x = (T)(cx+(x-cx)*ratio);
-        y = (T)(cy+(y-cy)*ratio);
-        z = (T)(cz+(z-cz)*ratio);
-      }
-      return *this;
-    }
-
-    //! Get a rescaled and centered version of the 3D object
-    CImg get_resize_object3d(const float siz=100, const bool centering=true) const {
-      return CImg<T>(*this,false).resize_object3d(siz,centering);
-    }
-
-    //@}
-    //----------------------------
-    //
-    //! \name Image Filtering
-    //@{
-    //----------------------------
-
-    //! Return the correlation of the image by a mask.
-    /**
-       The result \p res of the correlation of an image \p img by a mask \p mask is defined to be :
-
-       res(x,y,z) = sum_{i,j,k} img(x+i,y+j,z+k)*mask(i,j,k)
-
-       \param mask = the correlation kernel.
-       \param cond = the border condition type (0=zero, 1=dirichlet)
-       \param weighted_correl = enable local normalization.
-    **/
-    template<typename t> CImg<typename cimg::largest<T,t>::type>
-    get_correlate(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_correl=false) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      typedef typename cimg::largest<t,float>::type fftype;
-      typedef typename cimg::largest<T,fftype>::type ftype;
-
-      if (is_empty()) return CImg<restype>();
-      if (mask.is_empty() || mask.dim!=1)
-        throw CImgArgumentException("CImg<%s>::get_correlate() : Specified mask (%u,%u,%u,%u,%p) is not scalar.",
-                                    pixel_type(),mask.width,mask.height,mask.depth,mask.dim,mask.data);
-      CImg<restype> dest(width,height,depth,dim);
-      if (cond && mask.width==mask.height && ((mask.depth==1 && mask.width<=5) || (mask.depth==mask.width && mask.width<=3))) {
-        // A special optimization is done for 2x2,3x3,4x4,5x5,2x2x2 and 3x3x3 mask (with cond=1)
-        switch (mask.depth) {
-        case 3: {
-          CImg_3x3x3(I,T);
-          if (!weighted_correl) cimg_forZV(*this,z,v) cimg_for3x3x3(*this,x,y,z,v,I) dest(x,y,z,v) = cimg_corr3x3x3(I,mask);
-          else cimg_forZV(*this,z,v) cimg_for3x3x3(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum3x3x3(I);
-            dest(x,y,z,v) = (norm!=0)?(restype)(cimg_corr3x3x3(I,mask)/std::sqrt(norm)):0;
-          }
-        } break;
-        case 2: {
-          CImg_2x2x2(I,T);
-          if (!weighted_correl) cimg_forZV(*this,z,v) cimg_for2x2x2(*this,x,y,z,v,I) dest(x,y,z,v) = cimg_corr2x2x2(I,mask);
-          else cimg_forZV(*this,z,v) cimg_for2x2x2(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum2x2x2(I);
-            dest(x,y,z,v) = (norm!=0)?(restype)(cimg_corr2x2x2(I,mask)/std::sqrt(norm)):0;
-          }
-        } break;
-        default:
-        case 1:
-          switch (mask.width) {
-          case 5: {
-            CImg_5x5(I,T);
-            if (!weighted_correl) cimg_forZV(*this,z,v) cimg_for5x5(*this,x,y,z,v,I) dest(x,y,z,v) = cimg_corr5x5(I,mask);
-            else cimg_forZV(*this,z,v) cimg_for5x5(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum5x5(I);
-              dest(x,y,z,v) = (norm!=0)?(restype)(cimg_corr5x5(I,mask)/std::sqrt(norm)):0;
-            }
-          } break;
-          case 4: {
-            CImg_4x4(I,T);
-            if (!weighted_correl) cimg_forZV(*this,z,v) cimg_for4x4(*this,x,y,z,v,I) dest(x,y,z,v) = cimg_corr4x4(I,mask);
-            else cimg_forZV(*this,z,v) cimg_for4x4(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum4x4(I);
-              dest(x,y,z,v) = (norm!=0)?(restype)(cimg_corr4x4(I,mask)/std::sqrt(norm)):0;
-            }
-          } break;
-          case 3: {
-            CImg_3x3(I,T);
-            if (!weighted_correl) cimg_forZV(*this,z,v) cimg_for3x3(*this,x,y,z,v,I) dest(x,y,z,v) = cimg_corr3x3(I,mask);
-            else cimg_forZV(*this,z,v) cimg_for3x3(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum3x3(I);
-              dest(x,y,z,v) = (norm!=0)?(restype)(cimg_corr3x3(I,mask)/std::sqrt(norm)):0;
-            }
-          } break;
-          case 2: {
-            CImg_2x2(I,T);
-            if (!weighted_correl) cimg_forZV(*this,z,v) cimg_for2x2(*this,x,y,z,v,I) dest(x,y,z,v) = cimg_corr2x2(I,mask);
-            else cimg_forZV(*this,z,v) cimg_for2x2(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum2x2(I);
-              dest(x,y,z,v) = (norm!=0)?(restype)(cimg_corr2x2(I,mask)/std::sqrt(norm)):0;
-            }
-          } break;
-          case 1: dest = mask(0)*(*this); break;
-          }
-        }
-      } else {
-        // Generic version for other masks
-        const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2, fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
-        cimg_forV(*this,v)
-          if (!weighted_correl) {       // Classical correlation
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              ftype val = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                val+= (*this)(x+xm,y+ym,z+zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-              dest(x,y,z,v)=(restype)val;
-            }
-            if (cond) cimg_forYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                ftype val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= pix3d(x+xm,y+ym,z+zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(restype)val;
-              }
-            else cimg_forYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                ftype val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= pix3d(x+xm,y+ym,z+zm,v,0)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(restype)val;
-              }
-          } else {      // Weighted correlation
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              ftype val = 0, norm = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                const T cval = (*this)(x+xm,y+ym,z+zm,v);
-                val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                norm+= cval*cval;
-              }
-              dest(x,y,z,v)=(norm!=0)?(restype)(val/std::sqrt((double)norm)):0;
-            }
-            if (cond) cimg_forYZV(*this,y,z,v)
-             for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                ftype val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = pix3d(x+xm,y+ym,z+zm,v);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+=cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(restype)(val/std::sqrt((double)norm)):0;
-              }
-            else cimg_forYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                ftype val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = pix3d(x+xm,y+ym,z+zm,v,0);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+= cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(restype)(val/std::sqrt((double)norm)):0;
-              }
-          }
-      }
-      return dest;
-    }
-
-
-    //! Correlate the image by a mask
-    /**
-       This is the in-place version of get_correlate.
-       \see get_correlate
-    **/
-    template<typename t> CImg& correlate(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_correl=false) {
-      return get_correlate(mask,cond,weighted_correl).swap(*this);
-    }
-
-    //! Return the convolution of the image by a mask
-    /**
-       The result \p res of the convolution of an image \p img by a mask \p mask is defined to be :
-
-       res(x,y,z) = sum_{i,j,k} img(x-i,y-j,z-k)*mask(i,j,k)
-
-       \param mask = the correlation kernel.
-       \param cond = the border condition type (0=zero, 1=dirichlet)
-       \param weighted_convol = enable local normalization.
-    **/
-    template<typename t> CImg<typename cimg::largest<T,t>::type>
-    get_convolve(const CImg<t>& mask, const unsigned int cond=1, const bool weighted_convol=false) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      typedef typename cimg::largest<t,float>::type fftype;
-      typedef typename cimg::largest<T,fftype>::type ftype;
-
-      if (is_empty()) return CImg<restype>();
-      if (mask.is_empty() || mask.dim!=1)
-        throw CImgArgumentException("CImg<%s>::get_convolve() : Specified mask (%u,%u,%u,%u,%p) is not scalar.",
-                                    pixel_type(),mask.width,mask.height,mask.depth,mask.dim,mask.data);
-      CImg<restype> dest(width,height,depth,dim);
-      if (cond && mask.width==mask.height && ((mask.depth==1 && mask.width<=5) || (mask.depth==mask.width && mask.width<=3))) { // optimized version
-        switch (mask.depth) {
-        case 3: {
-          CImg_3x3x3(I,T);
-          if (!weighted_convol) cimg_forZV(*this,z,v) cimg_for3x3x3(*this,x,y,z,v,I) dest(x,y,z,v) = cimg_conv3x3x3(I,mask);
-          else cimg_forZV(*this,z,v) cimg_for3x3x3(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum3x3x3(I);
-            dest(x,y,z,v) = (norm!=0)?(restype)(cimg_conv3x3x3(I,mask)/std::sqrt(norm)):0;
-          }
-        } break;
-        case 2: {
-          CImg_2x2x2(I,T);
-          if (!weighted_convol) cimg_forZV(*this,z,v) cimg_for2x2x2(*this,x,y,z,v,I) dest(x,y,z,v) = cimg_conv2x2x2(I,mask);
-          else cimg_forZV(*this,z,v) cimg_for2x2x2(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum2x2x2(I);
-            dest(x,y,z,v) = (norm!=0)?(restype)(cimg_conv2x2x2(I,mask)/std::sqrt(norm)):0;
-          }
-        } break;
-        default:
-        case 1:
-          switch (mask.width) {
-          case 5: {
-            CImg_5x5(I,T);
-            if (!weighted_convol) cimg_forZV(*this,z,v) cimg_for5x5(*this,x,y,z,v,I) dest(x,y,z,v) = cimg_conv5x5(I,mask);
-            else cimg_forZV(*this,z,v) cimg_for5x5(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum5x5(I);
-              dest(x,y,z,v) = (norm!=0)?(restype)(cimg_conv5x5(I,mask)/std::sqrt(norm)):0;
-            }
-          } break;
-          case 4: {
-            CImg_4x4(I,T);
-            if (!weighted_convol) cimg_forZV(*this,z,v) cimg_for4x4(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv4x4(I,mask);
-            else cimg_forZV(*this,z,v) cimg_for4x4(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum4x4(I);
-              dest(x,y,z,v) = (norm!=0)?(restype)(cimg_conv4x4(I,mask)/std::sqrt(norm)):0;
-            }
-          } break;
-          case 3: {
-            CImg_3x3(I,T);
-            if (!weighted_convol) cimg_forZV(*this,z,v) cimg_for3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv3x3(I,mask);
-            else cimg_forZV(*this,z,v) cimg_for3x3(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum3x3(I);
-              dest(x,y,z,v) = (norm!=0)?(restype)(cimg_conv3x3(I,mask)/std::sqrt(norm)):0;
-            }
-          } break;
-          case 2: {
-            CImg_2x2(I,T);
-            if (!weighted_convol) cimg_forZV(*this,z,v) cimg_for2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv2x2(I,mask);
-            else cimg_forZV(*this,z,v) cimg_for2x2(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum2x2(I);
-              dest(x,y,z,v) = (norm!=0)?(restype)(cimg_conv2x2(I,mask)/std::sqrt(norm)):0;
-            }
-          } break;
-          case 1: dest = mask(0)*(*this); break;
-          }
-        }
-      } else { // generic version
-
-        const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2, fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
-        cimg_forV(*this,v)
-          if (!weighted_convol) {       // Classical convolution
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              ftype val = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                val+= (*this)(x-xm,y-ym,z-zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-              dest(x,y,z,v)=(restype)val;
-            }
-            if (cond) cimg_forYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                ftype val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= pix3d(x-xm,y-ym,z-zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(restype)val;
-              }
-            else cimg_forYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                ftype val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= pix3d(x-xm,y-ym,z-zm,v,0)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(restype)val;
-              }
-          } else {      // Weighted convolution
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              ftype val = 0, norm = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                const T cval = (*this)(x-xm,y-ym,z-zm,v);
-                val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                norm+= cval*cval;
-              }
-              dest(x,y,z,v)=(norm!=0)?(restype)(val/std::sqrt(norm)):0;
-            }
-            if (cond) cimg_forYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                ftype val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = pix3d(x-xm,y-ym,z-zm,v);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+=cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(restype)(val/std::sqrt(norm)):0;
-              }
-            else cimg_forYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = pix3d(x-xm,y-ym,z-zm,v,0);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+= cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(restype)(val/std::sqrt(norm)):0;
-              }
-          }
-      }
-      return dest;
-    }
-
-    //! Convolve the image by a mask
-    /**
-       This is the in-place version of get_convolve().
-       \see get_convolve()
-    **/
-    template<typename t> CImg& convolve(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_convol=false) {
-      return get_convolve(mask,cond,weighted_convol).swap(*this);
-    }
-
-    //! Return the erosion of the image by a structuring element.
-    template<typename t> CImg<typename cimg::largest<T,t>::type>
-    get_erode(const CImg<t>& mask, const unsigned int cond=1, const bool weighted_erosion=false) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      if (is_empty()) return CImg<restype>();
-      if (mask.is_empty() || mask.dim!=1)
-        throw CImgArgumentException("CImg<%s>::get_erosion() : Specified mask (%u,%u,%u,%u,%p) is not a scalar image.",
-                                    pixel_type(),mask.width,mask.height,mask.depth,mask.dim,mask.data);
-      CImg<restype> dest(width,height,depth,dim);
-      const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2,
-        fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
-      cimg_forV(*this,v)
-        if (!weighted_erosion) {        // Classical erosion
-          for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-            restype min_val = cimg::type<restype>::max();
-            for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-              if (mask(cxm+xm,cym+ym,czm+zm,0)) min_val = cimg::min((restype)(*this)(x+xm,y+ym,z+zm,v),min_val);
-            dest(x,y,z,v)=min_val;
-          }
-          if (cond) cimg_forYZV(*this,y,z,v)
-                      for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                        restype min_val = cimg::type<restype>::max();
-                        for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                          if (mask(cxm+xm,cym+ym,czm+zm,0)) min_val = cimg::min((restype)pix3d(x+xm,y+ym,z+zm,v),min_val);
-                        dest(x,y,z,v)=min_val;
-                      }
-          else cimg_forYZV(*this,y,z,v)
-                 for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                   restype min_val = cimg::type<restype>::max();
-                   for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                     if (mask(cxm+xm,cym+ym,czm+zm,0)) min_val = cimg::min((restype)pix3d(x+xm,y+ym,z+zm,v,0),min_val);
-                   dest(x,y,z,v)=min_val;
-                 }
-        } else { // Weighted erosion
-          t mval=0;
-          for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-            restype min_val = cimg::type<restype>::max();
-            for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-              if ((mval=mask(cxm+xm,cym+ym,czm+zm,0))!=0) min_val = cimg::min((restype)((*this)(x+xm,y+ym,z+zm,v)+mval),min_val);
-            dest(x,y,z,v)=min_val;
-          }
-          if (cond) cimg_forYZV(*this,y,z,v)
-                      for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                        restype min_val = cimg::type<restype>::max();
-                        for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                          if ((mval=mask(cxm+xm,cym+ym,czm+zm,0))!=0) min_val = cimg::min((restype)(pix3d(x+xm,y+ym,z+zm,v)+mval),min_val);
-                        dest(x,y,z,v)=min_val;
-                      }
-          else cimg_forYZV(*this,y,z,v)
-                 for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                   restype min_val = cimg::type<restype>::max();
-                   for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                     if ((mval=mask(cxm+xm,cym+ym,czm+zm,0))!=0) min_val = cimg::min((restype)(pix3d(x+xm,y+ym,z+zm,v,0)+mval),min_val);
-                   dest(x,y,z,v)=min_val;
-                 }
-        }
-      return dest;
-    }
-
-    //! Erode the image by a structuring element
-    /**
-       This is the in-place version of get_erode().
-       \see get_erode()
-    **/
-    template<typename t> CImg& erode(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_erosion=false) {
-      return get_erode(mask,cond,weighted_erosion).swap(*this);
-    }
-
-    //! Erode the image by a square structuring element of size n
-    CImg get_erode(const unsigned int n, const unsigned int cond=1) const {
-      static CImg<T> mask;
-      if (mask.width!=n) mask.assign(n,n,1,1,1);
-      const CImg<T> res = get_erode(mask,cond,false);
-      if (n>20) mask.assign();
-      return res;
-    }
-
-    //! Erode the image by a square structuring element of size n
-    CImg& erode(const unsigned int n, const unsigned int cond=1) {
-      return get_erode(n,cond).swap(*this);
-    }
-
-    //! Return the dilatation of the image by a structuring element.
-    template<typename t> CImg<typename cimg::largest<T,t>::type>
-    get_dilate(const CImg<t>& mask, const unsigned int cond=1, const bool weighted_dilatation=false) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      if (is_empty()) return CImg<restype>();
-      if (mask.is_empty() || mask.dim!=1)
-        throw CImgArgumentException("CImg<%s>::get_dilate() : Specified mask (%u,%u,%u,%u,%p) is not a scalar image.",
-                                    pixel_type(),mask.width,mask.height,mask.depth,mask.dim,mask.data);
-      CImg<restype> dest(width,height,depth,dim);
-      const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2,
-        fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
-      cimg_forV(*this,v)
-        if (!weighted_dilatation) { // Classical dilatation
-          for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-            restype max_val = cimg::type<restype>::min();
-            for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-              if (mask(cxm+xm,cym+ym,czm+zm,0)) max_val = cimg::max((restype)(*this)(x+xm,y+ym,z+zm,v),max_val);
-            dest(x,y,z,v)=max_val;
-          }
-          if (cond) cimg_forYZV(*this,y,z,v)
-                      for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                        restype max_val = cimg::type<restype>::min();
-                        for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                          if (mask(cxm+xm,cym+ym,czm+zm,0)) max_val = cimg::max((restype)pix3d(x+xm,y+ym,z+zm,v),max_val);
-                        dest(x,y,z,v)=max_val;
-                      }
-          else cimg_forYZV(*this,y,z,v)
-                 for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                   restype max_val = cimg::type<restype>::min();
-                   for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                     if (mask(cxm+xm,cym+ym,czm+zm,0)) max_val = cimg::max((restype)pix3d(x+xm,y+ym,z+zm,v,0),max_val);
-                   dest(x,y,z,v)=max_val;
-                 }
-        } else { // Weighted dilatation
-          t mval=0;
-          for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-            restype max_val = cimg::type<restype>::min();
-            for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-              if ((mval=mask(cxm+xm,cym+ym,czm+zm,0))!=0) max_val = cimg::max((restype)((*this)(x+xm,y+ym,z+zm,v)-mval),max_val);
-            dest(x,y,z,v)=max_val;
-          }
-          if (cond) cimg_forYZV(*this,y,z,v)
-                      for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                        restype max_val = cimg::type<restype>::min();
-                        for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                          if ((mval=mask(cxm+xm,cym+ym,czm+zm,0))!=0) max_val = cimg::max((restype)(pix3d(x+xm,y+ym,z+zm,v)-mval),max_val);
-                        dest(x,y,z,v)=max_val;
-                      }
-          else cimg_forYZV(*this,y,z,v)
-                 for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                   restype max_val = cimg::type<restype>::min();
-                   for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                     if ((mval=mask(cxm+xm,cym+ym,czm+zm,0))!=0) max_val = cimg::max((restype)(pix3d(x+xm,y+ym,z+zm,v,0)-mval),max_val);
-                   dest(x,y,z,v)=max_val;
-                 }
-        }
-      return dest;
-    }
-
-    //! Dilate the image by a structuring element
-    /**
-       This is the in-place version of get_dilate().
-       \see get_dilate()
-    **/
-    template<typename t> CImg& dilate(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_dilatation=false) {
-      return get_dilate(mask,cond,weighted_dilatation).swap(*this);
-    }
-
-    //! Dilate the image by a square structuring element of size n
-    CImg get_dilate(const unsigned int n, const unsigned int cond=1) const {
-      static CImg<T> mask;
-      if (mask.width!=n) mask.assign(n,n,1,1,1);
-      const CImg<T> res = get_dilate(mask,cond,false);
-      if (n>20) mask.assign();
-      return res;
-    }
-
-    //! Dilate the image by a square structuring element of size n
-    CImg& dilate(const unsigned int n, const unsigned int cond=1) {
-      return get_dilate(n,cond).swap(*this);
-    }
-
-    //! Add noise to the image
-    /**
-       This is the in-place version of get_noise.
-       \see get_noise.
-    **/
-    CImg& noise(const double sigma=-20, const unsigned int ntype=0) {
-      if (!is_empty()) {
-        double nsigma = sigma, max = (double)cimg::type<T>::max(), min = (double)cimg::type<T>::min();
-        static bool first_time = true;
-        if (first_time) { std::srand((unsigned int)::time(0)); first_time = false; }
-        CImgStats st;
-        if (nsigma==0) return *this;
-        if (nsigma<0 || ntype==2) st = CImgStats(*this,false);
-        if (nsigma<0) nsigma = -nsigma*(st.max-st.min)/100.0;
-        switch (ntype) {
-        case 0: { // Gaussian noise
-          cimg_for(*this,ptr,T) {
-            double val = *ptr+nsigma*cimg::grand();
-            if (val>max) val = max;
-            if (val<min) val = min;
-            *ptr = (T)val;
-          }
-        } break;
-        case 1: { // Uniform noise
-          cimg_for(*this,ptr,T) {
-            double val = *ptr+nsigma*cimg::crand();
-            if (val>max) val = max;
-            if (val<min) val = min;
-            *ptr = (T)val;
-          }
-        } break;
-        case 2: { // Salt & Pepper noise
-          if (st.max==st.min) { st.min=0; st.max=255; }
-          cimg_for(*this,ptr,T) if (cimg::rand()*100<nsigma) *ptr=(T)(cimg::rand()<0.5?st.max:st.min);
-        } break;
-        case 3: { // Poisson Noise
-          cimg_for(*this,ptr,T) {
-            const double z = (double)*ptr;
-            if (z<=1.0e-10) *ptr=(T)0;
-            else {
-              if (z>100.0) *ptr = (T)(unsigned int)((std::sqrt(z) * cimg::grand()) + z);
-              else {
-                unsigned int k = 0;
-                const double y=std::exp(-z);
-                for (double s=1.0; s>=y; k++) s *= cimg::rand();
-                *ptr=(T)(k-1);
-              }
-            }
-          }
-        } break;
-        case 4: { // Rice noise
-          const double sqrt2 = (double)std::sqrt(2.0);
-          cimg_for(*this,ptr,T) {
-            const double
-              val0 = (double)*ptr/sqrt2,
-              re = val0 + nsigma*cimg::grand(),
-              im = val0 + nsigma*cimg::grand();
-            double val = std::sqrt(re*re + im*im);
-            if (val>max) val = max;
-            if (val<min) val = min;
-            *ptr = (T)val;
-          }
-        } break;
-        }
-      }
-      return *this;
-    }
-
-    //! Return a noisy image
-    /**
-       \param sigma = power of the noise. if sigma<0, it corresponds to the percentage of the maximum image value.
-       \param ntype = noise type. can be 0=gaussian, 1=uniform or 2=Salt and Pepper.
-       \return A noisy version of the instance image.
-    **/
-    CImg get_noise(const double sigma=-20,const unsigned int ntype=0) const {
-      return (+*this).noise(sigma,ntype);
-    }
-
-#define cimg_deriche_apply(x0,y0,z0,k0,nb,offset,T) { \
-    ima = ptr(x0,y0,z0,k0); \
-    I2 = *ima; ima+=offset; I1 = *ima; ima+=offset; \
-    Y2 = *(Y++) = sumg0*I2; Y1 = *(Y++) = g0*I1 + sumg1*I2; \
-    for (i=2; i<(nb); i++) { I1 = *ima; ima+=offset; \
-        Y0 = *(Y++) = a1*I1 + a2*I2 + b1*Y1 + b2*Y2; \
-        I2=I1; Y2=Y1; Y1=Y0; } \
-    ima-=offset; I2 = *ima; Y2 = Y1 = parity*sumg1*I2; *ima = (T)(*(--Y)+Y2); \
-    ima-=offset; I1 = *ima; *ima = (T)(*(--Y)+Y1); \
-    for (i=(nb)-3; i>=0; i--) { Y0=a3*I1+a4*I2+b1*Y1+b2*Y2; ima-=offset; \
-      I2=I1; I1=*ima; *ima=(T)(*(--Y)+Y0); Y2=Y1; Y1=Y0; } \
-  }
-
-    //! Apply a deriche filter on the image
-    /**
-       This is the in-place version of get_deriche
-       \see get_deriche.
-    **/
-    CImg& deriche(const float sigma=1,const int order=0,const char axe='x',const unsigned int cond=1) {
-      if (!is_empty()) {
-        if (sigma<0 || order<0 || order>2)
-          throw CImgArgumentException("CImg<%s>::deriche() : Bad arguments (sigma=%g, order=%d)",pixel_type(),sigma,order);
-        const float alpha=sigma>0?(1.695f/sigma):20,ea=(float)std::exp(alpha),ema=(float)std::exp(-alpha),em2a=ema*ema,b1=2*ema,b2=-em2a;
-        float ek,ekn,parity,a1,a2,a3,a4,g0,sumg1,sumg0;
-        double *Y,Y0,Y1,Y2;
-        int i,offset,nb;
-        T *ima,I1,I2;
-        switch(order) {
-        case 1:                 // first derivative
-          ek = -(1-ema)*(1-ema)*(1-ema)/(2*(ema+1)*ema); a1 = a4 = 0;  a2 = ek*ema; a3 = -ek*ema; parity =-1;
-          if (cond) { sumg1 = (ek*ea) / ((ea-1)*(ea-1)); g0 = 0; sumg0 = g0+sumg1; }
-          else g0 = sumg0 = sumg1 = 0;
-          break;
-        case 2:               // second derivative
-          ekn = ( -2*(-1+3*ea-3*ea*ea+ea*ea*ea)/(3*ea+1+3*ea*ea+ea*ea*ea) );
-          ek = -(em2a-1)/(2*alpha*ema); a1 = ekn;  a2 = -ekn*(1+ek*alpha)*ema; a3 = ekn*(1-ek*alpha)*ema; a4 = -ekn*em2a; parity =1;
-          if (cond) { sumg1 = ekn/2; g0 = ekn; sumg0 = g0+sumg1; }
-          else g0=sumg0=sumg1=0;
-          break;
-        default:              // smoothing
-          ek = (1-ema)*(1-ema) / (1+2*alpha*ema - em2a); a1 = ek;  a2 = ek*ema*(alpha-1); a3 = ek*ema*(alpha+1); a4 = -ek*em2a; parity = 1;
-          if (cond) { sumg1 = ek*(alpha*ea+ea-1) / ((ea-1)*(ea-1)); g0 = ek; sumg0 = g0+sumg1; }
-          else  g0=sumg0=sumg1=0;
-          break;
-        }
-        // filter init
-        Y = new double[cimg::max(width,height,depth)];
-        switch(cimg::uncase(axe)) {
-        case 'x': if (width>1)  { offset = 1;            nb = width;  cimg_forYZV(*this,y,z,k) cimg_deriche_apply(0,y,z,k,nb,offset,T); }       break;
-        case 'y': if (height>1) { offset = width;        nb = height; cimg_forXZV(*this,x,z,k) cimg_deriche_apply(x,0,z,k,nb,offset,T); }       break;
-        case 'z': if (depth>1)  { offset = width*height; nb = depth;  cimg_forXYV(*this,x,y,k) cimg_deriche_apply(x,y,0,k,nb,offset,T); }       break;
-        default: throw CImgArgumentException("CImg<%s>::deriche() : unknow axe '%c', must be 'x','y' or 'z'",pixel_type(),axe);
-        }
-        delete[] Y;
-      }
-      return *this;
-    }
-
-    //! Return the result of the Deriche filter
-    /**
-       The Canny-Deriche filter is a recursive algorithm allowing to compute blurred derivatives of
-       order 0,1 or 2 of an image.
-       \see blur
-    **/
-    CImg get_deriche(const float sigma=1,const int order=0,const char axe='x',const unsigned int cond=1) const {
-      return (+*this).deriche(sigma,order,axe,cond);
-    }
-
-    //! Blur the image with a Deriche filter (anisotropically)
-    /**
-       This is the in-place version of get_blur().
-       \see get_blur().
-    **/
-    CImg& blur(const float sigmax,const float sigmay,const float sigmaz,const unsigned int cond=1) {
-      if (!is_empty()) {
-        if (width>1  && sigmax>0) deriche(sigmax,0,'x',cond);
-        if (height>1 && sigmay>0) deriche(sigmay,0,'y',cond);
-        if (depth>1  && sigmaz>0) deriche(sigmaz,0,'z',cond);
-      }
-      return *this;
-    }
-
-    //! Blur the image with a Canny-Deriche filter.
-    /** This is the in-place version of get_blur(). **/
-    CImg& blur(const float sigma,const unsigned int cond=1) { return blur(sigma,sigma,sigma,cond); }
-
-    //! Return a blurred version of the image, using a Canny-Deriche filter.
-    /**
-       Blur the image with an anisotropic exponential filter (Deriche filter of order 0).
-    **/
-    CImg get_blur(const float sigmax,const float sigmay,const float sigmaz,const unsigned int cond=1) const {
-      return (+*this).blur(sigmax,sigmay,sigmaz,cond);
-    }
-
-    //! Return a blurred version of the image, using a Canny-Deriche filter.
-    CImg get_blur(const float sigma,const unsigned int cond=1) const {
-      return (+*this).blur(sigma,cond);
-    }
-
-    //! Blur an image following a field of diffusion tensors.
-    /** This is the in-place version of get_blur_anisotropic(). **/
-    template<typename t>
-    CImg& blur_anisotropic(const CImg<t>& G, const float amplitude=60.0f, const float dl=0.8f,const float da=30.0f,
-                           const float gauss_prec=2.0f, const unsigned int interpolation=0, const bool fast_approx=true) {
-#define cimg_valign2d(i,j) \
-    { ftype &u = W(i,j,0,0), &v = W(i,j,0,1); \
-    if (u*curru + v*currv<0) { u=-u; v=-v; }}
-#define cimg_valign3d(i,j,k) \
-    { ftype &u = W(i,j,k,0), &v = W(i,j,k,1), &w = W(i,j,k,2); \
-    if (u*curru + v*currv + w*currw<0) { u=-u; v=-v; w=-w; }}
-
-      // Check arguments and init variables
-      typedef typename cimg::largest<T,float>::type ftype;
-      if (!is_empty() && amplitude>0) {
-        if (G.is_empty() || (G.dim!=3 && G.dim!=6) || G.width!=width || G.height!=height || G.depth!=depth)
-          throw CImgArgumentException("CImg<%s>::blur_anisotropic() : Specified tensor field (%u,%u,%u,%u) is not valid.",
-                                      pixel_type(),G.width,G.height,G.depth,G.dim);
-
-        const float sqrt2amplitude = (float)std::sqrt(2*amplitude);
-        const bool threed = (G.dim>=6);
-        const int
-          dx1 = dimx()-1,
-          dy1 = dimy()-1,
-          dz1 = dimz()-1;
-        CImg<ftype>
-          dest(width,height,depth,dim,0),
-          W(width,height,depth,threed?4:3),
-          tmp(dim);
-        int N = 0;
-
-        if (threed)
-          // 3D version of the algorithm
-          for (float phi=(180%(int)da)/2.0f; phi<=180; phi+=da) {
-            const float
-              phir = (float)(phi*cimg::PI/180),
-              datmp = (float)(da/std::cos(phir)),
-              da2 = datmp<1?360.0f:datmp;
-
-            for (float theta=0; theta<360; (theta+=da2),N++) {
-              const float
-                thetar = (float)(theta*cimg::PI/180),
-                vx = (float)(std::cos(thetar)*std::cos(phir)),
-                vy = (float)(std::sin(thetar)*std::cos(phir)),
-                vz = (float)std::sin(phir);
-              const t
-                *pa = G.ptr(0,0,0,0),
-                *pb = G.ptr(0,0,0,1),
-                *pc = G.ptr(0,0,0,2),
-                *pd = G.ptr(0,0,0,3),
-                *pe = G.ptr(0,0,0,4),
-                *pf = G.ptr(0,0,0,5);
-              ftype
-                *pd0 = W.ptr(0,0,0,0),
-                *pd1 = W.ptr(0,0,0,1),
-                *pd2 = W.ptr(0,0,0,2),
-                *pd3 = W.ptr(0,0,0,3);
-              cimg_forXYZ(G,xg,yg,zg) {
-                const t
-                  a = *(pa++), b = *(pb++), c = *(pc++),
-                  d = *(pd++), e = *(pe++), f = *(pf++);
-                const float
-                  u = (float)(a*vx + b*vy + c*vz),
-                  v = (float)(b*vx + d*vy + e*vz),
-                  w = (float)(c*vx + e*vy + f*vz),
-                  n = (float)std::sqrt(1e-5+u*u+v*v+w*w),
-                  dln = dl/n;
-                *(pd0++) = (ftype)(u*dln);
-                *(pd1++) = (ftype)(v*dln);
-                *(pd2++) = (ftype)(w*dln);
-                *(pd3++) = (ftype)n;
-              }
-
-              cimg_forXYZ(*this,x,y,z) {
-                tmp.fill(0);
-                const float
-                  cu = (float)W(x,y,z,0),
-                  cv = (float)W(x,y,z,1),
-                  cw = (float)W(x,y,z,2),
-                  n  = (float)W(x,y,z,3),
-                  fsigma = (float)(n*sqrt2amplitude),
-                  length = gauss_prec*fsigma,
-                  fsigma2 = 2*fsigma*fsigma;
-                float
-                  S = 0,
-                  pu = cu,
-                  pv = cv,
-                  pw = cw,
-                  X = (float)x,
-                  Y = (float)y,
-                  Z = (float)z;
-
-                switch (interpolation) {
-                case 0:
-                  // Nearest neighbor
-                  for (float l=0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1 && Z>=0 && Z<=dz1; l+=dl) {
-                    const int
-                      cx = (int)(X+0.5f),
-                      cy = (int)(Y+0.5f),
-                      cz = (int)(Z+0.5f);
-                    float
-                      u = (float)W(cx,cy,cz,0),
-                      v = (float)W(cx,cy,cz,1),
-                      w = (float)W(cx,cy,cz,2);
-                    if ((pu*u + pv*v + pw*w)<0) { u=-u; v=-v; w=-w; }
-                    if (fast_approx) { cimg_forV(*this,k) tmp[k]+=(ftype)(*this)(cx,cy,cz,k); S++; }
-                    else {
-                      const float coef = (float)std::exp(-l*l/fsigma2);
-                      cimg_forV(*this,k) tmp[k]+=(ftype)(coef*(*this)(cx,cy,cz,k));
-                      S+=coef;
-                    }
-                    X+=(pu=u); Y+=(pv=v); Z+=(pw=w);
-                  } break;
-
-                case 1:
-                  // Linear interpolation
-                  for (float l=0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1 && Z>=0 && Z<=dz1; l+=dl) {
-                    const int
-                      cx = (int)X, px = (cx-1<0)?0:cx-1, nx = (cx+1>dx1)?dx1:cx+1,
-                      cy = (int)Y, py = (cy-1<0)?0:cy-1, ny = (cy+1>dy1)?dy1:cy+1,
-                      cz = (int)Z, pz = (cz-1<0)?0:cz-1, nz = (cz+1>dz1)?dz1:cz+1;
-                    const float
-                      curru = (float)W(cx,cy,cz,0),
-                      currv = (float)W(cx,cy,cz,1),
-                      currw = (float)W(cx,cy,cz,2);
-                    cimg_valign3d(px,py,pz); cimg_valign3d(cx,py,pz); cimg_valign3d(nx,py,pz);
-                    cimg_valign3d(px,cy,pz); cimg_valign3d(cx,cy,pz); cimg_valign3d(nx,cy,pz);
-                    cimg_valign3d(px,ny,pz); cimg_valign3d(cx,ny,pz); cimg_valign3d(nx,ny,pz);
-                    cimg_valign3d(px,py,cz); cimg_valign3d(cx,py,cz); cimg_valign3d(nx,py,cz);
-                    cimg_valign3d(px,cy,cz);                          cimg_valign3d(nx,cy,cz);
-                    cimg_valign3d(px,ny,cz); cimg_valign3d(cx,ny,cz); cimg_valign3d(nx,ny,cz);
-                    cimg_valign3d(px,py,nz); cimg_valign3d(cx,py,nz); cimg_valign3d(nx,py,nz);
-                    cimg_valign3d(px,cy,nz); cimg_valign3d(cx,cy,nz); cimg_valign3d(nx,cy,nz);
-                    cimg_valign3d(px,ny,nz); cimg_valign3d(cx,ny,nz); cimg_valign3d(nx,ny,nz);
-                    float
-                      u = (float)(W.linear_pix3d(X,Y,Z,0)),
-                      v = (float)(W.linear_pix3d(X,Y,Z,1)),
-                      w = (float)(W.linear_pix3d(X,Y,Z,2));
-                    if ((pu*u + pv*v + pw*w)<0) { u=-u; v=-v; w=-w; }
-                    if (fast_approx) { cimg_forV(*this,k) tmp[k]+=(ftype)linear_pix3d(X,Y,Z,k); S++; }
-                    else {
-                      const float coef = (float)std::exp(-l*l/fsigma2);
-                      cimg_forV(*this,k) tmp[k]+=(ftype)(coef*linear_pix3d(X,Y,Z,k));
-                      S+=coef;
-                    }
-                    X+=(pu=u); Y+=(pv=v); Z+=(pw=w);
-                  } break;
-
-                default:
-                  // 2nd order Runge Kutta
-                  for (float l=0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1 && Z>=0 && Z<=dz1; l+=dl) {
-                    const int
-                      cx = (int)X, px = (cx-1<0)?0:cx-1, nx = (cx+1>dx1)?dx1:cx+1,
-                      cy = (int)Y, py = (cy-1<0)?0:cy-1, ny = (cy+1>dy1)?dy1:cy+1,
-                      cz = (int)Z, pz = (cz-1<0)?0:cz-1, nz = (cz+1>dz1)?dz1:cz+1;
-                    const float
-                      curru = (float)W(cx,cy,cz,0),
-                      currv = (float)W(cx,cy,cz,1),
-                      currw = (float)W(cx,cy,cz,2);
-                    cimg_valign3d(px,py,pz); cimg_valign3d(cx,py,pz); cimg_valign3d(nx,py,pz);
-                    cimg_valign3d(px,cy,pz); cimg_valign3d(cx,cy,pz); cimg_valign3d(nx,cy,pz);
-                    cimg_valign3d(px,ny,pz); cimg_valign3d(cx,ny,pz); cimg_valign3d(nx,ny,pz);
-                    cimg_valign3d(px,py,cz); cimg_valign3d(cx,py,cz); cimg_valign3d(nx,py,cz);
-                    cimg_valign3d(px,cy,cz);                          cimg_valign3d(nx,cy,cz);
-                    cimg_valign3d(px,ny,cz); cimg_valign3d(cx,ny,cz); cimg_valign3d(nx,ny,cz);
-                    cimg_valign3d(px,py,nz); cimg_valign3d(cx,py,nz); cimg_valign3d(nx,py,nz);
-                    cimg_valign3d(px,cy,nz); cimg_valign3d(cx,cy,nz); cimg_valign3d(nx,cy,nz);
-                    cimg_valign3d(px,ny,nz); cimg_valign3d(cx,ny,nz); cimg_valign3d(nx,ny,nz);
-                    const float
-                      u0 = (float)(0.5f*W.linear_pix3d(X,Y,Z,0)),
-                      v0 = (float)(0.5f*W.linear_pix3d(X,Y,Z,1)),
-                      w0 = (float)(0.5f*W.linear_pix3d(X,Y,Z,2));
-                    float
-                      u = (float)(W.linear_pix3d(X+u0,Y+v0,Z+w0,0)),
-                      v = (float)(W.linear_pix3d(X+u0,Y+v0,Z+w0,1)),
-                      w = (float)(W.linear_pix3d(X+u0,Y+v0,Z+w0,2));
-                    if ((pu*u + pv*v + pw*w)<0) { u=-u; v=-v; w=-w; }
-                    if (fast_approx) { cimg_forV(*this,k) tmp[k]+=(ftype)linear_pix3d(X,Y,Z,k); S++; }
-                    else {
-                      const float coef = (float)std::exp(-l*l/fsigma2);
-                      cimg_forV(*this,k) tmp[k]+=(ftype)(coef*linear_pix3d(X,Y,Z,k));
-                      S+=coef;
-                    }
-                    X+=(pu=u); Y+=(pv=v); Z+=(pw=w);
-                  } break;
-                }
-                if (S>0) cimg_forV(dest,k) dest(x,y,z,k)+=tmp[k]/S;
-                else cimg_forV(dest,k) dest(x,y,z,k)+=(ftype)((*this)(x,y,z,k));
-#ifdef cimg_plugin_greycstoration
-                if (!*(greycstoration_params->stop_request)) (*greycstoration_params->counter)++;
-                else return *this;
-#endif
-              }
-            }
-          } else
-            // 2D version of the algorithm
-            for (float theta=(360%(int)da)/2.0f; theta<360; (theta+=da),N++) {
-              const float
-                thetar = (float)(theta*cimg::PI/180),
-                vx = (float)(std::cos(thetar)),
-                vy = (float)(std::sin(thetar));
-              const t
-                *pa = G.ptr(0,0,0,0),
-                *pb = G.ptr(0,0,0,1),
-                *pc = G.ptr(0,0,0,2);
-              ftype
-                *pd0 = W.ptr(0,0,0,0),
-                *pd1 = W.ptr(0,0,0,1),
-                *pd2 = W.ptr(0,0,0,2);
-              cimg_forXY(G,xg,yg) {
-                const t a = *(pa++), b = *(pb++), c = *(pc++);
-                const float
-                  u = (float)(a*vx + b*vy),
-                  v = (float)(b*vx + c*vy),
-                  n = (float)std::sqrt(1e-5+u*u+v*v),
-                  dln = dl/n;
-                *(pd0++) = (ftype)(u*dln);
-                *(pd1++) = (ftype)(v*dln);
-                *(pd2++) = (ftype)n;
-              }
-
-              cimg_forXY(*this,x,y) {
-                tmp.fill(0);
-                const float
-                  cu = (float)W(x,y,0,0),
-                  cv = (float)W(x,y,0,1),
-                  n  = (float)W(x,y,0,2),
-                  fsigma = (float)(n*sqrt2amplitude),
-                  length = gauss_prec*fsigma,
-                  fsigma2 = 2*fsigma*fsigma;
-                float
-                  S = 0,
-                  pu = cu,
-                  pv = cv,
-                  X = (float)x,
-                  Y = (float)y;
-
-                switch (interpolation) {
-
-                case 0:
-                  // Nearest-neighbor interpolation for 2D images
-                  for (float l=0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1; l+=dl) {
-                    const int
-                      cx = (int)(X+0.5f),
-                      cy = (int)(Y+0.5f);
-                    float
-                      u = (float)W(cx,cy,0,0),
-                      v = (float)W(cx,cy,0,1);
-                    if ((pu*u + pv*v)<0) { u=-u; v=-v; }
-                    if (fast_approx) { cimg_forV(*this,k) tmp[k]+=(ftype)(*this)(cx,cy,0,k); S++; }
-                    else {
-                      const float coef = (float)std::exp(-l*l/fsigma2);
-                      cimg_forV(*this,k) tmp[k]+=(ftype)(coef*(*this)(cx,cy,0,k));
-                      S+=coef;
-                    }
-                    X+=(pu=u); Y+=(pv=v);
-                  } break;
-
-                case 1:
-                  // Linear interpolation for 2D images
-                  for (float l=0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1; l+=dl) {
-                    const int
-                      cx = (int)X, px = (cx-1<0)?0:cx-1, nx = (cx+1>dx1)?dx1:cx+1,
-                      cy = (int)Y, py = (cy-1<0)?0:cy-1, ny = (cy+1>dy1)?dy1:cy+1;
-                    const float
-                      curru = (float)W(cx,cy,0,0),
-                      currv = (float)W(cx,cy,0,1);
-                    cimg_valign2d(px,py); cimg_valign2d(cx,py); cimg_valign2d(nx,py);
-                    cimg_valign2d(px,cy);                       cimg_valign2d(nx,cy);
-                    cimg_valign2d(px,ny); cimg_valign2d(cx,ny); cimg_valign2d(nx,ny);
-                    float
-                      u = (float)(W.linear_pix2d(X,Y,0,0)),
-                      v = (float)(W.linear_pix2d(X,Y,0,1));
-                    if ((pu*u + pv*v)<0) { u=-u; v=-v; }
-                    if (fast_approx) { cimg_forV(*this,k) tmp[k]+=(ftype)linear_pix2d(X,Y,0,k); S++; }
-                    else {
-                      const float coef = (float)std::exp(-l*l/fsigma2);
-                      cimg_forV(*this,k) tmp[k]+=(ftype)(coef*linear_pix2d(X,Y,0,k));
-                      S+=coef;
-                    }
-                    X+=(pu=u); Y+=(pv=v);
-                  } break;
-
-                default:
-                  // 2nd-order Runge-kutta interpolation for 2D images
-                  for (float l=0; l<length && X>=0 && X<=dx1 && Y>=0 && Y<=dy1; l+=dl) {
-                    const int
-                      cx = (int)X, px = (cx-1<0)?0:cx-1, nx = (cx+1>dx1)?dx1:cx+1,
-                      cy = (int)Y, py = (cy-1<0)?0:cy-1, ny = (cy+1>dy1)?dy1:cy+1;
-                    const float
-                      curru = (float)W(cx,cy,0,0),
-                      currv = (float)W(cx,cy,0,1);
-                    cimg_valign2d(px,py); cimg_valign2d(cx,py); cimg_valign2d(nx,py);
-                    cimg_valign2d(px,cy);                       cimg_valign2d(nx,cy);
-                    cimg_valign2d(px,ny); cimg_valign2d(cx,ny); cimg_valign2d(nx,ny);
-                    const float
-                      u0 = (float)(0.5f*W.linear_pix2d(X,Y,0,0)),
-                      v0 = (float)(0.5f*W.linear_pix2d(X,Y,0,1));
-                    float
-                      u = (float)(W.linear_pix2d(X+u0,Y+v0,0,0)),
-                      v = (float)(W.linear_pix2d(X+u0,Y+v0,0,1));
-                    if ((pu*u + pv*v)<0) { u=-u; v=-v; }
-                    if (fast_approx) { cimg_forV(*this,k) tmp[k]+=(ftype)linear_pix2d(X,Y,0,k); S++; }
-                    else {
-                      const float coef = (float)std::exp(-l*l/fsigma2);
-                      cimg_forV(*this,k) tmp[k]+=(ftype)(coef*linear_pix2d(X,Y,0,k));
-                      S+=coef;
-                    }
-                    X+=(pu=u); Y+=(pv=v);
-                  } break;
-                }
-                if (S>0) cimg_forV(dest,k) dest(x,y,0,k)+=tmp[k]/S;
-                else cimg_forV(dest,k) dest(x,y,0,k)+=(ftype)((*this)(x,y,0,k));
-#ifdef cimg_plugin_greycstoration
-                if (!*(greycstoration_params->stop_request)) (*greycstoration_params->counter)++;
-                else return *this;
-#endif
-              }
-            }
-        const ftype *ptrs = dest.data+dest.size();
-        const T m = cimg::type<T>::min(), M = cimg::type<T>::max();
-        cimg_for(*this,ptrd,T) { const ftype val = *(--ptrs)/N; *ptrd = val<m?m:(val>M?M:(T)val); }
-      }
-      return *this;
-    }
-
-    //! Get a blurred version of an image following a field of diffusion tensors.
-    /**
-       \param G = Field of square roots of diffusion tensors used to drive the smoothing.
-       \param amplitude = amplitude of the smoothing.
-       \param dl = spatial discretization.
-       \param da = angular discretization.
-       \param gauss_prec = precision of the gaussian function.
-       \param interpolation Used interpolation scheme (0 = nearest-neighbor, 1 = linear, 2 = Runge-Kutta)
-       \param fast_approx = Tell to use the fast approximation or not.
-    **/
-    template<typename t>
-      CImg get_blur_anisotropic(const CImg<t>& G, const float amplitude=60.0f, const float dl=0.8f,const float da=30.0f,
-                                const float gauss_prec=2.0f, const unsigned int interpolation=0, const bool fast_approx=true) const {
-      return (+*this).blur_anisotropic(G,amplitude,dl,da,gauss_prec,interpolation,fast_approx);
-    }
-
-    //! Blur an image following a field of diffusion tensors.
-    template<typename tm>
-      CImg& blur_anisotropic(const CImg<tm>& mask, const float amplitude, const float sharpness=0.7f, const float anisotropy=0.3f,
-                             const float alpha=0.6f, const float sigma=1.1f, const float dl=0.8f,const float da=30.0f,
-                             const float gauss_prec=2.0f, const unsigned int interpolation=0, const bool fast_approx=true,
-			     const float geom_factor=1.0f) {
-      if (!is_empty() && amplitude>0) {
-        if (amplitude==0) return *this;
-        if (amplitude<0 || sharpness<0 || anisotropy<0 || anisotropy>1 || alpha<0 || sigma<0 || dl<0 || da<0 || gauss_prec<0)
-          throw CImgArgumentException("CImg<%s>::blur_anisotropic() : Given parameters are amplitude(%g), sharpness(%g), "
-                                      "anisotropy(%g), alpha(%g), sigma(%g), dl(%g), da(%g), gauss_prec(%g).\n"
-                                      "Admissible parameters are in the range : amplitude>0, sharpness>0, anisotropy in [0,1], "
-                                      "alpha>0, sigma>0, dl>0, da>0, gauss_prec>0.",
-                                      pixel_type(),amplitude,sharpness,anisotropy,alpha,sigma,dl,da,gauss_prec);
-        const bool threed = (depth>1), no_mask = mask.is_empty();
-        const float nsharpness = cimg::max(sharpness,1e-5f), power1 = 0.5f*nsharpness, power2 = power1/(1e-7f+1.0f-anisotropy);
-
-        CImg<float> blurred = CImg<float>(*this,false).blur(alpha);
-        if (geom_factor>0) blurred*=geom_factor;
-        else blurred.normalize(0,-geom_factor);
-
-        if (threed) { // Field for 3D volumes
-          CImg<float> val(3), vec(3,3), G(blurred.get_structure_tensorXYZ());
-          if (sigma>0) G.blur(sigma);
-          cimg_forXYZ(*this,x,y,z) {
-            if (no_mask || mask(x,y,z)) {
-              G.get_tensor_at(x,y,z).symmetric_eigen(val,vec);
-              const float l1 = val[2], l2 = val[1], l3 = val[0],
-                ux = vec(0,0), uy = vec(0,1), uz = vec(0,2),
-                vx = vec(1,0), vy = vec(1,1), vz = vec(1,2),
-                wx = vec(2,0), wy = vec(2,1), wz = vec(2,2),
-                n1 = (float)std::pow(1.0f+l1+l2+l3,-power1),
-                n2 = (float)std::pow(1.0f+l1+l2+l3,-power2);
-              G(x,y,z,0) = n1*(ux*ux + vx*vx) + n2*wx*wx;
-              G(x,y,z,1) = n1*(ux*uy + vx*vy) + n2*wx*wy;
-              G(x,y,z,2) = n1*(ux*uz + vx*vz) + n2*wx*wz;
-              G(x,y,z,3) = n1*(uy*uy + vy*vy) + n2*wy*wy;
-              G(x,y,z,4) = n1*(uy*uz + vy*vz) + n2*wy*wz;
-              G(x,y,z,5) = n1*(uz*uz + vz*vz) + n2*wz*wz;
-            } else G(x,y,z,0) = G(x,y,z,1) = G(x,y,z,2) = G(x,y,z,3) = G(x,y,z,4) = G(x,y,z,5) = 0;
-#ifdef cimg_plugin_greycstoration
-            if (!*(greycstoration_params->stop_request)) (*greycstoration_params->counter)++;
-            else return *this;
-#endif
-          }
-          blur_anisotropic(G,amplitude,dl,da,gauss_prec,interpolation,fast_approx);
-        } else { // Field for 2D images
-          CImg<float> val(2), vec(2,2), G(blurred.get_structure_tensorXY());
-          if (sigma>0) G.blur(sigma);
-          cimg_forXY(*this,x,y) {
-            if (no_mask || mask(x,y)) {
-              G.get_tensor_at(x,y).symmetric_eigen(val,vec);
-              const float l1 = val[1], l2 = val[0],
-                ux = vec(1,0), uy = vec(1,1),
-                vx = vec(0,0), vy = vec(0,1),
-                n1 = (float)std::pow(1.0f+l1+l2,-power1),
-                n2 = (float)std::pow(1.0f+l1+l2,-power2);
-              G(x,y,0,0) = n1*ux*ux + n2*vx*vx;
-              G(x,y,0,1) = n1*ux*uy + n2*vx*vy;
-              G(x,y,0,2) = n1*uy*uy + n2*vy*vy;
-            } else G(x,y,0,0) = G(x,y,0,1) = G(x,y,0,2) = 0;
-#ifdef cimg_plugin_greycstoration
-            if (!*(greycstoration_params->stop_request)) (*greycstoration_params->counter)++;
-            else return *this;
-#endif
-          }
-          blur_anisotropic(G,amplitude,dl,da,gauss_prec,interpolation,fast_approx);
-        }
-      }
-      return *this;
-    }
-
-    //! Blur an image in an anisotropic way.
-    /**
-       \param amplitude = amplitude of the anisotropic blur.
-       \param sharpness = define the contour preservation.
-       \param anisotropy = define the smoothing anisotropy.
-       \param alpha = image pre-blurring (gaussian).
-       \param sigma = regularity of the tensor-valued geometry.
-       \param dl = spatial discretization.
-       \param da = angular discretization.
-       \param gauss_prec = precision of the gaussian function.
-       \param interpolation Used interpolation scheme (0 = nearest-neighbor, 1 = linear, 2 = Runge-Kutta)
-       \param fast_approx = Tell to use the fast approximation or not
-    **/
-    template<typename tm>
-      CImg get_blur_anisotropic(const CImg<tm>& mask, const float amplitude, const float sharpness=0.7f, const float anisotropy=0.3f,
-                                const float alpha=0.6f, const float sigma=1.1f, const float dl=0.8f,
-                                const float da=30.0f, const float gauss_prec=2.0f, const unsigned int interpolation=0,
-                                const bool fast_approx=true, const float geom_factor=1.0f) const {
-      return (+*this).blur_anisotropic(mask,amplitude,sharpness,anisotropy,alpha,sigma,dl,da,gauss_prec,interpolation,fast_approx,geom_factor);
-    }
-
-    //! Blur an image following in an anistropic way.
-    CImg& blur_anisotropic(const float amplitude, const float sharpness=0.7f, const float anisotropy=0.3f,
-                           const float alpha=0.6f, const float sigma=1.1f, const float dl=0.8f,const float da=30.0f,
-                           const float gauss_prec=2.0f, const unsigned int interpolation=0, const bool fast_approx=true,
-                           const float geom_factor=1.0f) {
-      return blur_anisotropic(CImg<T>(),amplitude,sharpness,anisotropy,alpha,sigma,dl,da,gauss_prec,interpolation,fast_approx,geom_factor);
-    }
-
-    //! Blur an image following in an anistropic way.
-    CImg get_blur_anisotropic(const float amplitude, const float sharpness=0.7f, const float anisotropy=0.3f,
-                              const float alpha=0.6f, const float sigma=1.1f, const float dl=0.8f,
-                              const float da=30.0f, const float gauss_prec=2.0f, const unsigned int interpolation=0,
-                              const bool fast_approx=true, const float geom_factor=1.0f) const {
-      return (+*this).blur_anisotropic(amplitude,sharpness,anisotropy,alpha,sigma,dl,da,gauss_prec,interpolation,fast_approx,geom_factor);
-    }
-
-    //! Return the Fast Fourier Transform of an image (along a specified axis)
-    CImgList<typename cimg::largest<T,float>::type> get_FFT(const char axe, const bool inverse=false) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImgList<restype>(*this).FFT(axe,inverse);
-    }
-
-    //! Return the Fast Fourier Transform on an image
-    CImgList<typename cimg::largest<T,float>::type> get_FFT(const bool inverse=false) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImgList<restype>(*this).FFT(inverse);
-    }
-
-    //! Apply a median filter.
-    CImg get_blur_median(const unsigned int n=3) {
-      CImg<T> res(width,height,depth,dim);
-      if (!n || n==1) return *this;
-      const int hl=n/2, hr=hl-1+n%2;
-      if (res.depth!=1) {  // 3D median filter
-        CImg<T> vois;
-        cimg_forXYZV(*this,x,y,z,k) {
-          vois = get_crop(x-hl,y-hl,z-hl,k,x+hr,y+hr,z+hr,k);
-          res(x,y,z,k) = vois.median();
-        }
-      } else { // 2D median filter
-#define _median_sort(a,b) if ((a)>(b)) cimg::swap(a,b)
-        switch (n) {
-        case 3: {
-          CImg_3x3(I,T);
-          CImg_3x3(J,T);
-          cimg_forV(*this,k) cimg_for3x3(*this,x,y,0,k,I) {
-            cimg_copy3x3(I,J);
-            _median_sort(Jcp, Jnp); _median_sort(Jcc, Jnc); _median_sort(Jcn, Jnn);
-            _median_sort(Jpp, Jcp); _median_sort(Jpc, Jcc); _median_sort(Jpn, Jcn);
-            _median_sort(Jcp, Jnp); _median_sort(Jcc, Jnc); _median_sort(Jcn, Jnn);
-            _median_sort(Jpp, Jpc); _median_sort(Jnc, Jnn); _median_sort(Jcc, Jcn);
-            _median_sort(Jpc, Jpn); _median_sort(Jcp, Jcc); _median_sort(Jnp, Jnc);
-            _median_sort(Jcc, Jcn); _median_sort(Jcc, Jnp); _median_sort(Jpn, Jcc);
-            _median_sort(Jcc, Jnp);
-            res(x,y,0,k) = Jcc;
-          }
-        } break;
-        case 5: {
-          CImg_5x5(I,T);
-          CImg_5x5(J,T);
-          cimg_forV(*this,k) cimg_for5x5(*this,x,y,0,k,I) {
-            cimg_copy5x5(I,J);
-            _median_sort(Jbb, Jpb); _median_sort(Jnb, Jab); _median_sort(Jcb, Jab); _median_sort(Jcb, Jnb);
-            _median_sort(Jpp, Jcp); _median_sort(Jbp, Jcp); _median_sort(Jbp, Jpp); _median_sort(Jap, Jbc);
-            _median_sort(Jnp, Jbc); _median_sort(Jnp, Jap); _median_sort(Jcc, Jnc); _median_sort(Jpc, Jnc);
-            _median_sort(Jpc, Jcc); _median_sort(Jbn, Jpn); _median_sort(Jac, Jpn); _median_sort(Jac, Jbn);
-            _median_sort(Jnn, Jan); _median_sort(Jcn, Jan); _median_sort(Jcn, Jnn); _median_sort(Jpa, Jca);
-            _median_sort(Jba, Jca); _median_sort(Jba, Jpa); _median_sort(Jna, Jaa); _median_sort(Jcb, Jbp);
-            _median_sort(Jnb, Jpp); _median_sort(Jbb, Jpp); _median_sort(Jbb, Jnb); _median_sort(Jab, Jcp);
-            _median_sort(Jpb, Jcp); _median_sort(Jpb, Jab); _median_sort(Jpc, Jac); _median_sort(Jnp, Jac);
-            _median_sort(Jnp, Jpc); _median_sort(Jcc, Jbn); _median_sort(Jap, Jbn); _median_sort(Jap, Jcc);
-            _median_sort(Jnc, Jpn); _median_sort(Jbc, Jpn); _median_sort(Jbc, Jnc); _median_sort(Jba, Jna);
-            _median_sort(Jcn, Jna); _median_sort(Jcn, Jba); _median_sort(Jpa, Jaa); _median_sort(Jnn, Jaa);
-            _median_sort(Jnn, Jpa); _median_sort(Jan, Jca); _median_sort(Jnp, Jcn); _median_sort(Jap, Jnn);
-            _median_sort(Jbb, Jnn); _median_sort(Jbb, Jap); _median_sort(Jbc, Jan); _median_sort(Jpb, Jan);
-            _median_sort(Jpb, Jbc); _median_sort(Jpc, Jba); _median_sort(Jcb, Jba); _median_sort(Jcb, Jpc);
-            _median_sort(Jcc, Jpa); _median_sort(Jnb, Jpa); _median_sort(Jnb, Jcc); _median_sort(Jnc, Jca);
-            _median_sort(Jab, Jca); _median_sort(Jab, Jnc); _median_sort(Jac, Jna); _median_sort(Jbp, Jna);
-            _median_sort(Jbp, Jac); _median_sort(Jbn, Jaa); _median_sort(Jpp, Jaa); _median_sort(Jpp, Jbn);
-            _median_sort(Jcp, Jpn); _median_sort(Jcp, Jan); _median_sort(Jnc, Jpa); _median_sort(Jbn, Jna);
-            _median_sort(Jcp, Jnc); _median_sort(Jcp, Jbn); _median_sort(Jpb, Jap); _median_sort(Jnb, Jpc);
-            _median_sort(Jbp, Jcn); _median_sort(Jpc, Jcn); _median_sort(Jap, Jcn); _median_sort(Jab, Jbc);
-            _median_sort(Jpp, Jcc); _median_sort(Jcp, Jac); _median_sort(Jab, Jpp); _median_sort(Jab, Jcp);
-            _median_sort(Jcc, Jac); _median_sort(Jbc, Jac); _median_sort(Jpp, Jcp); _median_sort(Jbc, Jcc);
-            _median_sort(Jpp, Jbc); _median_sort(Jpp, Jcn); _median_sort(Jcc, Jcn); _median_sort(Jcp, Jcn);
-            _median_sort(Jcp, Jbc); _median_sort(Jcc, Jnn); _median_sort(Jcp, Jcc); _median_sort(Jbc, Jnn);
-            _median_sort(Jcc, Jba); _median_sort(Jbc, Jba); _median_sort(Jbc, Jcc);
-            res(x,y,0,k) = Jcc;
-          }
-        } break;
-        default: {
-          CImg<T> vois;
-          cimg_forXYV(*this,x,y,k) {
-            vois = get_crop(x-hl,y-hl,0,k,x+hr,y+hr,0,k);
-            res(x,y,0,k) = vois.median();
-          }
-        } break;
-        }
-      }
-      return res;
-    }
-
-    //! Apply a median filter
-    CImg& blur_median(const unsigned int n=3) {
-      return get_blur_median(n).swap(*this);
-    }
-
-    //! Sharpen image using anisotropic shock filters
-    CImg& sharpen(const float amplitude=50.0f, const float edge=1.0f, const float alpha=0.0f, const float sigma=0.0f) {
-      if (is_empty()) return *this;
-      const bool threed = (depth>1);
-      const float nedge = 0.5f*edge;
-      typedef typename cimg::largest<T,float>::type ftype;
-      CImg<ftype> val, vec, veloc(width,height,depth,dim);
-
-      if (threed) {
-        CImg<ftype> G = (alpha>0?get_blur(alpha).get_structure_tensorXYZ():get_structure_tensorXYZ());
-        if (sigma>0) G.blur(sigma);
-        CImg_3x3x3(I,float);
-        cimg_forXYZ(G,x,y,z) {
-          G.get_tensor_at(x,y,z).symmetric_eigen(val,vec);
-          G(x,y,z,0) = vec(0,0);
-          G(x,y,z,1) = vec(0,1);
-          G(x,y,z,2) = vec(0,2);
-          G(x,y,z,3) = 1.0f-(float)std::pow(1.0f+val[0]+val[1]+val[2],-nedge);
-        }
-        cimg_forV(*this,k) cimg_for3x3x3(*this,x,y,z,k,I) {
-          const float
-            u = G(x,y,z,0),
-            v = G(x,y,z,1),
-            w = G(x,y,z,2),
-            amp = G(x,y,z,3),
-            ixx = Incc+Ipcc-2*Iccc,
-            ixy = 0.25f*(Innc+Ippc-Inpc-Ipnc),
-            ixz = 0.25f*(Incn+Ipcp-Incp-Ipcn),
-            iyy = Icnc+Icpc-2*Iccc,
-            iyz = 0.25f*(Icnn+Icpp-Icnp-Icpn),
-            izz = Iccn+Iccp-2*Iccc,
-            ixf = Incc-Iccc,
-            ixb = Iccc-Ipcc,
-            iyf = Icnc-Iccc,
-            iyb = Iccc-Icpc,
-            izf = Iccn-Iccc,
-            izb = Iccc-Iccp,
-            itt = u*u*ixx + v*v*iyy + w*w*izz + 2*u*v*ixy + 2*u*w*ixz + 2*v*w*iyz,
-            it = u*cimg::minmod(ixf,ixb) + v*cimg::minmod(iyf,iyb) + w*cimg::minmod(izf,izb);
-          veloc(x,y,z,k) = -amp*cimg::sign(itt)*cimg::abs(it);
-        }
-      } else {
-        CImg<ftype> G = (alpha>0?get_blur(alpha).get_structure_tensorXY():get_structure_tensorXY());
-        if (sigma>0) G.blur(sigma);
-        CImg_3x3(I,float);
-        cimg_forXY(G,x,y) {
-          G.get_tensor_at(x,y).symmetric_eigen(val,vec);
-          G(x,y,0) = vec(0,0);
-          G(x,y,1) = vec(0,1);
-          G(x,y,2) = 1.0f-(float)std::pow(1.0f+val[0]+val[1],-nedge);
-        }
-        cimg_forV(*this,k) cimg_for3x3(*this,x,y,0,k,I) {
-          const float
-            u = G(x,y,0),
-            v = G(x,y,1),
-            amp = G(x,y,2),
-            ixx = Inc+Ipc-2*Icc,
-            ixy = 0.25f*(Inn+Ipp-Inp-Ipn),
-            iyy = Icn+Icp-2*Icc,
-            ixf = Inc-Icc,
-            ixb = Icc-Ipc,
-            iyf = Icn-Icc,
-            iyb = Icc-Icp,
-            itt = u*u*ixx + v*v*iyy + 2*u*v*ixy,
-            it = u*cimg::minmod(ixf,ixb) + v*cimg::minmod(iyf,iyb);
-          veloc(x,y,k) = -amp*cimg::sign(itt)*cimg::abs(it);
-        }
-      }
-      const CImgStats stats(veloc);
-      const float vmax = (float)cimg::max(cimg::abs(stats.min),cimg::abs(stats.max));
-      if (vmax!=0) { veloc*=amplitude/vmax; (*this)+=veloc; }
-      return *this;
-    }
-
-    CImg get_sharpen(const float amplitude=50.0f, const float edge=1.0f, const float alpha=0.0f, const float sigma=0.0f) const {
-      return (+*this).sharpen(amplitude,edge,alpha,sigma);
-    }
-
-    //@}
-    //-----------------------------
-    //
-    //! \name Matrix and Vectors
-    //@{
-    //-----------------------------
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1) {
-      return CImg<T>(1,1).fill(a1);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2) {
-      return CImg<T>(1,2).fill(a1,a2);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3) {
-      return CImg<T>(1,3).fill(a1,a2,a3);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4) {
-      return CImg<T>(1,4).fill(a1,a2,a3,a4);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5) {
-      return CImg<T>(1,5).fill(a1,a2,a3,a4,a5);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5,const T& a6) {
-      return CImg<T>(1,6).fill(a1,a2,a3,a4,a5,a6);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-                       const T& a5,const T& a6,const T& a7) {
-      return CImg<T>(1,7).fill(a1,a2,a3,a4,a5,a6,a7);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-                       const T& a5,const T& a6,const T& a7,const T& a8) {
-      return CImg<T>(1,8).fill(a1,a2,a3,a4,a5,a6,a7,a8);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-                       const T& a5,const T& a6,const T& a7,const T& a8,const T& a9) {
-      return CImg<T>(1,9).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-                       const T& a5,const T& a6,const T& a7,const T& a8,
-                       const T& a9,const T& a10) {
-      return CImg<T>(1,10).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-                       const T& a5,const T& a6,const T& a7,const T& a8,
-                       const T& a9,const T& a10, const T& a11) {
-      return CImg<T>(1,11).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-                       const T& a5,const T& a6,const T& a7,const T& a8,
-                       const T& a9,const T& a10, const T& a11, const T& a12) {
-      return CImg<T>(1,12).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12);
-    }
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-                       const T& a5,const T& a6,const T& a7,const T& a8,
-                       const T& a9,const T& a10, const T& a11, const T& a12,
-                       const T& a13) {
-      return CImg<T>(1,13).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13);
-    }
-
-    //! Return a 1x1 square matrix with specified coefficients
-    static CImg matrix(const T& a1) {
-      return vector(a1);
-    }
-
-    //! Return a 2x2 square matrix with specified coefficients
-    static CImg matrix(const T& a1,const T& a2,
-                       const T& a3,const T& a4) {
-      return CImg<T>(2,2).fill(a1,a2,
-                               a3,a4);
-    }
-
-    //! Return a 3x3 square matrix with specified coefficients
-    static CImg matrix(const T& a1,const T& a2,const T& a3,
-                       const T& a4,const T& a5,const T& a6,
-                       const T& a7,const T& a8,const T& a9) {
-      return CImg<T>(3,3).fill(a1,a2,a3,
-                               a4,a5,a6,
-                               a7,a8,a9);
-    }
-
-    //! Return a 4x4 square matrix with specified coefficients
-    static CImg matrix(const T& a1,const T& a2,const T& a3,const T& a4,
-                       const T& a5,const T& a6,const T& a7,const T& a8,
-                       const T& a9,const T& a10,const T& a11,const T& a12,
-                       const T& a13,const T& a14,const T& a15,const T& a16) {
-      return CImg<T>(4,4).fill(a1,a2,a3,a4,
-                               a5,a6,a7,a8,
-                               a9,a10,a11,a12,
-                               a13,a14,a15,a16);
-    }
-
-    //! Return a 5x5 square matrix with specified coefficients
-    static CImg matrix(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5,
-                       const T& a6,const T& a7,const T& a8,const T& a9,const T& a10,
-                       const T& a11,const T& a12,const T& a13,const T& a14,const T& a15,
-                       const T& a16,const T& a17,const T& a18,const T& a19,const T& a20,
-                       const T& a21,const T& a22,const T& a23,const T& a24,const T& a25) {
-      return CImg<T>(5,5).fill(a1,a2,a3,a4,a5,
-                               a6,a7,a8,a9,a10,
-                               a11,a12,a13,a14,a15,
-                               a16,a17,a18,a19,a20,
-                               a21,a22,a23,a24,a25);
-    }
-
-    //! In-place version of get_matrix().
-    CImg& matrix() {
-      const unsigned int siz = size();
-      switch (siz) {
-      case 1: break;
-      case 4: width = height = 2; break;
-      case 9: width = height = 3; break;
-      case 16: width = height = 4; break;
-      case 25: width = height = 5; break;
-      case 36: width = height = 6; break;
-      case 49: width = height = 7; break;
-      case 64: width = height = 8; break;
-      case 81: width = height = 9; break;
-      case 100: width = height = 10; break;
-      default: {
-        unsigned int i=11, i2=i*i;
-        while (i2<siz) { i2+=2*i+1; i++; }
-        if (i2==siz) width = height = i;
-        else throw CImgInstanceException("CImg<%s>::matrix() : Image size = %u is not a square number",pixel_type(),siz);
-      } break;
-      }
-      return *this;
-    }
-
-    //! Realign pixel values of the instance image as a square matrix
-    CImg get_matrix() const {
-      return (+*this).matrix();
-    }
-
-    //! Return a 1x1 symmetric matrix with specified coefficients
-    static CImg tensor(const T& a1) {
-      return matrix(a1);
-    }
-
-    //! Return a 2x2 symmetric matrix tensor with specified coefficients
-    static CImg tensor(const T& a1,const T& a2,const T& a3) {
-      return matrix(a1,a2,
-                    a2,a3);
-    }
-
-    //! Return a 3x3 symmetric matrix with specified coefficients
-    static CImg tensor(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5,const T& a6) {
-      return matrix(a1,a2,a3,
-                    a2,a4,a5,
-                    a3,a5,a6);
-    }
-
-    CImg get_tensor() const {
-      CImg<T> res;
-      const unsigned int siz = size();
-      switch (siz) {
-      case 1: break;
-      case 3:
-        res.assign(2,2);
-        res(0,0) = (*this)(0);
-        res(1,0) = res(0,1) = (*this)(1);
-        res(1,1) = (*this)(2);
-        break;
-      case 6:
-        res.assign(3,3);
-        res(0,0) = (*this)(0);
-        res(1,0) = res(0,1) = (*this)(1);
-        res(2,0) = res(0,2) = (*this)(2);
-        res(1,1) = (*this)(3);
-        res(2,1) = res(1,2) = (*this)(4);
-        res(2,2) = (*this)(5);
-        break;
-      default:
-        throw CImgInstanceException("CImg<%s>::get_tensor() : Wrong vector dimension = %u in instance image.",
-                                    pixel_type(), dim);
-        break;
-      }
-      return res;
-    }
-
-    //! In-place version of get_tensor().
-    CImg& tensor() {
-      return get_tensor().swap(*this);
-    }
-
-    //! Return a 1x1 diagonal matrix with specified coefficients
-    static CImg diagonal(const T& a1) {
-      return matrix(a1);
-    }
-
-    //! Return a 2x2 diagonal matrix with specified coefficients
-    static CImg diagonal(const T& a1,const T& a2) {
-      return matrix(a1,0,
-                    0,a2);
-    }
-
-    //! Return a 3x3 diagonal matrix with specified coefficients
-    static CImg diagonal(const T& a1,const T& a2,const T& a3) {
-      return matrix(a1,0,0,
-                    0,a2,0,
-                    0,0,a3);
-    }
-
-    //! Return a 4x4 diagonal matrix with specified coefficients
-    static CImg diagonal(const T& a1,const T& a2,const T& a3,const T& a4) {
-      return matrix(a1,0,0,0,
-                    0,a2,0,0,
-                    0,0,a3,0,
-                    0,0,0,a4);
-    }
-
-    //! Return a 5x5 diagonal matrix with specified coefficients
-    static CImg diagonal(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5) {
-      return matrix(a1,0,0,0,0,
-                    0,a2,0,0,0,
-                    0,0,a3,0,0,
-                    0,0,0,a4,0,
-                    0,0,0,0,a5);
-    }
-
-    //! Unroll all images values into specified axis.
-    CImg& unroll(const char axe='x') {
-      const unsigned int siz = size();
-      if (siz) switch (axe) {
-      case 'x': width = siz; height=depth=dim=1; break;
-      case 'y': height = siz; width=depth=dim=1; break;
-      case 'z': depth = siz; width=height=dim=1; break;
-      case 'v': dim = siz; width=height=depth=1; break;
-      default: throw CImgArgumentException("CImg<%s>::unroll() : Given axe is '%c' which is not 'x','y','z' or 'v'",
-                                           pixel_type(),axe);
-      }
-      return *this;
-    }
-
-    CImg get_unroll(const char axe='x') const {
-      return (+*this).unroll(axe);
-    }
-
-    CImg& vector() {
-      return unroll('y');
-    }
-
-    CImg get_vector() const {
-      return get_unroll('y');
-    }
-
-    //! Get a diagonal matrix, whose diagonal coefficients are the coefficients of the input image
-    CImg get_diagonal() const {
-      if (is_empty()) return CImg<T>();
-      CImg res(size(),size(),1,1,0);
-      cimg_foroff(*this,off) res(off,off)=(*this)(off);
-      return res;
-    }
-
-    //! Replace a vector by a diagonal matrix containing the original vector coefficients.
-    CImg& diagonal() {
-      return get_diagonal().swap(*this);
-    }
-
-    //! Return a NxN identity matrix
-    static CImg identity_matrix(const unsigned int N) {
-      CImg<T> res(N,N,1,1,0);
-      cimg_forX(res,x) res(x,x)=1;
-      return res;
-    }
-
-    CImg& identity_matrix() {
-      return get_identity_matrix(cimg::max(width,height)).swap(*this);
-    }
-
-    CImg get_identity_matrix() const {
-      return identity_matrix(cimg::max(width,height));
-    }
-
-    //! Return a N-numbered sequence vector from \p a0 to \p a1
-    CImg& sequence(const T& a0, const T& a1) {
-      if (!is_empty()) {
-        const unsigned int siz = size()-1;
-        const float delta = (float)((float)a1-a0);
-        T* ptr = data;
-        cimg_foroff(*this,l) *(ptr++) = (T)(a0 + delta*l/siz);
-      }
-      return *this;
-    }
-
-    CImg get_sequence(const T& a0, const T& a1) const {
-      return (+*this).sequence(a0,a1);
-    }
-
-    static CImg sequence(const unsigned int N, const T& a0, const T& a1) {
-      if (N) return CImg<T>(1,N).sequence(a0,a1);
-      return CImg<T>();
-    }
-
-    //! Return a 3x3 rotation matrix along the (x,y,z)-axis with an angle w.
-    static CImg rotation_matrix(const float x, const float y, const float z, const float w, const bool quaternion_data=false) {
-      float X,Y,Z,W;
-      if (!quaternion_data) {
-        const float norm = (float)std::sqrt(x*x + y*y + z*z),
-          nx = norm>0?x/norm:0,
-          ny = norm>0?y/norm:0,
-          nz = norm>0?z/norm:1,
-          nw = norm>0?w:0,
-          sina = (float)std::sin(nw/2),
-          cosa = (float)std::cos(nw/2);
-        X = nx*sina;
-        Y = ny*sina;
-        Z = nz*sina;
-        W = cosa;
-      } else {
-        const float norm = (float)std::sqrt(x*x + y*y + z*z + w*w);
-        if (norm>0) { X=x/norm; Y=y/norm; Z=z/norm; W=w/norm; }
-        else { X=Y=Z=0; W=1; }
-      }
-      const float xx=X*X, xy=X*Y, xz=X*Z, xw=X*W, yy=Y*Y, yz=Y*Z, yw=Y*W, zz=Z*Z, zw=Z*W;
-      return CImg<T>::matrix(1-2*(yy+zz),   2*(xy+zw),   2*(xz-yw),
-                             2*(xy-zw), 1-2*(xx+zz),   2*(yz+xw),
-                             2*(xz+yw),   2*(yz-xw), 1-2*(xx+yy));
-    }
-
-    //! Return a new image corresponding to the vector located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg get_vector_at(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0) const {
-      CImg dest(1,dim);
-      cimg_forV(*this,k) dest[k]=(*this)(x,y,z,k);
-      return dest;
-    }
-
-    //! Return a new image corresponding to the \a square \a matrix located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg get_matrix_at(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0) const {
-      const int n = (int)std::sqrt((double)dim);
-      CImg dest(n,n);
-      cimg_forV(*this,k) dest[k]=(*this)(x,y,z,k);
-      return dest;
-    }
-
-    //! Return a new image corresponding to the \a diffusion \a tensor located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg get_tensor_at(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {
-      if (dim==6) return tensor((*this)(x,y,z,0),(*this)(x,y,z,1),(*this)(x,y,z,2),
-                                          (*this)(x,y,z,3),(*this)(x,y,z,4),(*this)(x,y,z,5));
-      if (dim==3) return tensor((*this)(x,y,z,0),(*this)(x,y,z,1),(*this)(x,y,z,2));
-      return tensor((*this)(x,y,z,0));
-    }
-
-    //! Set the image \p vec as the \a vector \a valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg& set_vector_at(const CImg& vec,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
-      return draw_point(x,y,z,vec.data,1);
-    }
-
-    //! Set the image \p vec as the \a square \a matrix-valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg& set_matrix_at(const CImg& mat,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
-      return set_vector_at(mat,x,y,z);
-    }
-
-    //! Set the image \p vec as the \a tensor \a valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg& set_tensor_at(const CImg& ten,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
-      if (ten.height==2) {
-        (*this)(x,y,z,0)=ten[0];
-        (*this)(x,y,z,1)=ten[1];
-        (*this)(x,y,z,2)=ten[3];
-      }
-      else {
-        (*this)(x,y,z,0)=ten[0];
-        (*this)(x,y,z,1)=ten[1];
-        (*this)(x,y,z,2)=ten[2];
-        (*this)(x,y,z,3)=ten[4];
-        (*this)(x,y,z,4)=ten[5];
-        (*this)(x,y,z,5)=ten[8];
-      }
-      return *this;
-    }
-
-    //! Return the transpose version of the current matrix.
-    CImg get_transpose() const {
-      CImg<T> res(height,width,depth,dim);
-      cimg_forXYZV(*this,x,y,z,v) res(y,x,z,v) = (*this)(x,y,z,v);
-      return res;
-    }
-
-    //! Replace the current matrix by its transpose.
-    CImg& transpose() {
-      if (width==1) { width=height; height=1; return *this; }
-      if (height==1) { height=width; width=1; return *this; }
-      if (width==height) {
-        cimg_forYZV(*this,y,z,v) for (int x=y; x<(int)width; x++) cimg::swap((*this)(x,y,z,v),(*this)(y,x,z,v));
-        return *this;
-      }
-      return (*this)=get_transpose();
-    }
-
-    //! Inverse the current matrix.
-    CImg& inverse(const bool use_LU=true) {
-      if (!is_empty()) {
-        if (width!=height || depth!=1 || dim!=1)
-          throw CImgInstanceException("CImg<%s>::inverse() : Instance matrix (%u,%u,%u,%u,%p) is not square.",
-                                      pixel_type(),width,height,depth,dim,data);
-        const double dete = width>3?-1.0:det();
-        if (dete!=0.0 && width==2) {
-          const double
-            a = data[0], c = data[1],
-            b = data[2], d = data[3];
-          data[0] = (T)(d/dete);  data[1] = (T)(-c/dete);
-          data[2] = (T)(-b/dete), data[3] = (T)(a/dete);
-        } else if (dete!=0.0 && width==3) {
-          const double
-            a = data[0], d = data[1], g = data[2],
-            b = data[3], e = data[4], h = data[5],
-            c = data[6], f = data[7], i = data[8];
-          data[0] = (T)((i*e-f*h)/dete), data[1] = (T)((g*f-i*d)/dete), data[2] = (T)((d*h-g*e)/dete);
-          data[3] = (T)((h*c-i*b)/dete), data[4] = (T)((i*a-c*g)/dete), data[5] = (T)((g*b-a*h)/dete);
-          data[6] = (T)((b*f-e*c)/dete), data[7] = (T)((d*c-a*f)/dete), data[8] = (T)((a*e-d*b)/dete);
-        } else {
-          if (use_LU) { // LU-based inverse computation
-            CImg<T> A(*this), indx, col(1,width);
-            bool d;
-            A._LU(indx,d);
-            cimg_forX(*this,j) {
-              col.fill(0); col(j)=1;
-              col._solve(A,indx);
-              cimg_forX(*this,i) (*this)(j,i) = col(i);
-            }
-          } else { // SVD-based inverse computation
-            CImg<T> U(width,width),S(1,width),V(width,width);
-            SVD(U,S,V,false);
-            U.transpose();
-            cimg_forY(S,k) if (S[k]!=0) S[k]=1/S[k];
-            S.diagonal();
-            *this = V*S*U;
-          }
-        }
-      }
-      return *this;
-    }
-
-    //! Return the inverse of the current matrix.
-    CImg<typename cimg::largest<T,float>::type> get_inverse(const bool use_LU=true) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).inverse(use_LU);
-    }
-
-    //! Return the pseudo-inverse (Moore-Penrose) of the matrix
-    CImg<typename cimg::largest<T,float>::type> get_pseudoinverse() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      CImg<restype> At = get_transpose(), At2(At);
-      return (((At*=*this).inverse())*=At2);
-    }
-
-    //! Replace the matrix by its pseudo-inverse
-    CImg& pseudoinverse() {
-      typedef typename cimg::largest<T,float>::type restype;
-      CImg<restype> At = get_transpose(), At2(At);
-      ((At*=*this).inverse())*=At2;
-      return ((*this)=At);
-    }
-
-    //! Return the trace of the current matrix.
-    double trace() const {
-      if (is_empty())
-        throw CImgInstanceException("CImg<%s>::trace() : Instance matrix (%u,%u,%u,%u,%p) is empty.",
-                                    pixel_type(),width,height,depth,dim,data);
-      double res=0;
-      cimg_forX(*this,k) res+=(*this)(k,k);
-      return res;
-    }
-
-    //! Return the kth smallest element of the image
-    // (Adapted from the numerical recipies for CImg)
-    const T kth_smallest(const unsigned int k) const {
-      if (is_empty())
-        throw CImgInstanceException("CImg<%s>::kth_smallest() : Instance image (%u,%u,%u,%u,%p) is empty.",
-                                    pixel_type(),width,height,depth,dim,data);
-      CImg<T> arr(*this);
-      unsigned long l=0,ir=size()-1;
-      for (;;) {
-        if (ir<=l+1) {
-          if (ir==l+1 && arr[ir]<arr[l]) cimg::swap(arr[l],arr[ir]);
-          return arr[k];
-        } else {
-          const unsigned long mid = (l+ir)>>1;
-          cimg::swap(arr[mid],arr[l+1]);
-          if (arr[l]>arr[ir]) cimg::swap(arr[l],arr[ir]);
-          if (arr[l+1]>arr[ir]) cimg::swap(arr[l+1],arr[ir]);
-          if (arr[l]>arr[l+1]) cimg::swap(arr[l],arr[l+1]);
-          unsigned long i = l+1, j = ir;
-          const T pivot = arr[l+1];
-          for (;;) {
-            do i++; while (arr[i]<pivot);
-            do j--; while (arr[j]>pivot);
-            if (j<i) break;
-            cimg::swap(arr[i],arr[j]);
-          }
-          arr[l+1] = arr[j];
-          arr[j] = pivot;
-          if (j>=k) ir=j-1;
-          if (j<=k) l=i;
-        }
-      }
-      return 0;
-    }
-
-    //! Return the median of the image
-    const T median() const {
-      const unsigned int s = size();
-      const T res = kth_smallest(s>>1);
-      return (s%2)?res:((res+kth_smallest((s>>1)-1))/2);
-    }
-
-    //! Return the dot product of the current vector/matrix with the vector/matrix \p img.
-    double dot(const CImg& img) const {
-      if (is_empty())
-        throw CImgInstanceException("CImg<%s>::dot() : Instance object (%u,%u,%u,%u,%p) is empty.",
-                                    pixel_type(),width,height,depth,dim,data);
-      if (img.is_empty())
-        throw CImgArgumentException("CImg<%s>::trace() : Specified argument (%u,%u,%u,%u,%p) is empty.",
-                                    pixel_type(),img.width,img.height,img.depth,img.dim,img.data);
-      const unsigned long nb = cimg::min(size(),img.size());
-      double res=0;
-      for (unsigned long off=0; off<nb; off++) res+=data[off]*img[off];
-      return res;
-    }
-
-    //! Return the cross product between two 3d vectors
-    CImg& cross(const CImg& img) {
-      if (width!=1 || height<3 || img.width!=1 || img.height<3)
-        throw CImgInstanceException("CImg<%s>::cross() : Arguments (%u,%u,%u,%u,%p) and (%u,%u,%u,%u,%p) must be both 3d vectors.",
-                                    pixel_type(),width,height,depth,dim,data,img.width,img.height,img.depth,img.dim,img.data);
-      const T x = (*this)[0], y = (*this)[1], z = (*this)[2];
-      (*this)[0] = y*img[2]-z*img[1];
-      (*this)[1] = z*img[0]-x*img[2];
-      (*this)[2] = x*img[1]-y*img[0];
-      return *this;
-    }
-
-    //! Return the cross product between two 3d vectors
-    CImg get_cross(const CImg& img) const {
-      return (+*this).cross(img);
-    }
-
-    //! Return the determinant of the current matrix.
-    double det() const {
-      if (is_empty() || width!=height || depth!=1 || dim!=1)
-        throw CImgInstanceException("CImg<%s>::det() : Instance matrix (%u,%u,%u,%u,%p) is not square or is empty.",
-                                    pixel_type(),width,height,depth,dim,data);
-      switch (width) {
-      case 1: return (*this)(0,0);
-      case 2: return (*this)(0,0)*(*this)(1,1)-(*this)(0,1)*(*this)(1,0);
-      case 3: {
-        const double
-          a = data[0], d = data[1], g = data[2],
-          b = data[3], e = data[4], h = data[5],
-          c = data[6], f = data[7], i = data[8];
-        return i*a*e-a*h*f-i*b*d+b*g*f+c*d*h-c*g*e;
-      }
-      default: {
-        typedef typename cimg::largest<T,float>::type ftype;
-        CImg<ftype> lu(*this);
-        CImg<unsigned int> indx;
-        bool d;
-        lu._LU(indx,d);
-        double res = d?1.0:-1.0;
-        cimg_forX(lu,i) res*=lu(i,i);
-        return res;
-      }
-      }
-      return 0;
-    }
-
-    //! Return the norm of the current vector/matrix. \p ntype = norm type (0=L2, 1=L1, -1=Linf).
-    double norm(const int ntype=2) const {
-      if (is_empty())
-        throw CImgInstanceException("CImg<%s>::norm() : Instance object (%u,%u,%u,%u,%p) is empty.",
-                                    pixel_type(),width,height,depth,dim,data);
-      double res = 0;
-      switch (ntype) {
-      case -1: {
-        cimg_foroff(*this,off) {
-          const double tmp = cimg::abs((double)data[off]);
-          if (tmp>res) res = tmp;
-        }
-        return res;
-      } break;
-      case 1 : {
-        cimg_foroff(*this,off) res+=cimg::abs((double)data[off]);
-        return res;
-      } break;
-      default: { return std::sqrt(dot(*this)); }
-      }
-      return 0;
-    }
-
-    //! Return the sum of all the pixel values in an image.
-    double sum() const {
-      if (is_empty())
-        throw CImgInstanceException("CImg<%s>::sum() : Instance object (%u,%u,%u,%u,%p) is empty.",
-                                    pixel_type(),width,height,depth,dim,data);
-      double res=0;
-      cimg_for(*this,ptr,T) res+=*ptr;
-      return res;
-    }
-
-    //! Compute the SVD of a general matrix.
-    template<typename t> const CImg& SVD(CImg<t>& U, CImg<t>& S, CImg<t>& V,
-                                         const bool sorting=true, const unsigned int max_iter=40) const {
-      if (is_empty()) { U.assign(); S.assign(); V.assign(); }
-      else {
-        U = *this;
-        if (S.size()<width) S.assign(1,width);
-        if (V.width<width || V.height<height) V.assign(width,width);
-        CImg<t> rv1(width);
-        t anorm=0,c,f,g=0,h,s,scale=0;
-        int l=0, nm=0;
-
-        cimg_forX(U,i) {
-          l = i+1; rv1[i] = scale*g; g = s = scale = 0;
-          if (i<dimy()) {
-            for (int k=i; k<dimy(); k++) scale+= cimg::abs(U(i,k));
-            if (scale) {
-              for (int k=i; k<dimy(); k++) { U(i,k)/=scale; s+= U(i,k)*U(i,k); }
-              f = U(i,i); g = (t)((f>=0?-1:1)*std::sqrt(s)); h=f*g-s; U(i,i)=f-g;
-              for (int j=l; j<dimx(); j++) {
-                s = 0; for (int k=i; k<dimy(); k++) s+= U(i,k)*U(j,k);
-                f = s/h;
-                { for (int k=i; k<dimy(); k++) U(j,k)+= f*U(i,k); }
-              }
-              { for (int k=i; k<dimy(); k++) U(i,k)*= scale; }
-            }
-          }
-          S[i]=scale*g;
-
-          g = s = scale = 0;
-          if (i<dimy() && i!=dimx()-1) {
-            for (int k=l; k<dimx(); k++) scale += cimg::abs(U(k,i));
-            if (scale) {
-              for (int k=l; k<dimx(); k++) { U(k,i)/= scale; s+= U(k,i)*U(k,i); }
-              f = U(l,i); g = (t)((f>=0?-1:1)*std::sqrt(s)); h = f*g-s; U(l,i) = f-g;
-              { for (int k=l; k<dimx(); k++) rv1[k]=U(k,i)/h; }
-              for (int j=l; j<dimy(); j++) {
-                s=0; for (int k=l; k<dimx(); k++) s+= U(k,j)*U(k,i);
-                { for (int k=l; k<dimx(); k++) U(k,j)+= s*rv1[k]; }
-              }
-              { for (int k=l; k<dimx(); k++) U(k,i)*= scale; }
-            }
-          }
-          anorm=cimg::max((t)anorm,(cimg::abs(S[i])+cimg::abs(rv1[i])));
-        }
-
-        { for (int i=dimx()-1; i>=0; i--) {
-          if (i<dimx()-1) {
-            if (g) {
-              { for (int j=l; j<dimx(); j++) V(i,j) =(U(j,i)/U(l,i))/g; }
-              for (int j=l; j<dimx(); j++) {
-                s=0; for (int k=l; k<dimx(); k++) s+= U(k,i)*V(j,k);
-                { for (int k=l; k<dimx(); k++) V(j,k)+= s*V(i,k); }
-              }
-            }
-            for (int j=l; j<dimx(); j++) V(j,i)=V(i,j)=0.0;
-          }
-          V(i,i) = 1.0; g = rv1[i]; l = i;
-        }
-        }
-
-        { for (int i=cimg::min(dimx(),dimy())-1; i>=0; i--) {
-          l = i+1; g = S[i];
-          for (int j=l; j<dimx(); j++) U(j,i) = 0;
-          if (g) {
-            g = 1/g;
-            for (int j=l; j<dimx(); j++) {
-              s=0; for (int k=l; k<dimy(); k++) s+= U(i,k)*U(j,k);
-              f = (s/U(i,i))*g;
-              { for (int k=i; k<dimy(); k++) U(j,k)+= f*U(i,k); }
-            }
-            { for (int j=i; j<dimy(); j++) U(i,j)*= g; }
-          } else for (int j=i; j<dimy(); j++) U(i,j)=0;
-          U(i,i)++;
-        }
-        }
-
-        for (int k=dimx()-1; k>=0; k--) {
-          for (unsigned int its=0; its<max_iter; its++) {
-            bool flag = true;
-            for (l=k; l>=1; l--) {
-              nm = l-1;
-              if ((cimg::abs(rv1[l])+anorm)==anorm) { flag = false; break; }
-              if ((cimg::abs(S[nm])+anorm)==anorm) break;
-            }
-            if (flag) {
-              c = 0; s = 1;
-              for (int i=l; i<=k; i++) {
-                f = s*rv1[i]; rv1[i] = c*rv1[i];
-                if ((cimg::abs(f)+anorm)==anorm) break;
-                g = S[i]; h = (t)cimg::pythagore(f,g); S[i] = h; h = 1/h; c = g*h; s = -f*h;
-                cimg_forY(U,j) { const t y = U(nm,j), z = U(i,j); U(nm,j) = y*c+z*s; U(i,j) = z*c-y*s; }
-              }
-            }
-            const t& z = S[k];
-            if (l==k) { if (z<0) { S[k] = -z; cimg_forX(U,j) V(k,j) = -V(k,j); } break; }
-            nm = k-1;
-            t x = S[l], y = S[nm];
-            g = rv1[nm]; h = rv1[k];
-            f = ((y-z)*(y+z)+(g-h)*(g+h))/(2*h*y);
-            g = (t)cimg::pythagore(f,1.0);
-            f = ((x-z)*(x+z)+h*((y/(f+ (f>=0?g:-g)))-h))/x;
-            c = s = 1;
-            for (int j=l; j<=nm; j++) {
-              const int i = j+1;
-              g = rv1[i]; h = s*g; g = c*g;
-              t y = S[i];
-              t z = (t)cimg::pythagore(f,h);
-              rv1[j] = z; c = f/z; s = h/z;
-              f = x*c+g*s; g = g*c-x*s; h = y*s; y*=c;
-              cimg_forX(U,jj) { const t x = V(j,jj), z = V(i,jj); V(j,jj) = x*c+z*s; V(i,jj) = z*c-x*s; }
-              z = (t)cimg::pythagore(f,h); S[j] = z;
-              if (z) { z = 1/z; c = f*z; s = h*z; }
-              f = c*g+s*y; x = c*y-s*g;
-              { cimg_forY(U,jj) { const t y = U(j,jj); z = U(i,jj); U(j,jj) = y*c+z*s; U(i,jj) = z*c-y*s; }}
-            }
-            rv1[l] = 0; rv1[k]=f; S[k]=x;
-          }
-        }
-
-        if (sorting) {
-          CImg<int> permutations(width);
-          CImg<t> tmp(width);
-          S.sort(permutations,false);
-          cimg_forY(U,k) {
-            cimg_forX(permutations,x) tmp(x) = U(permutations(x),k);
-            std::memcpy(U.ptr(0,k),tmp.data,sizeof(t)*width);
-          }
-          { cimg_forY(V,k) {
-            cimg_forX(permutations,x) tmp(x) = V(permutations(x),k);
-            std::memcpy(V.ptr(0,k),tmp.data,sizeof(t)*width);
-          }}
-        }
-      }
-      return *this;
-    }
-
-    //! Compute the SVD of a general matrix.
-    template<typename t> const CImg& SVD(CImgList<t>& USV) const {
-      if (USV.size<3) USV.assign(3);
-      return SVD(USV[0],USV[1],USV[2]);
-    }
-
-    //! Compute the SVD of a general matrix.
-    CImgList<typename cimg::largest<T,float>::type> get_SVD(const bool sorting=true) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      CImgList<restype> res(3);
-      SVD(res[0],res[1],res[2],sorting);
-      return res;
-    }
-
-    // INNER ROUTINE : Compute the LU decomposition of a permuted matrix (c.f. numerical recipies)
-    template<typename t> CImg& _LU(CImg<t>& indx, bool& d) {
-      typedef typename cimg::largest<T,float>::type ftype;
-      const int N = dimx();
-      int imax=0;
-      CImg<ftype> vv(N);
-      indx.assign(N);
-      d=true;
-      cimg_forX(*this,i) {
-        ftype vmax=0.0;
-        cimg_forX(*this,j) {
-          const ftype tmp = cimg::abs((*this)(j,i));
-          if (tmp>vmax) vmax = tmp;
-        }
-        if (vmax==0) return fill(0);
-        vv[i] = 1/vmax;
-      }
-      cimg_forX(*this,j) {
-        for (int i=0; i<j; i++) {
-          ftype sum=(*this)(j,i);
-          for (int k=0; k<i; k++) sum-=(*this)(k,i)*(*this)(j,k);
-          (*this)(j,i) = (T)sum;
-        }
-        ftype vmax=0;
-        { for (int i=j; i<dimx(); i++) {
-          ftype sum=(*this)(j,i);
-          for (int k=0; k<j; k++) sum-=(*this)(k,i)*(*this)(j,k);
-          (*this)(j,i) = (T)sum;
-          const ftype tmp = vv[i]*cimg::abs(sum);
-          if (tmp>=vmax) { vmax=tmp; imax=i; }
-        }}
-        if (j!=imax) {
-          cimg_forX(*this,k) cimg::swap((*this)(k,imax),(*this)(k,j));
-          d =!d;
-          vv[imax] = vv[j];
-        }
-        indx[j] = (t)imax;
-        if ((*this)(j,j)==0) (*this)(j,j)=(T)1e-20;
-        if (j<N) {
-          const ftype tmp = 1/(ftype)(*this)(j,j);
-          for (int i=j+1; i<N; i++) (*this)(j,i)*=tmp;
-        }
-      }
-      return *this;
-    }
-
-    // INNER ROUTINE : Solve a linear system, using the LU decomposition
-    template<typename t> CImg& _solve(const CImg<T>& A, const CImg<t>& indx) {
-      typedef typename cimg::largest<T,float>::type ftype;
-      const int N = size();
-      int ii=-1;
-      ftype sum;
-      for (int i=0; i<N; i++) {
-        const int ip = (int)indx[i];
-        ftype sum = (*this)(ip);
-        (*this)(ip) = (*this)(i);
-        if (ii>=0) for (int j=ii; j<=i-1; j++) sum-=A(j,i)*(*this)(j);
-        else if (sum!=0) ii=i;
-        (*this)(i)=sum;
-      }
-      { for (int i=N-1; i>=0; i--) {
-        sum = (*this)(i);
-        for (int j=i+1; j<N; j++) sum-=A(j,i)*(*this)(j);
-        (*this)(i)=sum/A(i,i);
-      }}
-      return *this;
-    }
-
-    //! Solve a linear system AX=B where B=*this. (in-place version)
-    CImg& solve(const CImg& A) {
-      if (width!=1 || depth!=1 || dim!=1 || height!=A.height || A.depth!=1 || A.dim!=1)
-        throw CImgArgumentException("CImg<%s>::solve() : Instance matrix size is (%u,%u,%u,%u) while "
-                                    "size of given matrix A is (%u,%u,%u,%u).",
-                                    pixel_type(),width,height,depth,dim,A.width,A.height,A.depth,A.dim);
-      if (A.width==A.height) {
-        CImg<T> lu(A);
-        CImg<T> indx;
-        bool d;
-        lu._LU(indx,d);
-        _solve(lu,indx);
-      } else assign(A.get_pseudoinverse()*(*this));
-      return *this;
-    }
-
-    //! Solve a linear system AX=B where B=*this.
-    CImg<typename cimg::largest<T,float>::type> get_solve(const CImg& A) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImg<restype>(*this,false).solve(A);
-    }
-
-    //! Compute the eigenvalues and eigenvectors of a matrix.
-    template<typename t> const CImg<T>& eigen(CImg<t>& val, CImg<t> &vec) const {
-      if (is_empty()) { val.assign(); vec.assign(); }
-      else {
-        if (width!=height || depth>1 || dim>1)
-          throw CImgInstanceException("CImg<%s>::eigen() : Instance object (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),width,height,depth,dim,data);
-        if (val.size()<width) val.assign(1,width);
-        if (vec.size()<width*width) vec.assign(width,width);
-        switch(width) {
-        case 1: { val[0]=(t)(*this)[0]; vec[0]=(t)1; } break;
-        case 2: {
-          const double a = (*this)[0], b = (*this)[1], c = (*this)[2], d = (*this)[3], e = a+d;
-          double f = e*e-4*(a*d-b*c);
-          cimg::warn(f<0,"CImg<%s>::eigen() : Complex eigenvalues",pixel_type());
-          f = std::sqrt(f);
-          const double l1 = 0.5*(e-f), l2 = 0.5*(e+f);
-          const double theta1 = std::atan2(l2-a,b), theta2 = std::atan2(l1-a,b);
-          val[0]=(t)l2;
-          val[1]=(t)l1;
-          vec(0,0) = (t)std::cos(theta1);
-          vec(0,1) = (t)std::sin(theta1);
-          vec(1,0) = (t)std::cos(theta2);
-          vec(1,1) = (t)std::sin(theta2);
-        } break;
-        default:
-          throw CImgInstanceException("CImg<%s>::eigen() : Eigenvalues computation of general matrices is limited"
-                                      "to 2x2 matrices (given is %ux%u)", pixel_type(),width,height);
-        }
-      }
-      return *this;
-    }
-
-    //! Return the eigenvalues and eigenvectors of a matrix.
-    CImgList<typename cimg::largest<T,float>::type> get_eigen() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      CImgList<restype> res(2);
-      eigen(res[0],res[1]);
-      return res;
-    }
-
-    //! Compute the eigenvalues and eigenvectors of a matrix.
-    template<typename t> const CImg<T>& eigen(CImgList<t>& eig) const {
-      if (eig.size<2) eig.assign(2);
-      eigen(eig[0],eig[1]);
-      return *this;
-    }
-
-    //! Compute the eigenvalues and eigenvectors of a symmetric matrix.
-    template<typename t> const CImg<T>& symmetric_eigen(CImg<t>& val, CImg<t>& vec) const {
-      if (is_empty()) { val.assign(); vec.assign(); }
-      else {
-        if (width!=height || depth>1 || dim>1)
-          throw CImgInstanceException("CImg<%s>::eigen() : Instance object (%u,%u,%u,%u,%p) is empty.",
-                                      pixel_type(),width,height,depth,dim,data);
-
-        if (val.size()<width) val.assign(1,width);
-        if (vec.data && vec.size()<width*width) vec.assign(width,width);
-        if (width<3) return eigen(val,vec);
-        CImg<t> V(width,width);
-        SVD(vec,val,V,false);
-        cimg_forX(vec,x) {       // check for negative eigenvalues
-          t scal=0;
-          cimg_forY(vec,y) scal+=vec(x,y)*V(x,y);
-          if (scal<0) val[x]=-val[x];
-        }
-        CImg<int> permutations(width);  // sort eigenvalues in decreasing order
-        CImg<t> tmp(width);
-        val.sort(permutations,false);
-        cimg_forY(vec,k) {
-          cimg_forX(permutations,x) tmp(x) = vec(permutations(x),k);
-          std::memcpy(vec.ptr(0,k),tmp.data,sizeof(t)*width);
-        }
-      }
-      return *this;
-    }
-
-    //! Compute the eigenvalues and eigenvectors of a symmetric matrix.
-    CImgList<typename cimg::largest<T,float>::type> get_symmetric_eigen() const {
-      typedef typename cimg::largest<T,float>::type restype;
-      CImgList<restype> res(2);
-      symmetric_eigen(res[0],res[1]);
-      return res;
-    }
-
-    //! Compute the eigenvalues and eigenvectors of a symmetric matrix.
-    template<typename t> const CImg<T>& symmetric_eigen(CImgList<t>& eig) const {
-      if (eig.size<2) eig.assign(2);
-      symmetric_eigen(eig[0],eig[1]);
-      return *this;
-    }
-
-    template<typename t> CImg<T>& _quicksort(const int min,const int max,CImg<t>& permutations,const bool increasing) {
-      if (min<max) {
-        const int mid = (min+max)/2;
-        if (increasing) {
-          if ((*this)[min]>(*this)[mid]) {
-            cimg::swap((*this)[min],(*this)[mid]); cimg::swap(permutations[min],permutations[mid]); }
-          if ((*this)[mid]>(*this)[max]) {
-            cimg::swap((*this)[max],(*this)[mid]); cimg::swap(permutations[max],permutations[mid]); }
-          if ((*this)[min]>(*this)[mid]) {
-            cimg::swap((*this)[min],(*this)[mid]); cimg::swap(permutations[min],permutations[mid]); }
-        } else {
-          if ((*this)[min]<(*this)[mid]) {
-            cimg::swap((*this)[min],(*this)[mid]); cimg::swap(permutations[min],permutations[mid]); }
-          if ((*this)[mid]<(*this)[max]) {
-            cimg::swap((*this)[max],(*this)[mid]); cimg::swap(permutations[max],permutations[mid]); }
-          if ((*this)[min]<(*this)[mid]) {
-            cimg::swap((*this)[min],(*this)[mid]); cimg::swap(permutations[min],permutations[mid]); }
-        }
-        if (max-min>=3) {
-          const T pivot = (*this)[mid];
-          int i = min, j = max;
-          if (increasing) {
-            do {
-              while ((*this)[i]<pivot) i++;
-              while ((*this)[j]>pivot) j--;
-              if (i<=j) {
-                cimg::swap((*this)[i],(*this)[j]);
-                cimg::swap(permutations[i++],permutations[j--]);
-              }
-            } while (i<=j);
-          } else {
-            do {
-              while ((*this)[i]>pivot) i++;
-              while ((*this)[j]<pivot) j--;
-              if (i<=j) {
-                cimg::swap((*this)[i],(*this)[j]);
-                cimg::swap(permutations[i++],permutations[j--]);
-              }
-            } while (i<=j);
-          }
-          if (min<j) _quicksort(min,j,permutations,increasing);
-          if (i<max) _quicksort(i,max,permutations,increasing);
-        }
-      }
-      return *this;
-    }
-
-    //! Sort values of a vector and get permutations.
-    template<typename t>
-    CImg<T>& sort(CImg<t>& permutations,const bool increasing=true) {
-      if (is_empty()) permutations.assign();
-      else {
-        if (permutations.size()!=size()) permutations.assign(size());
-        cimg_foroff(permutations,off) permutations[off] = (t)off;
-        _quicksort(0,size()-1,permutations,increasing);
-      }
-      return *this;
-    }
-
-    //! Sort values of a vector.
-    CImg<T>& sort(const bool increasing=true) { CImg<T> foo; return sort(foo,increasing); }
-
-    //! Get a sorted version a of vector, with permutations.
-    template<typename t> CImg<T> get_sort(CImg<t>& permutations,const bool increasing=true) {
-      return (+*this).sort(permutations,increasing);
-    }
-
-    //! Get a sorted version of a vector.
-    CImg<T> get_sort(const bool increasing=true) {
-      return (+*this).sort(increasing);
-    }
-
-    //! Get a permutation of the pixels
-    template<typename t> CImg<T> get_permute(const CImg<t>& permutation) const {
-      if (permutation.size()!=size())
-        throw CImgArgumentException("CImg<%s>::get_permute() : Instance image (%u,%u,%u,%u,%p) and permutation (%u,%u,%u,%u,%p)"
-                                    "have different sizes.",pixel_type(),
-                                    width,height,depth,dim,data,
-                                    permutation.width,permutation.height,permutation.depth,permutation.dim,permutation.data);
-      CImg<T> res(width,height,depth,dim);
-      const t *p = permutation.ptr(permutation.size());
-      cimg_for(res,ptr,T) *ptr = (*this)[*(--p)];
-      return res;
-    }
-
-    //! In-place version of the previous function
-    template<typename t> CImg<T>& permute(const CImg<t>& permutation) {
-      return get_permute(permutation).swap(*this);
-    }
-
-    //@}
-    //-------------------
-    //
-    //! \name Display
-    //@{
-    //-------------------
-
-    //! Display an image into a CImgDisplay window.
-    const CImg& display(CImgDisplay& disp) const {
-      disp.display(*this);
-      return *this;
-    }
-
-    //! Display an image in a window with a title \p title, and wait a 'is_closed' or 'keyboard' event.\n
-    //! Parameters \p min_size and \p max_size set the minimum and maximum dimensions of the display window.
-    //! If negative, they corresponds to a percentage of the original image size.
-    const CImg& display(const char* title, const int min_size=128, const int max_size=1024) const {
-      if (is_empty())
-        throw CImgInstanceException("CImg<%s>::display() : Instance image (%u,%u,%u,%u,%p) is empty.",
-                                    pixel_type(),width,height,depth,dim,data);
-      CImgDisplay *disp;
-      unsigned int w = width+(depth>1?depth:0), h = height+(depth>1?depth:0), XYZ[3];
-      print(title);
-      const unsigned int dmin = cimg::min(w,h), minsiz = min_size>=0?min_size:(-min_size)*dmin/100;
-      if (dmin<minsiz) { w=w*minsiz/dmin; w+=(w==0); h=h*minsiz/dmin; h+=(h==0); }
-      const unsigned int dmax = cimg::max(w,h), maxsiz = max_size>=0?max_size:(-max_size)*dmax/100;
-      if (dmax>maxsiz) { w=w*maxsiz/dmax; w+=(w==0); h=h*maxsiz/dmax; h+=(h==0); }
-      disp = new CImgDisplay(w,h,title,3,3);
-      XYZ[0] = width/2; XYZ[1] = height/2; XYZ[2] = depth/2;
-      while (!disp->is_closed && !disp->key) feature_selection(0,1,*disp,XYZ);
-      delete disp;
-      return *this;
-    }
-
-    //! Display an image in a window, with a default title. See also \see display() for details on parameters.
-    const CImg& display(const int min_size=128, const int max_size=1024) const {
-      char title[256]={0};
-      std::sprintf(title,"CImg<%s>",pixel_type());
-      return display(title,min_size,max_size);
-    }
-
-    //! High-level interface to select features from images
-    const CImg& feature_selection(int* const selection, const int feature_type, CImgDisplay &disp,
-                                  unsigned int *const XYZ=0,const unsigned char *const color=0) const {
-      if (is_empty())
-        throw CImgInstanceException("CImg<%s>::feature_selection() : Instance image (%u,%u,%u,%u,%p) is empty.",
-                                    pixel_type(),width,height,depth,dim,data);
-
-      const unsigned int
-        old_events = disp.events,
-        old_normalization = disp.normalization,
-        hatch = 0x55555555;
-
-      bool old_is_resized = disp.is_resized;
-      disp.events = 3;
-      disp.normalization = 0;
-      disp.show().key = 0;
-
-      unsigned char fgcolor[3] = { 255,255,105 }, bgcolor[3] = { 0,0,0 };
-      if (color) std::memcpy(fgcolor,color,sizeof(unsigned char)*cimg::min(3,dimv()));
-
-      int area = 0, clicked_area = 0, phase = 0,
-        X0 = (int)((XYZ?XYZ[0]:width/2)%width), Y0 = (int)((XYZ?XYZ[1]:height/2)%height), Z0 = (int)((XYZ?XYZ[2]:depth/2)%depth),
-        X1 =-1, Y1 = -1, Z1 = -1,
-        X = -1, Y = -1, Z = -1,
-        oX = X, oY = Y, oZ = Z;
-      unsigned int old_button = 0, key = 0;
-
-      bool feature_selected = false, text_down = false;
-      CImg<unsigned char> visu, visu0;
-      char text[1024] = { 0 };
-
-      while (!key && !disp.is_closed && !feature_selected) {
-
-        // Handle mouse motion and selection
-        oX = X; oY = Y; oZ = Z;
-        int mx = disp.mouse_x, my = disp.mouse_y;
-        const int mX = mx*(width+(depth>1?depth:0))/disp.width, mY = my*(height+(depth>1?depth:0))/disp.height;
-
-        area = 0;
-        if (mX<dimx() && mY<dimy())  { area = 1; X = mX; Y = mY; Z = phase?Z1:Z0; }
-        if (mX<dimx() && mY>=dimy()) { area = 2; X = mX; Z = mY-height; Y = phase?Y1:Y0; }
-        if (mX>=dimx() && mY<dimy()) { area = 3; Y = mY; Z = mX-width; X = phase?X1:X0; }
-
-	key = disp.key;
-        if (key && key!=cimg::keyCTRLLEFT) {
-          if (disp.is_pressed(cimg::keyCTRLLEFT)) {
-            switch (key) {
-            case cimg::keyARROWLEFT:
-            case cimg::keyARROWDOWN: disp.wheel--; break;
-            case cimg::keyARROWRIGHT:
-            case cimg::keyARROWUP: disp.wheel++; break;
-            case cimg::keyD: if (disp.is_fullscreen) disp.toggle_fullscreen(); disp.resize(-200,-200); disp.is_resized = true; break;
-            case cimg::keyC: if (disp.is_fullscreen) disp.toggle_fullscreen(); disp.resize(-50,-50); disp.is_resized = true; break;
-            case cimg::keyF:
-              disp.resize(disp.screen_dimx(),disp.screen_dimy()).toggle_fullscreen();
-              disp.is_resized = true;
-              break;
-            case cimg::keyS: {
-              static unsigned int snap_number = 0;
-              char filename[32] = {0};
-              std::FILE *file;
-              do {
-                std::sprintf(filename,"CImg_%.4u.bmp",snap_number++);
-                if ((file=std::fopen(filename,"r"))!=0) std::fclose(file);
-              } while (file);
-              if (!visu0.is_empty()) visu0.save(filename);
-            } break;
-	    default: break;
-            }
-	    key = disp.key = 0;
-          }
-        } else key = 0;
-
-        if (!area) mx = my = X = Y = Z = -1;
-        else {
-          if (disp.button&1 && phase<2) { X1 = X; Y1 = Y; Z1 = Z; }
-          if (!(disp.button&1) && phase>=2) {
-            switch (clicked_area) {
-            case 1: Z1 = Z; break;
-            case 2: Y1 = Y; break;
-            case 3: X1 = X; break;
-            }
-          }
-          if (disp.button&2) { if (phase) { X1 = X; Y1 = Y; Z1 = Z; } else { X0 = X; Y0 = Y; Z0 = Z; } }
-          if (disp.button&4) { oX = X = X0; oY = Y = Y0; oZ = Z = Z0; phase = 0; visu.assign(); }
-          if (disp.wheel) {
-            switch (area) {
-            case 1: if (phase) Z = (Z1+=disp.wheel); else Z = (Z0+=disp.wheel); break;
-            case 2: if (phase) Y = (Y1+=disp.wheel); else Y = (Y0+=disp.wheel); break;
-            case 3: if (phase) X = (X1+=disp.wheel); else X = (X0+=disp.wheel); break;
-            default: break;
-            }
-            disp.wheel = 0;
-          }
-          if ((disp.button&1)!=old_button) {
-            switch (phase++) {
-            case 0: X0 = X1 = X; Y0 = Y1 = Y; Z0 = Z1 = Z; clicked_area = area; break;
-            case 1: X1 = X; Y1 = Y; Z1 = Z; break;
-            default: break;
-            }
-            old_button = disp.button&1;
-          }
-          if (depth>1 && (X!=oX || Y!=oY || Z!=oZ)) visu0.assign();
-        }
-
-        if (phase) {
-          if (!feature_type) feature_selected = phase?true:false;
-          else {
-            if (depth>1) feature_selected = (phase==3)?true:false;
-            else feature_selected = (phase==2)?true:false;
-          }
-        }
-
-        if (X0<0) X0 = 0; if (X0>=(int)width) X0 = (int)width-1; if (Y0<0) Y0 = 0; if (Y0>=(int)height) Y0 = (int)height-1;
-        if (Z0<0) Z0 = 0; if (Z0>=(int)depth) Z0 = (int)depth-1;
-        if (X1<1) X1 = 0; if (X1>=(int)width) X1 = (int)width-1; if (Y1<0) Y1 = 0; if (Y1>=(int)height) Y1 = (int)height-1;
-        if (Z1<0) Z1 = 0; if (Z1>=(int)depth) Z1 = (int)depth-1;
-
-        // Draw visualization image on the display
-        if (oX!=X || oY!=Y || oZ!=Z || visu0.is_empty()) {
-          if (visu0.is_empty()) {
-            CImg<T> tmp;
-            if (depth==1) tmp = get_resize(disp.width,disp.height,1,cimg::min(3,dimv()));
-            else tmp = (!phase?get_projections2d(X0,Y0,Z0):get_projections2d(X1,Y1,Z1)).get_resize(disp.width,disp.height,1,cimg::min(3,dimv()));
-            if (old_normalization) {
-              if (old_normalization<3 || cimg::type<T>::is_float()) {
-                if (sizeof(T)>1) visu0.assign(tmp.normalize(0,255));
-                else visu0.assign(tmp).normalize(0,255);
-              } else {
-                if (cimg::type<T>::id()!=cimg::type<unsigned char>::id()) {
-                  const float m = cimg::type<T>::min(), M = cimg::type<T>::max();
-                  visu0.assign((CImg<float>(tmp)-=m)*=255.0f/(M-m));
-                } else visu0.assign(tmp);
-              }
-            } else visu0.assign(tmp);
-          }
-          visu = visu0;
-
-          const int d=(depth>1)?depth:0;
-          if (phase) switch (feature_type) {
-          case 1: {
-            const int
-              x0=(int)((X0+0.5f)*disp.width/(width+d)), y0=(int)((Y0+0.5f)*disp.height/(height+d)),
-              x1=(int)((X1+0.5f)*disp.width/(width+d)), y1=(int)((Y1+0.5f)*disp.height/(height+d));
-            visu.draw_arrow(x0,y0,x1,y1,fgcolor,30.0f,5.0f,hatch);
-            if (d) {
-              const int zx0=(int)((width+Z0+0.5f)*disp.width/(width+d)), zx1=(int)((width+Z1+0.5f)*disp.width/(width+d)),
-                zy0=(int)((height+Z0+0.5f)*disp.height/(height+d)), zy1=(int)((height+Z1+0.5f)*disp.height/(height+d));
-              visu.draw_arrow(zx0,y0,zx1,y1,fgcolor,30.0f,5.0f,hatch).draw_arrow(x0,zy0,x1,zy1,fgcolor,30.0f,5.0f,hatch);
-            }
-          } break;
-          case 2: {
-            const int
-              x0=(X0<X1?X0:X1)*disp.width/(width+d),
-              y0=(Y0<Y1?Y0:Y1)*disp.height/(height+d),
-              x1=((X0<X1?X1:X0)+1)*disp.width/(width+d)-1,
-              y1=((Y0<Y1?Y1:Y0)+1)*disp.height/(height+d)-1;
-            visu.draw_rectangle(x0,y0,x1,y1,fgcolor,0.2f).draw_line(x0,y0,x1,y0,fgcolor,hatch).
-              draw_line(x1,y0,x1,y1,fgcolor,hatch).draw_line(x1,y1,x0,y1,fgcolor,hatch).draw_line(x0,y1,x0,y0,fgcolor,hatch);
-            if (d) {
-              const int
-                zx0=(int)((width+(Z0<Z1?Z0:Z1))*disp.width/(width+d)),
-                zy0=(int)((height+(Z0<Z1?Z0:Z1))*disp.height/(height+d)),
-                zx1=(int)((width+(Z0<Z1?Z1:Z0)+1)*disp.width/(width+d))-1,
-                zy1=(int)((height+(Z0<Z1?Z1:Z0)+1)*disp.height/(height+d))-1;
-              visu.draw_rectangle(zx0,y0,zx1,y1,fgcolor,0.2f).draw_line(zx0,y0,zx1,y0,fgcolor,hatch).
-                draw_line(zx1,y0,zx1,y1,fgcolor,hatch).draw_line(zx1,y1,zx0,y1,fgcolor,hatch).draw_line(zx0,y1,zx0,y0,fgcolor,hatch);
-              visu.draw_rectangle(x0,zy0,x1,zy1,fgcolor,0.2f).draw_line(x0,zy0,x1,zy0,fgcolor,hatch).
-                draw_line(x1,zy0,x1,zy1,fgcolor,hatch).draw_line(x1,zy1,x0,zy1,fgcolor,hatch).draw_line(x0,zy1,x0,zy0,fgcolor,hatch);
-            }
-          } break;
-          case 3: {
-            const int
-              x0=X0*disp.width/(width+d),
-              y0=Y0*disp.height/(height+d),
-              x1=X1*disp.width/(width+d)-1,
-              y1=Y1*disp.height/(height+d)-1;
-            visu.draw_ellipse(x0,y0,(float)(x1-x0),(float)(y1-y0),1.0f,0.0f,fgcolor,0L,0.2f).
-              draw_ellipse(x0,y0,(float)(x1-x0),(float)(y1-y0),1.0f,0.0f,fgcolor,hatch);
-            if (d) {
-              const int
-                zx0=(int)((width+Z0)*disp.width/(width+d)),
-                zy0=(int)((height+Z0)*disp.height/(height+d)),
-                zx1=(int)((width+Z1+1)*disp.width/(width+d))-1,
-                zy1=(int)((height+Z1+1)*disp.height/(height+d))-1;
-              visu.draw_ellipse(zx0,y0,(float)(zx1-zx0),(float)(y1-y0),1.0f,0.0f,fgcolor,0L,0.2f).
-                draw_ellipse(zx0,y0,(float)(zx1-zx0),(float)(y1-y0),1.0f,0.0f,fgcolor,hatch).
-                draw_ellipse(x0,zy0,(float)(x1-x0),(float)(zy1-zy0),1.0f,0.0f,fgcolor,0L,0.2f).
-                draw_ellipse(x0,zy0,(float)(x1-x0),(float)(zy1-zy0),1.0f,0.0f,fgcolor,hatch);
-            }
-          } break;
-          }
-
-          if (my<12) text_down = true;
-          if (my>=visu.dimy()-11) text_down = false;
-          if (!feature_type || !phase) {
-            if (X>=0 && Y>=0 && Z>=0 && X<(int)width && Y<(int)height && Z<(int)depth) {
-              if (depth>1) std::sprintf(text,"Coords (%d,%d,%d)={ ",X,Y,Z); else std::sprintf(text,"Coords (%d,%d)={ ",X,Y);
-              char *ctext = text + cimg::strlen(text), *const ltext = text+512;
-              for (unsigned int k=0; k<dim && ctext<ltext; k++) {
-                std::sprintf(ctext,"%g ",(double)(*this)(X,Y,Z,k));
-                ctext = text + cimg::strlen(text);
-              }
-              std::sprintf(text+cimg::strlen(text),"}");
-            }
-          } else switch (feature_type) {
-          case 1: {
-            const double dX=(double)(X0-X1), dY=(double)(Y0-Y1), dZ=(double)(Z0-Z1), norm = std::sqrt(dX*dX+dY*dY+dZ*dZ);
-            if (depth>1) std::sprintf(text,"Vect (%d,%d,%d)-(%d,%d,%d), norm=%g",X0,Y0,Z0,X1,Y1,Z1,norm);
-            else std::sprintf(text,"Vect (%d,%d)-(%d,%d), norm=%g",X0,Y0,X1,Y1,norm);
-          } break;
-          case 2:
-            if (depth>1) std::sprintf(text,"Box (%d,%d,%d)-(%d,%d,%d), Size=(%d,%d,%d)",
-                                      X0<X1?X0:X1,Y0<Y1?Y0:Y1,Z0<Z1?Z0:Z1,
-                                      X0<X1?X1:X0,Y0<Y1?Y1:Y0,Z0<Z1?Z1:Z0,
-                                      1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1),1+cimg::abs(Z0-Z1));
-            else  std::sprintf(text,"Box (%d,%d)-(%d,%d), Size=(%d,%d)",
-                               X0<X1?X0:X1,Y0<Y1?Y0:Y1,X0<X1?X1:X0,Y0<Y1?Y1:Y0,1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1));
-            break;
-          default:
-            if (depth>1) std::sprintf(text,"Ellipse (%d,%d,%d)-(%d,%d,%d), Radii=(%d,%d,%d)",
-                                      X0,Y0,Z0,X1,Y1,Z1,1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1),1+cimg::abs(Z0-Z1));
-            else  std::sprintf(text,"Ellipse (%d,%d)-(%d,%d), Radii=(%d,%d)",
-                               X0,Y0,X1,Y1,1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1));
-
-            break;
-          }
-          if (phase || (mx>=0 && my>=0)) visu.draw_text(text,0,text_down?visu.dimy()-11:0,fgcolor,bgcolor,11,0.7f);
-          disp.display(visu).wait(25);
-        } else disp.wait();
-
-        if (disp.is_resized) { disp.resize(false); old_is_resized = true; disp.is_resized = false; visu0.assign(); }
-      }
-
-      // Return result
-      if (XYZ) { XYZ[0] = (unsigned int)X0; XYZ[1] = (unsigned int)Y0; XYZ[2] = (unsigned int)Z0; }
-      if (feature_selected) {
-        if (feature_type==2) {
-          if (X0>X1) cimg::swap(X0,X1);
-          if (Y0>Y1) cimg::swap(Y0,Y1);
-          if (Z0>Z1) cimg::swap(Z0,Z1);
-        }
-        if (selection) {
-          if (X1<0 || Y1<0 || Z1<0) X0=Y0=Z0=X1=Y1=Z1=-1;
-          switch(feature_type) {
-          case 1:
-          case 2:  selection[3] = X1; selection[4] = Y1; selection[5] = Z1;
-          default: selection[0] = X0; selection[1] = Y0; selection[2] = Z0;
-          }
-        }
-      } else if (selection) selection[0]=selection[1]=selection[2]=selection[3]=selection[4]=selection[5]=-1;
-      disp.button = 0;
-      disp.events = old_events;
-      disp.normalization = old_normalization;
-      disp.is_resized = old_is_resized;
-      disp.key = key;
-      return *this;
-    }
-
-    //! High-level interface to select features in images
-    const CImg& feature_selection(int *const selection, const int feature_type,
-                                  unsigned int *const XYZ=0,const unsigned char *const color=0) const {
-      unsigned int w = width + (depth>1?depth:0), h = height + (depth>1?depth:0);
-      const unsigned int dmin = cimg::min(w,h), minsiz = 256;
-      if (dmin<minsiz) { w=w*minsiz/dmin; h=h*minsiz/dmin; }
-      const unsigned int dmax = cimg::max(w,h), maxsiz = 1024;
-      if (dmax>maxsiz) { w=w*maxsiz/dmax; h=h*maxsiz/dmax; }
-      CImgDisplay disp(w,h," ",1,3);
-      return feature_selection(selection,feature_type,disp,XYZ,color);
-    }
-
-    //! High-level interface for displaying a 3d object
-    template<typename tp, typename tf, typename to>
-    const CImg& display_object3d(const CImg<tp>& points,const CImgList<tf>& primitives,
-                                 const CImgList<T>& colors, const CImgList<to>& opacities, CImgDisplay& disp,
-                                 const bool centering=true,
-                                 const int render_static=4, const int render_motion=1,
-                                 const bool double_sided=false,
-                                 const float focale=500.0f, const float ambiant_light=0.05f,
-                                 const bool display_axes=true, float *const pose_matrix=0) const {
-
-      // Check input arguments
-      if (points.is_empty() || primitives.is_empty() || opacities.is_empty())
-        throw CImgArgumentException("CImg<%s>::display_object3d() : Given points (%u), primitives (%u) or opacities (%u) are empty.",
-                                    pixel_type(),points.size()/3,primitives.size,opacities.size);
-      if (is_empty())
-        return CImg<T>(disp.width,disp.height,1,colors[0].size(),0).
-          display_object3d(points,primitives,colors,opacities,disp,centering,
-                           render_static,render_motion,double_sided,focale,ambiant_light);
-      if (points.height<3)
-        return display_object3d(points.get_resize(-100,3,1,1,0),primitives,colors,opacities,disp,
-                                centering,render_static,render_motion,double_sided,focale,ambiant_light);
-
-      // Init 3D objects and compute object statistics
-      CImg<float> pose, rot_mat,
-        centered_points = centering?CImg<float>(points.width,3):CImg<float>(),
-        rotated_points(points.width,3),
-        bbox_points, rotated_bbox_points,
-        axes_points, rotated_axes_points;
-      CImgList<to> bbox_opacities, axes_opacities;
-      CImgList<T> bbox_colors, axes_colors;
-      CImgList<tf> bbox_primitives, axes_primitives;
-      float dx=0, dy=0, dz=0, ratio=1;
-      const T valmax = cimg::type<T>::max();
-
-      const CImgStats
-        sx(points.get_shared_line(0),false),
-        sy(points.get_shared_line(1),false),
-        sz(points.get_shared_line(2),false);
-      const float
-        xm = (float)sx.min, xM = (float)sx.max,
-        ym = (float)sy.min, yM = (float)sy.max,
-	zm = (float)sz.min, zM = (float)sz.max,
-        delta = cimg::max(xM-xm,yM-ym,zM-zm);
-
-      if (display_axes) {
-        axes_points.assign(7,3);
-        rotated_axes_points.assign(7,3);
-        axes_opacities.assign(3,1,1,1,1,1.0f);
-        axes_colors.assign(3,dim,1,1,1,valmax);
-        axes_points(0,0) = 0; axes_points(0,1) = 0; axes_points(0,2) = 0;
-        axes_points(1,0) = 20; axes_points(1,1) = 0; axes_points(1,2) = 0;
-        axes_points(2,0) = 0; axes_points(2,1) = 20; axes_points(2,2) = 0;
-        axes_points(3,0) = 0; axes_points(3,1) = 0; axes_points(3,2) = 20;
-        axes_points(4,0) = 22; axes_points(4,1) = -6; axes_points(4,2) = 0;
-        axes_points(5,0) = -6; axes_points(5,1) = 22; axes_points(5,2) = 0;
-        axes_points(6,0) = -6; axes_points(6,1) = -6; axes_points(6,2) = 22;
-        axes_primitives.insert(CImg<tf>::vector(0,1));
-        axes_primitives.insert(CImg<tf>::vector(0,2));
-        axes_primitives.insert(CImg<tf>::vector(0,3));
-      }
-
-      // Begin user interaction loop
-      CImg<T> visu0(*this), visu;
-      bool init = true, clicked = false, redraw = true;
-      unsigned int key = 0;
-      int x0 = 0, y0 = 0, x1 = 0, y1 = 0;
-      const unsigned int old_events = disp.events;
-      disp.show().button = disp.key = 0;
-      disp.events = 3;
-
-      while (!disp.is_closed && !key) {
-
-        // Init object position and scale if necessary
-        if (init) {
-          ratio = delta>0?(2.0f*cimg::min(disp.width,disp.height)/(3.0f*delta)):0;
-          dx = 0.5f*(xM+xm); dy = 0.5f*(yM+ym); dz = 0.5f*(zM+zm);
-          if (centering) {
-            cimg_forX(centered_points,l) {
-              centered_points(l,0) = (float)((points(l,0)-dx)*ratio);
-              centered_points(l,1) = (float)((points(l,1)-dy)*ratio);
-              centered_points(l,2) = (float)((points(l,2)-dz)*ratio);
-            }
-          }
-
-          if (render_static<0 || render_motion<0) {
-            bbox_colors.assign(12,dim,1,1,1,valmax);
-            bbox_primitives.assign(12,1,2);
-            bbox_points.assign(8,3);
-            rotated_bbox_points.assign(8,3);
-            bbox_points(0,0) = xm; bbox_points(0,1) = ym; bbox_points(0,2) = zm;
-            bbox_points(1,0) = xM; bbox_points(1,1) = ym; bbox_points(1,2) = zm;
-            bbox_points(2,0) = xM; bbox_points(2,1) = yM; bbox_points(2,2) = zm;
-            bbox_points(3,0) = xm; bbox_points(3,1) = yM; bbox_points(3,2) = zm;
-            bbox_points(4,0) = xm; bbox_points(4,1) = ym; bbox_points(4,2) = zM;
-            bbox_points(5,0) = xM; bbox_points(5,1) = ym; bbox_points(5,2) = zM;
-            bbox_points(6,0) = xM; bbox_points(6,1) = yM; bbox_points(6,2) = zM;
-            bbox_points(7,0) = xm; bbox_points(7,1) = yM; bbox_points(7,2) = zM;
-            bbox_primitives[0].fill(0,1); bbox_primitives[1].fill(1,2); bbox_primitives[2].fill(2,3);  bbox_primitives[3].fill(3,0);
-            bbox_primitives[4].fill(4,5); bbox_primitives[5].fill(5,6); bbox_primitives[6].fill(6,7);  bbox_primitives[7].fill(7,4);
-            bbox_primitives[8].fill(0,4); bbox_primitives[9].fill(1,5); bbox_primitives[10].fill(2,6); bbox_primitives[11].fill(3,7);
-            bbox_opacities.assign(bbox_primitives.size,1,1,1,1,1.0f);
-          }
-
-          if (pose_matrix) pose = CImg<float>(pose_matrix,4,4,1,1,false); else pose = CImg<float>::identity_matrix(4);
-          init = false;
-          redraw = true;
-        }
-
-        // Rotate and Draw 3D object
-        if (redraw) {
-          const float
-            r00 = pose(0,0), r10 = pose(1,0), r20 = pose(2,0), r30 = pose(3,0),
-            r01 = pose(0,1), r11 = pose(1,1), r21 = pose(2,1), r31 = pose(3,1),
-            r02 = pose(0,2), r12 = pose(1,2), r22 = pose(2,2), r32 = pose(3,2);
-          if ((clicked && render_motion>=0) || (!clicked && render_static>=0)) {
-            if (centering) cimg_forX(centered_points,l) {
-              const float x = centered_points(l,0), y = centered_points(l,1), z = centered_points(l,2);
-              rotated_points(l,0) = r00*x + r10*y + r20*z + r30;
-              rotated_points(l,1) = r01*x + r11*y + r21*z + r31;
-              rotated_points(l,2) = r02*x + r12*y + r22*z + r32;
-            } else cimg_forX(points,l) {
-              const float x = (float)points(l,0), y = (float)points(l,1), z = (float)points(l,2);
-              rotated_points(l,0) = r00*x + r10*y + r20*z + r30;
-              rotated_points(l,1) = r01*x + r11*y + r21*z + r31;
-              rotated_points(l,2) = r02*x + r12*y + r22*z + r32;
-            }
-          } else {
-            if (!centering) cimg_forX(bbox_points,l) {
-              const float x = bbox_points(l,0), y = bbox_points(l,1), z = bbox_points(l,2);
-              rotated_bbox_points(l,0) = r00*x + r10*y + r20*z + r30;
-              rotated_bbox_points(l,1) = r01*x + r11*y + r21*z + r31;
-              rotated_bbox_points(l,2) = r02*x + r12*y + r22*z + r32;
-            } else cimg_forX(bbox_points,l) {
-              const float x = (bbox_points(l,0)-dx)*ratio, y = (bbox_points(l,1)-dy)*ratio, z = (bbox_points(l,2)-dz)*ratio;
-              rotated_bbox_points(l,0) = r00*x + r10*y + r20*z + r30;
-              rotated_bbox_points(l,1) = r01*x + r11*y + r21*z + r31;
-              rotated_bbox_points(l,2) = r02*x + r12*y + r22*z + r32;
-            }
-          }
-
-          // Draw object
-          visu = visu0;
-          if ((clicked && render_motion<0) || (!clicked && render_static<0))
-            visu.draw_object3d(visu.width/2.0f, visu.height/2.0f, 0,
-                               rotated_bbox_points,bbox_primitives,bbox_colors,bbox_opacities,1,
-                               false,focale,visu.dimx()/2.0f,visu.dimy()/2.0f,-5000.0f,0.2f);
-          else visu.draw_object3d(visu.width/2.0f, visu.height/2.0f, 0,
-                                  rotated_points,primitives,colors,opacities,clicked?render_motion:render_static,
-                                  double_sided,focale,visu.dimx()/2.0f,visu.dimy()/2.0f,-5000.0f,ambiant_light);
-
-          // Draw axes
-          if (display_axes) {
-            const float Xaxes = 25.0f, Yaxes = visu.height-35.0f;
-            cimg_forX(axes_points,l) {
-              const float x = axes_points(l,0), y = axes_points(l,1), z = axes_points(l,2);
-              rotated_axes_points(l,0) = r00*x + r10*y + r20*z;
-              rotated_axes_points(l,1) = r01*x + r11*y + r21*z;
-              rotated_axes_points(l,2) = r02*x + r12*y + r22*z;
-            }
-            axes_opacities(0,0) = (rotated_axes_points(1,2)>0)?0.5f:1.0f;
-            axes_opacities(1,0) = (rotated_axes_points(2,2)>0)?0.5f:1.0f;
-            axes_opacities(2,0) = (rotated_axes_points(3,2)>0)?0.5f:1.0f;
-            visu.draw_object3d(Xaxes, Yaxes, 0, rotated_axes_points,axes_primitives,axes_colors,axes_opacities,1,false,focale,0,0,0,0).
-              draw_text("X",(int)(Xaxes+rotated_axes_points(4,0)), (int)(Yaxes+rotated_axes_points(4,1)), axes_colors[0].ptr(), 0, 11, axes_opacities(0,0)).
-              draw_text("Y",(int)(Xaxes+rotated_axes_points(5,0)), (int)(Yaxes+rotated_axes_points(5,1)), axes_colors[1].ptr(), 0, 11, axes_opacities(1,0)).
-              draw_text("Z",(int)(Xaxes+rotated_axes_points(6,0)), (int)(Yaxes+rotated_axes_points(6,1)), axes_colors[2].ptr(), 0, 11, axes_opacities(2,0));
-          }
-
-          visu.display(disp);
-          if (!clicked || render_motion==render_static) redraw = false;
-        }
-
-        // Handle user interaction
-        if ((disp.button || disp.wheel) && disp.mouse_x>=0 && disp.mouse_y>=0) {
-          redraw = true;
-          if (!clicked) { x0 = x1 = disp.mouse_x; y0 = y1 = disp.mouse_y; if (!disp.wheel) clicked = true; }
-          else { x1 = disp.mouse_x; y1 = disp.mouse_y; }
-          if (disp.button&1) {
-            const float
-              R = 0.4f*cimg::min(disp.width,disp.height),
-              R2 = R*R,
-              u0 = (float)(x0-disp.dimx()/2),
-              v0 = (float)(y0-disp.dimy()/2),
-              u1 = (float)(x1-disp.dimx()/2),
-              v1 = (float)(y1-disp.dimy()/2),
-              n0 = (float)std::sqrt(u0*u0+v0*v0),
-              n1 = (float)std::sqrt(u1*u1+v1*v1),
-              nu0 = n0>R?(u0*R/n0):u0,
-              nv0 = n0>R?(v0*R/n0):v0,
-              nw0 = (float)std::sqrt(cimg::max(0.0f,R2-nu0*nu0-nv0*nv0)),
-              nu1 = n1>R?(u1*R/n1):u1,
-              nv1 = n1>R?(v1*R/n1):v1,
-              nw1 = (float)std::sqrt(cimg::max(0.0f,R2-nu1*nu1-nv1*nv1)),
-              u = nv0*nw1-nw0*nv1,
-              v = nw0*nu1-nu0*nw1,
-              w = nv0*nu1-nu0*nv1,
-              n = (float)std::sqrt(u*u+v*v+w*w),
-              alpha = (float)std::asin(n/R2);
-            rot_mat = CImg<float>::rotation_matrix(u,v,w,alpha);
-            rot_mat *= pose.get_crop(0,0,2,2);
-            pose.draw_image(rot_mat,0,0);
-            x0=x1; y0=y1;
-          }
-          if (disp.button&2) { pose(3,2)+=(y1-y0); x0=x1; y0=y1; }
-          if (disp.wheel) { pose(3,2)-=15*disp.wheel; disp.wheel=0; }
-          if (disp.button&4) { pose(3,0)+=(x1-x0); pose(3,1)+=(y1-y0); x0=x1; y0=y1; }
-          if ((disp.button&1) && (disp.button&2)) { init = true; disp.button = 0; x0 = x1; y0 = y1; pose = CImg<float>::identity_matrix(4); }
-        } else if (clicked) { x0=x1; y0=y1; clicked = false; redraw = true; }
-
-        key = disp.key;
-        if (key && key!=cimg::keyCTRLLEFT) {
-          if (disp.is_pressed(cimg::keyCTRLLEFT)) {
-            switch (key) {
-            case cimg::keyD: if (disp.is_fullscreen) disp.toggle_fullscreen(); disp.resize(-200,-200); disp.is_resized = true; break;
-            case cimg::keyC: if (disp.is_fullscreen) disp.toggle_fullscreen(); disp.resize(-50,-50); disp.is_resized = true; break;
-            case cimg::keyF: disp.resize(disp.screen_dimx(),disp.screen_dimy()).toggle_fullscreen().is_resized = true; break;
-            case cimg::keyS: { // Save snapshot
-              static unsigned int snap_number = 0;
-              char filename[32] = {0};
-              std::FILE *file;
-              do {
-                std::sprintf(filename,"CImg_%.4u.bmp",snap_number++);
-                if ((file=std::fopen(filename,"r"))!=0) std::fclose(file);
-              } while (file);
-              visu.save(filename);
-            } break;
-            }
-            disp.key = key = 0;
-          }
-        } else key = 0;
-        if (disp.is_resized) { disp.resize(false); visu0 = get_resize(disp,1); redraw = true; }
-      }
-      if (pose_matrix) std::memcpy(pose_matrix,pose.data,16*sizeof(float));
-      disp.events = old_events;
-      disp.button = 0;
-      return *this;
-    }
-
-    //! High-level interface for displaying a 3d object
-    template<typename tp, typename tf, typename to>
-    const CImg& display_object3d(const CImgList<tp>& points,const CImgList<tf>& primitives,
-                                 const CImgList<T>& colors, const CImgList<to>& opacities, CImgDisplay &disp,
-                                 const bool centering=true,
-                                 const int render_static=4, const int render_motion=1,
-                                 const bool double_sided=false,
-                                 const float focale=500.0f, const float ambiant_light=0.05f,
-                                 const bool display_axes=true, float *const pose_matrix=0) const {
-      CImg<tp> npoints(points.size,3,1,1,0);
-      tp *ptrX = npoints.ptr(), *ptrY = npoints.ptr(0,1), *ptrZ = npoints.ptr(0,2);
-      cimg_forX(npoints,l) {
-        const CImg<tp>& point = points[l];
-        const unsigned int siz = point.size();
-        if (!siz)
-          throw CImgArgumentException("CImg<%s>::display_object3d() : Given points (size=%u) contains a null element at "
-                                      "position %u.",pixel_type(),points.size,l);
-        *(ptrZ++) = (siz>2)?point(2):0;
-        *(ptrY++) = (siz>1)?point(1):0;
-        *(ptrX++) = point(0);
-      }
-      return display_object3d(npoints,primitives,colors,opacities,disp,centering,
-                              render_static,render_motion,double_sided,focale,ambiant_light,display_axes,pose_matrix);
-    }
-
-    //! High-level interface for displaying a 3d object
-    template<typename tp, typename tf, typename to>
-    const CImg& display_object3d(const CImg<tp>& points, const CImgList<tf>& primitives,
-                                 const CImgList<T>& colors, const CImg<to>& opacities, CImgDisplay& disp,
-                                 const bool centering=true,
-                                 const int render_static=4, const int render_motion=1,
-                                 const bool double_sided=false,
-                                 const float focale=500.0f, const float ambiant_light=0.05f,
-                                 const bool display_axes=true, float *const pose_matrix=0) const {
-      CImgList<to> nopacities(opacities.size(),1);
-      cimglist_for(nopacities,l) nopacities(l,0) = opacities(l);
-      return display_object3d(points,primitives,colors,nopacities,disp,centering,
-                              render_static,render_motion,double_sided,focale,ambiant_light,display_axes,pose_matrix);
-
-    }
-
-    //! High-level interface for displaying a 3d object
-    template<typename tp, typename tf, typename to>
-    const CImg& display_object3d(const CImgList<tp>& points,const CImgList<tf>& primitives,
-                                 const CImgList<T>& colors, const CImg<to>& opacities, CImgDisplay& disp,
-                                 const bool centering=true,
-                                 const int render_static=4, const int render_motion=1,
-                                 const bool double_sided=false,
-                                 const float focale=500.0f, const float ambiant_light=0.05f,
-                                 const bool display_axes=true, float *const pose_matrix=0) const {
-      CImgList<to> nopacities(opacities.size(),1);
-      cimglist_for(nopacities,l) nopacities(l,0) = opacities(l);
-      if (points.is_empty()) throw CImgArgumentException("CImg<%s>::display_object3d() : Given points are empty.",
-                                                         pixel_type());
-      CImg<tp> npoints(points.size,3,1,1,0);
-      tp *ptrX = npoints.ptr(), *ptrY = npoints.ptr(0,1), *ptrZ = npoints.ptr(0,2);
-      { cimg_forX(npoints,l) {
-        const CImg<tp>& point = points[l];
-        const unsigned int siz = point.size();
-        if (!siz)
-          throw CImgArgumentException("CImg<%s>::display_object3d() : Given points (size=%u) contains a null element at "
-                                      "position %u.",pixel_type(),points.size,l);
-        *(ptrZ++) = (siz>2)?point(2):0;
-        *(ptrY++) = (siz>1)?point(1):0;
-        *(ptrX++) = point(0);
-      }
-      }
-      return display_object3d(npoints,primitives,colors,nopacities,disp,centering,
-                              render_static,render_motion,double_sided,focale,ambiant_light,display_axes,pose_matrix);
-    }
-
-    //! High-level interface for displaying a 3d object
-    template<typename tp, typename tf, typename to>
-    const CImg& display_object3d(const tp& points, const CImgList<tf>& primitives,
-                                 const CImgList<T>& colors, const to& opacities,
-                                 const bool centering=true,
-                                 const int render_static=4, const int render_motion=1,
-                                 const bool double_sided=false,
-                                 const float focale=500.0f, const float ambiant_light=0.05f,
-                                 const bool display_axes=true, float *const pose_matrix=0) const {
-      CImgDisplay disp(width,height," ",0);
-      return display_object3d(points,primitives,colors,opacities,disp,centering,
-                              render_static,render_motion,double_sided,focale,ambiant_light,display_axes,pose_matrix);
-    }
-
-    //! High-level interface for displaying a 3d object
-    template<typename tp, typename tf>
-    const CImg& display_object3d(const tp& points, const CImgList<tf>& primitives,
-                                 const CImgList<T>& colors,
-                                 const bool centering=true,
-                                 const int render_static=4, const int render_motion=1,
-                                 const bool double_sided=false,
-                                 const float focale=500.0f, const float ambiant_light=0.05f,
-                                 const float opacity=1.0f, const bool display_axes=true, float *const pose_matrix=0) const {
-      CImgDisplay disp(width,height," ",0);
-      return display_object3d(points,primitives,colors,CImg<float>::vector(opacity),
-                              disp,centering,render_static,render_motion,double_sided,
-                              focale,ambiant_light,display_axes,pose_matrix);
-    }
-
-    //! High-level interface for displaying a 3d object
-    template<typename tp, typename tf>
-    const CImg& display_object3d(const tp& points, const CImgList<tf>& primitives,
-                                 const CImgList<T>& colors, CImgDisplay &disp,
-                                 const bool centering=true,
-                                 const int render_static=4, const int render_motion=1,
-                                 const bool double_sided=false,
-                                 const float focale=500.0f, const float ambiant_light=0.05f,
-                                 const float opacity=1.0f, const bool display_axes=true, float *const pose_matrix=0) const {
-      return display_object3d(points,primitives,colors,CImg<float>::vector(opacity),
-                              disp,centering,render_static,render_motion,double_sided,
-                              focale,ambiant_light,display_axes,pose_matrix);
-    }
-
-    //@}
-    //----------------------
-    //
-    //! \name Input-Output
-    //@{
-    //----------------------
-
-    //! Load an image from a file.
-    /**
-       \param filename = name of the image file to load.
-       \return A CImg<T> instance containing the pixel data defined in the image file.
-       \note The extension of \c filename defines the file format. If no filename
-       extension is provided, CImg<T>::get_load() will try to load a CRAW file (CImg Raw file).
-    **/
-    static CImg get_load(const char *const filename) {
-      const char *ext = cimg::filename_split(filename);
-      if (!cimg::strncasecmp(ext,"asc",3))   return get_load_ascii(filename);
-      if (!cimg::strncasecmp(ext,"dlm",3) ||
-          !cimg::strncasecmp(ext,"txt",3))   return get_load_dlm(filename);
-      if (!cimg::strncasecmp(ext,"inr",3))   return get_load_inr(filename);
-      if (!cimg::strncasecmp(ext,"hdr",3))   return get_load_analyze(filename);
-      if (!cimg::strncasecmp(ext,"par",3) ||
-          !cimg::strncasecmp(ext,"rec",3))   return get_load_parrec(filename);
-      if (!cimg::strncasecmp(ext,"pan",3))   return get_load_pandore(filename);
-      if (!cimg::strncasecmp(ext,"bmp",3))   return get_load_bmp(filename);
-      if (!cimg::strncasecmp(ext,"png",3))   return get_load_png(filename);
-      if (!cimg::strncasecmp(ext,"tif",3))   return get_load_tiff(filename);
-      if (!cimg::strncasecmp(ext,"jpg",3) ||
-          !cimg::strncasecmp(ext,"jpeg",4))  return get_load_jpeg(filename);
-      if (!cimg::strncasecmp(ext,"ppm",3) ||
-          !cimg::strncasecmp(ext,"pgm",3) ||
-          !cimg::strncasecmp(ext,"pnm",3))   return get_load_pnm(filename);
-      if (!cimg::strncasecmp(ext,"cimg",4) ||
-          ext[0]=='\0')                      return get_load_cimg(filename);
-      if (!cimg::strncasecmp(ext,"dcm",3) ||
-          !cimg::strncasecmp(ext,"dicom",5)) return get_load_dicom(filename);
-      return get_load_other(filename);
-    }
-
-    //! Load an image from a file
-    /** This is the in-place version of get_load(). **/
-    CImg& load(const char *const filename) {
-      return get_load(filename).swap(*this);
-    }
-
-    //! Load an image from an ASCII file.
-    static CImg get_load_ascii(std::FILE *const file, const char *const filename=0) {
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      char line[256] = {0};
-      std::fscanf(nfile,"%255[^\n]",line);
-      unsigned int off, dx = 0, dy = 1, dz = 1, dv = 1;
-      int err = 1;
-      std::sscanf(line,"%u %u %u %u",&dx,&dy,&dz,&dv);
-      if (!dx || !dy || !dz || !dv) {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_ascii() : File '%s' is not a valid .ASC file.\n"
-                              "Specified image dimensions are (%u,%u,%u,%u).",
-                              pixel_type(),filename?filename:"(FILE*)",dx,dy,dz,dv);
-      }
-      CImg dest(dx,dy,dz,dv);
-      double val;
-      T *ptr = dest.data;
-      for (off=0; off<dest.size() && err==1; off++) {
-        err = std::fscanf(nfile,"%lf%*[^0-9.eE+-]",&val);
-        *(ptr++)=(T)val;
-      }
-      cimg::warn(off<dest.size(),"CImg<%s>::get_load_ascii() : File '%s', only %u/%u values read.",
-                 pixel_type(),filename?filename:"(FILE*)",off,dest.size());
-      if (!file) cimg::fclose(nfile);
-      return dest;
-    }
-
-    //! Load an image from an ASCII file.
-    static CImg get_load_ascii(const char *const filename) {
-      return get_load_ascii(0,filename);
-    }
-
-    //! Load an image from an ASCII file (in-place version).
-    CImg& load_ascii(std::FILE *const file, const char *const filename=0) {
-      return get_load_ascii(file,filename).swap(*this);
-    }
-
-    //! Load an image from an ASCII file (in-place version).
-    CImg& load_ascii(const char *const filename) {
-      return get_load_ascii(filename).swap(*this);
-    }
-
-    //! Load an image from a DLM file
-    static CImg get_load_dlm(std::FILE *const file, const char *const filename=0) {
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"r");
-      CImg dest(256,256);
-      char c, delimiter[256]={0}, tmp[256];
-      unsigned int cdx=0,dx=0,dy=0;
-      int oerr=0, err;
-      double val;
-      while ((err = std::fscanf(nfile,"%lf%255[^0-9.eE+-]",&val,delimiter))!=EOF) {
-        oerr = err;
-        if (err>0) dest(cdx++,dy) = (T)val;
-        if (cdx>=dest.width) dest.resize(dest.width+256,1,1,1,0);
-        c=0; if (!std::sscanf(delimiter,"%255[^\n]%c",tmp,&c) || c=='\n') {
-          dx = cimg::max(cdx,dx);
-          dy++;
-          if (dy>=dest.height) dest.resize(dest.width,dest.height+256,1,1,0);
-          cdx=0;
-        }
-      }
-      if (cdx && oerr==1) { dx=cdx; dy++; }
-      if (!dx || !dy) {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_dlm() : File '%s' is not a valid DLM file.\n"
-                              "Specified image dimensions are (%u,%u).",
-                              pixel_type(),filename?filename:"(FILE*)",dx,dy);
-      }
-      dest.resize(dx,dy,1,1,0);
-      if (!file) cimg::fclose(nfile);
-      return dest;
-    }
-
-    //! Load an image from a DLM file
-    static CImg get_load_dlm(const char *const filename=0) {
-      return get_load_dlm(0,filename);
-    }
-
-    //! Load an image from a DLM file (in-place version).
-    CImg& load_dlm(std::FILE *const file, const char *const filename=0) {
-      return get_load_dlm(file,filename).swap(*this);
-    }
-
-    //! Load an image from a DLM file (in-place version).
-    CImg& load_dlm(const char *const filename) {
-      return get_load_dlm(filename).swap(*this);
-    }
-
-    //! Load an image from a PNM file
-    static CImg get_load_pnm(std::FILE *const file, const char *const filename=0) {
-      std::FILE *const nfile=file?file:cimg::fopen(filename,"rb");
-      unsigned int ppm_type,width,height,colormax=255;
-      char item[1024]={0};
-      int err;
-      while ((err=std::fscanf(nfile,"%1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(nfile);
-      if(std::sscanf(item," P%u",&ppm_type)!=1) {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_pnm() : File '%s', PNM header 'P?' not found.",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-      while ((err=std::fscanf(nfile," %1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(nfile);
-      if ((err=std::sscanf(item," %u %u %u",&width,&height,&colormax))<2) {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_pnm() : File '%s', WIDTH and HEIGHT fields are not defined in PNM header.",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-      if (err==2) {
-        while ((err=std::fscanf(nfile," %1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(nfile);
-        cimg::warn(std::sscanf(item,"%u",&colormax)!=1,
-                   "CImg<%s>::get_load_pnm() : File '%s', COLORMAX field is not defined in PNM header.",
-                   pixel_type(),filename?filename:"(FILE*)");
-      }
-      std::fgetc(nfile);
-
-      CImg dest;
-      int rval,gval,bval;
-
-      switch (ppm_type) {
-      case 2: { // Grey Ascii
-        dest.assign(width,height,1,1);
-        T* rdata = dest.ptr();
-        cimg_foroff(dest,off) { std::fscanf(nfile,"%d",&rval); *(rdata++)=(T)rval; }
-      } break;
-      case 3: { // Color Ascii
-        dest.assign(width,height,1,3);
-        T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
-        cimg_forXY(dest,x,y) {
-          std::fscanf(nfile,"%d %d %d",&rval,&gval,&bval);
-          *(rdata++)=(T)rval;
-          *(gdata++)=(T)gval;
-          *(bdata++)=(T)bval; }
-      } break;
-      case 5: { // Grey Binary
-        if (colormax<256) { // 8 bits
-          CImg<unsigned char> raw(width,height,1,1);
-          cimg::fread(raw.data,width*height,nfile);
-          dest=raw;
-        } else { // 16 bits
-          CImg<unsigned short> raw(width,height,1,1);
-          cimg::fread(raw.data,width*height,nfile);
-          if (!cimg::endian()) cimg::endian_swap(raw.data,width*height);
-          dest=raw;
-        }
-      } break;
-      case 6: { // Color Binary
-        if (colormax<256) { // 8 bits
-          CImg<unsigned char> raw(width,height,1,3);
-          cimg::fread(raw.data,width*height*3,nfile);
-          dest.assign(width,height,1,3);
-          T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
-          const unsigned char *ptrs = raw.ptr();
-          for (unsigned int off = raw.width*raw.height; off; --off) {
-            *(rdata++) = (T)*(ptrs++);
-            *(gdata++) = (T)*(ptrs++);
-            *(bdata++) = (T)*(ptrs++);
-          }
-        } else { // 16 bits
-          CImg<unsigned short> raw(width,height,1,3);
-          cimg::fread(raw.data,width*height*3,nfile);
-          if (!cimg::endian()) cimg::endian_swap(raw.data,width*height*3);
-          dest.assign(width,height,1,3);
-          T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
-          const unsigned short *ptrs = raw.ptr();
-          for (unsigned int off = raw.width*raw.height; off; --off) {
-            *(rdata++) = (T)*(ptrs++);
-            *(gdata++) = (T)*(ptrs++);
-            *(bdata++) = (T)*(ptrs++);
-          }
-        }
-      } break;
-      default:
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_pnm() : File '%s', PPM type 'P%d' not supported.",
-                              pixel_type(),filename?filename:"(FILE*)",ppm_type);
-      }
-      if (!file) cimg::fclose(nfile);
-      return dest;
-    }
-
-    //! Load an image from a PNM file.
-    static CImg get_load_pnm(const char *const filename) {
-      return get_load_pnm(0,filename);
-    }
-
-    //! Load an image from a PNM file (in-place version).
-    CImg& load_pnm(std::FILE *const file, const char *const filename=0) {
-      return get_load_pnm(file,filename).swap(*this);
-    }
-
-    //! Load an image from a PNM file (in-place version).
-    CImg& load_pnm(const char *const filename) {
-      return get_load_pnm(filename).swap(*this);
-    }
-
-    //! Load a YUV image sequence file.
-    static CImg get_load_yuv(std::FILE *const file, const char *const filename,
-                             const unsigned int sizex, const unsigned int sizey=1,
-                             const unsigned int first_frame=0, const int last_frame=-1,
-                             const bool yuv2rgb = false) {
-      return CImgList<T>::get_load_yuv(file,filename,sizex,sizey,first_frame,last_frame,yuv2rgb).get_append('z','c');
-    }
-
-    //! Load a YUV image sequence file.
-    static CImg get_load_yuv(const char *const filename,
-                             const unsigned int sizex, const unsigned int sizey=1,
-                             const unsigned int first_frame=0, const int last_frame=-1,
-                             const bool yuv2rgb = false) {
-      return CImgList<T>::get_load_yuv(filename,sizex,sizey,first_frame,last_frame,yuv2rgb).get_append('z','c');
-    }
-
-    //! Load a YUV image sequence file (in-place).
-    CImg& load_yuv(std::FILE *const file, const char *const filename,
-                   const unsigned int sizex, const unsigned int sizey=1,
-                   const unsigned int first_frame=0, const int last_frame=-1,
-                   const bool yuv2rgb = false) {
-      return get_load_yuv(file,filename,sizex,sizey,first_frame,last_frame,yuv2rgb).swap(*this);
-    }
-
-    //! Load a YUV image sequence file (in-place).
-    CImg& load_yuv(const char *const filename,
-                   const unsigned int sizex, const unsigned int sizey=1,
-                   const unsigned int first_frame=0, const int last_frame=-1,
-                   const bool yuv2rgb = false) {
-      return get_load_yuv(filename,sizex,sizey,first_frame,last_frame,yuv2rgb).swap(*this);
-    }
-
-    //! Load an image from a BMP file.
-    static CImg get_load_bmp(std::FILE *const file, const char *const filename=0) {
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      unsigned char header[64];
-      cimg::fread(header,54,nfile);
-      if (header[0]!='B' || header[1]!='M') {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_bmp() : File '%s' is not a valid BMP file.",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-
-      // Read header and pixel buffer
-      int
-        file_size   = header[0x02] + (header[0x03]<<8) + (header[0x04]<<16) + (header[0x05]<<24),
-        offset      = header[0x0A] + (header[0x0B]<<8) + (header[0x0C]<<16) + (header[0x0D]<<24),
-        dx          = header[0x12] + (header[0x13]<<8) + (header[0x14]<<16) + (header[0x15]<<24),
-        dy          = header[0x16] + (header[0x17]<<8) + (header[0x18]<<16) + (header[0x19]<<24),
-        compression = header[0x1E] + (header[0x1F]<<8) + (header[0x20]<<16) + (header[0x21]<<24),
-        nb_colors   = header[0x2E] + (header[0x2F]<<8) + (header[0x30]<<16) + (header[0x31]<<24),
-        bpp         = header[0x1C] + (header[0x1D]<<8),
-        *palette    = 0;
-      const int
-        dx_bytes   = (bpp==1)?(dx/8+(dx%8?1:0)):((bpp==4)?(dx/2+(dx%2?1:0)):(dx*bpp/8)),
-        align      = (4-dx_bytes%4)%4,
-        buf_size   = cimg::min(cimg::abs(dy)*(dx_bytes+align),file_size-offset);
-
-      if (bpp<16) { if (!nb_colors) nb_colors=1<<bpp; } else nb_colors=0;
-      if (nb_colors) { palette = new int[nb_colors]; cimg::fread(palette,nb_colors,nfile); }
-      const int xoffset = offset-54-4*nb_colors;
-      if (xoffset>0) std::fseek(nfile,xoffset,SEEK_CUR);
-      unsigned char *buffer  = new unsigned char[buf_size], *ptrs = buffer;
-      cimg::fread(buffer,buf_size,nfile);
-      if (!file) cimg::fclose(nfile);
-
-      // Decompress buffer (if necessary)
-      if (compression) {
-        delete[] buffer;
-        if (file) {
-          throw CImgIOException("CImg<%s>::get_load_bmp() : Not able to read a compressed BMP file using a *FILE input",pixel_type());
-        } else return get_load_other(filename);
-      }
-
-      // Read pixel data
-      CImg res(dx,cimg::abs(dy),1,3);
-      switch (bpp) {
-      case 1: { // Monochrome
-        for (int y=res.height-1; y>=0; y--) {
-          unsigned char mask = 0x80, val = 0;
-          cimg_forX(res,x) {
-            if (mask==0x80) val = *(ptrs++);
-            const unsigned char *col = (unsigned char*)(palette+(val&mask?1:0));
-            res(x,y,2) = (T)*(col++);
-            res(x,y,1) = (T)*(col++);
-            res(x,y,0) = (T)*(col++);
-            mask = cimg::ror(mask);
-          } ptrs+=align; }
-      } break;
-      case 4: { // 16 colors
-        for (int y=res.height-1; y>=0; y--) {
-          unsigned char mask = 0xF0, val = 0;
-          cimg_forX(res,x) {
-            if (mask==0xF0) val = *(ptrs++);
-            const unsigned char color = (mask<16)?(val&mask):((val&mask)>>4);
-            unsigned char *col = (unsigned char*)(palette+color);
-            res(x,y,2) = (T)*(col++);
-            res(x,y,1) = (T)*(col++);
-            res(x,y,0) = (T)*(col++);
-            mask = cimg::ror(mask,4);
-          } ptrs+=align; }
-      } break;
-      case 8: { //  256 colors
-        for (int y=res.height-1; y>=0; y--) { cimg_forX(res,x) {
-          const unsigned char *col = (unsigned char*)(palette+*(ptrs++));
-          res(x,y,2) = (T)*(col++);
-          res(x,y,1) = (T)*(col++);
-          res(x,y,0) = (T)*(col++);
-        } ptrs+=align; }
-      } break;
-      case 16: { // 16 bits colors
-        for (int y=res.height-1; y>=0; y--) { cimg_forX(res,x) {
-          const unsigned char c1 = *(ptrs++), c2 = *(ptrs++);
-          const unsigned short col = c1+(c2<<8);
-          res(x,y,2) = (T)(col&0x1F);
-          res(x,y,1) = (T)((col>>5)&0x1F);
-          res(x,y,0) = (T)((col>>10)&0x1F);
-        } ptrs+=align; }
-      } break;
-      case 24: { // 24 bits colors
-        for (int y=res.height-1; y>=0; y--) { cimg_forX(res,x) {
-          res(x,y,2) = (T)*(ptrs++);
-          res(x,y,1) = (T)*(ptrs++);
-          res(x,y,0) = (T)*(ptrs++);
-        } ptrs+=align; }
-      } break;
-      case 32: { // 32 bits colors
-        for (int y=res.height-1; y>=0; y--) { cimg_forX(res,x) {
-          res(x,y,2) = (T)*(ptrs++);
-          res(x,y,1) = (T)*(ptrs++);
-          res(x,y,0) = (T)*(ptrs++);
-          ptrs++;
-        } ptrs+=align; }
-      } break;
-      }
-      if (palette) delete[] palette;
-      delete[] buffer;
-      if (dy<0) res.mirror('y');
-      return res;
-    }
-
-    //! Load an image from a BMP file
-    static CImg get_load_bmp(const char *const filename) {
-      return get_load_bmp(0,filename);
-    }
-
-    //! Load an image from a BMP file
-    CImg& load_bmp(std::FILE *const file, const char *const filename=0) {
-      return get_load_bmp(file,filename).swap(*this);
-    }
-
-    //! Load an image from a BMP file
-    CImg& load_bmp(const char *const filename) {
-      return get_load_bmp(filename).swap(*this);
-    }
-
-    //! Load an image from a PNG file.
-    // Note : Most of this function has been written by Eric Fausett
-    static CImg get_load_png(std::FILE *const file, const char *const filename=0) {
-#ifndef cimg_use_png
-      if (file)
-        throw CImgIOException("CImg<%s>::get_load_png() : File '(FILE*)' cannot be read without using libpng.",pixel_type());
-      else return get_load_other(filename);
-#else
-      // Open file and check for PNG validity
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      unsigned char pngCheck[8];
-      cimg::fread(pngCheck,8,nfile);
-      if (png_sig_cmp(pngCheck,0,8)) {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_png() : File '%s' is not a valid PNG file.",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-
-      // Setup PNG structures for read
-      png_voidp user_error_ptr=0;
-      png_error_ptr user_error_fn=0, user_warning_fn=0;
-      png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,       // Verifies libpng version correct
-                                                   user_error_ptr, user_error_fn, user_warning_fn);
-      if(!png_ptr){
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_png() : File '%s', trouble initializing 'png_ptr' data structure.",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-      png_infop info_ptr = png_create_info_struct(png_ptr);
-      if(!info_ptr){
-        if (!file) cimg::fclose(nfile);
-        png_destroy_read_struct(&png_ptr, (png_infopp)0, (png_infopp)0);
-        throw CImgIOException("CImg<%s>::get_load_png() : File '%s', trouble initializing 'info_ptr' data structure.",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-      png_infop end_info = png_create_info_struct(png_ptr);
-      if(!end_info){
-        if (!file) cimg::fclose(nfile);
-        png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)0);
-        throw CImgIOException("CImg<%s>::get_load_png() : File '%s', trouble initializing 'end_info' data structure.",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-
-      // Error handling callback for png file reading
-      if (setjmp(png_jmpbuf(png_ptr))){
-        if (!file) cimg::fclose(nfile);
-        png_destroy_read_struct(&png_ptr, &end_info, (png_infopp)0);
-        throw CImgIOException("CImg<%s>::get_load_png() : File '%s', unknown fatal error.",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-      png_init_io(png_ptr, nfile);
-      png_set_sig_bytes(png_ptr, 8);
-
-      // Get PNG Header Info up to data block
-      png_read_info(png_ptr, info_ptr);
-      png_uint_32 width, height;
-      int bit_depth, color_type, interlace_type;
-      png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, &interlace_type,
-                   int_p_NULL, int_p_NULL);
-      int new_bit_depth = bit_depth;
-      int new_color_type = color_type;
-
-      // Transforms to unify image data
-      if (new_color_type == PNG_COLOR_TYPE_PALETTE){
-        png_set_palette_to_rgb(png_ptr);
-        new_color_type -= PNG_COLOR_MASK_PALETTE;
-        new_bit_depth = 8;
-      }
-      if (new_color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8){
-        png_set_gray_1_2_4_to_8(png_ptr);
-        new_bit_depth = 8;
-      }
-      if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
-        png_set_tRNS_to_alpha(png_ptr);
-      if (new_color_type == PNG_COLOR_TYPE_GRAY || new_color_type == PNG_COLOR_TYPE_GRAY_ALPHA){
-        png_set_gray_to_rgb(png_ptr);
-        new_color_type |= PNG_COLOR_MASK_COLOR;
-      }
-      if (new_color_type == PNG_COLOR_TYPE_RGB) png_set_filler(png_ptr, 0xffffU, PNG_FILLER_AFTER);
-      png_read_update_info(png_ptr, info_ptr);
-      if (!(new_bit_depth==8 || new_bit_depth==16)) {
-        if (!file) cimg::fclose(nfile);
-        png_destroy_read_struct(&png_ptr, &end_info, (png_infopp)0);
-        throw CImgIOException("CImg<%s>::get_load_png() : File '%s', wrong bit coding (bit_depth=%u)",
-                              pixel_type(),filename?filename:"(FILE*)",new_bit_depth);
-      }
-      const int byte_depth = new_bit_depth>>3;
-
-      // Allocate Memory for Image Read
-      png_bytep *imgData = new png_bytep[height];
-      for (unsigned int row=0; row < height; row++) imgData[row] = new png_byte[byte_depth * 4 * width];
-      png_read_image(png_ptr, imgData);
-      png_read_end(png_ptr, end_info);
-
-      // Read pixel data
-      if (!(new_color_type==PNG_COLOR_TYPE_RGB || new_color_type==PNG_COLOR_TYPE_RGB_ALPHA)) {
-        if (!file) cimg::fclose(nfile);
-        png_destroy_read_struct(&png_ptr, &end_info, (png_infopp)0);
-        throw CImgIOException("CImg<%s>::get_load_png() : File '%s', wrong color coding (new_color_type=%u)",
-                              pixel_type(),filename?filename:"(FILE*)",new_color_type);
-      }
-      const bool no_alpha_channel = (new_color_type==PNG_COLOR_TYPE_RGB);
-      CImg res(width,height,1,no_alpha_channel?3:4);
-      const unsigned long off = width*height;
-      T *ptr1 = res.data, *ptr2 = ptr1+off, *ptr3 = ptr2+off, *ptr4 = ptr3+off;
-      switch(new_bit_depth){
-      case 8: {
-        cimg_forY(res,y){
-          const unsigned char *ptrs = (unsigned char*)imgData[y];
-          cimg_forX(res,x){
-            *(ptr1++) = (T)*(ptrs++);
-            *(ptr2++) = (T)*(ptrs++);
-            *(ptr3++) = (T)*(ptrs++);
-            if (no_alpha_channel) ptrs++; else *(ptr4++) = (T)*(ptrs++);
-          }
-        }
-      } break;
-      case 16: {
-        cimg_forY(res,y){
-          const unsigned short *ptrs = (unsigned short*)(imgData[y]);
-          cimg_forX(res,x){
-            *(ptr1++) = (T)*(ptrs++);
-            *(ptr2++) = (T)*(ptrs++);
-            *(ptr3++) = (T)*(ptrs++);
-            if (no_alpha_channel) ptrs++; else *(ptr4++) = (T)*(ptrs++);
-          }
-        }
-      } break;
-      }
-      png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
-
-      // Deallocate Image Read Memory
-      for (unsigned int n=0; n<height; n++) delete[] imgData[n];
-      delete[] imgData;
-      if (!file) cimg::fclose(nfile);
-      return res;
-#endif
-    }
-
-    //! Load an image from a PNG file
-    static CImg get_load_png(const char *const filename) {
-      return get_load_png(0,filename);
-    }
-
-    //! Load an image from a PNG file
-    CImg& load_png(std::FILE *const file, const char *const filename=0) {
-      return get_load_png(file,filename).swap(*this);
-    }
-
-    //! Load an image from a PNG file
-    CImg& load_png(const char *const filename) {
-      return get_load_png(filename).swap(*this);
-    }
-
-    //! Load an image in TIFF format
-    // Original contribution by Jerome Boulanger.
-    static CImg get_load_tiff(const char *const filename=0) {
-#ifndef cimg_use_tiff
-      return get_load_other(filename);
-#else
-      CImg dest;
-      TIFF *tif = TIFFOpen(filename,"r");
-#if cimg_debug>=3
-      TIFFSetWarningHandler(0);
-      TIFFSetErrorHandler(0);
-#endif
-      if (tif) {
-        unsigned int number_of_directories = 0;
-        do number_of_directories++; while (TIFFReadDirectory(tif));
-        uint16 samplesperpixel, bitspersample;
-        uint32 nx,ny;
-        TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);
-        TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);
-        TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&samplesperpixel);
-        if (samplesperpixel!=1 && samplesperpixel!=3 && samplesperpixel!=4) {
-          cimg::warn(true,"CImg<%s>::get_load_tiff() : File '%s', unknow value for tag : TIFFTAG_SAMPLESPERPIXEL, will force it to 1.",
-                     pixel_type(),filename?filename:"(FILE*)");
-          samplesperpixel=1;
-        }
-        TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);
-        TIFFClose(tif);
-        tif = TIFFOpen(filename,"r");
-        dest.assign(nx,ny,number_of_directories,samplesperpixel);
-
-        unsigned  int dir=0;
-        do {
-          if (bitspersample!=8 || !(samplesperpixel == 1 || samplesperpixel == 3 || samplesperpixel == 4)){ //if !rgba 8bit
-            uint16 photo, config;
-            TIFFGetField(tif,TIFFTAG_PLANARCONFIG,&config);
-            TIFFGetField(tif,TIFFTAG_PHOTOMETRIC,&photo);
-            if (TIFFIsTiled(tif)) {
-	      uint32 tw, th;
-	      TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);
-	      TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);
-              if (config==PLANARCONFIG_CONTIG) {
-		switch(bitspersample){
-		case 8:{
-                unsigned char *buf;
-                buf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif));
-                if (buf) {
-                  for (unsigned int row = 0; row<ny; row+=th) {
-                    for (unsigned int col = 0; col<nx; col+=tw) {
-                      if (TIFFReadTile(tif,buf,col,row,0,0)<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', an error occure while reading a tile.",
-					    pixel_type(),filename?filename:"(FILE*)");
-                      } else {
-			unsigned char * ptr = buf;
-			for (unsigned int rr=row;rr<cimg::min( row+th,(unsigned int)ny);rr++)
-			  for (unsigned int cc=col;cc<cimg::min( col+tw,(unsigned int)nx);cc++)
-			    for (unsigned int vv=0;vv<samplesperpixel;vv++)
-			      dest(cc,rr,dir,vv)= (T)(float)*(ptr++);
-                        }
-                    }
-                  }
-                  _TIFFfree(buf);
-                }
-		break;
-		}
-		case 16:{
-                unsigned short *buf;
-                buf = (unsigned short *)_TIFFmalloc(TIFFTileSize(tif));
-                if (buf) {
-                  for (unsigned int row = 0; row<ny; row+=th) {
-                    for (unsigned int col = 0; col<nx; col+=tw) {
-                      if (TIFFReadTile(tif,buf,col,row,0,0)<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', an error occure while reading a tile.",
-					    pixel_type(),filename?filename:"(FILE*)");
-                      } else {
-			unsigned short * ptr = buf;
-			for (unsigned int rr=row;rr<cimg::min( row+th,(unsigned int)ny);rr++)
-			  for (unsigned int cc=col;cc<cimg::min( col+tw,(unsigned int)nx);cc++)
-			    for (unsigned int vv=0;vv<samplesperpixel;vv++)
-			      dest(cc,rr,dir,vv)= (T)(float)*(ptr++);
-                        }
-                    }
-                  }
-                  _TIFFfree(buf);
-                }
-		break;
-		}
-		case 32:{
-                float *buf;
-                buf = (float *)_TIFFmalloc(TIFFTileSize(tif));
-                if (buf) {
-                  for (unsigned int row = 0; row<ny; row+=th) {
-                    for (unsigned int col = 0; col<nx; col+=tw) {
-                      if (TIFFReadTile(tif,buf,col,row,0,0)<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', an error occure while reading a tile.",
-					    pixel_type(),filename?filename:"(FILE*)");
-                      } else {
-			float * ptr = buf;
-			for (unsigned int rr=row;rr<cimg::min( row+th,(unsigned int)ny);rr++)
-			  for (unsigned int cc=col;cc<cimg::min( col+tw,(unsigned int)nx);cc++)
-			    for (unsigned int vv=0;vv<samplesperpixel;vv++)
-			      dest(cc,rr,dir,vv)= (T)(float)*(ptr++);
-                        }
-                    }
-                  }
-                  _TIFFfree(buf);
-                }
-		break;
-		}
-		}
-              }
-              else {
-		switch(bitspersample){
-		case 8:{
-                unsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFTileSize(tif));
-                if (buf) {
-		  for (unsigned int vv=0;vv<samplesperpixel;vv++)
-                  for (unsigned int row = 0; row<ny; row+=th) {
-                    for (unsigned int col = 0; col<nx; col+=tw) {
-                      if (TIFFReadTile(tif,buf,col,row,0,vv)<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', an error occure while reading a tile.",
-					    pixel_type(),filename?filename:"(FILE*)");
-                      } else {
-			unsigned char * ptr = buf;
-			for (unsigned int rr=row;rr<cimg::min( row+th,(unsigned int)ny);rr++)
-			  for (unsigned int cc=col;cc<cimg::min( col+tw,(unsigned int)nx);cc++)
-			      dest(cc,rr,dir,vv)= (T)(float)*(ptr++);
-                        }
-                    }
-                  }
-                  _TIFFfree(buf);
-                }
-		break;
-		}
-		case 16:{
-                unsigned short *buf = (unsigned short *)_TIFFmalloc(TIFFTileSize(tif));
-                if (buf) {
-		  for (unsigned int vv=0;vv<samplesperpixel;vv++)
-                  for (unsigned int row = 0; row<ny; row+=th) {
-                    for (unsigned int col = 0; col<nx; col+=tw) {
-                      if (TIFFReadTile(tif,buf,col,row,0,vv)<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', an error occure while reading a tile.",
-					    pixel_type(),filename?filename:"(FILE*)");
-                      } else {
-			unsigned short * ptr = buf;
-			for (unsigned int rr=row;rr<cimg::min( row+th,(unsigned int)ny);rr++)
-			  for (unsigned int cc=col;cc<cimg::min( col+tw,(unsigned int)nx);cc++)
-			      dest(cc,rr,dir,vv)= (T)(float)*(ptr++);
-                        }
-                    }
-                  }
-                  _TIFFfree(buf);
-                }
-		break;
-		}
-		case 32:{
-                float *buf = (float *)_TIFFmalloc(TIFFTileSize(tif));
-                if (buf) {
-		  for (unsigned int vv=0;vv<samplesperpixel;vv++)
-                  for (unsigned int row = 0; row<ny; row+=th) {
-                    for (unsigned int col = 0; col<nx; col+=tw) {
-                      if (TIFFReadTile(tif,buf,col,row,0,vv)<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', an error occure while reading a tile.",
-					    pixel_type(),filename?filename:"(FILE*)");
-                      } else {
-			float * ptr = buf;
-			for (unsigned int rr=row;rr<cimg::min( row+th,(unsigned int)ny);rr++)
-			  for (unsigned int cc=col;cc<cimg::min( col+tw,(unsigned int)nx);cc++)
-			      dest(cc,rr,dir,vv)= (T)(float)*(ptr++);
-                        }
-                    }
-                  }
-                  _TIFFfree(buf);
-                }
-		break;
-		}
-		}
-              }
-            } else {
-              if (config==PLANARCONFIG_CONTIG) {
-		switch(bitspersample){
-		case 8 :{
-		  unsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));
-		  if (buf) {
-		    uint32 row, rowsperstrip = (uint32)-1;
-		    TIFFGetField(tif,TIFFTAG_ROWSPERSTRIP,&rowsperstrip);
-		    for (row = 0; row<ny; row+= rowsperstrip) {
-		      uint32 nrow = (row+rowsperstrip>ny?ny-row:rowsperstrip);
-		      tstrip_t strip = TIFFComputeStrip(tif, row, 0);
-		      if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', an error occure while reading a strip.",
-					    pixel_type(),filename?filename:"(FILE*)");
-		      }
-			unsigned char * ptr = buf;
-			for (unsigned int rr=0; rr<nrow; rr++)
-			  for (unsigned int cc=0;cc<nx;cc++)
-			    for (unsigned int vv=0;vv<samplesperpixel;vv++)
-			      dest(cc,row+rr,dir,vv)= (T)(float)*(ptr++);
-
-		    }
-		    _TIFFfree(buf);
-		  }
-		  break;
-		}
-		case 16:{
-		  unsigned short *buf = (unsigned  short *)_TIFFmalloc(TIFFStripSize(tif));
-		  if (buf) {
-		    uint32 row, rowsperstrip = (uint32)-1;
-		    TIFFGetField(tif,TIFFTAG_ROWSPERSTRIP,&rowsperstrip);
-		    for (row = 0; row<ny; row+= rowsperstrip) {
-		      uint32 nrow = (row+rowsperstrip>ny?ny-row:rowsperstrip);
-		      tstrip_t strip = TIFFComputeStrip(tif, row, 0);
-		      if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', error while reading a strip.",
-					    pixel_type(),filename?filename:"(FILE*)");
-		      }
-		      unsigned short * ptr = buf;
-			for (unsigned int rr=0; rr<nrow; rr++)
-			  for (unsigned int cc=0;cc<nx;cc++)
-			    for (unsigned int vv=0;vv<samplesperpixel;vv++)
-			      dest(cc,row+rr,dir,vv)= (T)(float)*(ptr++);
-		    }
-		    _TIFFfree(buf);
-		  }
-		  break;
-		}
-		case 32:{
-		  float *buf  = (float *)_TIFFmalloc(TIFFStripSize(tif));
-		  if (buf) {
-		    uint32 row, rowsperstrip = (uint32)-1;
-		    TIFFGetField(tif,TIFFTAG_ROWSPERSTRIP,&rowsperstrip);
-		    for (row = 0; row<ny; row+= rowsperstrip) {
-		      uint32 nrow = (row+rowsperstrip>ny?ny-row:rowsperstrip);
-		      tstrip_t strip = TIFFComputeStrip(tif, row, 0);
-		      if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', error while reading a strip.",
-					    pixel_type(),filename?filename:"(FILE*)");
-		      }
-		      float * ptr = buf;
-			for (unsigned int rr=0; rr<nrow; rr++)
-			  for (unsigned int cc=0;cc<nx;cc++)
-			    for (unsigned int vv=0;vv<samplesperpixel;vv++)
-			      dest(cc,row+rr,dir,vv)= (T)(float)*(ptr++);
-		    }
-		    _TIFFfree(buf);
-		  }
-		  break;
-	}
-
-		}
-	      }
-	      else {
-		switch(bitspersample){
-		case 8 :{
-		  unsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));
-		  if (buf) {
-		    uint32 row, rowsperstrip = (uint32)-1;
-		    TIFFGetField(tif,TIFFTAG_ROWSPERSTRIP,&rowsperstrip);
-		    for (unsigned int vv=0;vv<samplesperpixel;vv++){
-		    for (row = 0; row<ny; row+= rowsperstrip) {
-		      uint32 nrow = (row+rowsperstrip>ny?ny-row:rowsperstrip);
-		      tstrip_t strip = TIFFComputeStrip(tif, row, vv);
-		      if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
-			_TIFFfree(buf);
-			TIFFClose(tif);
-			throw CImgException("CImg<%s>::get_load_tiff() : File '%s', an error occure while reading a strip.",
-					      pixel_type(),filename?filename:"(FILE*)");
-		      }
-			unsigned char * ptr = buf;
-			  for (unsigned int rr=0;rr<nrow; rr++)
-			    for (unsigned int cc=0;cc<nx;cc++)
-			      dest(cc,row+rr,dir,vv)= (T)(float)*(ptr++);
-			}}
-		    _TIFFfree(buf);
-		  }
-		  break;
-		}
-		case 16:{
-		  unsigned short *buf = (unsigned  short *)_TIFFmalloc(TIFFStripSize(tif));
-		  if (buf) {
-		    uint32 row, rowsperstrip = (uint32)-1;
-		    TIFFGetField(tif,TIFFTAG_ROWSPERSTRIP,&rowsperstrip);
-		    for (unsigned int vv=0;vv<samplesperpixel;vv++)
-		      for (row = 0; row<ny; row+= rowsperstrip) {
-			uint32 nrow = (row+rowsperstrip>ny?ny-row:rowsperstrip);
-			tstrip_t strip = TIFFComputeStrip(tif, row, vv);
-			if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
-			  _TIFFfree(buf);
-			  TIFFClose(tif);
-			  throw CImgException("CImg<%s>::get_load_tiff() : File '%s', error while reading a strip.",
-					      pixel_type(),filename?filename:"(FILE*)");
-			}
-			unsigned short * ptr = buf;
-			for (unsigned int rr=0;rr<nrow;rr++)
-			  for (unsigned int cc=0;cc<nx;cc++)
-			    dest(cc,row+rr,dir,vv)= (T)(float)*(ptr++);
-		      }
-		    _TIFFfree(buf);
-		  }
-		  break;
-		}
-		 case 32:{
-		  float *buf = (float *)_TIFFmalloc(TIFFStripSize(tif));
-		  if (buf) {
-		    uint32 row, rowsperstrip = (uint32)-1;
-		    TIFFGetField(tif,TIFFTAG_ROWSPERSTRIP,&rowsperstrip);
-		    for (unsigned int vv=0;vv<samplesperpixel;vv++)
-		      for (row = 0; row<ny; row+= rowsperstrip) {
-			uint32 nrow = (row+rowsperstrip>ny?ny-row:rowsperstrip);
-			tstrip_t strip = TIFFComputeStrip(tif, row, vv);
-			if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
-			  _TIFFfree(buf);
-			  TIFFClose(tif);
-			  throw CImgException("CImg<%s>::get_load_tiff() : File '%s', error while reading a strip.",
-					      pixel_type(),filename?filename:"(FILE*)");
-			}
-			float * ptr = buf;
-			for (unsigned int rr=0;rr<nrow;rr++)
-			  for (unsigned int cc=0;cc<nx;cc++)
-			    dest(cc,row+rr,dir,vv)= (T)(float)*(ptr++);
-		      }
-		    _TIFFfree(buf);
-		  }
-		  break;
-		}
-		}
-              }
-            }
-          }
-          else {
-	    uint32* raster = (uint32*)_TIFFmalloc(nx * ny * sizeof (uint32));
-	    if (!raster) {
-	      _TIFFfree(raster);
-	      TIFFClose(tif);
-	      throw CImgException("CImg<%s>::get_load_tiff() : File '%s', not enough memory for buffer allocation.",
-				  pixel_type(),filename?filename:"(FILE*)");
-	    }
-            TIFFReadRGBAImage(tif,nx,ny,raster,0);
-            switch (samplesperpixel){
-	      case 1:{
-              cimg_forXY(dest,x,y) dest(x,y,dir)=(T)(float)((raster[nx*(ny-1-y)+x]+ 128) / 257);
-	      break;
-	    }
-	  case 3:{
-	    cimg_forXY(dest,x,y) {
-	      dest(x,y,dir,0)=(T)(float)TIFFGetR(raster[nx*(ny-1-y)+x]);
-	      dest(x,y,dir,1)=(T)(float)TIFFGetG(raster[nx*(ny-1-y)+x]);
-	      dest(x,y,dir,2)=(T)(float)TIFFGetB(raster[nx*(ny-1-y)+x]);
-              }
-	    break;
-	  }
-	  case 4:{
-	     cimg_forXY(dest,x,y) {
-	      dest(x,y,dir,0)=(T)(float)TIFFGetR(raster[nx*(ny-1-y)+x]);
-	      dest(x,y,dir,1)=(T)(float)TIFFGetG(raster[nx*(ny-1-y)+x]);
-	      dest(x,y,dir,2)=(T)(float)TIFFGetB(raster[nx*(ny-1-y)+x]);
-	      dest(x,y,dir,3)=(T)(float)TIFFGetA(raster[nx*(ny-1-y)+x]);
-              }
-	     break;
-	  }
-	  }
-	    _TIFFfree(raster);
-          }
-          dir++;
-        } while (TIFFReadDirectory(tif));
-        TIFFClose(tif);
-      } else
-        throw CImgException("CImg<%s>::get_load_tiff() : File '%s', error while loading the image.",
-                            pixel_type(),filename?filename:"(FILE*)");
-      return dest;
-#endif
-    }
-
-    //! Load an image from a TIFF file
-    CImg& load_tiff(const char *const filename) {
-      return get_load_tiff(filename).swap(*this);
-    }
-
-    //! Load a file in JPEG format.
-    static CImg get_load_jpeg(std::FILE *const file, const char *const filename=0) {
-#ifndef cimg_use_jpeg
-      if (file)
-        throw CImgIOException("CImg<%s>::get_load_jpeg() : File '(FILE*)' cannot be read without using libjpeg.",
-                              pixel_type());
-      else return get_load_other(filename);
-#else
-      struct jpeg_decompress_struct cinfo;
-      struct jpeg_error_mgr jerr;
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-
-      cinfo.err = jpeg_std_error(&jerr);
-      jpeg_create_decompress(&cinfo);
-      jpeg_stdio_src(&cinfo,nfile);
-      jpeg_read_header(&cinfo,TRUE);
-      jpeg_start_decompress(&cinfo);
-
-      if (cinfo.output_components!=1 && cinfo.output_components!=3 && cinfo.output_components!=4) {
-        cimg::warn(true,"CImg<%s>::get_load_jpeg() : Don't know how to read image '%s' with libpeg, trying ImageMagick's convert",
-                   pixel_type(),filename?filename:"(unknown)");
-        if (!file) return get_load_other(filename);
-        else {
-          if (!file) cimg::fclose(nfile);
-          throw CImgIOException("CImg<%s>::get_load_jpeg() : Cannot read JPEG image '%s' using a *FILE input.",
-                                pixel_type(),filename?filename:"(FILE*)");
-        }
-      }
-
-      const unsigned int row_stride = cinfo.output_width * cinfo.output_components;
-      unsigned char *buf = new unsigned char[cinfo.output_width*cinfo.output_height*cinfo.output_components], *buf2 = buf;
-      JSAMPROW row_pointer[1];
-      while (cinfo.output_scanline < cinfo.output_height) {
-        row_pointer[0] = &buf[cinfo.output_scanline*row_stride];
-        jpeg_read_scanlines(&cinfo,row_pointer,1);
-      }
-      jpeg_finish_decompress(&cinfo);
-      jpeg_destroy_decompress(&cinfo);
-      if (!file) cimg::fclose(nfile);
-
-      CImg<T> dest(cinfo.output_width,cinfo.output_height,1,cinfo.output_components);
-      switch (dest.dim) {
-      case 1: {
-        T *ptr_g = dest.ptr();
-        cimg_forXY(dest,x,y) *(ptr_g++) = (T)*(buf2++);
-      } break;
-      case 3: {
-        T *ptr_r = dest.ptr(0,0,0,0), *ptr_g = dest.ptr(0,0,0,1), *ptr_b = dest.ptr(0,0,0,2);
-        cimg_forXY(dest,x,y) {
-          *(ptr_r++) = (T)*(buf2++);
-          *(ptr_g++) = (T)*(buf2++);
-          *(ptr_b++) = (T)*(buf2++);
-        }
-      } break;
-      case 4: {
-        T *ptr_r = dest.ptr(0,0,0,0), *ptr_g = dest.ptr(0,0,0,1),
-          *ptr_b = dest.ptr(0,0,0,2), *ptr_a = dest.ptr(0,0,0,3);
-        cimg_forXY(dest,x,y) {
-          *(ptr_r++) = (T)*(buf2++);
-          *(ptr_g++) = (T)*(buf2++);
-          *(ptr_b++) = (T)*(buf2++);
-          *(ptr_a++) = (T)*(buf2++);
-        }
-      } break;
-      }
-      delete[] buf;
-      return dest;
-#endif
-    }
-
-    //! Load an image from a JPEG file
-    static CImg get_load_jpeg(const char *const filename) {
-      return get_load_jpeg(0,filename);
-    }
-
-    //! Load an image from a JPEG file
-    CImg& load_jpeg(std::FILE *const file, const char *const filename=0) {
-      return get_load_jpeg(file,filename).swap(*this);
-    }
-
-    //! Load an image from a JPEG file
-    CImg& load_jpeg(const char *const filename) {
-      return get_load_jpeg(filename).swap(*this);
-    }
-
-    //! Load an image using builtin ImageMagick++ Library
-    /**
-       Added April/may 2006 by Christoph Hormann <chris_hormann@gmx.de>
-       This is experimental code, not much tested, use with care.
-    **/
-    static CImg get_load_magick(const char *const filename) {
-      CImg dest;
-#ifdef cimg_use_magick
-      Magick::Image image(filename);
-      const unsigned int width = image.size().width(), height = image.size().height();
-      switch (image.type()) {
-      case Magick::PaletteMatteType:
-      case Magick::TrueColorMatteType:
-      case Magick::ColorSeparationType: {
-        dest.assign(width,height,1,4);
-        T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2), *adata = dest.ptr(0,0,0,3);
-        Magick::PixelPacket *pixels = image.getPixels(0,0,width,height);
-        for (unsigned int off = width*height; off; --off) {
-          *(rdata++) = (T)(pixels->red);
-          *(gdata++) = (T)(pixels->green);
-          *(bdata++) = (T)(pixels->blue);
-          *(adata++) = (T)(pixels->opacity);
-          pixels++;
-        }
-      } break;
-      case Magick::PaletteType:
-      case Magick::TrueColorType: {
-        dest.assign(width,height,1,3);
-        T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
-        Magick::PixelPacket *pixels = image.getPixels(0,0,width,height);
-        for (unsigned int off = width*height; off; --off) {
-          *(rdata++) = (T)(pixels->red);
-          *(gdata++) = (T)(pixels->green);
-          *(bdata++) = (T)(pixels->blue);
-          pixels++;
-        }
-      } break;
-      case Magick::GrayscaleMatteType: {
-        dest.assign(width,height,1,2);
-        T *data = dest.ptr(0,0,0,0), *adata = dest.ptr(0,0,0,1);
-        Magick::PixelPacket *pixels = image.getPixels(0,0,width,height);
-        for (unsigned int off = width*height; off; --off) {
-          *(data++) = (T)(pixels->red);
-          *(adata++) = (T)(pixels->opacity);
-          pixels++;
-        }
-      } break;
-      default: {
-        dest.assign(width,height,1,1);
-        T *data = dest.ptr(0,0,0,0);
-        Magick::PixelPacket *pixels = image.getPixels(0,0,width,height);
-        for (unsigned int off = width*height; off; --off) {
-          *(data++) = (T)(pixels->red);
-          pixels++;
-        }
-      } break;
-      }
-      return dest;
-#else
-      throw CImgIOException("CImg<%s>::get_load_magick() : File '%s', Magick++ has not been linked during compilation.",
-                            pixel_type(),filename?filename:"(null)");
-      return dest;
-#endif
-    }
-
-    //! Load an image using builtin ImageMagick++ Library (in-place version).
-    CImg& load_magick(const char *const filename) {
-      return get_load_magick(filename).swap(*this);
-    }
-
-    //! Load an image from a RAW file.
-    static CImg get_load_raw(std::FILE *const file, const char *const filename,
-                             const unsigned int sizex, const unsigned int sizey=1,
-                             const unsigned int sizez=1, const unsigned int sizev=1,
-                             const bool multiplexed=false, const bool endian_swap=false) {
-      CImg<T> res(sizex,sizey,sizez,sizev,0);
-      if (res.is_empty()) return res;
-
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      if (!multiplexed) {
-        cimg::fread(res.ptr(),res.size(),nfile);
-        if (endian_swap) cimg::endian_swap(res.ptr(),res.size());
-      }
-      else {
-        CImg<T> buf(1,1,1,sizev);
-        cimg_forXYZ(res,x,y,z) {
-          cimg::fread(buf.ptr(),sizev,nfile);
-          if (endian_swap) cimg::endian_swap(buf.ptr(),sizev);
-          res.set_vector_at(buf,x,y,z); }
-      }
-      if (!file) cimg::fclose(nfile);
-      return res;
-    }
-
-    //! Load an image from a RAW file.
-    static CImg get_load_raw(const char *const filename,
-                             const unsigned int sizex, const unsigned int sizey=1,
-                             const unsigned int sizez=1, const unsigned int sizev=1,
-                             const bool multiplexed = false, const bool endian_swap = false) {
-      return get_load_raw(0,filename,sizex,sizey,sizez,sizev,multiplexed,endian_swap);
-    }
-
-    //! In-place version of get_load_raw()
-    CImg& load_raw(std::FILE *const file, const char *const filename,
-                   const unsigned int sizex, const unsigned int sizey=1,
-                   const unsigned int sizez=1, const unsigned int sizev=1,
-                   const bool multiplexed = false, const bool endian_swap = false) {
-      return get_load_raw(file,filename,sizex,sizey,sizez,sizev,multiplexed,endian_swap).swap(*this);
-    }
-
-    //! In-place version of get_load_raw()
-    CImg& load_raw(const char *const filename,
-                   const unsigned int sizex, const unsigned int sizey=1,
-                   const unsigned int sizez=1, const unsigned int sizev=1,
-                   const bool multiplexed = false, const bool endian_swap = false) {
-      return get_load_raw(filename,sizex,sizey,sizez,sizev,multiplexed,endian_swap).swap(*this);
-    }
-
-    //! Load an image from a RGBA file.
-    static CImg get_load_rgba(std::FILE *const file, const char *const filename, const unsigned int dimw, const unsigned int dimh) {
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      unsigned char *buffer = new unsigned char[dimw*dimh*4];
-      cimg::fread(buffer,dimw*dimh*4,nfile);
-      if (!file) cimg::fclose(nfile);
-      CImg res(dimw,dimh,1,4);
-      T *pR = res.ptr(0,0,0,0), *pG = res.ptr(0,0,0,1), *pB = res.ptr(0,0,0,2), *pA = res.ptr(0,0,0,3);
-      const unsigned char *ptrs = buffer;
-      for (unsigned int off=res.width*res.height; off>0; --off) {
-        *(pR++) = (T)*(ptrs++);
-        *(pG++) = (T)*(ptrs++);
-        *(pB++) = (T)*(ptrs++);
-        *(pA++) = (T)*(ptrs++);
-      }
-      delete[] buffer;
-      return res;
-    }
-
-    //! Load an image from a RGBA file.
-    static CImg get_load_rgba(const char *const filename, const unsigned int dimw, const unsigned int dimh) {
-      return get_load_rgba(0,filename,dimw,dimh);
-    }
-
-    //! In-place version of get_load_rgba()
-    CImg& load_rgba(std::FILE *const file, const char *const filename, const unsigned int dimw, const unsigned int dimh) {
-      return get_load_rgba(file, filename,dimw,dimh).swap(*this);
-    }
-
-    //! In-place version of get_load_rgba()
-    CImg& load_rgba(const char *const filename, const unsigned int dimw, const unsigned int dimh) {
-      return get_load_rgba(filename,dimw,dimh).swap(*this);
-    }
-
-    //! Load an image from a RGB file.
-    static CImg get_load_rgb(std::FILE *const file, const char *const filename, const unsigned int dimw, const unsigned int dimh) {
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      unsigned char *buffer = new unsigned char[dimw*dimh*3];
-      cimg::fread(buffer,dimw*dimh*3,nfile);
-      if (!file) cimg::fclose(nfile);
-      CImg res(dimw,dimh,1,3);
-      T *pR = res.ptr(0,0,0,0), *pG = res.ptr(0,0,0,1), *pB=res.ptr(0,0,0,2);
-      const unsigned char *ptrs = buffer;
-      for (unsigned int off=res.width*res.height; off>0; --off) {
-        *(pR++) = (T)*(ptrs++);
-        *(pG++) = (T)*(ptrs++);
-        *(pB++) = (T)*(ptrs++);
-      }
-      delete[] buffer;
-      return res;
-    }
-
-    //! Load an image from a RGB file.
-    static CImg get_load_rgb(const char *const filename, const unsigned int dimw, const unsigned int dimh) {
-      return get_load_rgb(0,filename,dimw,dimh);
-    }
-
-    //! In-place version of get_load_rgb()
-    CImg& load_rgb(std::FILE *const file, const char *const filename, const unsigned int dimw, const unsigned int dimh) {
-      return get_load_rgb(file, filename,dimw,dimh).swap(*this);
-    }
-
-    //! In-place version of get_load_rgb()
-    CImg& load_rgb(const char *const filename, const unsigned int dimw, const unsigned int dimh) {
-      return get_load_rgb(filename,dimw,dimh).swap(*this);
-    }
-
-#define cimg_load_inr_case(Tf,sign,pixsize,Ts) \
-  if (!loaded && fopt[6]==pixsize && fopt[4]==Tf && fopt[5]==sign) { \
-      Ts *xval, *val = new Ts[fopt[0]*fopt[3]]; \
-      cimg_forYZ(dest,y,z) { \
-          cimg::fread(val,fopt[0]*fopt[3],nfile); \
-          if (fopt[7]!=endian) cimg::endian_swap(val,fopt[0]*fopt[3]); \
-          xval = val; cimg_forX(dest,x) cimg_forV(dest,k) \
-                          dest(x,y,z,k) = (T)*(xval++); \
-        } \
-      delete[] val; \
-      loaded = true; \
-    }
-
-    static void _load_inr(std::FILE *file, int out[8], float *const voxsize=0) {
-      char item[1024],tmp1[64],tmp2[64];
-      out[0]=out[1]=out[2]=out[3]=out[5]=1; out[4]=out[6]=out[7]=-1;
-      std::fscanf(file,"%63s",item);
-      if(cimg::strncasecmp(item,"#INRIMAGE-4#{",13)!=0)
-        throw CImgIOException("CImg<%s>::get_load_inr() : File does not appear to be a valid INR file.\n"
-                              "(INRIMAGE-4 identifier not found)",pixel_type());
-      while (std::fscanf(file," %63[^\n]%*c",item)!=EOF && cimg::strncmp(item,"##}",3)) {
-        std::sscanf(item," XDIM%*[^0-9]%d",out);
-        std::sscanf(item," YDIM%*[^0-9]%d",out+1);
-        std::sscanf(item," ZDIM%*[^0-9]%d",out+2);
-        std::sscanf(item," VDIM%*[^0-9]%d",out+3);
-        std::sscanf(item," PIXSIZE%*[^0-9]%d",out+6);
-        if (voxsize) {
-          std::sscanf(item," VX%*[^0-9.eE+-]%f",voxsize);
-          std::sscanf(item," VY%*[^0-9.eE+-]%f",voxsize+1);
-          std::sscanf(item," VZ%*[^0-9.eE+-]%f",voxsize+2);
-        }
-        if (std::sscanf(item," CPU%*[ =]%s",tmp1)) out[7]=cimg::strncasecmp(tmp1,"sun",3)?0:1;
-        switch(std::sscanf(item," TYPE%*[ =]%s %s",tmp1,tmp2)) {
-        case 0: break;
-        case 2: out[5] = cimg::strncasecmp(tmp1,"unsigned",8)?1:0; std::strcpy(tmp1,tmp2);
-        case 1:
-          if (!cimg::strncasecmp(tmp1,"int",3)   || !cimg::strncasecmp(tmp1,"fixed",5))  out[4]=0;
-          if (!cimg::strncasecmp(tmp1,"float",5) || !cimg::strncasecmp(tmp1,"double",6)) out[4]=1;
-          if (!cimg::strncasecmp(tmp1,"packed",6))                                       out[4]=2;
-          if (out[4]>=0) break;
-        default: throw CImgIOException("cimg::inr_header_read() : Invalid TYPE '%s'",tmp2);
-        }
-      }
-      if(out[0]<0 || out[1]<0 || out[2]<0 || out[3]<0)
-        throw CImgIOException("CImg<%s>::get_load_inr() : Bad dimensions in .inr file = ( %d , %d , %d , %d )",
-                              pixel_type(),out[0],out[1],out[2],out[3]);
-      if(out[4]<0 || out[5]<0) throw CImgIOException("CImg<%s>::get_load_inr() : TYPE is not fully defined",pixel_type());
-      if(out[6]<0) throw CImgIOException("CImg<%s>::get_load_inr() : PIXSIZE is not fully defined",pixel_type());
-      if(out[7]<0) throw CImgIOException("CImg<%s>::get_load_inr() : Big/Little Endian coding type is not defined",pixel_type());
-    }
-
-    //! Load an image from an INRIMAGE-4 file.
-    static CImg get_load_inr(std::FILE *const file, const char *const filename=0, float *voxsize=0) {
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      int fopt[8], endian=cimg::endian()?1:0;
-      bool loaded = false;
-      if (voxsize) voxsize[0]=voxsize[1]=voxsize[2]=1;
-      _load_inr(nfile,fopt,voxsize);
-      CImg<T> dest(fopt[0],fopt[1],fopt[2],fopt[3]);
-      cimg_load_inr_case(0,0,8, unsigned char);
-      cimg_load_inr_case(0,1,8, char);
-      cimg_load_inr_case(0,0,16,unsigned short);
-      cimg_load_inr_case(0,1,16,short);
-      cimg_load_inr_case(0,0,32,unsigned int);
-      cimg_load_inr_case(0,1,32,int);
-      cimg_load_inr_case(1,0,32,float);
-      cimg_load_inr_case(1,1,32,float);
-      cimg_load_inr_case(1,0,64,double);
-      cimg_load_inr_case(1,1,64,double);
-      if (!loaded) {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_inr() : File '%s', cannot read images of the type specified in the file",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-      if (!file) cimg::fclose(nfile);
-      return dest;
-    }
-
-    //! Load an image from an INRIMAGE-4 file.
-    static CImg get_load_inr(const char *const filename, float *const voxsize=0) {
-      return get_load_inr(0,filename,voxsize);
-    }
-
-    //! In-place version of get_load_inr()
-    CImg& load_inr(std::FILE *const file, const char *const filename=0, float *const voxsize=0) {
-      return get_load_inr(file,filename,voxsize).swap(*this);
-    }
-
-    //! In-place version of get_load_inr()
-    CImg& load_inr(const char *const filename, float *const voxsize=0) {
-      return get_load_inr(filename,voxsize).swap(*this);
-    }
-
-#define cimg_load_pandore_case(nid,nbdim,nwidth,nheight,ndepth,ndim,stype) \
-  case nid: { \
-    cimg::fread(dims,nbdim,nfile); \
-    if (endian) cimg::endian_swap(dims,nbdim); \
-    dest.assign(nwidth,nheight,ndepth,ndim); \
-    stype *buffer = new stype[dest.size()]; \
-    cimg::fread(buffer,dest.size(),nfile); \
-    if (endian) cimg::endian_swap(buffer,dest.size()); \
-    T *ptrd = dest.ptr(); \
-    cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++); \
-    buffer-=dest.size(); \
-    delete[] buffer; \
-   } \
-   break;
-
-    //! Load an image from a PANDORE-5 file.
-    static CImg get_load_pandore(std::FILE *const file, const char *const filename=0) {
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      typedef unsigned char uchar;
-      /* Don't use these two and they cause warnings.
-       *
-      typedef unsigned short ushort;
-      typedef unsigned int uint;
-       */
-      typedef unsigned long ulong;
-      CImg dest;
-      char tmp[32];
-      cimg::fread(tmp,12,nfile);
-      if (cimg::strncasecmp("PANDORE",tmp,7)) {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_pandore() : File '%s' is not a valid PANDORE file.\n"
-                              "(PANDORE identifier not found).",pixel_type(),filename?filename:"(FILE*)");
-      }
-      unsigned int imageid,dims[8];
-      int ptbuf[4];
-      cimg::fread(&imageid,1,nfile);
-      const bool endian = (imageid>255);
-      if (endian) cimg::endian_swap(imageid);
-
-      cimg::fread(tmp,20,nfile);
-      switch (imageid) {
-        cimg_load_pandore_case(2,2,dims[1],1,1,1,uchar);
-        cimg_load_pandore_case(3,2,dims[1],1,1,1,long);
-        cimg_load_pandore_case(4,2,dims[1],1,1,1,float);
-        cimg_load_pandore_case(5,3,dims[2],dims[1],1,1,uchar);
-        cimg_load_pandore_case(6,3,dims[2],dims[1],1,1,long);
-        cimg_load_pandore_case(7,3,dims[2],dims[1],1,1,float);
-        cimg_load_pandore_case(8,4,dims[3],dims[2],dims[1],1,uchar);
-        cimg_load_pandore_case(9,4,dims[3],dims[2],dims[1],1,long);
-        cimg_load_pandore_case(10,4,dims[3],dims[2],dims[1],1,float);
-
-      case 11: { // Region 1D
-        cimg::fread(dims,3,nfile);
-        if (endian) cimg::endian_swap(dims,3);
-        dest.assign(dims[1],1,1,1);
-        if (dims[2]<256) {
-          unsigned char *buffer = new unsigned char[dest.size()];
-          cimg::fread(buffer,dest.size(),nfile);
-          T *ptrd = dest.ptr();
-          cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++);
-          buffer-=dest.size();
-          delete[] buffer;
-        } else {
-          if (dims[2]<65536) {
-            unsigned short *buffer = new unsigned short[dest.size()];
-            cimg::fread(buffer,dest.size(),nfile);
-            if (endian) cimg::endian_swap(buffer,dest.size());
-            T *ptrd = dest.ptr();
-            cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++);
-            buffer-=dest.size();
-            delete[] buffer;
-          } else {
-            unsigned int *buffer = new unsigned int[dest.size()];
-            cimg::fread(buffer,dest.size(),nfile);
-            if (endian) cimg::endian_swap(buffer,dest.size());
-            T *ptrd = dest.ptr();
-            cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++);
-            buffer-=dest.size();
-            delete[] buffer;
-          }
-        }
-      }
-        break;
-      case 12: { // Region 2D
-        cimg::fread(dims,4,nfile);
-        if (endian) cimg::endian_swap(dims,4);
-        dest.assign(dims[2],dims[1],1,1);
-        if (dims[3]<256) {
-          unsigned char *buffer = new unsigned char[dest.size()];
-          cimg::fread(buffer,dest.size(),nfile);
-          T *ptrd = dest.ptr();
-          cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++);
-          buffer-=dest.size();
-          delete[] buffer;
-        } else {
-          if (dims[3]<65536) {
-            unsigned short *buffer = new unsigned short[dest.size()];
-            cimg::fread(buffer,dest.size(),nfile);
-            if (endian) cimg::endian_swap(buffer,dest.size());
-            T *ptrd = dest.ptr();
-            cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++);
-            buffer-=dest.size();
-            delete[] buffer;
-          } else {
-            unsigned long *buffer = new unsigned long[dest.size()];
-            cimg::fread(buffer,dest.size(),nfile);
-            if (endian) cimg::endian_swap(buffer,dest.size());
-            T *ptrd = dest.ptr();
-            cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++);
-            buffer-=dest.size();
-            delete[] buffer;
-          }
-        }
-      }
-        break;
-      case 13: { // Region 3D
-        cimg::fread(dims,5,nfile);
-        if (endian) cimg::endian_swap(dims,5);
-        dest.assign(dims[3],dims[2],dims[1],1);
-        if (dims[4]<256) {
-          unsigned char *buffer = new unsigned char[dest.size()];
-          cimg::fread(buffer,dest.size(),nfile);
-          T *ptrd = dest.ptr();
-          cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++);
-          buffer-=dest.size();
-          delete[] buffer;
-        } else {
-          if (dims[4]<65536) {
-            unsigned short *buffer = new unsigned short[dest.size()];
-            cimg::fread(buffer,dest.size(),nfile);
-            if (endian) cimg::endian_swap(buffer,dest.size());
-            T *ptrd = dest.ptr();
-            cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++);
-            buffer-=dest.size();
-            delete[] buffer;
-          } else {
-            unsigned int *buffer = new unsigned int[dest.size()];
-            cimg::fread(buffer,dest.size(),nfile);
-            if (endian) cimg::endian_swap(buffer,dest.size());
-            T *ptrd = dest.ptr();
-            cimg_foroff(dest,off) *(ptrd++) = (T)*(buffer++);
-            buffer-=dest.size();
-            delete[] buffer;
-          }
-        }
-      }
-        break;
-        cimg_load_pandore_case(16,4,dims[2],dims[1],1,3,uchar);
-        cimg_load_pandore_case(17,4,dims[2],dims[1],1,3,long);
-        cimg_load_pandore_case(18,4,dims[2],dims[1],1,3,float);
-        cimg_load_pandore_case(19,5,dims[3],dims[2],dims[1],3,uchar);
-        cimg_load_pandore_case(20,5,dims[3],dims[2],dims[1],3,long);
-        cimg_load_pandore_case(21,5,dims[3],dims[2],dims[1],3,float);
-        cimg_load_pandore_case(22,2,dims[1],1,1,dims[0],uchar);
-        cimg_load_pandore_case(23,2,dims[1],1,1,dims[0],long);
-        cimg_load_pandore_case(24,2,dims[1],1,1,dims[0],ulong);
-        cimg_load_pandore_case(25,2,dims[1],1,1,dims[0],float);
-        cimg_load_pandore_case(26,3,dims[2],dims[1],1,dims[0],uchar);
-        cimg_load_pandore_case(27,3,dims[2],dims[1],1,dims[0],long);
-        cimg_load_pandore_case(28,3,dims[2],dims[1],1,dims[0],ulong);
-        cimg_load_pandore_case(29,3,dims[2],dims[1],1,dims[0],float);
-        cimg_load_pandore_case(30,4,dims[3],dims[2],dims[1],dims[0],uchar);
-        cimg_load_pandore_case(31,4,dims[3],dims[2],dims[1],dims[0],long);
-        cimg_load_pandore_case(32,4,dims[3],dims[2],dims[1],dims[0],ulong);
-        cimg_load_pandore_case(33,4,dims[3],dims[2],dims[1],dims[0],float);
-      case 34: // Points 1D
-        cimg::fread(ptbuf,1,nfile);
-        if (endian) cimg::endian_swap(ptbuf,1);
-        dest.assign(1); dest[0]=(T)ptbuf[0];
-        break;
-      case 35: // Points 2D
-        cimg::fread(ptbuf,2,nfile);
-        if (endian) cimg::endian_swap(ptbuf,2);
-        dest.assign(2); dest[0]=(T)ptbuf[1]; dest[1]=(T)ptbuf[0];
-        break;
-      case 36: // Points 3D
-        cimg::fread(ptbuf,3,nfile);
-        if (endian) cimg::endian_swap(ptbuf,3);
-        dest.assign(3); dest[0]=(T)ptbuf[2]; dest[1]=(T)ptbuf[1]; dest[2]=(T)ptbuf[0];
-        break;
-      default:
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::get_load_pandore() : File '%s', cannot read images with ID_type=%u",
-                              pixel_type(),filename?filename:"(FILE*)",imageid);
-      }
-      if (!file) cimg::fclose(nfile);
-      return dest;
-    }
-
-    //! Load an image from a PANDORE-5 file.
-    static CImg get_load_pandore(const char *const filename) {
-      return get_load_pandore(0,filename);
-    }
-
-    //! In-place version of get_load_pandore()
-    CImg& load_pandore(std::FILE *const file, const char *const filename) {
-      return get_load_pandore(file,filename).swap(*this);
-    }
-
-    //! In-place version of get_load_pandore()
-    CImg& load_pandore(const char *const filename) {
-      return get_load_pandore(filename).swap(*this);
-    }
-
-    //! Load an image from an ANALYZE7.5 file
-    static CImg get_load_analyze(const char *const filename, float *const voxsize=0) {
-
-      // Open header and data files
-      std::FILE *file_header=0, *file=0;
-      char body[1024];
-      const char *ext = cimg::filename_split(filename,body);
-      if (!cimg::strncasecmp(ext,"hdr",3) ||
-          !cimg::strncasecmp(ext,"img",3)) {
-        std::sprintf(body+cimg::strlen(body),".hdr");
-        file_header = cimg::fopen(body,"rb");
-        if (!file_header) return CImg<T>();
-        std::sprintf(body+cimg::strlen(body)-3,"img");
-        file = cimg::fopen(body,"rb");
-        if (!file) { cimg::fclose(file_header); return CImg<T>(); }
-      } else throw CImgIOException("CImg<%s>::get_load_analyze() : Filename '%s', not recognized as an Analyze 7.5 file.",
-                                   pixel_type(),filename);
-
-      // Read header
-      bool endian = false;
-      unsigned int header_size;
-      cimg::fread(&header_size,1,file_header);
-      if (header_size>=4096) { endian = true; cimg::endian_swap(header_size); }
-      unsigned char *header = new unsigned char[header_size];
-      cimg::fread(header+4,header_size-4,file_header);
-      cimg::fclose(file_header);
-      if (endian) {
-        cimg::endian_swap((short*)(header+40),5);
-        cimg::endian_swap((short*)(header+70),1);
-        cimg::endian_swap((short*)(header+72),1);
-        cimg::endian_swap((float*)(header+76),4);
-        cimg::endian_swap((float*)(header+112),1);
-      }
-      unsigned short *dim = (unsigned short*)(header+40), dimx=1, dimy=1, dimz=1, dimv=1;
-      cimg::warn(!dim[0],"CImg<%s>::get_load_analyze() : Specified image has zero dimensions.",pixel_type());
-      cimg::warn(dim[0]>4,"CImg<%s>::get_load_analyze() : Number of image dimension is %d, reading only the 4 first dimensions",
-                 pixel_type(),dim[0]);
-      if (dim[0]>=1) dimx = dim[1];
-      if (dim[0]>=2) dimy = dim[2];
-      if (dim[0]>=3) dimz = dim[3];
-      if (dim[0]>=4) dimv = dim[4];
-
-      float scalefactor = *(float*)(header+112); if (scalefactor==0) scalefactor=1;
-      const unsigned short datatype = *(short*)(header+70);
-      if (voxsize) { const float *vsize = (float*)(header+76); voxsize[0] = vsize[1]; voxsize[1] = vsize[2]; voxsize[2] = vsize[3]; }
-      delete[] header;
-
-      // Read pixel data
-      CImg dest(dimx,dimy,dimz,dimv);
-      switch (datatype) {
-      case 2: {
-        unsigned char *buffer = new unsigned char[dimx*dimy*dimz*dimv];
-        cimg::fread(buffer,dimx*dimy*dimz*dimv,file);
-        cimg_foroff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-        delete[] buffer;
-      } break;
-      case 4: {
-        short *buffer = new short[dimx*dimy*dimz*dimv];
-        cimg::fread(buffer,dimx*dimy*dimz*dimv,file);
-        if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-        cimg_foroff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-        delete[] buffer;
-      } break;
-      case 8: {
-        int *buffer = new int[dimx*dimy*dimz*dimv];
-        cimg::fread(buffer,dimx*dimy*dimz*dimv,file);
-        if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-        cimg_foroff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-        delete[] buffer;
-      } break;
-      case 16: {
-        float *buffer = new float[dimx*dimy*dimz*dimv];
-        cimg::fread(buffer,dimx*dimy*dimz*dimv,file);
-        if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-        cimg_foroff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-        delete[] buffer;
-      } break;
-      case 64: {
-        double *buffer = new double[dimx*dimy*dimz*dimv];
-        cimg::fread(buffer,dimx*dimy*dimz*dimv,file);
-        if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-        cimg_foroff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-        delete[] buffer;
-      } break;
-      default:
-        cimg::fclose(file);
-        throw CImgIOException("CImg<%s>::get_load_analyze() : File '%s, cannot read images width 'datatype = %d'",
-                              pixel_type(),filename,datatype);
-      }
-      cimg::fclose(file);
-      return dest;
-    }
-
-    //! In-place version of get_load_analyze()
-    CImg& load_analyze(const char *const filename, float *const voxsize = 0) {
-      return get_load_analyze(filename,voxsize).swap(*this);
-    }
-
-    //! Load PAR-REC (Philips) image file
-    static CImg get_load_parrec(const char *const filename, const char axe='v', const char align='p') {
-      return CImgList<T>::get_load_parrec(filename).get_append(axe,align);
-    }
-
-    //! In-place version of get_load_parrec()
-    CImg& load_parrec(const char *const filename, const char axis='v', const char align='p') {
-      return get_load_parrec(filename,axis,align).swap(*this);
-    }
-
-    //! Load an image from a CImg RAW file
-    static CImg get_load_cimg(std::FILE *const file, const char *const filename=0, const char axis='v', const char align='p') {
-      return CImgList<T>::get_load_cimg(file,filename).get_append(axis,align);
-    }
-
-    //! Load an image from a CImg RAW file
-    static CImg get_load_cimg(const char *const filename, const char axis='v', const char align='p') {
-      return get_load_cimg(0,filename,axis,align);
-    }
-
-    //! In-place version of get_load_cimg()
-    CImg& load_cimg(std::FILE *const file, const char *const filename=0, const char axis='v', const char align='p') {
-      return get_load_cimg(file,filename,axis,align).swap(*this);
-    }
-
-    //! In-place version of get_load_cimg()
-    CImg& load_cimg(const char *const filename, const char axis='v', const char align='p') {
-      return get_load_cimg(filename,axis,align).swap(*this);
-    }
-
-    //! Function that loads the image for other file formats that are not natively handled by CImg.
-    //! This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...).
-    static CImg get_load_imagemagick(const char *const filename) {
-      static bool first_time = true;
-      char command[1024], filetmp[512];
-      if (first_time) { std::srand((unsigned int)::time(0)); first_time = false; }
-      std::FILE *file = 0;
-      do {
-        std::sprintf(filetmp,"%s%sCImg%.4d.ppm",cimg::temporary_path(),cimg_OS==2?"\\":"/",std::rand()%10000);
-        if ((file=std::fopen(filetmp,"rb"))!=0) std::fclose(file);
-      } while (file);
-      std::sprintf(command,"%s \"%s\" %s",cimg::imagemagick_path(),filename,filetmp);
-      cimg::system(command,cimg::imagemagick_path());
-      if (!(file = std::fopen(filetmp,"rb"))) {
-        cimg::fclose(cimg::fopen(filename,"r"));
-        throw CImgIOException("CImg<%s>::get_load_imagemagick() : Failed to open image '%s'.\n\n"
-                              "Path of 'ImageMagick's convert' : \"%s\"\n"
-                              "Path of temporary filename : \"%s\"",
-                              pixel_type(),filename,cimg::imagemagick_path(),filetmp);
-      } else cimg::fclose(file);
-      const CImg dest = CImg<T>::get_load_pnm(filetmp);
-      std::remove(filetmp);
-      return dest;
-    }
-
-    //! In-place version of get_load_imagemagick()
-    CImg& load_imagemagick(const char *const filename) {
-      return get_load_imagemagick(filename).swap(*this);
-    }
-
-    //! Function that loads the image for other file formats that are not natively handled by CImg.
-    //! This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...).
-    static CImg get_load_graphicsmagick(const char *const filename) {
-      static bool first_time = true;
-      char command[1024], filetmp[512];
-      if (first_time) { std::srand((unsigned int)::time(0)); first_time = false; }
-      std::FILE *file = 0;
-      do {
-        std::sprintf(filetmp,"%s%sCImg%.4d.ppm",cimg::temporary_path(),cimg_OS==2?"\\":"/",std::rand()%10000);
-        if ((file=std::fopen(filetmp,"rb"))!=0) std::fclose(file);
-      } while (file);
-      std::sprintf(command,"%s convert \"%s\" %s",cimg::graphicsmagick_path(),filename,filetmp);
-      cimg::system(command,cimg::graphicsmagick_path());
-      if (!(file = std::fopen(filetmp,"rb"))) {
-        cimg::fclose(cimg::fopen(filename,"r"));
-        throw CImgIOException("CImg<%s>::get_load_graphicsmagick() : Failed to open image '%s'.\n\n"
-                              "Path of 'GraphicsMagick's gm' : \"%s\"\n"
-                              "Path of temporary filename : \"%s\"",
-                              pixel_type(),filename,cimg::graphicsmagick_path(),filetmp);
-      } else cimg::fclose(file);
-      const CImg dest = CImg<T>::get_load_pnm(filetmp);
-      std::remove(filetmp);
-      return dest;
-    }
-
-    //! In-place version of get_load_graphicsmagick()
-    CImg& load_graphicsmagick(const char *const filename) {
-      return get_load_graphicsmagick(filename).swap(*this);
-    }
-
-    //! Function that loads the image for other file formats that are not natively handled by CImg.
-    //! This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...).
-    static CImg get_load_other(const char *const filename) {
-      CImg<T> res;
-      const unsigned int odebug = cimg::exception_mode();
-      cimg::exception_mode() = 0;
-      try { res.load_magick(filename); }
-      catch (CImgException&) {
-	try { res.load_imagemagick(filename); }
-	catch (CImgException&) {
-	  try { res.load_graphicsmagick(filename); }
-	  catch (CImgException&) {
-	    res.assign();
-	  }
-	}
-      }
-      cimg::exception_mode()=odebug;
-      if (res.is_empty())
-        throw CImgIOException("CImg<%s>::get_load_other() : Failed to open image '%s'.\n"
-                              "Check you have either the ImageMagick or GraphicsMagick package installed.",
-                              pixel_type(),filename);
-      return res;
-    }
-
-    //! In-place version of get_load_graphicsmagick()
-    CImg& load_other(const char *const filename) {
-      return get_load_other(filename).swap(*this);
-    }
-
-    //! Load an image from a Dicom file (need '(X)Medcon' : http://xmedcon.sourceforge.net )
-    static CImg get_load_dicom(const char *const filename) {
-      static bool first_time = true;
-      char command[1024], filetmp[512], body[512];
-      if (first_time) { std::srand((unsigned int)::time(0)); first_time = false; }
-      cimg::fclose(cimg::fopen(filename,"r"));
-      std::FILE *file;
-      do {
-        std::sprintf(filetmp,"CImg%.4d.hdr",std::rand()%10000);
-        if ((file=std::fopen(filetmp,"rb"))!=0) std::fclose(file);
-      } while (file);
-      std::sprintf(command,"%s -w -c anlz -o %s -f %s",cimg::medcon_path(),filetmp,filename);
-      cimg::system(command);
-      cimg::filename_split(filetmp,body);
-      std::sprintf(command,"m000-%s.hdr",body);
-      file = std::fopen(command,"rb");
-      if (!file) {
-        throw CImgIOException("CImg<%s>::get_load_dicom() : Failed to open image '%s'.\n\n"
-                              "Path of 'medcon' : \"%s\"\n"
-                              "Path of temporary filename : \"%s\"",
-                              pixel_type(),filename,cimg::medcon_path,filetmp);
-      } else cimg::fclose(file);
-      const CImg dest = CImg<T>::get_load_analyze(command);
-      std::remove(command);
-      std::sprintf(command,"m000-%s.img",body);
-      std::remove(command);
-      return dest;
-    }
-
-    //! In-place version of get_load_dicom()
-    CImg& load_dicom(const char *const filename) {
-      return get_load_dicom(filename).swap(*this);
-    }
-
-    //! Load OFF files (GeomView 3D object files)
-    template<typename tf,typename tc>
-    static CImg<T> get_load_off(const char *const filename, CImgList<tf>& primitives, CImgList<tc>& colors,
-                                const bool invert_faces=false) {
-      std::FILE *file=cimg::fopen(filename,"r");
-      unsigned int nb_points=0, nb_triangles=0;
-      int err;
-      if ((err = std::fscanf(file,"OFF%u%u%*[^\n]",&nb_points,&nb_triangles))!=2) {
-        cimg::fclose(file);
-        throw CImgIOException("CImg<%s>::get_load_off() : File '%s' is not a valid OFF file.",pixel_type(),filename);
-      }
-
-      // Read points data
-      CImg<T> points(nb_points,3);
-      float X=0,Y=0,Z=0;
-      cimg_forX(points,l) {
-        if ((err = std::fscanf(file,"%f%f%f%*[^\n]",&X,&Y,&Z))!=3) {
-          cimg::fclose(file);
-          throw CImgIOException("CImg<%s>::get_load_off() : File '%s', cannot read point %u.\n",pixel_type(),filename,l);
-        }
-        points(l,0) = (T)X; points(l,1) = (T)Y; points(l,2) = (T)Z;
-      }
-
-      // Read primitive data
-      primitives.assign();
-      colors.assign();
-      bool stopflag = false;
-      while (!stopflag) {
-        unsigned int prim=0, i0=0, i1=0, i2=0, i3=0;
-        char s_colors[256] = {'\0'};
-        if ((err = std::fscanf(file,"%u",&prim))!=1) stopflag=true;
-        else switch (prim) {
-        case 3: {
-          if ((err = std::fscanf(file,"%u%u%u%255[^\n]",&i0,&i1,&i2,s_colors))<3) stopflag = true;
-          else {
-            float c0=0.5, c1=0.5, c2=0.5;
-            std::sscanf(s_colors,"%f%f%f",&c0,&c1,&c2);
-            if (invert_faces) primitives.insert(CImg<tf>::vector(i0,i1,i2));
-            else primitives.insert(CImg<tf>::vector(i0,i2,i1));
-            colors.insert(CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255)));
-          }
-        } break;
-        case 4: {
-          if ((err = std::fscanf(file,"%u%u%u%u%255[^\n]",&i0,&i1,&i2,&i3,s_colors))<4) stopflag = true;
-          else {
-            float c0=0.5, c1=0.5, c2=0.5;
-            std::sscanf(s_colors,"%f%f%f",&c0,&c1,&c2);
-            if (invert_faces) primitives.insert(CImg<tf>::vector(i0,i1,i2,i3));
-            else primitives.insert(CImg<tf>::vector(i0,i3,i2,i1));
-            colors.insert(CImg<tc>::vector((tc)(c0*255),(tc)(c1*255),(tc)(c2*255),(tc)(c2*255)));
-          }
-        } break;
-        default: stopflag = true;
-        }
-      }
-      cimg::fclose(file);
-      cimg::warn(primitives.size!=nb_triangles,
-                 "CImg<%s>::get_load_off() : File '%s' contained %u triangles instead of %u as claimed in the header.",
-                 pixel_type(),filename,primitives.size,nb_triangles);
-      return points;
-    }
-
-    //! In-place version of get_load_off()
-    template<typename tf,typename tc>
-    CImg& load_off(const char *const filename, CImgList<tf>& primitives, CImgList<tc>& colors, const bool invert_faces=false) {
-      return get_load_off(filename,primitives,colors,invert_faces).swap(*this);
-    }
-
-    //! Save the image as a file.
-    /**
-       The used file format is defined by the file extension in the filename \p filename.\n
-       Parameter \p number can be used to add a 6-digit number to the filename before saving.\n
-       If \p normalize is true, a normalized version of the image (between [0,255]) is saved.
-    **/
-    const CImg& save(const char *const filename, const int number=-1) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename);
-      if (!filename) throw CImgArgumentException("CImg<%s>::save() : Instance image (%u,%u,%u,%u,%p), specified filename is (null).",
-                                                 pixel_type(),width,height,depth,dim,data);
-      const char *ext = cimg::filename_split(filename);
-      char nfilename[1024];
-      const char *const fn = (number>=0)?cimg::filename_number(filename,number,6,nfilename):filename;
-      if (!cimg::strncasecmp(ext,"asc",3)) return save_ascii(fn);
-      if (!cimg::strncasecmp(ext,"dlm",3) ||
-          !cimg::strncasecmp(ext,"txt",3)) return save_dlm(fn);
-      if (!cimg::strncasecmp(ext,"inr",3)) return save_inr(fn);
-      if (!cimg::strncasecmp(ext,"hdr",3)) return save_analyze(fn);
-      if (!cimg::strncasecmp(ext,"dcm",3)) return save_dicom(fn);
-      if (!cimg::strncasecmp(ext,"pan",3)) return save_pandore(fn);
-      if (!cimg::strncasecmp(ext,"bmp",3)) return save_bmp(fn);
-      if (!cimg::strncasecmp(ext,"png",3)) return save_png(fn);
-      if (!cimg::strncasecmp(ext,"tif",3)) return save_tiff(fn);
-      if (!cimg::strncasecmp(ext,"jpg",3) ||
-          !cimg::strncasecmp(ext,"jpeg",4)) return save_jpeg(fn);
-      if (!cimg::strncasecmp(ext,"rgba",4)) return save_rgba(fn);
-      if (!cimg::strncasecmp(ext,"rgb",3)) return save_rgb(fn);
-      if (!cimg::strncasecmp(ext,"raw",3)) return save_raw(fn);
-      if (!cimg::strncasecmp(ext,"cimg",4) || ext[0]=='\0') return save_cimg(fn);
-      if (!cimg::strncasecmp(ext,"pgm",3) ||
-          !cimg::strncasecmp(ext,"ppm",3) ||
-          !cimg::strncasecmp(ext,"pnm",3)) return save_pnm(fn);
-      if (!cimg::strncasecmp(ext,"yuv",3)) return save_yuv(fn,true);
-      return save_other(fn);
-    }
-
-    //! Save the image as an ASCII file (ASCII Raw + simple header).
-    const CImg& save_ascii(std::FILE *const file, const char *const filename=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_ascii() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_ascii() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"w");
-      std::fprintf(nfile,"%u %u %u %u\n",width,height,depth,dim);
-      const T* ptrs = data;
-      cimg_forYZV(*this,y,z,v) {
-        cimg_forX(*this,x) std::fprintf(nfile,"%g ",(double)*(ptrs++));
-        std::fputc('\n',nfile);
-      }
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save the image as an ASCII file (ASCII Raw + simple header).
-    const CImg& save_ascii(const char *const filename) const {
-      return save_ascii(0,filename);
-    }
-
-    //! Save the image as a DLM file.
-    const CImg& save_dlm(std::FILE *const file, const char *const filename=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_dlm() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_dlm() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      cimg::warn(depth>1,
-                 "CImg<%s>::save_dlm() : Instance image (%u,%u,%u,%u,%p) is volumetric. Pixel values along Z will be unrolled (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      cimg::warn(dim>1,
-                 "CImg<%s>::save_dlm() : Instance image (%u,%u,%u,%u,%p) is multispectral. Pixel values along V will be unrolled (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"w");
-      const T* ptrs = data;
-      cimg_forYZV(*this,y,z,v) {
-        cimg_forX(*this,x) std::fprintf(nfile,"%g%s",(double)*(ptrs++),(x==(int)width-1)?"":",");
-        std::fputc('\n',nfile);
-      }
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save the image as a DLM file.
-    const CImg& save_dlm(const char *const filename) const {
-      return save_dlm(0,filename);
-    }
-
-    //! Save the image as a PNM file.
-    const CImg& save_pnm(std::FILE *const file, const char *const filename=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_pnm() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_pnm() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      const CImgStats st(*this,false);
-      cimg::warn(depth>1,
-                 "CImg<%s>::save_pnm() : Instance image (%u,%u,%u,%u,%p) is volumetric. Only the first slice will be saved (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      cimg::warn(dim>3,
-                 "CImg<%s>::save_pnm() : Instance image (%u,%u,%u,%u,%p) is multispectral. Only the three first channels will be saved (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      const double stmin = st.min, stmax = st.max;
-      cimg::warn(stmin<0 || stmax>65535,"CImg<%s>::save_pnm() : Instance image (%u,%u,%u,%u,%p) has pixel values in [%g,%g]. Probable type overflow (file '%s').",pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      const T
-        *ptrR = ptr(0,0,0,0),
-        *ptrG = (dim>=2)?ptr(0,0,0,1):ptrR,
-        *ptrB = (dim>=3)?ptr(0,0,0,2):ptrR;
-      const unsigned int buf_size = width*height*(dim==1?1:3);
-
-      std::fprintf(nfile,"P%c\n# CREATOR: CImg : Original size=%ux%ux%ux%u\n%u %u\n%u\n",
-                   (dim==1?'5':'6'),width,height,depth,dim,width,height,(st.max)<256?255:65535);
-
-      switch(dim) {
-      case 1: {
-        if ((st.max)<256) { // Binary PGM 8 bits
-          unsigned char *ptrd = new unsigned char[buf_size], *xptrd = ptrd;
-          cimg_forXY(*this,x,y) *(xptrd++) = (unsigned char)*(ptrR++);
-          cimg::fwrite(ptrd,buf_size,nfile);
-          delete[] ptrd;
-        } else {             // Binary PGM 16 bits
-          unsigned short *ptrd = new unsigned short[buf_size], *xptrd = ptrd;
-          cimg_forXY(*this,x,y) *(xptrd++) = (unsigned short)*(ptrR++);
-          if (!cimg::endian()) cimg::endian_swap(ptrd,buf_size);
-          cimg::fwrite(ptrd,buf_size,nfile);
-          delete[] ptrd;
-        }
-      } break;
-      default: {
-        if ((st.max)<256) { // Binary PPM 8 bits
-          unsigned char *ptrd = new unsigned char[buf_size], *xptrd = ptrd;
-          cimg_forXY(*this,x,y) {
-            *(xptrd++) = (unsigned char)*(ptrR++);
-            *(xptrd++) = (unsigned char)*(ptrG++);
-            *(xptrd++) = (unsigned char)*(ptrB++);
-          }
-          cimg::fwrite(ptrd,buf_size,nfile);
-          delete[] ptrd;
-        } else {             // Binary PPM 16 bits
-          unsigned short *ptrd = new unsigned short[buf_size], *xptrd = ptrd;
-          cimg_forXY(*this,x,y) {
-            *(xptrd++) = (unsigned short)*(ptrR++);
-            *(xptrd++) = (unsigned short)*(ptrG++);
-            *(xptrd++) = (unsigned short)*(ptrB++);
-          }
-          if (!cimg::endian()) cimg::endian_swap(ptrd,buf_size);
-          cimg::fwrite(ptrd,buf_size,nfile);
-          delete[] ptrd;
-        }
-      } break;
-      }
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save the image as a PNM file.
-    const CImg& save_pnm(const char *const filename) const {
-      return save_pnm(0,filename);
-    }
-
-    //! Save an image as a Dicom file (need '(X)Medcon' : http://xmedcon.sourceforge.net )
-    const CImg& save_dicom(const char *const filename) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_dicom() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename);
-      if (!filename) throw CImgArgumentException("CImg<%s>::save_dicom() : Instance image (%u,%u,%u,%u,%p), specified filename is (null).",
-                                                 pixel_type(),width,height,depth,dim,data);
-      static bool first_time = true;
-      char command[1024], filetmp[512], body[512];
-      if (first_time) { std::srand((unsigned int)::time(0)); first_time = false; }
-      std::FILE *file;
-      do {
-        std::sprintf(filetmp,"CImg%.4d.hdr",std::rand()%10000);
-        if ((file=std::fopen(filetmp,"rb"))!=0) std::fclose(file);
-      } while (file);
-      save_analyze(filetmp);
-      std::sprintf(command,"%s -w -c dicom -o %s -f %s",cimg::medcon_path(),filename,filetmp);
-      cimg::system(command);
-      std::remove(filetmp);
-      cimg::filename_split(filetmp,body);
-      std::sprintf(filetmp,"%s.img",body);
-      std::remove(filetmp);
-      std::sprintf(command,"m000-%s",filename);
-      file = std::fopen(command,"rb");
-      if (!file) {
-        cimg::fclose(cimg::fopen(filename,"r"));
-        throw CImgIOException("CImg<%s>::save_dicom() : Failed to save image '%s'.\n\n"
-                              "Path of 'medcon' : \"%s\"\n"
-                              "Path of temporary filename : \"%s\"",
-                              pixel_type(),filename,cimg::medcon_path(),filetmp);
-      } else cimg::fclose(file);
-      std::rename(command,filename);
-      return *this;
-    }
-
-    //! Save the image as an ANALYZE7.5 file.
-    const CImg& save_analyze(const char *const filename, const float *const voxsize=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_analyze() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename);
-      if (!filename) throw CImgArgumentException("CImg<%s>::save_analyze() :  Instance image (%u,%u,%u,%u,%p), specified filename is (null).",
-                                                 pixel_type(),width,height,depth,dim,data);
-      std::FILE *file;
-      char header[348],hname[1024],iname[1024];
-      const char *ext = cimg::filename_split(filename);
-      short datatype=-1;
-      std::memset(header,0,348);
-      if (!ext[0]) { std::sprintf(hname,"%s.hdr",filename); std::sprintf(iname,"%s.img",filename); }
-      if (!cimg::strncasecmp(ext,"hdr",3)) {
-        std::strcpy(hname,filename); std::strcpy(iname,filename); std::sprintf(iname+cimg::strlen(iname)-3,"img");
-      }
-      if (!cimg::strncasecmp(ext,"img",3)) {
-        std::strcpy(hname,filename); std::strcpy(iname,filename); std::sprintf(hname+cimg::strlen(iname)-3,"hdr");
-      }
-      ((int*)(header))[0] = 348;
-      std::sprintf(header+4,"CImg");
-      std::sprintf(header+14," ");
-      ((short*)(header+36))[0] = 4096;
-      ((char*)(header+38))[0] = 114;
-      ((short*)(header+40))[0] = 4;
-      ((short*)(header+40))[1] = width;
-      ((short*)(header+40))[2] = height;
-      ((short*)(header+40))[3] = depth;
-      ((short*)(header+40))[4] = dim;
-      if (!cimg::strcasecmp(pixel_type(),"bool"))           datatype = 2;
-      if (!cimg::strcasecmp(pixel_type(),"unsigned char"))  datatype = 2;
-      if (!cimg::strcasecmp(pixel_type(),"char"))           datatype = 2;
-      if (!cimg::strcasecmp(pixel_type(),"unsigned short")) datatype = 4;
-      if (!cimg::strcasecmp(pixel_type(),"short"))          datatype = 4;
-      if (!cimg::strcasecmp(pixel_type(),"unsigned int"))   datatype = 8;
-      if (!cimg::strcasecmp(pixel_type(),"int"))            datatype = 8;
-      if (!cimg::strcasecmp(pixel_type(),"unsigned long"))  datatype = 8;
-      if (!cimg::strcasecmp(pixel_type(),"long"))           datatype = 8;
-      if (!cimg::strcasecmp(pixel_type(),"float"))          datatype = 16;
-      if (!cimg::strcasecmp(pixel_type(),"double"))         datatype = 64;
-      if (datatype<0)
-        throw CImgIOException("CImg<%s>::save_analyze() : Cannot save image '%s' since pixel type (%s)"
-                              "is not handled in Analyze7.5 specifications.\n",
-                              pixel_type(),filename,pixel_type());
-      ((short*)(header+70))[0] = datatype;
-      ((short*)(header+72))[0] = sizeof(T);
-      ((float*)(header+112))[0] = 1;
-      ((float*)(header+76))[0] = 0;
-      if (voxsize) {
-        ((float*)(header+76))[1] = voxsize[0];
-        ((float*)(header+76))[2] = voxsize[1];
-        ((float*)(header+76))[3] = voxsize[2];
-      } else ((float*)(header+76))[1] = ((float*)(header+76))[2] = ((float*)(header+76))[3] = 1;
-      file = cimg::fopen(hname,"wb");
-      cimg::fwrite(header,348,file);
-      cimg::fclose(file);
-      file = cimg::fopen(iname,"wb");
-      cimg::fwrite(data,size(),file);
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a CImg file (Binary RAW + simple header)
-    const CImg& save_cimg(std::FILE *const file, const char *const filename=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_cimg() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_cimg() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      CImgList<T> tmp(1);
-      tmp[0].width = width;
-      tmp[0].height = height;
-      tmp[0].depth = depth;
-      tmp[0].dim = dim;
-      tmp[0].data = data;
-      tmp.save_cimg(file,filename);
-      tmp[0].width = tmp[0].height = tmp[0].depth = tmp[0].dim = 0;
-      tmp[0].data = 0;
-      return *this;
-    }
-
-    //! Save the image as a CImg file (Binary RAW + simple header)
-    const CImg& save_cimg(const char *const filename) const {
-      return save_cimg(0,filename);
-    }
-
-    //! Save the image as a RAW file
-    const CImg& save_raw(std::FILE *const file, const char *const filename=0, const bool multiplexed=false) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_raw() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_raw() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      if (!multiplexed) cimg::fwrite(data,size(),nfile);
-      else {
-        CImg<T> buf(dim);
-        cimg_forXYZ(*this,x,y,z) {
-          cimg_forV(*this,k) buf[k] = (*this)(x,y,z,k);
-          cimg::fwrite(buf.data,dim,nfile);
-        }
-      }
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save the image as a RAW file
-    const CImg& save_raw(const char *const filename=0, const bool multiplexed=false) const {
-      return save_raw(0,filename,multiplexed);
-    }
-
-    //! Save the image using ImageMagick's convert.
-    /** Function that saves the image for other file formats that are not natively handled by CImg,
-        using the tool 'convert' from the ImageMagick package.\n
-        This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...). You need to install
-        the ImageMagick package in order to get
-        this function working properly (see http://www.imagemagick.org ).
-    **/
-    const CImg& save_imagemagick(const char *const filename, const unsigned int quality=100) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_imagemagick() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s')",
-                                                  pixel_type(),width,height,depth,dim,data,filename);
-      if (!filename) throw CImgArgumentException("CImg<%s>::save_imagemagick() : Instance image (%u,%u,%u,%u,%p), specified filename is (null).",
-                                                 pixel_type(),width,height,depth,dim,data);
-      static bool first_time = true;
-      char command[512],filetmp[512];
-      if (first_time) { std::srand((unsigned int)::time(0)); first_time = false; }
-      std::FILE *file;
-      do {
-        if (dim==1) std::sprintf(filetmp,"%s%sCImg%.4d.pgm",cimg::temporary_path(),cimg_OS==2?"\\":"/",std::rand()%10000);
-        else std::sprintf(filetmp,"%s%sCImg%.4d.ppm",cimg::temporary_path(),cimg_OS==2?"\\":"/",std::rand()%10000);
-        if ((file=std::fopen(filetmp,"rb"))!=0) std::fclose(file);
-      } while (file);
-      save_pnm(filetmp);
-      std::sprintf(command,"%s -quality %u%% %s \"%s\"",cimg::imagemagick_path(),quality,filetmp,filename);
-      cimg::system(command);
-      file = std::fopen(filename,"rb");
-      if (!file) throw CImgIOException("CImg<%s>::save_imagemagick() : Failed to save image '%s'.\n\n"
-                                       "Path of 'convert' : \"%s\"\n"
-                                       "Path of temporary filename : \"%s\"\n",
-                                       pixel_type(),filename,cimg::imagemagick_path(),filetmp);
-      if (file) cimg::fclose(file);
-      std::remove(filetmp);
-      return *this;
-    }
-
-    //! Save the image using GraphicsMagick's gm.
-    /** Function that saves the image for other file formats that are not natively handled by CImg,
-        using the tool 'gm' from the GraphicsMagick package.\n
-        This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...). You need to install
-        the GraphicsMagick package in order to get
-        this function working properly (see http://www.graphicsmagick.org ).
-    **/
-    const CImg& save_graphicsmagick(const char *const filename, const unsigned int quality=100) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_graphicsmagick() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s')",
-                                                  pixel_type(),width,height,depth,dim,data,filename);
-      if (!filename) throw CImgArgumentException("CImg<%s>::save_graphicsmagick() : Instance image (%u,%u,%u,%u,%p), specified filename is (null).",
-                                                 pixel_type(),width,height,depth,dim,data);
-      static bool first_time = true;
-      char command[512],filetmp[512];
-      if (first_time) { std::srand((unsigned int)::time(0)); first_time = false; }
-      std::FILE *file;
-      do {
-        if (dim==1) std::sprintf(filetmp,"%s%sCImg%.4d.pgm",cimg::temporary_path(),cimg_OS==2?"\\":"/",std::rand()%10000);
-        else std::sprintf(filetmp,"%s%sCImg%.4d.ppm",cimg::temporary_path(),cimg_OS==2?"\\":"/",std::rand()%10000);
-        if ((file=std::fopen(filetmp,"rb"))!=0) std::fclose(file);
-      } while (file);
-      save_pnm(filetmp);
-      std::sprintf(command,"%s -quality %u%% %s \"%s\"",cimg::graphicsmagick_path(),quality,filetmp,filename);
-      cimg::system(command);
-      file = std::fopen(filename,"rb");
-      if (!file) throw CImgIOException("CImg<%s>::save_graphicsmagick() : Failed to save image '%s'.\n\n"
-                                       "Path of 'gm' : \"%s\"\n"
-                                       "Path of temporary filename : \"%s\"\n",
-                                       pixel_type(),filename,cimg::graphicsmagick_path(),filetmp);
-      if (file) cimg::fclose(file);
-      std::remove(filetmp);
-      return *this;
-    }
-
-    const CImg& save_other(const char *const filename, const unsigned int quality=100) const {
-      const unsigned int odebug = cimg::exception_mode();
-      bool is_saved = true;
-      cimg::exception_mode() = 0;
-      try { save_magick(filename); }
-      catch (CImgException&) {
-	try { save_imagemagick(filename,quality); }
-	catch (CImgException&) {
-	  try { save_graphicsmagick(filename,quality); }
-	  catch (CImgException&) {
-	    is_saved = false;
-	  }
-	}
-      }
-      cimg::exception_mode() = odebug;
-      if (!is_saved) throw CImgIOException("CImg<%s>::save_other() : File '%s' cannot be saved.\n"
-                                           "Check you have either the ImageMagick or GraphicsMagick package installed.",
-                                           pixel_type(),filename);
-      return *this;
-    }
-
-    //! Save the image as an INRIMAGE-4 file.
-    const CImg& save_inr(std::FILE *const file, const char *const filename=0, const float *const voxsize=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_inr() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!filename) throw CImgArgumentException("CImg<%s>::save_inr() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                 pixel_type(),width,height,depth,dim,data);
-      int inrpixsize=-1;
-      const char *inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0";
-      if (!cimg::strcasecmp(pixel_type(),"unsigned char"))  { inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1; }
-      if (!cimg::strcasecmp(pixel_type(),"char"))           { inrtype = "fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1; }
-      if (!cimg::strcasecmp(pixel_type(),"unsigned short")) { inrtype = "unsigned fixed\nPIXSIZE=16 bits\nSCALE=2**0";inrpixsize = 2; }
-      if (!cimg::strcasecmp(pixel_type(),"short"))          { inrtype = "fixed\nPIXSIZE=16 bits\nSCALE=2**0"; inrpixsize = 2; }
-      if (!cimg::strcasecmp(pixel_type(),"unsigned int"))   { inrtype = "unsigned fixed\nPIXSIZE=32 bits\nSCALE=2**0";inrpixsize = 4; }
-      if (!cimg::strcasecmp(pixel_type(),"int"))            { inrtype = "fixed\nPIXSIZE=32 bits\nSCALE=2**0"; inrpixsize = 4; }
-      if (!cimg::strcasecmp(pixel_type(),"float"))          { inrtype = "float\nPIXSIZE=32 bits"; inrpixsize = 4; }
-      if (!cimg::strcasecmp(pixel_type(),"double"))         { inrtype = "float\nPIXSIZE=64 bits"; inrpixsize = 8; }
-      if (inrpixsize<=0) throw CImgIOException("CImg<%s>::save_inr() : Don't know how to save images of '%s'",pixel_type(),pixel_type());
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      char header[257];
-      int err = std::sprintf(header,"#INRIMAGE-4#{\nXDIM=%u\nYDIM=%u\nZDIM=%u\nVDIM=%u\n",width,height,depth,dim);
-      if (voxsize) err += std::sprintf(header+err,"VX=%g\nVY=%g\nVZ=%g\n",voxsize[0],voxsize[1],voxsize[2]);
-      err += std::sprintf(header+err,"TYPE=%s\nCPU=%s\n",inrtype,cimg::endian()?"sun":"decm");
-      std::memset(header+err,'\n',252-err);
-      std::memcpy(header+252,"##}\n",4);
-      cimg::fwrite(header,256,nfile);
-      cimg_forXYZ(*this,x,y,z) cimg_forV(*this,k) cimg::fwrite(&((*this)(x,y,z,k)),1,nfile);
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save the image as an INRIMAGE-4 file.
-    const CImg& save_inr(const char *const filename, const float *const voxsize=0) const {
-      return save_inr(0,filename,voxsize);
-    }
-
-#define cimg_save_pandore_case(sy,sz,sv,stype,id) \
-   if (!saved && (sy?(sy==height):true) && (sz?(sz==depth):true) && (sv?(sv==dim):true) && !strcmp(stype,pixel_type())) { \
-      unsigned int *iheader = (unsigned int*)(header+12); \
-      nbdims = _save_pandore_header_length((*iheader=id),dims,colorspace); \
-      cimg::fwrite(header,36,nfile); \
-      cimg::fwrite(dims,nbdims,nfile); \
-      if (id==2 || id==5 || id==8 || id==16 || id==19 || id==22 || id==26 || id==30) { \
-        unsigned char *buffer = new unsigned char[size()]; \
-        const T *ptrs = ptr(); \
-        cimg_foroff(*this,off) *(buffer++)=(unsigned char)(*(ptrs++)); \
-        buffer-=size(); \
-        cimg::fwrite(buffer,size(),nfile); \
-        delete[] buffer; \
-      } \
-      if (id==3 || id==6 || id==9 || id==17 || id==20 || id==23 || id==27 || id==31) { \
-        unsigned long *buffer = new unsigned long[size()]; \
-        const T *ptrs = ptr(); \
-        cimg_foroff(*this,off) *(buffer++)=(long)(*(ptrs++)); \
-        buffer-=size(); \
-        cimg::fwrite(buffer,size(),nfile); \
-        delete[] buffer; \
-      } \
-      if (id==4 || id==7 || id==10 || id==18 || id==21 || id==25 || id==29 || id==33) { \
-        float *buffer = new float[size()]; \
-        const T *ptrs = ptr(); \
-        cimg_foroff(*this,off) *(buffer++)=(float)(*(ptrs++)); \
-        buffer-=size(); \
-        cimg::fwrite(buffer,size(),nfile); \
-        delete[] buffer; \
-      } \
-      saved = true; \
-    }
-
-    unsigned int _save_pandore_header_length(unsigned int id,unsigned int *dims,const unsigned int colorspace=0) const {
-      unsigned int nbdims=0;
-      if (id==2 || id==3 || id==4)    { dims[0]=1; dims[1]=width; nbdims=2; }
-      if (id==5 || id==6 || id==7)    { dims[0]=1; dims[1]=height; dims[2]=width; nbdims=3; }
-      if (id==8 || id==9 || id==10)   { dims[0]=dim; dims[1]=depth; dims[2]=height; dims[3]=width; nbdims=4; }
-      if (id==16 || id==17 || id==18) { dims[0]=3; dims[1]=height; dims[2]=width; dims[3]=colorspace; nbdims=4; }
-      if (id==19 || id==20 || id==21) { dims[0]=3; dims[1]=depth; dims[2]=height; dims[3]=width; dims[4]=colorspace; nbdims=5; }
-      if (id==22 || id==23 || id==25) { dims[0]=dim; dims[1]=width; nbdims=2; }
-      if (id==26 || id==27 || id==29) { dims[0]=dim; dims[1]=height; dims[2]=width; nbdims=3; }
-      if (id==30 || id==31 || id==33) { dims[0]=dim; dims[1]=depth; dims[2]=height; dims[3]=width; nbdims=4; }
-      return nbdims;
-    }
-
-    //! Save the image as a PANDORE-5 file.
-    const CImg& save_pandore(std::FILE *const file, const char *const filename=0, const unsigned int colorspace=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_pandore() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_pandore() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      unsigned char header[36] = { 'P','A','N','D','O','R','E','0','4',0,0,0,
-                                   0,0,0,0,
-                                   'C','I','m','g',0,0,0,0,0,
-                                   'N','o',' ','d','a','t','e',0,0,0,
-                                   0 };
-      unsigned int nbdims,dims[5];
-      bool saved=false;
-      cimg_save_pandore_case(1,1,1,"unsigned char",2);
-      cimg_save_pandore_case(1,1,1,"char",3);
-      cimg_save_pandore_case(1,1,1,"short",3);
-      cimg_save_pandore_case(1,1,1,"unsigned short",3);
-      cimg_save_pandore_case(1,1,1,"unsigned int",3);
-      cimg_save_pandore_case(1,1,1,"int",3);
-      cimg_save_pandore_case(1,1,1,"unsigned long",4);
-      cimg_save_pandore_case(1,1,1,"long",3);
-      cimg_save_pandore_case(1,1,1,"float",4);
-      cimg_save_pandore_case(1,1,1,"double",4);
-
-      cimg_save_pandore_case(0,1,1,"unsigned char",5);
-      cimg_save_pandore_case(0,1,1,"char",6);
-      cimg_save_pandore_case(0,1,1,"short",6);
-      cimg_save_pandore_case(0,1,1,"unsigned short",6);
-      cimg_save_pandore_case(0,1,1,"unsigned int",6);
-      cimg_save_pandore_case(0,1,1,"int",6);
-      cimg_save_pandore_case(0,1,1,"unsigned long",7);
-      cimg_save_pandore_case(0,1,1,"long",6);
-      cimg_save_pandore_case(0,1,1,"float",7);
-      cimg_save_pandore_case(0,1,1,"double",7);
-
-      cimg_save_pandore_case(0,0,1,"unsigned char",8);
-      cimg_save_pandore_case(0,0,1,"char",9);
-      cimg_save_pandore_case(0,0,1,"short",9);
-      cimg_save_pandore_case(0,0,1,"unsigned short",9);
-      cimg_save_pandore_case(0,0,1,"unsigned int",9);
-      cimg_save_pandore_case(0,0,1,"int",9);
-      cimg_save_pandore_case(0,0,1,"unsigned long",10);
-      cimg_save_pandore_case(0,0,1,"long",9);
-      cimg_save_pandore_case(0,0,1,"float",10);
-      cimg_save_pandore_case(0,0,1,"double",10);
-
-      cimg_save_pandore_case(0,1,3,"unsigned char",16);
-      cimg_save_pandore_case(0,1,3,"char",17);
-      cimg_save_pandore_case(0,1,3,"short",17);
-      cimg_save_pandore_case(0,1,3,"unsigned short",17);
-      cimg_save_pandore_case(0,1,3,"unsigned int",17);
-      cimg_save_pandore_case(0,1,3,"int",17);
-      cimg_save_pandore_case(0,1,3,"unsigned long",18);
-      cimg_save_pandore_case(0,1,3,"long",17);
-      cimg_save_pandore_case(0,1,3,"float",18);
-      cimg_save_pandore_case(0,1,3,"double",18);
-
-      cimg_save_pandore_case(0,0,3,"unsigned char",19);
-      cimg_save_pandore_case(0,0,3,"char",20);
-      cimg_save_pandore_case(0,0,3,"short",20);
-      cimg_save_pandore_case(0,0,3,"unsigned short",20);
-      cimg_save_pandore_case(0,0,3,"unsigned int",20);
-      cimg_save_pandore_case(0,0,3,"int",20);
-      cimg_save_pandore_case(0,0,3,"unsigned long",21);
-      cimg_save_pandore_case(0,0,3,"long",20);
-      cimg_save_pandore_case(0,0,3,"float",21);
-      cimg_save_pandore_case(0,0,3,"double",21);
-
-      cimg_save_pandore_case(1,1,0,"unsigned char",22);
-      cimg_save_pandore_case(1,1,0,"char",23);
-      cimg_save_pandore_case(1,1,0,"short",23);
-      cimg_save_pandore_case(1,1,0,"unsigned short",23);
-      cimg_save_pandore_case(1,1,0,"unsigned int",23);
-      cimg_save_pandore_case(1,1,0,"int",23);
-      cimg_save_pandore_case(1,1,0,"unsigned long",25);
-      cimg_save_pandore_case(1,1,0,"long",23);
-      cimg_save_pandore_case(1,1,0,"float",25);
-      cimg_save_pandore_case(1,1,0,"double",25);
-
-      cimg_save_pandore_case(0,1,0,"unsigned char",26);
-      cimg_save_pandore_case(0,1,0,"char",27);
-      cimg_save_pandore_case(0,1,0,"short",27);
-      cimg_save_pandore_case(0,1,0,"unsigned short",27);
-      cimg_save_pandore_case(0,1,0,"unsigned int",27);
-      cimg_save_pandore_case(0,1,0,"int",27);
-      cimg_save_pandore_case(0,1,0,"unsigned long",29);
-      cimg_save_pandore_case(0,1,0,"long",27);
-      cimg_save_pandore_case(0,1,0,"float",29);
-      cimg_save_pandore_case(0,1,0,"double",29);
-
-      cimg_save_pandore_case(0,0,0,"unsigned char",30);
-      cimg_save_pandore_case(0,0,0,"char",31);
-      cimg_save_pandore_case(0,0,0,"short",31);
-      cimg_save_pandore_case(0,0,0,"unsigned short",31);
-      cimg_save_pandore_case(0,0,0,"unsigned int",31);
-      cimg_save_pandore_case(0,0,0,"int",31);
-      cimg_save_pandore_case(0,0,0,"unsigned long",33);
-      cimg_save_pandore_case(0,0,0,"long",31);
-      cimg_save_pandore_case(0,0,0,"float",33);
-      cimg_save_pandore_case(0,0,0,"double",33);
-
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save the image as a PANDORE-5 file.
-    const CImg& save_pandore(const char *const filename=0, const unsigned int colorspace=0) const {
-      return save_pandore(0,filename,colorspace);
-    }
-
-    //! Save the image as a YUV video sequence file
-    const CImg& save_yuv(std::FILE *const file, const char *const filename=0, const bool rgb2yuv=true) const {
-      CImgList<T>(*this).save_yuv(file,filename,rgb2yuv);
-      return *this;
-    }
-
-    //! Save the image as a YUV video sequence file
-    const CImg& save_yuv(const char *const filename, const bool rgb2yuv=true) const {
-      return save_yuv(0,filename,rgb2yuv);
-    }
-
-    //! Save the image as a BMP file
-    const CImg& save_bmp(std::FILE *const file, const char *const filename=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_bmp() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_bmp() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      cimg::warn(depth>1,
-                 "CImg<%s>::save_bmp() : Instance image (%u,%u,%u,%u,%p) is volumetric. Only the first slice will be saved (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      cimg::warn(dim>3,
-                 "CImg<%s>::save_bmp() : Instance image (%u,%u,%u,%u,%p) is multispectral. Only the three first channels will be saved (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      unsigned char header[54]={0}, align_buf[4]={0};
-      const unsigned int
-        align     = (4-(3*width)%4)%4,
-        buf_size  = (3*width+align)*dimy(),
-        file_size = 54+buf_size;
-      header[0] = 'B'; header[1] = 'M';
-      header[0x02]=file_size&0xFF; header[0x03]=(file_size>>8)&0xFF;
-      header[0x04]=(file_size>>16)&0xFF; header[0x05]=(file_size>>24)&0xFF;
-      header[0x0A]=0x36;
-      header[0x0E]=0x28;
-      header[0x12]=width&0xFF; header[0x13]=(width>>8)&0xFF;
-      header[0x14]=(width>>16)&0xFF; header[0x15]=(width>>24)&0xFF;
-      header[0x16]=height&0xFF; header[0x17]=(height>>8)&0xFF;
-      header[0x18]=(height>>16)&0xFF; header[0x19]=(height>>24)&0xFF;
-      header[0x1A]=1;  header[0x1B]=0;
-      header[0x1C]=24; header[0x1D]=0;
-      header[0x22]=buf_size&0xFF; header[0x23]=(buf_size>>8)&0xFF;
-      header[0x24]=(buf_size>>16)&0xFF; header[0x25]=(buf_size>>24)&0xFF;
-      header[0x27]=0x1; header[0x2B]=0x1;
-      cimg::fwrite(header,54,nfile);
-
-      const T
-        *pR = ptr(0,height-1,0,0),
-        *pG = (dim>=2)?ptr(0,height-1,0,1):pR,
-        *pB = (dim>=3)?ptr(0,height-1,0,2):pR;
-
-      cimg_forY(*this,y) {
-        cimg_forX(*this,x) {
-          std::fputc((unsigned char)(*(pB++)),nfile);
-          std::fputc((unsigned char)(*(pG++)),nfile);
-          std::fputc((unsigned char)(*(pR++)),nfile);
-        }
-        cimg::fwrite(align_buf,align,nfile);
-        pR-=2*width; pG-=2*width; pB-=2*width;
-      }
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save the image as a BMP file
-    const CImg& save_bmp(const char *const filename) const {
-      return save_bmp(0,filename);
-    }
-
-    //! Save an image to a PNG file.
-    // Most of this function has been written by Eric Fausett
-    /**
-       \param filename = name of the png image file to save
-       \return *this
-       \note The png format specifies a variety of possible data formats.  Grey scale, Grey
-       scale with Alpha, RGB color, RGB color with Alpha, and Palletized color are supported.
-       Per channel bit depths of 1, 2, 4, 8, and 16 are natively supported. The
-       type of file saved depends on the number of channels in the CImg file.  If there is 4 or more
-       channels, the image will be saved as an RGB color with Alpha image using the bottom 4 channels.
-       If there are 3 channels, the saved image will be an RGB color image.  If 2 channels then the
-       image saved will be Grey scale with Alpha, and if 1 channel will be saved as a Grey scale
-       image.
-    **/
-    const CImg& save_png(std::FILE *const file, const char *const filename=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_png() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!filename) throw CImgArgumentException("CImg<%s>::save_png() : Instance image (%u,%u,%u,%u,%p), specified filename is (null).",
-                                                 pixel_type(),width,height,depth,dim,data);
-      cimg::warn(depth>1,
-                 "CImg<%s>::save_png() : Instance image (%u,%u,%u,%u,%p) is volumetric. Only the first slice will be saved (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-#ifndef cimg_use_png
-      if (!file) return save_other(filename);
-      else throw CImgIOException("CImg<%s>::save_png() : Cannot save a PNG image in a *FILE output. Use libpng instead.",
-                                 pixel_type());
-#else
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-
-      // Setup PNG structures for write
-      png_voidp user_error_ptr=0;
-      png_error_ptr user_error_fn=0, user_warning_fn=0;
-      png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,
-                                                    user_error_ptr, user_error_fn, user_warning_fn);
-      if(!png_ptr){
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::save_png() : File '%s', error when initializing 'png_ptr' data structure.",
-                              pixel_type(),filename?filename:"(unknown)");
-      }
-      png_infop info_ptr = png_create_info_struct(png_ptr);
-      if(!info_ptr){
-        png_destroy_write_struct(&png_ptr,(png_infopp)0);
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::save_png() : File '%s', error when initializing 'info_ptr' data structure.",
-                              pixel_type(),filename?filename:"(unknown)");
-      }
-      if (setjmp(png_jmpbuf(png_ptr))){
-        png_destroy_write_struct(&png_ptr, &info_ptr);
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::save_png() : File '%s', unknown fatal error.",
-                              pixel_type(),filename?filename:"(unknown)");
-      }
-
-      png_init_io(png_ptr, nfile);
-      png_uint_32 width = dimx();
-      png_uint_32 height = dimy();
-      const CImgStats stats(*this,false);
-      const float vmin = (float)stats.min, vmax = (float)stats.max;
-      const int bit_depth = (vmin<0 || vmax>=256)?16:8;
-      int color_type;
-      switch (dimv()) {
-      case 1: color_type = PNG_COLOR_TYPE_GRAY; break;
-      case 2: color_type = PNG_COLOR_TYPE_GRAY_ALPHA; break;
-      case 3: color_type = PNG_COLOR_TYPE_RGB; break;
-      default: color_type = PNG_COLOR_TYPE_RGB_ALPHA;
-      }
-      const int interlace_type = PNG_INTERLACE_NONE;
-      const int compression_type = PNG_COMPRESSION_TYPE_DEFAULT;
-      const int filter_method = PNG_FILTER_TYPE_DEFAULT;
-      png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, color_type, interlace_type,
-                   compression_type, filter_method);
-      png_write_info(png_ptr, info_ptr);
-      const int byte_depth = bit_depth>>3;
-      const int numChan = dimv()>4?4:dimv();
-      const int pixel_bit_depth_flag = numChan * (bit_depth-1);
-
-      // Allocate Memory for Image Save and Fill pixel data
-      png_bytep *imgData = new png_byte*[height];
-      for(unsigned int row=0; row<height; row++) imgData[row] = new png_byte[byte_depth * numChan * width];
-      const T *pC0 = ptr(0,0,0,0);
-      switch(pixel_bit_depth_flag) {
-      case 7 :  { // Gray 8-bit
-        cimg_forY(*this,y) {
-          unsigned char *ptrs = imgData[y];
-          cimg_forX(*this,x) *(ptrs++) = (unsigned char)*(pC0++);
-        }
-      } break;
-      case 14: { // Gray w/ Alpha 8-bit
-        const T *pC1 = ptr(0,0,0,1);
-        cimg_forY(*this,y) {
-          unsigned char *ptrs = imgData[y];
-          cimg_forX(*this,x) {
-            *(ptrs++) = (unsigned char)*(pC0++);
-            *(ptrs++) = (unsigned char)*(pC1++);
-          }
-        }
-      } break;
-      case 21:  { // RGB 8-bit
-        const T *pC1 = ptr(0,0,0,1);
-        const T *pC2 = ptr(0,0,0,2);
-        cimg_forY(*this,y) {
-          unsigned char *ptrs = imgData[y];
-          cimg_forX(*this,x) {
-            *(ptrs++) = (unsigned char)*(pC0++);
-            *(ptrs++) = (unsigned char)*(pC1++);
-            *(ptrs++) = (unsigned char)*(pC2++);
-          }
-        }
-      } break;
-      case 28: { // RGB x/ Alpha 8-bit
-        const T *pC1 = ptr(0,0,0,1);
-        const T *pC2 = ptr(0,0,0,2);
-        const T *pC3 = ptr(0,0,0,3);
-        cimg_forY(*this,y){
-          unsigned char *ptrs = imgData[y];
-          cimg_forX(*this,x){
-            *(ptrs++) = (unsigned char)*(pC0++);
-            *(ptrs++) = (unsigned char)*(pC1++);
-            *(ptrs++) = (unsigned char)*(pC2++);
-            *(ptrs++) = (unsigned char)*(pC3++);
-          }
-        }
-      } break;
-      case 15: { // Gray 16-bit
-        cimg_forY(*this,y){
-          unsigned short *ptrs = reinterpret_cast<unsigned short*>(imgData[y]);
-          cimg_forX(*this,x) *(ptrs++) = (unsigned short)*(pC0++);
-        }
-      } break;
-      case 30: { // Gray w/ Alpha 16-bit
-        const T *pC1 = ptr(0,0,0,1);
-        cimg_forY(*this,y){
-          unsigned short *ptrs = reinterpret_cast<unsigned short*>(imgData[y]);
-          cimg_forX(*this,x) {
-            *(ptrs++) = (unsigned short)*(pC0++);
-            *(ptrs++) = (unsigned short)*(pC1++);
-          }
-        }
-      } break;
-      case 45: { // RGB 16-bit
-        const T *pC1 = ptr(0,0,0,1);
-        const T *pC2 = ptr(0,0,0,2);
-        cimg_forY(*this,y) {
-          unsigned short *ptrs = reinterpret_cast<unsigned short*>(imgData[y]);
-          cimg_forX(*this,x) {
-            *(ptrs++) = (unsigned short)*(pC0++);
-            *(ptrs++) = (unsigned short)*(pC1++);
-            *(ptrs++) = (unsigned short)*(pC2++);
-          }
-        }
-      } break;
-      case 60: { // RGB w/ Alpha 16-bit
-        const T *pC1 = ptr(0,0,0,1);
-        const T *pC2 = ptr(0,0,0,2);
-        const T *pC3 = ptr(0,0,0,3);
-        cimg_forY(*this,y) {
-          unsigned short *ptrs = reinterpret_cast<unsigned short*>(imgData[y]);
-          cimg_forX(*this,x) {
-            *(ptrs++) = (unsigned short)*(pC0++);
-            *(ptrs++) = (unsigned short)*(pC1++);
-            *(ptrs++) = (unsigned short)*(pC2++);
-            *(ptrs++) = (unsigned short)*(pC3++);
-          }
-        }
-      } break;
-      default:
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImg<%s>::save_png() : File '%s', unknown fatal error.",
-                              pixel_type(),filename?filename:"(unknown)");
-        break;
-      }
-      png_write_image(png_ptr, imgData);
-      png_write_end(png_ptr, info_ptr);
-      png_destroy_write_struct(&png_ptr, &info_ptr);
-
-      // Deallocate Image Write Memory
-      for (unsigned int n=0; n<height; n++) delete[] imgData[n];
-      delete[] imgData;
-      if (!file) cimg::fclose(nfile);
-      return *this;
-#endif
-    }
-
-    //! Save a file in PNG format
-    const CImg& save_png(const char *const filename) const {
-      return save_png(0,filename);
-    }
-
-    //! Save a file in TIFF format.
-    const CImg& save_tiff(const char *const filename) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_tiff() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename);
-      if (!filename) throw CImgArgumentException("CImg<%s>::save_tiff() : Instance image (%u,%u,%u,%u,%p), specified filename is (null).",
-                                                 pixel_type(),width,height,depth,dim,data);
-#ifdef cimg_use_tiff
-      uint32 rowsperstrip = (uint32) -1;
-      uint16 spp = dimv(), bpp = sizeof(T)*8;
-      uint16 photometric;
-      if (spp==3 || spp==4)
-	photometric = PHOTOMETRIC_RGB;
-	  else
-	    photometric =   PHOTOMETRIC_MINISBLACK;
-      uint16 compression = COMPRESSION_NONE;
-      TIFF *out;
-      out = TIFFOpen(filename,"w");
-      if (out) {
-        for (unsigned int dir=0; dir<depth; dir++) {
-          TIFFSetField(out, TIFFTAG_IMAGEWIDTH, (uint32)dimx());
-          TIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32)dimy());
-          TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);
-          TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);
-          TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bpp);
-          TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
-          TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);
-          TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
-          rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);
-          TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
-	  TIFFSetField(out, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
-	  TIFFSetField(out, TIFFTAG_SOFTWARE, "CImg");
-	  T *buf =  (T *)_TIFFmalloc(TIFFStripSize(out));
-	  if (buf){
-	    for (unsigned int row = 0; row < height; row+=rowsperstrip) {
-	      uint32 nrow = (row+rowsperstrip>height?height-row:rowsperstrip);
-	      tstrip_t strip = TIFFComputeStrip(out, row, 0);
-	      tsize_t i = 0;
-	      for (unsigned int rr=0; rr<nrow; rr++)
-		for (unsigned int cc=0;cc<width;cc++)
-		  for (unsigned int vv=0;vv<spp;vv++)
-		    buf[i++] = (*this)(cc,row+rr,dir,vv);
-	      if(TIFFWriteEncodedStrip(out, strip, buf, i*sizeof(T))<0){
-		throw CImgException("CImg<%s>::get_save_tiff() : File '%s', an error occure while writing a strip.",
-				    pixel_type(),filename?filename:"(FILE*)");
-	      }
-	    }
-	    _TIFFfree(buf);
-	  }
-          TIFFWriteDirectory(out);
-        }
-        TIFFClose(out);
-      }
-      else throw CImgException("CImg<%s>::save_tiff() : File '%s', error while writing tiff file.",
-                               pixel_type(),filename);
-#else
-      return save_other(filename);
-#endif
-      return *this;
-    }
-
-    //! Save a file in JPEG format.
-    const CImg<T>& save_jpeg(std::FILE *const file, const char *const filename=0, const unsigned int quality=100) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_jpeg() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_jpeg() : Instance image (%u,%u,%u,%u,%p), specified filename is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      cimg::warn(depth>1,
-                 "CImg<%s>::save_jpeg() : Instance image (%u,%u,%u,%u,%p) is volumetric. Only the first slice will be saved (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-#ifndef cimg_use_jpeg
-      if (!file) return save_other(filename,quality);
-      else throw CImgIOException("CImg<%s>::save_jpeg() : Cannot save a JPEG image in a *FILE output. Use libjpeg instead.",
-                                 pixel_type());
-#else
-
-      // Fill pixel buffer
-      unsigned char *buf;
-      unsigned int dimbuf=0;
-      J_COLOR_SPACE colortype=JCS_RGB;
-      switch (dim) {
-      case 1: { // Greyscale images
-        unsigned char *buf2 = buf = new unsigned char[width*height*(dimbuf=1)];
-        colortype = JCS_GRAYSCALE;
-        const T *ptr_g = ptr();
-        cimg_forXY(*this,x,y) *(buf2++) = (unsigned char)*(ptr_g++);
-      } break;
-      case 2:
-      case 3: { // RGB images
-        unsigned char *buf2 = buf = new unsigned char[width*height*(dimbuf=3)];
-        const T *ptr_r = ptr(0,0,0,0), *ptr_g = ptr(0,0,0,1), *ptr_b = ptr(0,0,0,dim>2?2:0);
-        colortype = JCS_RGB;
-        cimg_forXY(*this,x,y) {
-          *(buf2++) = (unsigned char)*(ptr_r++);
-          *(buf2++) = (unsigned char)*(ptr_g++);
-          *(buf2++) = (unsigned char)*(ptr_b++);
-        }
-      } break;
-      default: { // YCMYK images
-        unsigned char *buf2 = buf = new unsigned char[width*height*(dimbuf=4)];
-        const T *ptr_r = ptr(0,0,0,0), *ptr_g = ptr(0,0,0,1), *ptr_b = ptr(0,0,0,2), *ptr_a = ptr(0,0,0,3);
-        colortype = JCS_CMYK;
-        cimg_forXY(*this,x,y) {
-          *(buf2++) = (unsigned char)*(ptr_r++);
-          *(buf2++) = (unsigned char)*(ptr_g++);
-          *(buf2++) = (unsigned char)*(ptr_b++);
-          *(buf2++) = (unsigned char)*(ptr_a++);
-        }
-      } break;
-      }
-
-      // Call libjpeg functions
-      struct jpeg_compress_struct cinfo;
-      struct jpeg_error_mgr jerr;
-      cinfo.err = jpeg_std_error(&jerr);
-      jpeg_create_compress(&cinfo);
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      jpeg_stdio_dest(&cinfo,nfile);
-      cinfo.image_width = width;
-      cinfo.image_height = height;
-      cinfo.input_components = dimbuf;
-      cinfo.in_color_space = colortype;
-      jpeg_set_defaults(&cinfo);
-      jpeg_set_quality(&cinfo,quality<100?quality:100,TRUE);
-      jpeg_start_compress(&cinfo,TRUE);
-
-      const unsigned int row_stride = width*dimbuf;
-      JSAMPROW row_pointer[1];
-      while (cinfo.next_scanline < cinfo.image_height) {
-        row_pointer[0] = &buf[cinfo.next_scanline*row_stride];
-        jpeg_write_scanlines(&cinfo,row_pointer,1);
-      }
-      jpeg_finish_compress(&cinfo);
-
-      delete[] buf;
-      if (!file) cimg::fclose(nfile);
-      jpeg_destroy_compress(&cinfo);
-      return *this;
-#endif
-    }
-
-    //! Save a file in JPEG format.
-    const CImg<T>& save_jpeg(const char *const filename, const unsigned int quality=100) const {
-      return save_jpeg(0,filename,quality);
-    }
-
-    //! Save the image using built-in ImageMagick++ library
-    const CImg& save_magick(const char *const filename) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_magick() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data);
-      if (!filename) throw CImgArgumentException("CImg<%s>::save_magick() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                 pixel_type(),width,height,depth,dim,data);
-#ifdef cimg_use_magick
-      Magick::Image image(Magick::Geometry(width,height),"black");
-      image.type(Magick::TrueColorType);
-      const T *rdata = ptr(0,0,0,0), *gdata = dim>1?ptr(0,0,0,1):rdata, *bdata = dim>2?ptr(0,0,0,2):gdata;
-      cimg_forXY(*this,x,y) image.pixelColor(x,y,Magick::ColorRGB(*(rdata++)/255.0,*(gdata++)/255.0,*(bdata++)/255.0));
-      image.syncPixels();
-      image.write(filename);
-#else
-      throw CImgIOException("CImg<%s>::save_magick() : File '%s', Magick++ library has not been linked.",
-                            pixel_type(),filename);
-#endif
-      return *this;
-    }
-
-    //! Save the image as a RGBA file
-    const CImg& save_rgba(std::FILE *const file, const char *const filename=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_rgba() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_rgba() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      cimg::warn(dim!=4,
-                 "CImg<%s>::save_rgba() : Instance image (%u,%u,%u,%u,%p) has not exactly 4 channels (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      const unsigned int wh = width*height;
-      unsigned char *buffer = new unsigned char[4*wh], *nbuffer=buffer;
-      const T
-        *ptr1 = ptr(0,0,0,0),
-        *ptr2 = dim>1?ptr(0,0,0,1):ptr1,
-        *ptr3 = dim>2?ptr(0,0,0,2):ptr1,
-        *ptr4 = dim>3?ptr(0,0,0,3):0;
-      for (unsigned int k=0; k<wh; k++) {
-        *(nbuffer++) = (unsigned char)(*(ptr1++));
-        *(nbuffer++) = (unsigned char)(*(ptr2++));
-        *(nbuffer++) = (unsigned char)(*(ptr3++));
-        *(nbuffer++) = (unsigned char)(ptr4?(*(ptr4++)):255);
-      }
-      cimg::fwrite(buffer,4*wh,nfile);
-      if (!file) cimg::fclose(nfile);
-      delete[] buffer;
-      return *this;
-    }
-
-    //! Save the image as a RGBA file
-    const CImg& save_rgba(const char *const filename) const {
-      return save_rgba(0,filename);
-    }
-
-    //! Save the image as a RGB file
-    const CImg& save_rgb(std::FILE *const file, const char *const filename=0) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_rgb() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_rgb() : Instance image (%u,%u,%u,%u,%p), specified file is (null).",
-                                                          pixel_type(),width,height,depth,dim,data);
-      cimg::warn(dim!=3,
-                 "CImg<%s>::save_rgb() : Instance image (%u,%u,%u,%u,%p) has not exactly 3 channels (file '%s').",
-                 pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      const unsigned int wh = width*height;
-      unsigned char *buffer = new unsigned char[3*wh], *nbuffer=buffer;
-      const T
-        *ptr1 = ptr(0,0,0,0),
-        *ptr2 = dim>1?ptr(0,0,0,1):ptr1,
-        *ptr3 = dim>2?ptr(0,0,0,2):ptr1;
-      for (unsigned int k=0; k<wh; k++) {
-        *(nbuffer++) = (unsigned char)(*(ptr1++));
-        *(nbuffer++) = (unsigned char)(*(ptr2++));
-        *(nbuffer++) = (unsigned char)(*(ptr3++));
-      }
-      cimg::fwrite(buffer,3*wh,nfile);
-      if (!file) cimg::fclose(nfile);
-      delete[] buffer;
-      return *this;
-    }
-
-    //! Save the image as a RGB file
-    const CImg& save_rgb(const char *const filename) const {
-      return save_rgb(0,filename);
-    }
-
-    //! Get a 40x38 color logo of a 'danger' item
-    static CImg get_logo40x38() {
-      static bool first_time = true;
-      static CImg<T> res(40,38,1,3);
-      if (first_time) {
-        const unsigned char *ptrs = cimg::logo40x38;
-        T *ptr1 = res.ptr(0,0,0,0), *ptr2 = res.ptr(0,0,0,1), *ptr3 = res.ptr(0,0,0,2);
-        for (unsigned int off = 0; off<res.width*res.height;) {
-          const unsigned char n = *(ptrs++), r = *(ptrs++), g = *(ptrs++), b = *(ptrs++);
-          for (unsigned int l=0; l<n; off++,l++) { *(ptr1++) = (T)r; *(ptr2++) = (T)g; *(ptr3++) = (T)b; }
-        }
-        first_time = false;
-      }
-      return res;
-    }
-
-    //! Save OFF files (GeomView 3D object files)
-    template<typename tf, typename tc>
-    const CImg& save_off(std::FILE *const file, const char *const filename,
-                         const CImgList<tf>& primitives, const CImgList<tc>& colors, const bool invert_faces=false) const {
-      if (is_empty()) throw CImgInstanceException("CImg<%s>::save_off() : Instance image (%u,%u,%u,%u,%p) is empty (file '%s').",
-                                                  pixel_type(),width,height,depth,dim,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_off() : Specified filename is (null).",pixel_type());
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"w");
-      std::fprintf(nfile,"OFF\n%u %u %u\n",width,primitives.size,3*primitives.size);
-      cimg_forX(*this,i) std::fprintf(nfile,"%f %f %f\n",(float)((*this)(i,0)),(float)((*this)(i,1)),(float)((*this)(i,2)));
-      cimglist_for(primitives,l) {
-        const unsigned int prim = primitives[l].size();
-        switch (prim) {
-        case 3: {
-          if (invert_faces)
-            std::fprintf(nfile,"3 %u %u %u %f %f %f\n",
-                         (unsigned int)primitives(l,0),(unsigned int)primitives(l,1),(unsigned int)primitives(l,2),
-                         (float)(colors(l,0)/255.0f),(float)(colors(l,1)/255.0f),(float)(colors(l,2)/255.0f));
-          else
-            std::fprintf(nfile,"3 %u %u %u %f %f %f\n",
-                         (unsigned int)primitives(l,0),(unsigned int)primitives(l,2),(unsigned int)primitives(l,1),
-                         (float)(colors(l,0)/255.0f),(float)(colors(l,1)/255.0f),(float)(colors(l,2)/255.0f));
-        } break;
-        case 4: {
-          if (invert_faces)
-            std::fprintf(nfile,"4 %u %u %u %u %f %f %f\n",
-                         (unsigned int)primitives(l,0),(unsigned int)primitives(l,1),(unsigned int)primitives(l,2),(unsigned int)primitives(l,3),
-                         (float)(colors(l,0)/255.0f),(float)(colors(l,1)/255.0f),(float)(colors(l,2)/255.0f));
-          else
-            std::fprintf(nfile,"4 %u %u %u %u %f %f %f\n",
-                         (unsigned int)primitives(l,0),(unsigned int)primitives(l,3),(unsigned int)primitives(l,2),(unsigned int)primitives(l,1),
-                         (float)(colors(l,0)/255.0f),(float)(colors(l,1)/255.0f),(float)(colors(l,2)/255.0f));
-        } break;
-        }
-      }
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save OFF files (GeomView 3D object files)
-    template<typename tf, typename tc>
-    const CImg& save_off(const char *const filename,
-                         const CImgList<tf>& primitives, const CImgList<tc>& colors, const bool invert_faces=false) const {
-      return save_off(filename,primitives,colors,invert_faces);
-    }
-
-  };
-
-
-  /*
-   #-----------------------------------------
-   #
-   #
-   #
-   # Definition of the CImgList<> structure
-   #
-   #
-   #
-   #------------------------------------------
-   */
-
-  //! Class representing list of images CImg<T>.
-  template<typename T> struct CImgList {
-
-    //! Size of the list (number of elements inside)
-    unsigned int size;
-
-    //! Allocation size of the list
-    unsigned int allocsize;
-
-    //! Pointer to the first list element
-    CImg<T> *data;
-
-    //! Define a CImgList<T>::iterator
-    typedef CImg<T>* iterator;
-
-    //! Define a CImgList<T>::const_iterator
-    typedef const CImg<T>* const_iterator;
-
-    //! Get value type
-    typedef T value_type;
-
-    //@}
-    //---------------------------
-    //
-    //! \name Plugins
-    //@{
-    //---------------------------
-#ifdef cimglist_plugin
-#include cimglist_plugin
-#endif
-    //@}
-
-    //------------------------------------------
-    //
-    //! \name Constructors - Destructor - Copy
-    //@{
-    //------------------------------------------
-
-    //! Default constructor
-    CImgList():
-      size(0),allocsize(0),data(0) {}
-
-    //! Destructor
-    ~CImgList() {
-      if (data) delete[] data;
-    }
-
-    //! In-place version of the default constructor and default destructor
-    CImgList& assign() {
-      if (data) delete[] data;
-      size = allocsize = 0;
-      data = 0;
-      return *this;
-    }
-
-    //! Equivalent to assign() (STL-compliant name)
-    CImgList& clear() {
-      return assign();
-    }
-
-    //! Copy constructor
-    template<typename t> CImgList(const CImgList<t>& list):
-      size(0),allocsize(0),data(0) {
-      assign(list);
-    }
-
-    CImgList(const CImgList& list):
-      size(0),allocsize(0),data(0) {
-      assign(list);
-    }
-
-    //! Copy constructor that create a shared object
-    template<typename t> CImgList(const CImgList<t>& list, const bool shared):
-      size(0),allocsize(0),data(0) {
-      assign(list,shared);
-    }
-
-    CImgList(const CImgList& list, const bool shared):
-      size(0),allocsize(0),data(0) {
-      assign(list,shared);
-    }
-
-    //! In-place version of the copy constructor
-    template<typename t> CImgList& assign(const CImgList<t>& list, const bool shared=false) {
-      assign(list.size);
-      cimglist_for(*this,l) (*this)[l].assign(list[l],shared);
-      return *this;
-    }
-
-    //! Construct an image list containing n empty images
-    explicit CImgList(const unsigned int n):
-      size(n) {
-      data = new CImg<T>[allocsize=cimg::nearest_pow2(n)];
-    }
-
-    //! In-place version of the previous constructor
-    CImgList& assign(const unsigned int n) {
-      if (n) {
-        if (allocsize<n || allocsize>(n<<2)) {
-          if (data) delete[] data;
-          data = new CImg<T>[allocsize=cimg::nearest_pow2(n)];
-        }
-        size = n;
-      } else return assign();
-      return *this;
-    }
-
-    //! Construct an image list containing n images with specified size
-    CImgList(const unsigned int n, const unsigned int width, const unsigned int height=1,
-          const unsigned int depth=1, const unsigned int dim=1):
-      size(0),allocsize(0),data(0) {
-      assign(n,width,height,depth,dim);
-    }
-
-    //! In-place version of the previous constructor
-    CImgList& assign(const unsigned int n, const unsigned int width, const unsigned int height=1,
-                  const unsigned int depth=1, const unsigned int dim=1) {
-      const unsigned int siz = width*height*depth*dim;
-      if (n && siz) { assign(n); cimglist_for(*this,l) data[l].assign(width,height,depth,dim); }
-      else return assign();
-      return *this;
-    }
-
-    //! Construct an image list containing n images with specified size, filled with val
-    CImgList(const unsigned int n, const unsigned int width, const unsigned int height,
-          const unsigned int depth, const unsigned int dim, const T& val):
-      size(0),allocsize(0),data(0) {
-      assign(n,width,height,depth,dim,val);
-    }
-
-    //! In-place version of the previous constructor
-    CImgList& assign(const unsigned int n,const unsigned int width,const unsigned int height,
-                  const unsigned int depth, const unsigned int dim,const T& val) {
-      assign(n,width,height,depth,dim);
-      cimglist_for(*this,l) data[l].fill(val);
-      return *this;
-    }
-
-    //! Construct a list containing n copies of the image img
-    template<typename t> CImgList(const unsigned int n, const CImg<t>& img, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(n,img,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t> CImgList& assign(const unsigned int n, const CImg<t>& img, const bool shared=false) {
-      assign(n);
-      cimglist_for(*this,l) data[l].assign(img,shared);
-      return *this;
-    }
-
-    //! Construct an image list from one image
-    template<typename t> explicit CImgList(const CImg<t>& img, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t> CImgList& assign(const CImg<t>& img, const bool shared=false) {
-      return assign(1,img,shared);
-    }
-
-    //! Construct an image list from two images
-    template<typename t1, typename t2> CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img1,img2,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t1, typename t2> CImgList& assign(const CImg<t1>& img1, const CImg<t2>& img2, const bool shared=false) {
-      assign(2);
-      data[0].assign(img1,shared); data[1].assign(img2,shared);
-      return *this;
-    }
-
-    //! Construct an image list from three images
-    template<typename t1, typename t2, typename t3> CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img1,img2,img3,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t1, typename t2, typename t3> CImgList& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const bool shared=false) {
-      assign(3);
-      data[0].assign(img1,shared); data[1].assign(img2,shared); data[2].assign(img3,shared);
-      return *this;
-    }
-
-    //! Construct an image list from four images
-    template<typename t1, typename t2, typename t3, typename t4>
-    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img1,img2,img3,img4,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t1, typename t2, typename t3, typename t4>
-    CImgList& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const bool shared=false) {
-      assign(4);
-      data[0].assign(img1,shared); data[1].assign(img2,shared); data[2].assign(img3,shared); data[3].assign(img4,shared);
-      return *this;
-    }
-
-    //! Construct an image list from five images
-    template<typename t1, typename t2, typename t3, typename t4, typename t5>
-    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img1,img2,img3,img4,img5,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t1, typename t2, typename t3, typename t4, typename t5>
-    CImgList& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-                     const bool shared=false) {
-      assign(5);
-      data[0].assign(img1,shared); data[1].assign(img2,shared); data[2].assign(img3,shared); data[3].assign(img4,shared);
-      data[4].assign(img5,shared);
-      return *this;
-    }
-
-    //! Construct an image list from six images
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6>
-    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-             const CImg<t6>& img6, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img1,img2,img3,img4,img5,img6,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6>
-    CImgList& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-                     const CImg<t6>& img6, const bool shared=false) {
-      assign(6);
-      data[0].assign(img1,shared); data[1].assign(img2,shared); data[2].assign(img3,shared); data[3].assign(img4,shared);
-      data[4].assign(img5,shared); data[5].assign(img6,shared);
-      return *this;
-    }
-
-    //! Construct an image list from seven images
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7>
-    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-             const CImg<t6>& img6, const CImg<t7>& img7, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img1,img2,img3,img4,img5,img6,img7,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7>
-    CImgList& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-                     const CImg<t6>& img6, const CImg<t7>& img7, const bool shared=false) {
-      assign(7);
-      data[0].assign(img1,shared); data[1].assign(img2,shared); data[2].assign(img3,shared); data[3].assign(img4,shared);
-      data[4].assign(img5,shared); data[5].assign(img6,shared); data[6].assign(img7,shared);
-      return *this;
-    }
-
-    //! Construct an image list from eight images
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8>
-    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-             const CImg<t6>& img6, const CImg<t7>& img7, const CImg<t8>& img8, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img1,img2,img3,img4,img5,img6,img7,img8,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8>
-    CImgList& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-                     const CImg<t6>& img6, const CImg<t7>& img7, const CImg<t8>& img8, const bool shared=false) {
-      assign(8);
-      data[0].assign(img1,shared); data[1].assign(img2,shared); data[2].assign(img3,shared); data[3].assign(img4,shared);
-      data[4].assign(img5,shared); data[5].assign(img6,shared); data[6].assign(img7,shared); data[7].assign(img8,shared);
-      return *this;
-    }
-
-    //! Construct an image list from nine images
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8, typename t9>
-    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-             const CImg<t6>& img6, const CImg<t7>& img7, const CImg<t8>& img8, const CImg<t9>& img9, const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img1,img2,img3,img4,img5,img6,img7,img8,img9,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8, typename t9>
-    CImgList& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-                     const CImg<t6>& img6, const CImg<t7>& img7, const CImg<t8>& img8, const CImg<t9>& img9, const bool shared=false) {
-      assign(9);
-      data[0].assign(img1,shared); data[1].assign(img2,shared); data[2].assign(img3,shared); data[3].assign(img4,shared);
-      data[4].assign(img5,shared); data[5].assign(img6,shared); data[6].assign(img7,shared); data[7].assign(img8,shared);
-      data[8].assign(img9,shared);
-      return *this;
-    }
-
-    //! Construct an image list from ten images
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8, typename t9, typename t10>
-    CImgList(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-             const CImg<t6>& img6, const CImg<t7>& img7, const CImg<t8>& img8, const CImg<t9>& img9, const CImg<t10>& img10,
-          const bool shared=false):
-      size(0),allocsize(0),data(0) {
-      assign(img1,img2,img3,img4,img5,img6,img7,img8,img9,img10,shared);
-    }
-
-    //! In-place version of the previous constructor
-    template<typename t1, typename t2, typename t3, typename t4, typename t5, typename t6, typename t7, typename t8, typename t9, typename t10>
-    CImgList& assign(const CImg<t1>& img1, const CImg<t2>& img2, const CImg<t3>& img3, const CImg<t4>& img4, const CImg<t5>& img5,
-                     const CImg<t6>& img6, const CImg<t7>& img7, const CImg<t8>& img8, const CImg<t9>& img9, const CImg<t10>& img10,
-                     const bool shared=false) {
-      assign(10);
-      data[0].assign(img1,shared); data[1].assign(img2,shared); data[2].assign(img3,shared); data[3].assign(img4,shared);
-      data[4].assign(img5,shared); data[5].assign(img6,shared); data[6].assign(img7,shared); data[7].assign(img8,shared);
-      data[8].assign(img9,shared); data[9].assign(img10,shared);
-      return *this;
-    }
-
-    //! Construct an image list from a filename
-    CImgList(const char *const filename):
-      size(0),allocsize(0),data(0) {
-      assign(filename);
-    }
-
-    //! In-place version of the previous constructor
-    CImgList& assign(const char *const filename) {
-      return load(filename);
-    }
-
-    //! Return a string describing the type of the image pixels in the list (template parameter \p T).
-    static const char* pixel_type() {
-      return cimg::type<T>::id();
-    }
-
-    //! Return \p true if list is empty
-    bool is_empty() const {
-      return (!data || !size);
-    }
-
-    //! Return \c true if the list contains an image with indice k
-    bool contains(const int k) const {
-      return data && k<size;
-    }
-
-    //! Return \c true if the k-th image of the list contains the pixel (x,y,z,v)
-    bool contains(const int k, const int x, const int y=0, const int z=0, const int v=0) const {
-      return contains(k) && data[k].contains(x,y,z,v);
-    }
-
-
-
-    //@}
-    //------------------------------
-    //
-    //! \name Arithmetics Operators
-    //@{
-    //------------------------------
-
-    //! Assignement operator
-    template<typename t> CImgList& operator=(const CImgList<t>& list) {
-      return assign(list);
-    }
-
-    CImgList& operator=(const CImgList& list) {
-      return assign(list);
-    }
-
-    //! Assignement operator.
-    template<typename t> CImgList& operator=(const CImg<t>& img) {
-      cimglist_for(*this,l) data[l]=img;
-      return *this;
-    }
-
-    //! Assignement operator.
-    CImgList& operator=(const T& val) {
-      cimglist_for(*this,l) data[l].fill(val);
-      return *this;
-    }
-
-    //! Operator+
-    CImgList operator+() const {
-      return CImgList<T>(*this);
-    }
-
-    //! Operator+=
-#ifdef cimg_use_visualcpp6
-    CImgList& operator+=(const T& val) {
-#else
-        template<typename t> CImgList& operator+=(const t& val) {
-#endif
-      cimglist_for(*this,l) (*this)[l]+=val;
-      return *this;
-    }
-
-    //! Operator+=
-    template<typename t> CImgList& operator+=(const CImgList<t>& list) {
-      const unsigned int sizemax = min(size,list.size);
-      for (unsigned int l=0; l<sizemax; l++) (*this)[l]+=list[l];
-      return *this;
-    }
-
-    //! Operator++
-    CImgList& operator++() {
-      cimglist_for(*this,l) (*this)[l]++;
-      return *this;
-    }
-
-    //! Operator-
-    CImgList operator-() const {
-      CImgList<T> res(size);
-      cimglist_for(res,l) res[l].assign(-data[l]);
-      return res;
-    }
-
-    //! Operator-=.
-#ifdef cimg_use_visualcpp6
-    CImgList& operator-=(const T& val) {
-#else
-        template<typename t> CImgList& operator-=(const t& val) {
-#endif
-      cimglist_for(*this,l) (*this)[l]-=val;
-      return *this;
-    }
-
-    //! Operator-=.
-    template<typename t> CImgList& operator-=(const CImgList<t>& list) {
-      const unsigned int sizemax = min(size,list.size);
-      for (unsigned int l=0; l<sizemax; l++) (*this)[l]-=list[l];
-      return *this;
-    }
-
-    //! Operator--
-    CImgList& operator--() {
-      cimglist_for(*this,l) (*this)[l]--;
-      return *this;
-    }
-
-    //! Operator*=.
-#ifdef cimg_use_visualcpp6
-    CImgList& operator*=(const double val) {
-#else
-        template<typename t> CImgList& operator*=(const t& val) {
-#endif
-      cimglist_for(*this,l) (*this)[l]*=val;
-      return *this;
-    }
-
-    //! Operator*=.
-    template<typename t> CImgList& operator*=(const CImgList<t>& list) {
-      const unsigned int N = cimg::min(size,list.size);
-      for (unsigned int l=0; l<N; l++) (*this)[l]*=list[l];
-      return this;
-    }
-
-    //! Operator/=.
-#ifdef cimg_use_visualcpp6
-    CImgList& operator/=(const double val) {
-#else
-        template<typename t> CImgList& operator/=(const t& val) {
-#endif
-      cimglist_for(*this,l) (*this)[l]/=val;
-      return *this;
-    }
-
-    //! Operator/=.
-    template<typename t> CImgList& operator/=(const CImgList<t>& list) {
-      const unsigned int N = cimg::min(size,list.size);
-      for (unsigned int l=0; l<N; l++) (*this)[l]/=list[l];
-      return this;
-    }
-
-    //@}
-    //-------------------------
-    //
-    //! \name List Manipulation
-    //@{
-    //-------------------------
-
-    //! Return a reference to the i-th element of the image list.
-    CImg<T>& operator[](const unsigned int pos) {
-#if cimg_debug>=3
-      if (pos>=size) {
-        cimg::warn(true,"CImgList<%s>::operator[] : bad list position %u, in a list of %u images",pixel_type(),pos,size);
-        return *data;
-      }
-#endif
-      return data[pos];
-    }
-
-    const CImg<T>& operator[](const unsigned int pos) const {
-#if cimg_debug>=3
-      if (pos>=size) {
-        cimg::warn(true,"CImgList<%s>::operator[] : bad list position %u, in a list of %u images",pixel_type(),pos,size);
-        return *data;
-      }
-#endif
-      return data[pos];
-    }
-
-    //! Equivalent to CImgList<T>::operator[]
-    CImg<T>& operator()(const unsigned int pos) { return (*this)[pos]; }
-    const CImg<T>& operator()(const unsigned int pos) const { return (*this)[pos]; }
-
-    //! Return a reference to (x,y,z,v) pixel of the pos-th image of the list
-    T& operator()(const unsigned int pos, const unsigned int x, const unsigned int y=0,
-                  const unsigned int z=0, const unsigned int v=0) {
-      return (*this)[pos](x,y,z,v);
-    }
-    const T& operator()(const unsigned int pos, const unsigned int x, const unsigned int y=0,
-                        const unsigned int z=0, const unsigned int v=0) const {
-      return (*this)[pos](x,y,z,v);
-    }
-
-    //! Equivalent to CImgList<T>::operator[], with boundary checking
-    CImg<T>& at(const unsigned int pos) {
-      if (pos>=size)
-        throw CImgArgumentException("CImgList<%s>::at() : bad list position %u, in a list of %u images",
-                                    pixel_type(),pos,size);
-      return data[pos];
-    }
-
-    const CImg<T>& at(const unsigned int pos) const {
-      if (pos>=size)
-        throw CImgArgumentException("CImgList<%s>::at() : bad list position %u, in a list of %u images",
-                                    pixel_type(),pos,size);
-      return data[pos];
-    }
-
-    //! Returns a reference to last element
-    CImg<T>& back() {
-      return (*this)(size-1);
-    }
-
-    const CImg<T>& back() const {
-      return (*this)(size-1);
-    }
-
-    //! Returns a reference to the first element
-    CImg<T>& front() {
-      return *data;
-    }
-
-    const CImg<T>& front() const {
-      return *data;
-    }
-
-    //! Returns an iterator to the beginning of the vector.
-    iterator begin() {
-      return data;
-    }
-
-    const_iterator begin() const {
-      return data;
-    }
-
-    //! Returns an iterator just past the last element.
-    iterator end() {
-      return data + size;
-    }
-
-    const_iterator end() const {
-      return data + size;
-    }
-
-    //! Insert a copy of the image \p img into the current image list, at position \p pos.
-    template<typename t> CImgList& insert(const CImg<t>& img, const unsigned int pos, const bool shared) {
-      if (pos>size)
-        throw CImgArgumentException("CImgList<%s>::insert() : Cannot insert at position %u into a list with %u elements",
-                                    pixel_type(),pos,size);
-      if (shared)
-        throw CImgArgumentException("CImgList<%s>::insert(): Cannot insert a shared image CImg<%s> into a CImgList<%s>",
-                                    pixel_type(),img.pixel_type(),pixel_type());
-      CImg<T> *new_data = (++size>allocsize)?new CImg<T>[allocsize?(allocsize<<=1):(allocsize=1)]:0;
-      if (!size || !data) { data = new_data; *data = img; } else {
-        if (new_data) {
-          if (pos) std::memcpy(new_data,data,sizeof(CImg<T>)*pos);
-          if (pos!=size-1) std::memcpy(new_data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
-          std::memset(data,0,sizeof(CImg<T>)*(size-1));
-          delete[] data;
-          data = new_data;
-        }
-        else if (pos!=size-1) memmove(data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
-        data[pos].width = data[pos].height = data[pos].depth = data[pos].dim = 0; data[pos].data = 0;
-        data[pos] = img;
-      }
-      return *this;
-    }
-
-   CImgList& insert(const CImg<T>& img, const unsigned int pos, const bool shared) {
-      if (pos>size)
-        throw CImgArgumentException("CImgList<%s>::insert() : Can't insert at position %u into a list with %u elements",
-                                    pixel_type(),pos,size);
-      CImg<T> *new_data = (++size>allocsize)?new CImg<T>[allocsize?(allocsize<<=1):(allocsize=1)]:0;
-      if (!size || !data) {
-        data = new_data;
-        if (shared && !img.is_empty()) {
-          data->width = img.width; data->height = img.height; data->depth = img.depth; data->dim = img.dim;
-          data->is_shared = true; data->data = img.data;
-        } else *data = img;
-      }
-      else {
-        if (new_data) {
-          if (pos) std::memcpy(new_data,data,sizeof(CImg<T>)*pos);
-          if (pos!=size-1) std::memcpy(new_data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
-          std::memset(data,0,sizeof(CImg<T>)*(size-1));
-          delete[] data;
-          data = new_data;
-        }
-        else if (pos!=size-1) memmove(data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
-        if (shared && !img.is_empty()) {
-          data[pos].width = img.width; data[pos].height = img.height; data[pos].depth = img.depth; data[pos].dim = img.dim;
-          data[pos].is_shared = true; data[pos].data = img.data;
-        } else {
-          data[pos].width = data[pos].height = data[pos].depth = data[pos].dim = 0; data[pos].data = 0;
-          data[pos] = img;
-        }
-      }
-      return *this;
-    }
-
-   template<typename t> CImgList& insert(const CImg<t>& img, const unsigned int pos) {
-                return insert(img,pos,false);
-   }
-
-    template<typename t> CImgList<typename cimg::largest<T,t>::type> get_insert(const CImg<t>& img, const unsigned int pos, const bool shared=false) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImgList<restype>(*this).insert(img,pos,shared);
-    }
-
-    //! Insert a copy of the image \p img at the current image list.
-    template<typename t> CImgList& insert(const CImg<t>& img) {
-      return insert(img,size);
-    }
-
-    template<typename t> CImgList<typename cimg::largest<T,t>::type> get_insert(const CImg<t>& img) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImgList<restype>(*this).insert(img);
-    }
-
-    //! Insert a copy of the image \p img at the current image list.
-    CImgList& operator<<(const CImg<T>& img) {
-      return insert(img);
-    }
-
-    //! Insert n copies of the image \p img into the current image list, at position \p pos.
-    template<typename t> CImgList& insert(const unsigned int n, const CImg<t>& img, const unsigned int pos) {
-      for (unsigned int i=0; i<n; i++) insert(img,pos);
-      return *this;
-    }
-
-    template<typename t> CImgList<typename cimg::largest<T,t>::type> get_insert(const unsigned int n, const CImg<t>& img, const unsigned int pos) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImgList<restype>(*this).insert(n,img,pos);
-    }
-
-
-    //! Insert n copies of the image \p img at the end of the list.
-    template<typename t> CImgList& insert(const unsigned int n, const CImg<t>& img) {
-      for (unsigned int i=0; i<n; i++) insert(img);
-      return *this;
-    }
-
-    template<typename t> CImgList<typename cimg::largest<T,t>::type> get_insert(const unsigned int n, const CImg<t>& img) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImgList<restype>(*this).insert(n,img);
-    }
-
-    //! Insert a copy of the image list \p list into the current image list, starting from position \p pos.
-    template<typename t> CImgList& insert(const CImgList<t>& list, const unsigned int pos) {
-      cimglist_for(list,l) insert(list[l],pos+l);
-      return *this;
-    }
-
-    CImgList& insert(const CImgList<T>& list, const unsigned int pos) {
-      if (this!=&list) cimglist_for(list,l) insert(list[l],pos+l);
-      else insert(CImgList<T>(list),pos);
-      return *this;
-    }
-
-    template<typename t> CImgList<typename cimg::largest<T,t>::type> get_insert(const CImgList<t>& list, const unsigned int pos) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImgList<restype>(*this).insert(list,pos);
-    }
-
-    //! Append a copy of the image list \p list at the current image list.
-    template<typename t> CImgList& insert(const CImgList<t>& list) {
-      return insert(list,size);
-    }
-
-    template<typename t> CImgList<typename cimg::largest<T,t>::type> get_insert(const CImgList<t>& list) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImgList<restype>(*this).insert(list);
-    }
-
-    //! Insert a copy of the image list \p list at the current image list.
-    CImgList& operator<<(const CImgList& list) {
-      return insert(list);
-    }
-
-    //! Insert n copies of the list \p list at position \p pos of the current list.
-    template<typename t> CImgList& insert(const unsigned int n, const CImgList<t>& list, const unsigned int pos) {
-      for (unsigned int i=0; i<n; i++) insert(list,pos);
-      return *this;
-    }
-
-    template<typename t> CImgList<typename cimg::largest<T,t>::type> get_insert(const unsigned int n, const CImgList<t>& list, const unsigned int pos) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImgList<restype>(*this).insert(n,list,pos);
-    }
-
-    //! Insert n copies of the list at the end of the current list
-    template<typename t> CImgList& insert(const unsigned int n, const CImgList<t>& list) {
-      for (unsigned int i=0; i<n; i++) insert(list);
-      return *this;
-    }
-
-    template<typename t> CImgList<typename cimg::largest<T,t>::type> get_insert(const unsigned int n, const CImgList<t>& list) const {
-      typedef typename cimg::largest<T,t>::type restype;
-      return CImgList<restype>(*this).insert(n,list);
-    }
-
-    //! Insert image \p img at the end of the list.
-    template<typename t> CImgList& push_back(const CImg<t>& img) {
-      return insert(img);
-    }
-
-    //! Insert image \p img at the front of the list.
-    template<typename t> CImgList& push_front(const CImg<t>& img) {
-      return insert(img,0);
-    }
-
-    //! Insert list \p list at the end of the current list.
-    template<typename t> CImgList& push_back(const CImgList<t>& list) {
-      return insert(list);
-    }
-
-    //! Insert list \p list at the front of the current list.
-    template<typename t> CImgList& push_front(const CImgList<t>& list) {
-      return insert(list,0);
-    }
-
-    //! Insert a shared copy of the image \p img into the current image list, at position \p pos.
-    template<typename t> CImgList& insert_shared(const CImg<t>& img, const unsigned int pos) {
-      return insert(img,pos,true);
-    }
-
-    template<typename t> CImgList get_insert_shared(const CImg<t>& img, const unsigned int pos) const {
-      return CImgList<T>(*this).insert_shared(img,pos);
-    }
-
-    //! Insert a shared copy of the image \p img at the current image list.
-    template<typename t> CImgList& insert_shared(const CImg<t>& img) {
-      return insert_shared(img,size);
-    }
-
-    template<typename t> CImgList get_insert_shared(const CImg<t>& img) const {
-      return CImgList<T>(*this).insert_shared(img);
-    }
-
-    //! Insert n shared copies of the image \p img into the current image list, at position \p pos.
-    template<typename t> CImgList& insert_shared(const unsigned int n, const CImg<t>& img, const unsigned int pos) {
-      for (unsigned int i=0; i<n; i++) insert_shared(img,pos);
-      return *this;
-    }
-
-    template<typename t> CImgList get_insert_shared(const unsigned int n, const CImg<t>& img, const unsigned int pos) const {
-      return CImgList<T>(*this).insert_shared(n,img,pos);
-    }
-
-    //! Insert n shared copies of the image \p img at the end of the list.
-    template<typename t> CImgList& insert_shared(const unsigned int n, const CImg<t>& img) {
-      for (unsigned int i=0; i<n; i++) insert_shared(img);
-      return *this;
-    }
-
-    template<typename t> CImgList get_insert_shared(const unsigned int n, const CImg<t>& img) const {
-      return CImgList<T>(*this).insert_shared(n,img);
-    }
-
-    //! Insert a shared copy of all image of the list \p list into the current image list, starting from position \p pos.
-    template<typename t> CImgList& insert_shared(const CImgList<t>& list, const unsigned int pos) {
-      if (this!=&list) cimglist_for(list,l) insert_shared(list[l],pos+l);
-      else insert_shared(CImgList<T>(list),pos);
-      return *this;
-    }
-
-    template<typename t> CImgList get_insert_shared(const CImgList<t>& list, const unsigned int pos) const {
-      return CImgList<T>(*this).insert_shared(list,pos);
-    }
-
-    //! Append a shared copy of the image list \p list at the current image list.
-    template<typename t> CImgList& insert_shared(const CImgList<t>& list) {
-      return insert_shared(list,size);
-    }
-
-    template<typename t> CImgList get_insert_shared(const CImgList<t>& list) const {
-      return CImgList<T>(*this).insert_shared(list);
-    }
-
-    //! Insert n shared copies of the list \p list at position \p pos of the current list.
-    template<typename t> CImgList& insert_shared(const unsigned int n, const CImgList<t>& list, const unsigned int pos) {
-      for (unsigned int i=0; i<n; i++) insert_shared(list,pos);
-      return *this;
-    }
-
-    template<typename t> CImgList get_insert_shared(const unsigned int n, const CImgList<t>& list, const unsigned int pos) const {
-      return CImgList<T>(*this).insert_shared(n,list,pos);
-    }
-
-    //! Insert n shared copies of the list \p list at the end of the list
-    template<typename t> CImgList& insert_shared(const unsigned int n, const CImgList<t>& list) {
-      return insert_shared(n,list,size);
-    }
-
-    template<typename t> CImgList get_insert_shared(const unsigned int n, const CImgList<t>& list) const {
-      return CImgList<T>(*this).insert_shared(n,list);
-    }
-
-    //! Remove the image at position \p pos from the image list.
-    CImgList& remove(const unsigned int pos) {
-      if (pos>=size)
-        cimg::warn(true,"CImgList<%s>::remove() : Cannot remove an image from a list (%p,%u), at position %u.",
-                   pixel_type(),data,size,pos);
-      else {
-        data[pos].assign();
-        if (!(--size)) return assign();
-        if (size<8 || size>(allocsize>>2)) { // Removing item without reallocation.
-          if (pos!=size) {
-            std::memmove(data+pos,data+pos+1,sizeof(CImg<T>)*(size-pos));
-            CImg<T> &tmp = data[size];
-            tmp.width = tmp.height = tmp.depth = tmp.dim = 0; tmp.data = 0;
-          }
-        } else { // Removing item with reallocation.
-          allocsize>>=2;
-          CImg<T> *new_data = new CImg<T>[allocsize];
-          if (pos) std::memcpy(new_data,data,sizeof(CImg<T>)*pos);
-          if (pos!=size) std::memcpy(new_data+pos,data+pos+1,sizeof(CImg<T>)*(size-pos));
-          std::memset(data,0,sizeof(CImg<T>)*(size+1));
-          delete[] data;
-          data = new_data;
-        }
-      }
-      return *this;
-    }
-
-    CImgList get_remove(const unsigned int pos) const {
-      return CImgList<T>(*this).remove(pos);
-    }
-
-    //! Remove last element of the list;
-    CImgList& pop_back() {
-      return remove(size-1);
-    }
-
-    //! Remove last element of the list;
-    CImgList& operator>>(CImg<T>& img) {
-      if (size) { img.swap((*this)[size-1]); return remove(size-1); }
-      cimg::warn(true,"CImgl<%s>::operator>>() : List is empty",pixel_type());
-      img.assign();
-      return *this;
-    }
-
-    //! Remove first element of the list;
-    CImgList& pop_front() {
-      return remove(0);
-    }
-
-    //! Remove the element pointed by iterator \p iter;
-    CImgList& erase(const iterator iter) {
-      return remove(iter-data);
-    }
-
-    //! Remove the last image from the image list.
-    CImgList& remove() {
-      if (size) return remove(size-1);
-      else cimg::warn(true,"CImgList<%s>::remove() : List is empty",pixel_type());
-      return *this;
-    }
-
-    CImgList get_remove() const {
-      return CImgList<T>(*this).remove();
-    }
-
-    //! Reverse list order
-    CImgList& reverse() {
-      for (unsigned int l=0; l<size/2; l++) (*this)[l].swap((*this)[size-1-l]);
-      return *this;
-    }
-
-    //! Get reversed list
-    CImgList get_reverse() const {
-      return CImgList<T>(*this).reverse();
-    }
-
-    //! Get a sub-list
-    const CImgList get_crop(const unsigned int i0, const unsigned int i1, const bool shared=false) const {
-      if (i0>i1 || i1>=size)
-        throw CImgArgumentException("CImgList<%s>::get_crop() : Cannot get a sub-list (%u->%u) from a list of %u images",
-                                    pixel_type(),i0,i1,size);
-      CImgList<T> res(i1-i0+1);
-      cimglist_for(res,l) res[l].assign((*this)[i0+l],shared);
-      return res;
-    }
-
-    //! Replace a list by its sublist
-    CImgList& crop(const unsigned int i0, const unsigned int i1, const bool shared=false) {
-      return get_crop(i0,i1,shared).swap(*this);
-    }
-
-    //@}
-    //----------------------------
-    //
-    //! \name Fourier Transforms
-    //@{
-    //----------------------------
-
-    //! Compute the Fast Fourier Transform (along the specified axis).
-    CImgList& FFT(const char axe, const bool inverse=false) {
-      if (is_empty()) throw CImgInstanceException("CImgList<%s>::FFT() : Instance list (%u,%p) is empty",pixel_type(),size,data);
-      if (data[0].is_empty()) throw CImgInstanceException("CImgList<%s>::FFT() : Real part (%u,%u,%u,%u,%p) is empty",
-                                                          pixel_type,data[0].width,data[0].height,data[0].depth,data[0].dim,data[0].data);
-      cimg::warn(size>2,"CImgList<%s>::FFT() : Instance list (%u,%p) have more than 2 images",pixel_type(),size,data);
-      if (size==1) insert(CImg<T>(data[0].width,data[0].height,data[0].depth,data[0].dim,0));
-      CImg<T> &Ir = data[0], &Ii = data[1];
-      if (Ir.width!=Ii.width || Ir.height!=Ii.height || Ir.depth!=Ii.depth || Ir.dim!=Ii.dim)
-        throw CImgInstanceException("CImgList<%s>::FFT() : Real part (%u,%u,%u,%u,%p) and imaginary part (%u,%u,%u,%u,%p)"
-                                    "have different dimensions",pixel_type(),
-                                    Ir.width,Ir.height,Ir.depth,Ir.dim,Ir.data,Ii.width,Ii.height,Ii.depth,Ii.dim,Ii.data);
-
-#ifdef cimg_use_fftw3
-      fftw_complex *data_in;
-      fftw_plan data_plan;
-
-      switch (cimg::uncase(axe)) {
-      case 'x': {
-        data_in = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * Ir.width);
-        data_plan = fftw_plan_dft_1d(Ir.width, data_in, data_in, inverse?FFTW_BACKWARD:FFTW_FORWARD, FFTW_ESTIMATE);
-        cimg_forYZV(Ir,y,z,k) {
-          T *ptrr = Ir.ptr(0,y,z,k), *ptri = Ii.ptr(0,y,z,k);
-          double *ptrd = (double*)data_in;
-          cimg_forX(Ir,x) { *(ptrd++) = (double)*(ptrr++); *(ptrd++) = (double)*(ptri++); }
-          fftw_execute(data_plan);
-          cimg_forX(Ir,x) { *(--ptri) = (T)*(--ptrd); *(--ptrr) = (T)*(--ptrd); }
-        }
-      } break;
-
-      case 'y': {
-        data_in = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * Ir.height);
-        data_plan = fftw_plan_dft_1d(Ir.height, data_in, data_in, inverse?FFTW_BACKWARD:FFTW_FORWARD, FFTW_ESTIMATE);
-        const unsigned int off = Ir.width;
-        cimg_forXZV(Ir,x,z,k) {
-          T *ptrr = Ir.ptr(x,0,z,k), *ptri = Ii.ptr(x,0,z,k);
-          double *ptrd = (double*)data_in;
-          cimg_forY(Ir,y) { *(ptrd++) = (double)*ptrr; *(ptrd++) = (double)*ptri; ptrr+=off; ptri+=off; }
-          fftw_execute(data_plan);
-          cimg_forY(Ir,y) { ptrr-=off; ptri-=off; *ptri = (T)*(--ptrd); *ptrr = (T)*(--ptrd); }
-        }
-      } break;
-
-      case 'z': {
-        data_in = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * Ir.depth);
-        data_plan = fftw_plan_dft_1d(Ir.depth, data_in, data_in, inverse?FFTW_BACKWARD:FFTW_FORWARD, FFTW_ESTIMATE);
-        const unsigned int off = Ir.width*Ir.height;
-        cimg_forXYV(Ir,x,y,k) {
-          T *ptrr = Ir.ptr(x,y,0,k), *ptri = Ii.ptr(x,y,0,k);
-          double *ptrd = (double*)data_in;
-          cimg_forZ(Ir,z) { *(ptrd++) = (double)*ptrr; *(ptrd++) = (double)*ptri; ptrr+=off; ptri+=off; }
-          fftw_execute(data_plan);
-          cimg_forZ(Ir,z) { ptrr-=off; ptri-=off; *ptri = (T)*(--ptrd); *ptrr = (T)*(--ptrd); }
-        }
-      } break;
-
-      case 'v': {
-        data_in = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * Ir.dim);
-        data_plan = fftw_plan_dft_1d(Ir.dim, data_in, data_in, inverse?FFTW_BACKWARD:FFTW_FORWARD, FFTW_ESTIMATE);
-        const unsigned int off = Ir.width*Ir.height*Ir.depth;
-        cimg_forXYZ(Ir,x,y,z) {
-          T *ptrr = Ir.ptr(x,y,z,0), *ptri = Ii.ptr(x,y,z,0);
-          double *ptrd = (double*)data_in;
-          cimg_forV(Ir,k) { *(ptrd++) = (double)*ptrr; *(ptrd++) = (double)*ptri; ptrr+=off; ptri+=off; }
-          fftw_execute(data_plan);
-          cimg_forV(Ir,k) { ptrr-=off; ptri-=off; *ptri = (T)*(--ptrd); *ptrr = (T)*(--ptrd); }
-        }
-      } break;
-      }
-
-      fftw_destroy_plan(data_plan);
-      fftw_free(data_in);
-#else
-      switch (cimg::uncase(axe)) {
-      case 'x': { // Fourier along X
-        const unsigned int N = Ir.width, N2 = (N>>1);
-        if (((N-1)&N) && N!=1) throw CImgInstanceException("CImgList<%s>::FFT() : Dimension of instance image along 'x' is %d != 2^N",
-                                                           pixel_type(),N);
-        for (unsigned int i=0,j=0; i<N2; i++) {
-          if (j>i) cimg_forYZV(Ir,y,z,v) { cimg::swap(Ir(i,y,z,v),Ir(j,y,z,v)); cimg::swap(Ii(i,y,z,v),Ii(j,y,z,v));
-          if (j<N2) {
-            const unsigned int ri = N-1-i, rj = N-1-j;
-            cimg::swap(Ir(ri,y,z,v),Ir(rj,y,z,v)); cimg::swap(Ii(ri,y,z,v),Ii(rj,y,z,v));
-          }}
-          for (unsigned int m=N, n=N2; (j+=n)>=m; j-=m, m=n, n>>=1);
-        }
-        for (unsigned int delta=2; delta<=N; delta<<=1) {
-          const unsigned int delta2 = (delta>>1);
-          for (unsigned int i=0; i<N; i+=delta) {
-            float wr = 1, wi = 0;
-            const float angle = (float)((inverse?+1:-1)*2*cimg::PI/delta),
-                        ca = (float)std::cos(angle),
-                        sa = (float)std::sin(angle);
-            for (unsigned int k=0; k<delta2; k++) {
-              const unsigned int j = i + k, nj = j + delta2;
-              cimg_forYZV(Ir,y,z,k) {
-                T &ir = Ir(j,y,z,k), &ii = Ii(j,y,z,k), &nir = Ir(nj,y,z,k), &nii = Ii(nj,y,z,k);
-                const T tmpr = wr*nir - wi*nii, tmpi = wr*nii + wi*nir;
-                nir = ir - tmpr; nii = ii - tmpi;
-                ir += tmpr; ii += tmpi;
-              }
-              const float nwr = wr*ca-wi*sa;
-              wi = wi*ca + wr*sa;
-              wr = nwr;
-            }
-          }
-        }
-        if (inverse) (*this)/=N;
-      } break;
-
-      case 'y': { // Fourier along Y
-        const unsigned int N = Ir.height, N2 = (N>>1);
-        if (((N-1)&N) && N!=1) throw CImgInstanceException("CImgList<%s>::FFT() : Dimension of instance image(s) along 'y' is %d != 2^N",
-                                                           pixel_type(),N);
-        for (unsigned int i=0,j=0; i<N2; i++) {
-          if (j>i) cimg_forXZV(Ir,x,z,v) { cimg::swap(Ir(x,i,z,v),Ir(x,j,z,v)); cimg::swap(Ii(x,i,z,v),Ii(x,j,z,v));
-          if (j<N2) {
-            const unsigned int ri = N-1-i, rj = N-1-j;
-            cimg::swap(Ir(x,ri,z,v),Ir(x,rj,z,v)); cimg::swap(Ii(x,ri,z,v),Ii(x,rj,z,v));
-          }}
-          for (unsigned int m=N, n=N2; (j+=n)>=m; j-=m, m=n, n>>=1);
-        }
-        for (unsigned int delta=2; delta<=N; delta<<=1) {
-          const unsigned int delta2 = (delta>>1);
-          for (unsigned int i=0; i<N; i+=delta) {
-            float wr = 1, wi = 0;
-            const float angle = (float)((inverse?+1:-1)*2*cimg::PI/delta),
-                        ca = (float)std::cos(angle), sa = (float)std::sin(angle);
-            for (unsigned int k=0; k<delta2; k++) {
-              const unsigned int j = i + k, nj = j + delta2;
-              cimg_forXZV(Ir,x,z,k) {
-                T &ir = Ir(x,j,z,k), &ii = Ii(x,j,z,k), &nir = Ir(x,nj,z,k), &nii = Ii(x,nj,z,k);
-                const T tmpr = wr*nir - wi*nii, tmpi = wr*nii + wi*nir;
-                nir = ir - tmpr; nii = ii - tmpi;
-                ir += tmpr; ii += tmpi;
-              }
-              const float nwr = wr*ca-wi*sa;
-              wi = wi*ca + wr*sa;
-              wr = nwr;
-            }
-          }
-        }
-        if (inverse) (*this)/=N;
-      } break;
-
-      case 'z': { // Fourier along Z
-        const unsigned int N = Ir.depth, N2 = (N>>1);
-        if (((N-1)&N) && N!=1) throw CImgInstanceException("CImgList<%s>::FFT() : Dimension of instance image(s) along 'z' is %d != 2^N",
-                                                           pixel_type(),N);
-        for (unsigned int i=0,j=0; i<N2; i++) {
-          if (j>i) cimg_forXYV(Ir,x,y,v) { cimg::swap(Ir(x,y,i,v),Ir(x,y,j,v)); cimg::swap(Ii(x,y,i,v),Ii(x,y,j,v));
-          if (j<N2) {
-            const unsigned int ri = N-1-i, rj = N-1-j;
-            cimg::swap(Ir(x,y,ri,v),Ir(x,y,rj,v)); cimg::swap(Ii(x,y,ri,v),Ii(x,y,rj,v));
-          }}
-          for (unsigned int m=N, n=N2; (j+=n)>=m; j-=m, m=n, n>>=1);
-        }
-        for (unsigned int delta=2; delta<=N; delta<<=1) {
-          const unsigned int delta2 = (delta>>1);
-          for (unsigned int i=0; i<N; i+=delta) {
-            float wr = 1, wi = 0;
-            const float angle = (float)((inverse?+1:-1)*2*cimg::PI/delta),
-                        ca = (float)std::cos(angle), sa = (float)std::sin(angle);
-            for (unsigned int k=0; k<delta2; k++) {
-              const unsigned int j = i + k, nj = j + delta2;
-              cimg_forXYV(Ir,x,y,k) {
-                T &ir = Ir(x,y,j,k), &ii = Ii(x,y,j,k), &nir = Ir(x,y,nj,k), &nii = Ii(x,y,nj,k);
-                const T tmpr = wr*nir - wi*nii, tmpi = wr*nii + wi*nir;
-                nir = ir - tmpr; nii = ii - tmpi;
-                ir += tmpr; ii += tmpi;
-              }
-              const float nwr = wr*ca-wi*sa;
-              wi = wi*ca + wr*sa;
-              wr = nwr;
-            }
-          }
-        }
-        if (inverse) (*this)/=N;
-      } break;
-
-      default: throw CImgArgumentException("CImgList<%s>::FFT() : unknown axe '%c', must be 'x','y' or 'z'");
-      }
-#endif
-      return *this;
-    }
-
-    //! Return the Fast Fourier Transform of a complex image (along a specified axis).
-    CImgList<typename cimg::largest<T,float>::type> get_FFT(const char axe,const bool inverse=false) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImgList<restype>(*this).FFT(axe,inverse);
-    }
-
-    //! Compute the Fast Fourier Transform of a complex image.
-    CImgList& FFT(const bool inverse=false) {
-      if (is_empty()) throw CImgInstanceException("CImgList<%s>::FFT() : Instance list (%u,%p) is empty",pixel_type(),size,data);
-      cimg::warn(size>2,"CImgList<%s>::FFT() : Instance list (%u,%p) have more than 2 images",pixel_type(),size,data);
-      if (size==1) insert(CImg<T>(data[0].width,data[0].height,data[0].depth,data[0].dim,0));
-      CImg<T> &Ir = data[0];
-
-#ifdef cimg_use_fftw3
-      CImg<T> &Ii = data[1];
-      fftw_complex *data_in = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * Ir.width*Ir.height*Ir.depth);
-      fftw_plan data_plan;
-      const unsigned int w = Ir.width, wh = w*Ir.height, whd = wh*Ir.depth;
-      data_plan = fftw_plan_dft_3d(Ir.width, Ir.height, Ir.depth, data_in, data_in, inverse?FFTW_BACKWARD:FFTW_FORWARD, FFTW_ESTIMATE);
-      cimg_forV(Ir,k) {
-        T *ptrr = Ir.ptr(0,0,0,k), *ptri = Ii.ptr(0,0,0,k);
-        double *ptrd = (double*)data_in;
-        cimg_forX(Ir,x) { cimg_forY(Ir,y) { cimg_forZ(Ir,z)
-          { *(ptrd++) = (double)*ptrr; *(ptrd++) = (double)*ptri; ptrr+=wh; ptri+=wh; }
-        ptrr-=whd-w; ptri-=whd-w; }
-        ptrr-=wh-1; ptri-=wh-1; }
-        fftw_execute(data_plan);
-        ptrd = (double*)data_in;
-        ptrr = Ir.ptr(0,0,0,k), ptri = Ii.ptr(0,0,0,k);
-        cimg_forX(Ir,x) { cimg_forY(Ir,y) { cimg_forZ(Ir,z)
-          { *ptrr = (T)*(ptrd++); *ptri = (T)*(ptrd++); ptrr+=wh; ptri+=wh; }
-        ptrr-=whd-w; ptri-=whd-w; }
-        ptrr-=wh-1; ptri-=wh-1; }
-      }
-      fftw_destroy_plan(data_plan);
-      fftw_free(data_in);
-#else
-      if (Ir.depth>1)  FFT('z',inverse);
-      if (Ir.height>1) FFT('y',inverse);
-      if (Ir.width>1)  FFT('x',inverse);
-#endif
-      return *this;
-    }
-
-    //! Return the Fast Fourier Transform of a complex image
-    CImgList<typename cimg::largest<T,float>::type> get_FFT(const bool inverse=false) const {
-      typedef typename cimg::largest<T,float>::type restype;
-      return CImgList<restype>(*this).FFT(inverse);
-    }
-
-    //@}
-    //----------------------------------
-    //
-    //! \name Input-Output and Display
-    //@{
-    //----------------------------------
-
-    //! Print informations about the list on the standard output.
-    const CImgList& print(const char* title=0, const unsigned int print_flag=1) const {
-      char tmp[1024];
-      std::fprintf(stderr,"%-8s(this=%p) : { size=%u, data=%p }\n",title?title:"CImgList",
-                   (void*)this,size,(void*)data);
-      if (print_flag>0) cimglist_for(*this,l) {
-        std::sprintf(tmp,"%s[%d]",title?title:"CImgList",l);
-        data[l].print(tmp,print_flag);
-      }
-      return *this;
-    }
-
-    //! Display informations about the list on the standart output.
-    const CImgList& print(const unsigned int print_flag) const {
-      return print(0,print_flag);
-    }
-
-    //! Load an image list from a file.
-    static CImgList get_load(const char *const filename) {
-      const char *ext = cimg::filename_split(filename);
-      if (!cimg::strncasecmp(ext,"cimg",4) || !ext[0]) return get_load_cimg(filename);
-      if (!cimg::strncasecmp(ext,"rec",3) ||
-          !cimg::strncasecmp(ext,"par",3)) return get_load_parrec(filename);
-      CImgList res(1);
-      res[0].load(filename);
-      return res;
-    }
-
-    //! In-place version of load().
-    CImgList& load(const char *const filename) {
-      return get_load(filename).swap(*this);
-    }
-
-#define cimg_load_cimg_case(Ts,Tss) \
-  if (!loaded && !cimg::strcasecmp(Ts,tmp2)) for (unsigned int l=0; l<n; l++) { \
-      const bool endian = cimg::endian(); \
-      j=0; while((i=std::fgetc(nfile))!='\n') tmp[j++]=(char)i; tmp[j]='\0'; \
-      std::sscanf(tmp,"%u %u %u %u",&w,&h,&z,&k);\
-      if (w*h*z*k>0) { \
-        Tss *buf = new Tss[w*h*z*k]; cimg::fread(buf,w*h*z*k,nfile); \
-        if (endian) cimg::endian_swap(buf,w*h*z*k); \
-        CImg<T> idest(w,h,z,k); \
-        cimg_foroff(idest,off) idest[off] = (T)(buf[off]); idest.swap(res[l]); \
-        delete[] buf; \
-       } \
-      loaded = true; \
-    }
-
-    //! Load an image list from a file (.raw format).
-    static CImgList get_load_cimg(std::FILE *const file, const char *const filename=0) {
-      typedef unsigned char uchar;
-      typedef unsigned short ushort;
-      typedef unsigned int uint;
-      typedef unsigned long ulong;
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      char tmp[256],tmp2[256];
-      int i;
-      bool loaded = false;
-      unsigned int n,j,w,h,z,k,err;
-      j=0; while((i=std::fgetc(nfile))!='\n' && i!=EOF && j<256) tmp[j++]=i; tmp[j]='\0';
-      err=std::sscanf(tmp,"%u%*c%255[A-Za-z ]",&n,tmp2);
-      if (err!=2) {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImgList<%s>::get_load_cimg() : File '%s', Unknow CImg RAW header.",
-                              pixel_type(),filename?filename:"(FILE*)");
-      }
-      CImgList<T> res(n);
-      cimg_load_cimg_case("bool",bool);
-      cimg_load_cimg_case("unsigned char",uchar);
-      cimg_load_cimg_case("uchar",uchar);
-      cimg_load_cimg_case("char",char);
-      cimg_load_cimg_case("unsigned short",ushort);
-      cimg_load_cimg_case("ushort",ushort);
-      cimg_load_cimg_case("short",short);
-      cimg_load_cimg_case("unsigned int",uint);
-      cimg_load_cimg_case("uint",uint);
-      cimg_load_cimg_case("int",int);
-      cimg_load_cimg_case("unsigned long",ulong);
-      cimg_load_cimg_case("ulong",ulong);
-      cimg_load_cimg_case("long",long);
-      cimg_load_cimg_case("float",float);
-      cimg_load_cimg_case("double",double);
-      if (!loaded) {
-        if (!file) cimg::fclose(nfile);
-        throw CImgIOException("CImgList<%s>::get_load_cimg() : File '%s', cannot read images of pixels coded as '%s'.",
-                              pixel_type(),filename?filename:"(FILE*)",tmp2);
-      }
-      if (!file) cimg::fclose(nfile);
-      return res;
-    }
-
-    //! Load an image list from a file (.raw format).
-    static CImgList get_load_cimg(const char *const filename) {
-      return get_load_cimg(0,filename);
-    }
-
-    //! In-place version of get_load_cimg().
-    CImgList& load_cimg(std::FILE *const file, const char *const filename=0) {
-      return get_load_cimg(file,filename).swap(*this);
-    }
-
-    //! In-place version of get_load_cimg().
-    CImgList& load_cimg(const char *const filename) {
-      return get_load_cimg(filename).swap(*this);
-    }
-
-    //! Load PAR-REC (Philips) image file
-    static CImgList get_load_parrec(const char *const filename) {
-      char body[1024], filenamepar[1024], filenamerec[1024];
-      const char *ext = cimg::filename_split(filename,body);
-      if (!cimg::strncmp(ext,"par",3)) { std::strcpy(filenamepar,filename); std::sprintf(filenamerec,"%s.rec",body); }
-      if (!cimg::strncmp(ext,"PAR",3)) { std::strcpy(filenamepar,filename); std::sprintf(filenamerec,"%s.REC",body); }
-      if (!cimg::strncmp(ext,"rec",3)) { std::strcpy(filenamerec,filename); std::sprintf(filenamepar,"%s.par",body); }
-      if (!cimg::strncmp(ext,"REC",3)) { std::strcpy(filenamerec,filename); std::sprintf(filenamepar,"%s.PAR",body); }
-      std::FILE *file = cimg::fopen(filenamepar,"r");
-
-      // Parse header file
-      CImgList<float> st_slices;
-      CImgList<unsigned int> st_global;
-      int err;
-      char line[256]={0};
-      do { err=std::fscanf(file,"%255[^\n]%*c",line); } while (err!=EOF && (line[0]=='#' || line[0]=='.'));
-      do {
-        unsigned int sn,sizex,sizey,pixsize;
-        float rs,ri,ss;
-        err=std::fscanf(file,"%u%*u%*u%*u%*u%*u%*u%u%*u%u%u%g%g%g%*[^\n]",&sn,&pixsize,&sizex,&sizey,&ri,&rs,&ss);
-        if (err==7) {
-          st_slices.insert(CImg<float>::vector((float)sn,(float)pixsize,(float)sizex,(float)sizey,ri,rs,ss,0));
-          unsigned int i; for (i=0; i<st_global.size && sn<=st_global[i][2]; i++);
-          if (i==st_global.size) st_global.insert(CImg<unsigned int>::vector(sizex,sizey,sn));
-          else {
-            CImg<unsigned int> &vec = st_global[i];
-            if (sizex>vec[0]) vec[0] = sizex;
-            if (sizey>vec[1]) vec[1] = sizey;
-            vec[2] = sn;
-          }
-          st_slices[st_slices.size-1][7] = (float)i;
-        }
-      } while (err==7);
-
-      // Read data
-      std::FILE *file2 = cimg::fopen(filenamerec,"rb");
-      CImgList<T> dest;
-      { cimglist_for(st_global,l) {
-        const CImg<unsigned int>& vec = st_global[l];
-        dest.insert(CImg<T>(vec[0],vec[1],vec[2]));
-      }}
-
-      cimglist_for(st_slices,l) {
-        const CImg<float>& vec = st_slices[l];
-        const unsigned int
-          sn = (unsigned int)vec[0]-1,
-          pixsize = (unsigned int)vec[1],
-          sizex = (unsigned int)vec[2],
-          sizey = (unsigned int)vec[3],
-          imn = (unsigned int)vec[7];
-        const float ri = vec[4], rs = vec[5], ss = vec[6];
-        switch (pixsize) {
-        case 8: {
-          CImg<unsigned char> buf(sizex,sizey);
-          cimg::fread(buf.data,sizex*sizey,file2);
-          if (cimg::endian()) cimg::endian_swap(buf.data,sizex*sizey);
-          CImg<T>& img = dest[imn];
-          cimg_forXY(img,x,y) img(x,y,sn) = (T)(( buf(x,y)*rs + ri )/(rs*ss));
-        } break;
-        case 16: {
-          CImg<unsigned short> buf(sizex,sizey);
-          cimg::fread(buf.data,sizex*sizey,file2);
-          if (cimg::endian()) cimg::endian_swap(buf.data,sizex*sizey);
-          CImg<T>& img = dest[imn];
-          cimg_forXY(img,x,y) img(x,y,sn) = (T)(( buf(x,y)*rs + ri )/(rs*ss));
-        } break;
-        case 32: {
-          CImg<unsigned int> buf(sizex,sizey);
-          cimg::fread(buf.data,sizex*sizey,file2);
-          if (cimg::endian()) cimg::endian_swap(buf.data,sizex*sizey);
-          CImg<T>& img = dest[imn];
-          cimg_forXY(img,x,y) img(x,y,sn) = (T)(( buf(x,y)*rs + ri )/(rs*ss));
-        } break;
-        default:
-          cimg::fclose(file);
-          cimg::fclose(file2);
-          throw CImgIOException("CImg<%s>::get_load_parrec() : File '%s', cannot handle image with pixsize = %d bits.",
-                                pixel_type(),filename,pixsize);
-          break;
-        }
-      }
-      cimg::fclose(file);
-      cimg::fclose(file2);
-      if (!dest.size)
-        throw CImgIOException("CImg<%s>::get_load_parrec() : File '%s' does not appear to be a valid PAR-REC file.",
-                              pixel_type(),filename);
-      return dest;
-    }
-
-    //! In-place version of get_load_parrec().
-    CImgList& load_parrec(const char *const filename) {
-      return get_load_parrec(filename).swap(*this);
-    }
-
-    //! Load YUV image sequence.
-    static CImgList get_load_yuv(std::FILE *const file, const char *const filename,
-                                 const unsigned int sizex, const unsigned int sizey=1,
-                                 const unsigned int first_frame=0, const int last_frame=-1,
-                                 const bool yuv2rgb=false) {
-      if (sizex%2 || sizey%2)
-        throw CImgArgumentException("CImgList<%s>::get_load_yuv() : File '%s', image dimensions along X and Y must be even numbers (given are %ux%u)\n",
-                                    pixel_type(),filename?filename:"(unknown)",sizex,sizey);
-      if (!sizex || !sizey)
-        throw CImgArgumentException("CImgList<%s>::get_load_yuv() : File '%s', given image sequence size (%u,%u) is invalid",
-                                    pixel_type(),filename?filename:"(unknown)",sizex,sizey);
-      if (last_frame>0 && first_frame>(unsigned int)last_frame)
-        throw CImgArgumentException("CImgList<%s>::get_load_yuv() : File '%s', given first frame %u is posterior to last frame %d.",
-                                    pixel_type(),filename?filename:"(unknown)",first_frame,last_frame);
-      if (!sizex || !sizey)
-        throw CImgArgumentException("CImgList<%s>::get_load_yuv() : File '%s', given frame size (%u,%u) is invalid.",
-                                    pixel_type(),filename?filename:"(unknown)",sizex,sizey);
-      CImgList<T> res;
-      CImg<unsigned char> tmp(sizex,sizey,1,3), UV(sizex/2,sizey/2,1,2);
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"rb");
-      bool stopflag = false;
-      int err;
-      if (first_frame) {
-        err = std::fseek(nfile,first_frame*(sizex*sizey + sizex*sizey/2),SEEK_CUR);
-        if (err) {
-          if (!file) cimg::fclose(nfile);
-          throw CImgIOException("CImgList<%s>::get_load_yuv() : File '%s' doesn't contain frame number %u "
-                                "(out of range error).",pixel_type(),filename?filename:"(FILE*)",first_frame);
-        }
-      }
-      unsigned int frame;
-      for (frame = first_frame; !stopflag && (last_frame<0 || frame<=(unsigned int)last_frame); frame++) {
-        tmp.fill(0);
-        // TRY to read the luminance, don't replace by cimg::fread !
-        err = (int)std::fread((void*)(tmp.ptr()),1,(size_t)(tmp.width*tmp.height),nfile);
-        if (err!=(int)(tmp.width*tmp.height)) {
-          stopflag = true;
-          cimg::warn(err>0,"CImgList<%s>::get_load_yuv() : File '%s' contains incomplete data,"
-                     " or given image dimensions (%u,%u) are incorrect.",
-                     pixel_type(),filename?filename:"(unknown)",sizex,sizey);
-        } else {
-          UV.fill(0);
-          // TRY to read the luminance, don't replace by cimg::fread !
-          err = (int)std::fread((void*)(UV.ptr()),1,(size_t)(UV.size()),nfile);
-          if (err!=(int)(UV.size())) {
-            stopflag = true;
-            cimg::warn(err>0,"CImgList<%s>::get_load_yuv() : File '%s' contains incomplete data,"
-                       " or given image dimensions (%u,%u) are incorrect.",
-                       pixel_type(),filename?filename:"(unknown)",sizex,sizey);
-          } else {
-            cimg_forXY(UV,x,y) {
-              const int x2=2*x, y2=2*y;
-              tmp(x2,y2,1) = tmp(x2+1,y2,1) = tmp(x2,y2+1,1) = tmp(x2+1,y2+1,1) = UV(x,y,0);
-              tmp(x2,y2,2) = tmp(x2+1,y2,2) = tmp(x2,y2+1,2) = tmp(x2+1,y2+1,2) = UV(x,y,1);
-            }
-            if (yuv2rgb) tmp.YCbCrtoRGB();
-            res.insert(tmp);
-          }
-        }
-      }
-      cimg::warn(stopflag && last_frame>=0 && frame!=(unsigned int)last_frame,
-                 "CImgList<%s>::get_load_yuv() : File '%s', frame %d not reached since only %u frames were found in the file.",
-                 pixel_type(),filename?filename:"(unknown)",last_frame,frame-1,filename);
-      if (!file) cimg::fclose(nfile);
-      return res;
-    }
-
-    //! Load YUV image sequence.
-    static CImgList get_load_yuv(const char *const filename,
-                                 const unsigned int sizex, const unsigned int sizey=1,
-                                 const unsigned int first_frame=0, const int last_frame=-1,
-                                 const bool yuv2rgb=false) {
-      return get_load_yuv(0,filename,sizex,sizey,first_frame,last_frame,yuv2rgb);
-    }
-
-    //! In-place version of get_load_yuv().
-    CImgList& load_yuv(std::FILE *const file, const char *const filename,
-                       const unsigned int sizex, const unsigned int sizey=1,
-                       const unsigned int first_frame=0, const int last_frame=-1,
-                       const bool yuv2rgb=false) {
-      return get_load_yuv(file,filename,sizex,sizey,first_frame,last_frame,yuv2rgb).swap(*this);
-    }
-
-    //! In-place version of get_load_yuv().
-    CImgList& load_yuv(const char *const filename,
-                       const unsigned int sizex, const unsigned int sizey,
-                       const unsigned int first_frame=0, const int last_frame=-1,
-                       const bool yuv2rgb=false) {
-      return get_load_yuv(filename,sizex,sizey,first_frame,last_frame,yuv2rgb).swap(*this);
-    }
-
-    //! Load from OFF file format
-    template<typename tf,typename tc>
-    static CImgList<T> get_load_off(std::FILE *const file, const char *const filename,
-                                    CImgList<tf>& primitives, CImgList<tc>& colors,
-                                    const bool invert_faces=false) {
-      return CImg<T>::get_load_off(file,filename,primitives,colors,invert_faces).get_split('x');
-    }
-
-    //! Load from OFF file format
-    template<typename tf,typename tc>
-      static CImgList<T> get_load_off(const char *const filename,
-                                    CImgList<tf>& primitives, CImgList<tc>& colors,
-                                      const bool invert_faces=false) {
-      return get_load_off(0,filename,primitives,colors,invert_faces);
-    }
-
-    //! In-place version of get_load_off()
-    template<typename tf,typename tc>
-    CImgList& load_off(std::FILE *const file, const char *const filename, CImgList<tf>& primitives, CImgList<tc>& colors,
-                       const bool invert_faces=false) {
-      return get_load_off(file,filename,primitives,colors,invert_faces).swap(*this);
-    }
-
-    //! In-place version of get_load_off()
-    template<typename tf,typename tc>
-    CImgList& load_off(const char *const filename, CImgList<tf>& primitives, CImgList<tc>& colors,
-                       const bool invert_faces=false) {
-      return get_load_off(filename,primitives,colors,invert_faces).swap(*this);
-    }
-
-    //! Save an image list into a file.
-    /**
-       Depending on the extension of the given filename, a file format is chosen for the output file.
-    **/
-    const CImgList& save(const char *const filename) const {
-      if (is_empty()) throw CImgInstanceException("CImgList<%s>::save() : Instance list (%u,%p) is empty (file '%s').",
-                                                  pixel_type(),size,data,filename);
-      if (!filename) throw CImgArgumentException("CImg<%s>::save() : Instance list (%u,%p), specified filename is (null).",
-                                                 pixel_type(),size,data);
-      const char *ext = cimg::filename_split(filename);
-      if (!cimg::strncasecmp(ext,"cimg",4) || !ext[0]) return save_cimg(filename);
-      if (!cimg::strncasecmp(ext,"yuv",3)) return save_yuv(filename,true);
-      if (size==1) data[0].save(filename,-1);
-      else cimglist_for(*this,l) data[l].save(filename,l);
-      return *this;
-    }
-
-    //! Save an image sequence into a YUV file
-    const CImgList& save_yuv(std::FILE *const file, const char *const filename=0, const bool rgb2yuv=true) const {
-      if (is_empty()) throw CImgInstanceException("CImgList<%s>::save_yuv() : Instance list (%u,%p) is empty (file '%s').",
-                                                  pixel_type(),size,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_yuv() : Instance list (%u,%p), specified file is (null).",
-                                                          pixel_type(),size,data);
-      if ((*this)[0].dimx()%2 || (*this)[0].dimy()%2)
-        throw CImgInstanceException("CImgList<%s>::save_yuv() : Image dimensions must be even numbers (current are %ux%u, file '%s').",
-                                    pixel_type(),(*this)[0].dimx(),(*this)[0].dimy(),filename?filename:"(unknown)");
-
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      cimglist_for(*this,l) {
-        CImg<unsigned char> YCbCr((*this)[l]);
-        if (rgb2yuv) YCbCr.RGBtoYCbCr();
-        cimg::fwrite(YCbCr.ptr(),YCbCr.width*YCbCr.height,nfile);
-        cimg::fwrite(YCbCr.get_resize(YCbCr.width/2, YCbCr.height/2,1,3,3).ptr(0,0,0,1),
-                     YCbCr.width*YCbCr.height/2,nfile);
-      }
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save an image sequence into a YUV file
-    const CImgList& save_yuv(const char *const filename=0, const bool rgb2yuv=true) const {
-      return save_yuv(0,filename,rgb2yuv);
-    }
-
-    //! Save an image list into a CImg file (RAW binary file + simple header)
-    /**
-       A CImg RAW file is a simple uncompressed binary file that may be used to save list of CImg<T> images.
-       \param filename : name of the output file.
-       \return A reference to the current CImgList instance is returned.
-    **/
-    const CImgList& save_cimg(std::FILE *const file, const char *const filename=0) const {
-      if (is_empty()) throw CImgInstanceException("CImgList<%s>::save_cimg() : Instance list (%u,%p) is empty (file '%s').",
-                                                  pixel_type(),size,data,filename?filename:"(unknown)");
-      if (!file && !filename) throw CImgArgumentException("CImg<%s>::save_cimg() : Instance list (%u,%p), specified file is (null).",
-                                                          pixel_type(),size,data);
-      std::FILE *const nfile = file?file:cimg::fopen(filename,"wb");
-      std::fprintf(nfile,"%u %s\n",size,pixel_type());
-      cimglist_for(*this,l) {
-        const CImg<T>& img = data[l];
-        std::fprintf(nfile,"%u %u %u %u\n",img.width,img.height,img.depth,img.dim);
-        if (img.data) {
-          if (cimg::endian()) {
-            CImg<T> tmp(img);
-            cimg::endian_swap(tmp.data,tmp.size());
-            cimg::fwrite(tmp.data,img.width*img.height*img.depth*img.dim,nfile);
-          } else cimg::fwrite(img.data,img.width*img.height*img.depth*img.dim,nfile);
-        }
-      }
-      if (!file) cimg::fclose(nfile);
-      return *this;
-    }
-
-    //! Save an image list into a CImg file (RAW binary file + simple header)
-    const CImgList& save_cimg(const char *const filename) const {
-      return save_cimg(0,filename);
-    }
-
-    //! Save an image list into a OFF file.
-    template<typename tf, typename tc>
-    const CImgList& save_off(std::FILE *const file, const char *const filename,
-                             const CImgList<tf>& primitives, const CImgList<tc>& colors, const bool invert_faces=false) const {
-      get_append('x').save_off(file,filename,primitives,colors,invert_faces);
-      return *this;
-    }
-
-    //! Save an image list into a OFF file.
-    template<typename tf, typename tc>
-    const CImgList& save_off(const char *const filename,
-                             const CImgList<tf>& primitives, const CImgList<tc>& colors, const bool invert_faces=false) const {
-      return save_off(filename,primitives,colors,invert_faces);
-    }
-
-    //! Return a single image which is the concatenation of all images of the current CImgList instance.
-    /**
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \return A CImg<T> image corresponding to the concatenation is returned.
-    **/
-    CImg<T> get_append(const char axe='x',const char align='c') const {
-      if (is_empty()) return CImg<T>();
-      unsigned int dx=0,dy=0,dz=0,dv=0,pos=0;
-      CImg<T> res;
-      switch(cimg::uncase(axe)) {
-      case 'x': {
-        cimglist_for(*this,l) {
-          const CImg<T>& img = (*this)[l];
-          dx += img.width;
-          dy = cimg::max(dy,img.height);
-          dz = cimg::max(dz,img.depth);
-          dv = cimg::max(dv,img.dim);
-        }
-        res.assign(dx,dy,dz,dv,0);
-        switch (cimg::uncase(align)) {
-        case 'p' : { cimglist_for(*this,ll) { res.draw_image((*this)[ll],pos,0,0,0); pos+=(*this)[ll].width; }} break;
-        case 'n' : { cimglist_for(*this,ll) {
-              res.draw_image((*this)[ll],pos,dy-(*this)[ll].height,dz-(*this)[ll].depth,dv-(*this)[ll].dim); pos+=(*this)[ll].width;
-            }} break;
-        default  : { cimglist_for(*this,ll) {
-              res.draw_image((*this)[ll],pos,(dy-(*this)[ll].height)/2,(dz-(*this)[ll].depth)/2,(dv-(*this)[ll].dim)/2);
-              pos+=(*this)[ll].width;
-            }} break;
-        }
-      } break;
-      case 'y': {
-        cimglist_for(*this,l) {
-          const CImg<T>& img = (*this)[l];
-          dx = cimg::max(dx,img.width);
-          dy += img.height;
-          dz = cimg::max(dz,img.depth);
-          dv = cimg::max(dv,img.dim);
-        }
-        res.assign(dx,dy,dz,dv,0);
-        switch (cimg::uncase(align)) {
-        case 'p': { cimglist_for(*this,ll) { res.draw_image((*this)[ll],0,pos,0,0); pos+=(*this)[ll].height; }} break;
-        case 'n': { cimglist_for(*this,ll) {
-              res.draw_image((*this)[ll],dx-(*this)[ll].width,pos,dz-(*this)[ll].depth,dv-(*this)[ll].dim); pos+=(*this)[ll].height;
-            }} break;
-        default : { cimglist_for(*this,ll) {
-              res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,pos,(dz-(*this)[ll].depth)/2,(dv-(*this)[ll].dim)/2);
-              pos+=(*this)[ll].height;
-            }} break;
-        }
-      } break;
-      case 'z': {
-        cimglist_for(*this,l) {
-          const CImg<T>& img = (*this)[l];
-          dx = cimg::max(dx,img.width);
-          dy = cimg::max(dy,img.height);
-          dz += img.depth;
-          dv = cimg::max(dv,img.dim);
-        }
-        res.assign(dx,dy,dz,dv,0);
-        switch (cimg::uncase(align)) {
-        case 'p': { cimglist_for(*this,ll) { res.draw_image((*this)[ll],0,0,pos,0); pos+=(*this)[ll].depth; }} break;
-        case 'n': { cimglist_for(*this,ll) {
-              res.draw_image((*this)[ll],dx-(*this)[ll].width,dy-(*this)[ll].height,pos,dv-(*this)[ll].dim); pos+=(*this)[ll].depth;
-            }} break;
-        case 'c': { cimglist_for(*this,ll) {
-              res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,(dy-(*this)[ll].height)/2,pos,(dv-(*this)[ll].dim)/2);
-              pos+=(*this)[ll].depth;
-            }} break;
-        }
-      } break;
-      case 'v': {
-        cimglist_for(*this,l) {
-          const CImg<T>& img = (*this)[l];
-          dx = cimg::max(dx,img.width);
-          dy = cimg::max(dy,img.height);
-          dz = cimg::max(dz,img.depth);
-          dv += img.dim;
-        }
-        res.assign(dx,dy,dz,dv,0);
-        switch (cimg::uncase(align)) {
-        case 'p': { cimglist_for(*this,ll) { res.draw_image((*this)[ll],0,0,0,pos); pos+=(*this)[ll].dim; }} break;
-        case 'n': { cimglist_for(*this,ll) {
-              res.draw_image((*this)[ll],dx-(*this)[ll].width,dy-(*this)[ll].height,dz-(*this)[ll].depth,pos); pos+=(*this)[ll].dim;
-            }} break;
-        case 'c': { cimglist_for(*this,ll) {
-              res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,(dy-(*this)[ll].height)/2,(dz-(*this)[ll].depth)/2,pos);
-              pos+=(*this)[ll].dim;
-            }} break;
-        }
-      } break;
-      default: throw CImgArgumentException("CImg<%s>::get_append() : unknow axe '%c', must be 'x','y','z' or 'v'",pixel_type(),axe);
-      }
-      return res;
-    }
-
-    // Create an auto-cropped font (along the X axis) from a input font \p font.
-    CImgList<T> get_crop_font() const {
-      CImgList<T> res;
-      cimglist_for(*this,l) {
-        const CImg<T>& letter = (*this)[l];
-        int xmin = letter.width, xmax = 0;
-        cimg_forXY(letter,x,y) if (letter(x,y)) { if (x<xmin) xmin=x; if (x>xmax) xmax=x; }
-        if (xmin>xmax) res.insert(CImg<T>(letter.width,letter.height,1,letter.dim,0));
-        else res.insert(letter.get_crop(xmin,0,xmax,letter.height-1));
-      }
-      res[' '].resize(res['f'].width);
-      res[' '+256].resize(res['f'].width);
-      return res;
-    }
-
-    CImgList<T>& crop_font() {
-      return get_crop_font().swap(*this);
-    }
-
-    static CImgList<T> get_font(const unsigned int *const font,const unsigned int w,const unsigned int h,
-                             const unsigned int paddingx, const unsigned int paddingy, const bool variable_size=true) {
-      CImgList<T> res = CImgList<T>(256,w,h,1,3).insert(CImgList<T>(256,w,h,1,1));
-      const unsigned int *ptr = font;
-      unsigned int m = 0, val = 0;
-      for (unsigned int y=0; y<h; y++)
-        for (unsigned int x=0; x<256*w; x++) {
-          m>>=1; if (!m) { m=0x80000000; val = *(ptr++); }
-          CImg<T>& img = res[x/w], &mask = res[x/w+256];
-          unsigned int xm = x%w;
-          img(xm,y,0) = img(xm,y,1) = img(xm,y,2) = mask(xm,y,0) = (T)((val&m)?1:0);
-        }
-      if (variable_size) res.crop_font();
-      if (paddingx || paddingy) cimglist_for(res,l) res[l].resize(res[l].dimx()+paddingx, res[l].dimy()+paddingy,1,-100,0);
-      return res;
-    }
-
-    //! Return a CImg pre-defined font with desired size
-    /**
-       \param font_height = height of the desired font (can be 11,13,24,38 or 57)
-       \param fixed_size = tell if the font has a fixed or variable width.
-    **/
-    static CImgList<T> get_font(const unsigned int font_width, const bool variable_size=true) {
-      if (font_width<=11) {
-        static CImgList<T> font7x11, nfont7x11;
-        if (!variable_size && font7x11.is_empty()) font7x11 = get_font(cimg::font7x11,7,11,1,0,false);
-        if (variable_size && nfont7x11.is_empty()) nfont7x11 = get_font(cimg::font7x11,7,11,1,0,true);
-        return variable_size?nfont7x11:font7x11;
-      }
-      if (font_width<=13) {
-        static CImgList<T> font10x13, nfont10x13;
-        if (!variable_size && font10x13.is_empty()) font10x13 = get_font(cimg::font10x13,10,13,1,0,false);
-        if (variable_size && nfont10x13.is_empty()) nfont10x13 = get_font(cimg::font10x13,10,13,1,0,true);
-        return variable_size?nfont10x13:font10x13;
-      }
-      if (font_width<=17) {
-        static CImgList<T> font8x17, nfont8x17;
-        if (!variable_size && font8x17.is_empty()) font8x17 = get_font(cimg::font8x17,8,17,1,0,false);
-        if (variable_size && nfont8x17.is_empty()) nfont8x17 = get_font(cimg::font8x17,8,17,1,0,true);
-        return variable_size?nfont8x17:font8x17;
-      }
-      if (font_width<=19) {
-        static CImgList<T> font10x19, nfont10x19;
-        if (!variable_size && font10x19.is_empty()) font10x19 = get_font(cimg::font10x19,10,19,2,0,false);
-        if (variable_size && nfont10x19.is_empty()) nfont10x19 = get_font(cimg::font10x19,10,19,2,0,true);
-        return variable_size?nfont10x19:font10x19;
-      }
-      if (font_width<=24) {
-        static CImgList<T> font12x24, nfont12x24;
-        if (!variable_size && font12x24.is_empty()) font12x24 = get_font(cimg::font12x24,12,24,2,0,false);
-        if (variable_size && nfont12x24.is_empty()) nfont12x24 = get_font(cimg::font12x24,12,24,2,0,true);
-        return variable_size?nfont12x24:font12x24;
-      }
-      if (font_width<=32) {
-        static CImgList<T> font16x32, nfont16x32;
-        if (!variable_size && font16x32.is_empty()) font16x32 = get_font(cimg::font16x32,16,32,2,0,false);
-        if (variable_size && nfont16x32.is_empty()) nfont16x32 = get_font(cimg::font16x32,16,32,2,0,true);
-        return variable_size?nfont16x32:font16x32;
-      }
-      if (font_width<=38) {
-        static CImgList<T> font19x38, nfont19x38;
-        if (!variable_size && font19x38.is_empty()) font19x38 = get_font(cimg::font19x38,19,38,3,0,false);
-        if (variable_size && nfont19x38.is_empty()) nfont19x38 = get_font(cimg::font19x38,19,38,3,0,true);
-        return variable_size?nfont19x38:font19x38;
-      }
-      static CImgList<T> font29x57, nfont29x57;
-      if (!variable_size && font29x57.is_empty()) font29x57 = get_font(cimg::font29x57,29,57,5,0,false);
-      if (variable_size && nfont29x57.is_empty()) nfont29x57 = get_font(cimg::font29x57,29,57,5,0,true);
-      return variable_size?nfont29x57:font29x57;
-    }
-
-    //! Display the current CImgList instance in an existing CImgDisplay window (by reference).
-    /**
-       This function displays the list images of the current CImgList instance into an existing CImgDisplay window.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns immediately.
-       \param disp : reference to an existing CImgDisplay instance, where the current image list will be displayed.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \return A reference to the current CImgList instance is returned.
-    **/
-    const CImgList& display(CImgDisplay& disp, const char axe='x', const char align='c') const {
-      get_append(axe,align).display(disp);
-      return *this;
-    }
-
-    //! Display the current CImgList instance in a new display window.
-    /**
-       This function opens a new window with a specific title and displays the list images of the current CImgList instance into it.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns when a key is pressed or the display window is closed by the user.
-       \param title : specify the title of the opening display window.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgList instance is returned.
-    **/
-    const CImgList& display(const char* title,const char axe='x',const char align='c',
-                         const int min_size=128,const int max_size=1024) const {
-      get_append(axe,align).display(title,min_size,max_size);
-      return *this;
-    }
-
-    //! Display the current CImgList instance in a new display window.
-    /**
-       This function opens a new window and displays the list images of the current CImgList instance into it.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns when a key is pressed or the display window is closed by the user.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgList instance is returned.
-    **/
-    const CImgList& display(const char axe='x',const char align='c',
-                         const int min_size=128,const int max_size=1024) const {
-      return display(" ",axe,align,min_size,max_size);
-    }
-
-    //! Rescale and center 3D object
-    CImgList& resize_object3d(const float siz=100, const bool centering=true) {
-      float xm = (float)((*this)(0,0)), ym = (float)((*this)(0,1)), zm = (float)((*this)(0,2)), xM = xm, yM = ym, zM = zm;
-      for (unsigned int p=1; p<size; p++) {
-         const float x = (float)((*this)(p,0)), y = (float)((*this)(p,1)), z = (float)((*this)(p,2));
-         if (x<xm) xm = x;
-         if (y<ym) ym = y;
-         if (z<zm) zm = z;
-         if (x>xM) xM = x;
-         if (y>yM) yM = y;
-         if (z>zM) zM = z;
-      }
-      const float
-        cx = 0.5f*(xm+xM),
-        cy = 0.5f*(ym+yM),
-        cz = 0.5f*(zm+zM),
-        delta = cimg::max(xM-xm,yM-ym,zM-zm),
-        ratio = (siz>=0)?siz/delta:-siz/100;
-      if (centering) cimglist_for(*this,l) {
-        T &x = (*this)(l,0), &y = (*this)(l,1), &z = (*this)(l,2);
-        x = (T)((x-cx)*ratio);
-        y = (T)((y-cy)*ratio);
-        z = (T)((z-cz)*ratio);
-      } else cimglist_for(*this,l) {
-        T &x = (*this)(l,0), &y = (*this)(l,1), &z = (*this)(l,2);
-        x = (T)(cx+(x-cx)*ratio);
-        y = (T)(cy+(y-cy)*ratio);
-        z = (T)(cz+(z-cz)*ratio);
-      }
-      return *this;
-    }
-
-    //! Get a rescaled and centered version of the 3D object
-    CImgList get_resize_object3d(const float siz=100, const bool centering=true) const {
-      return CImgList<T>(*this).resize_object3d(siz,centering);
-    }
-
-    // Swap fields of two CImgList instances.
-    CImgList& swap(CImgList& list) {
-      cimg::swap(size,list.size);
-      cimg::swap(allocsize,list.allocsize);
-      cimg::swap(data,list.data);
-      return list;
-    }
-
-  };
-
-  /*
-   #-----------------------------------------
-   #
-   #
-   #
-   # Complete previously defined functions
-   #
-   #
-   #
-   #------------------------------------------
-  */
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImg<t> operator+(const CImg<t>& img, const t& val) {
-        return CImg<t>(img,false)+=val;
-  }
-#else
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator+(const CImg<t1>& img, const t2& val) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImg<restype>(img,false)+=val;
- }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImg<t> operator+(const t& val, const CImg<t>& img) {
-    return img+val;
-  }
-#else
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator+(const t1& val, const CImg<t2>& img) {
-    return img+val;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImgList<t> operator+(const CImgList<t>& list, const t& val) {
-    return CImgList<t>(list)+=val;
-  }
-#else
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator+(const CImgList<t1>& list, const t2& val) {
-          typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list)+=val;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImgList<t> operator+(const t& val, const CImgList<t>& list) {
-          return list+val;
-  }
-#else
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator+(const t1& val, const CImgList<t2>& list) {
-          return list+val;
-  }
-#endif
-
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator+(const CImg<t1>& img1, const CImg<t2>& img2) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImg<restype>(img1,false)+=img2;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator+(const CImg<t1>& img, const CImgList<t2>& list) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list)+=img;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator+(const CImgList<t1>& list, const CImg<t2>& img) {
-    return img+list;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator+(const CImgList<t1>& list1, const CImgList<t2>& list2) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list1)+=list2;
-  }
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImg<t> operator-(const CImg<t>& img, const t& val) {
-          return CImg<t>(img,false)-=val;
-  }
-#else
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator-(const CImg<t1>& img, const t2& val) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImg<restype>(img,false)-=val;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImg<t> operator-(const t& val, const CImg<t>& img) {
-    return CImg<t>(img.width,img.height,img.depth,img.dim,val)-=img;
-  }
-#else
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator-(const t1& val, const CImg<t2>& img) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImg<restype>(img.width,img.height,img.depth,img.dim,(restype)val)-=img;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImgList<t> operator-(const CImgList<t>& list, const t& val) {
-          return CImgList<t>(list)-=val;
-  }
-#else
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator-(const CImgList<t1>& list, const t2& val) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list)-=val;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImgList<double> operator-(const t& val, const CImgList<t>& list) {
-    CImgList<t> res(list.size);
-    cimglist_for(res,l) res[l] = val-list[l];
-    return res;
-  }
-#else
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator-(const t1& val, const CImgList<t2>& list) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    CImgList<restype> res(list.size);
-    cimglist_for(res,l) res[l] = val-list[l];
-    return res;
-  }
-#endif
-
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator-(const CImg<t1>& img1, const CImg<t2>& img2) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImg<restype>(img1,false)-=img2;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator-(const CImg<t1>& img, const CImgList<t2>& list) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    CImgList<restype> res(list.size);
-    cimglist_for(res,l) res[l] = img-list[l];
-    return res;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator-(const CImgList<t1>& list, const CImg<t2>& img) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list)-=img;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator-(const CImgList<t1>& list1, const CImgList<t2>& list2) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list1)-=list2;
-  }
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImg<t> operator*(const CImg<t>& img, const double val) {
-        return CImg<t>(img,false)*=val;
-  }
-#else
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator*(const CImg<t1>& img, const t2& val) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImg<restype>(img,false)*=val;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImg<t> operator*(const double val, const CImg<t>& img) {
-        return img*val;
-  }
-#else
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator*(const t1& val, const CImg<t2>& img) {
-          return img*val;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImgList<t> operator*(const CImgList<t>& list, const double val) {
-          return CImgList<t>(list)*=val;
-  }
-#else
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator*(const CImgList<t1>& list, const t2& val) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list)*=val;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImgList<t> operator*(const double val, const CImgList<t>& list) {
-        return list*val;
-  }
-#else
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator*(const t1& val, const CImgList<t2>& list) {
-          return list*val;
-  }
-#endif
-
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator*(const CImg<t1>& img1, const CImg<t2>& img2) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    if (img1.width!=img2.height)
-      throw CImgArgumentException("operator*() : can't multiply a matrix (%ux%u) by a matrix (%ux%u)",
-                                  img1.width,img1.height,img2.width,img2.height);
-    CImg<restype> res(img2.width,img1.height);
-    restype val;
-    cimg_forXY(res,i,j) { val=0; cimg_forX(img1,k) val+=img1(k,j)*img2(i,k); res(i,j) = val; }
-    return res;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator*(const CImg<t1>& img, const CImgList<t2>& list) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    CImgList<restype> res(list.size);
-    cimglist_for(res,l) res[l] = img*list[l];
-    return res;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator*(const CImgList<t1>& list, const CImg<t2>& img) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    CImgList<restype> res(list.size);
-    cimglist_for(res,l) res[l] = list[l]*img;
-    return res;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator*(const CImgList<t1>& list1, const CImgList<t2>& list2) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    CImgList<restype> res(cimg::min(list1.size,list2.size));
-    cimglist_for(res,l) res[l] = list1[l]*list2[l];
-    return res;
-  }
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImg<t> operator/(const CImg<t>& img, const double val) {
-         return CImg<t>(img,false)/=val;
-         }
-#else
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator/(const CImg<t1>& img, const t2& val) {
-          typedef typename cimg::largest<t1,t2>::type restype;
-    return CImg<restype>(img,false)/=val;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImg<t> operator/(const double val, CImg<t>& img) {
-        return val*img.get_inverse();
-  }
-#else
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator/(const t1& val, CImg<t2>& img) {
-          return val*img.get_inverse();
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImgList<t> operator/(const CImgList<t>& list, const double val) {
-          return CImgList<t>(list)/=val;
-  }
-#else
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator/(const CImgList<t1>& list, const t2& val) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list)/=val;
-  }
-#endif
-
-#ifdef cimg_use_visualcpp6
-  template<typename t> inline CImgList<t> operator/(const double val, const CImgList<t>& list) {
-    CImgList<t> res(list.size);
-    cimglist_for(res,l) res[l] = val/list[l];
-    return res;
-  }
-#else
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator/(const t1& val, const CImgList<t2>& list) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    CImgList<restype> res(list.size);
-    cimglist_for(res,l) res[l] = val/list[l];
-    return res;
-  }
-#endif
-
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator/(const CImg<t1>& img1, const CImg<t2>& img2) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImg<restype>(img1,false)*=img2.get_inverse();
-  }
-
-  template<typename t1, typename t2> inline CImg<typename cimg::largest<t1,t2>::type> operator/(const CImg<t1>& img, const CImgList<t2>& list) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    CImgList<restype> res(list.size);
-    cimglist_for(res,l) res[l] = img/list[l];
-    return res;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator/(const CImgList<t1>& list, const CImg<t2>& img) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list)/=img;
-  }
-
-  template<typename t1, typename t2> inline CImgList<typename cimg::largest<t1,t2>::type> operator/(const CImgList<t1>& list1, const CImgList<t2>& list2) {
-    typedef typename cimg::largest<t1,t2>::type restype;
-    return CImgList<restype>(list1)/=list2;
-  }
-
-namespace cimg {
-
-  //! Display a dialog box, where a user can click standard buttons.
-  /**
-     Up to 6 buttons can be defined in the dialog window.
-     This function returns when a user clicked one of the button or closed the dialog window.
-     \param title = Title of the dialog window.
-     \param msg = Main message displayed inside the dialog window.
-     \param button1_txt = Label of the 1st button.
-     \param button2_txt = Label of the 2nd button.
-     \param button3_txt = Label of the 3rd button.
-     \param button4_txt = Label of the 4th button.
-     \param button5_txt = Label of the 5th button.
-     \param button6_txt = Label of the 6th button.
-     \param logo = Logo image displayed at the left of the main message. This parameter is optional.
-     \param centering = Tell to center the dialog window on the screen.
-     \return The button number (from 0 to 5), or -1 if the dialog window has been closed by the user.
-     \note If a button text is set to 0, then the corresponding button (and the followings) won't appear in
-     the dialog box. At least one button is necessary.
-  **/
-
-  template<typename t>
-  inline int dialog(const char *title,const char *msg,
-                    const char *button1_txt,const char *button2_txt,
-                    const char *button3_txt,const char *button4_txt,
-                    const char *button5_txt,const char *button6_txt,
-                    const CImg<t>& logo, const bool centering = false) {
-#if cimg_display_type!=0
-    const unsigned char
-      black[3]={0,0,0}, white[3]={255,255,255}, gray[3]={200,200,200}, gray2[3]={150,150,150};
-
-      // Create buttons and canvas graphics
-      CImgList<unsigned char> buttons, cbuttons, sbuttons;
-      if (button1_txt) { buttons.insert(CImg<unsigned char>().draw_text(button1_txt,0,0,black,gray,13));
-      if (button2_txt) { buttons.insert(CImg<unsigned char>().draw_text(button2_txt,0,0,black,gray,13));
-      if (button3_txt) { buttons.insert(CImg<unsigned char>().draw_text(button3_txt,0,0,black,gray,13));
-      if (button4_txt) { buttons.insert(CImg<unsigned char>().draw_text(button4_txt,0,0,black,gray,13));
-      if (button5_txt) { buttons.insert(CImg<unsigned char>().draw_text(button5_txt,0,0,black,gray,13));
-      if (button6_txt) { buttons.insert(CImg<unsigned char>().draw_text(button6_txt,0,0,black,gray,13));
-      }}}}}}
-      if (!buttons.size) throw CImgArgumentException("cimg::dialog() : No buttons have been defined. At least one is necessary");
-
-      unsigned int bw=0, bh=0;
-      cimglist_for(buttons,l) { bw = cimg::max(bw,buttons[l].width); bh = cimg::max(bh,buttons[l].height); }
-      bw+=8; bh+=8;
-      if (bw<64) bw=64;
-      if (bw>128) bw=128;
-      if (bh<24) bh=24;
-      if (bh>48) bh=48;
-
-      CImg<unsigned char> button = CImg<unsigned char>(bw,bh,1,3).
-        draw_rectangle(0,0,bw-1,bh-1,gray).
-        draw_line(0,0,bw-1,0,white).draw_line(0,bh-1,0,0,white).
-        draw_line(bw-1,0,bw-1,bh-1,black).draw_line(bw-1,bh-1,0,bh-1,black).
-        draw_line(1,bh-2,bw-2,bh-2,gray2).draw_line(bw-2,bh-2,bw-2,1,gray2);
-      CImg<unsigned char> sbutton = CImg<unsigned char>(bw,bh,1,3).
-        draw_rectangle(0,0,bw-1,bh-1,gray).
-        draw_line(0,0,bw-1,0,black).draw_line(bw-1,0,bw-1,bh-1,black).
-        draw_line(bw-1,bh-1,0,bh-1,black).draw_line(0,bh-1,0,0,black).
-        draw_line(1,1,bw-2,1,white).draw_line(1,bh-2,1,1,white).
-        draw_line(bw-2,1,bw-2,bh-2,black).draw_line(bw-2,bh-2,1,bh-2,black).
-        draw_line(2,bh-3,bw-3,bh-3,gray2).draw_line(bw-3,bh-3,bw-3,2,gray2).
-        draw_line(4,4,bw-5,4,black,0xAAAAAAAA).draw_line(bw-5,4,bw-5,bh-5,black,0xAAAAAAAA).
-        draw_line(bw-5,bh-5,4,bh-5,black,0xAAAAAAAA).draw_line(4,bh-5,4,4,black,0xAAAAAAAA);
-      CImg<unsigned char> cbutton = CImg<unsigned char>(bw,bh,1,3).
-        draw_rectangle(0,0,bw-1,bh-1,black).draw_rectangle(1,1,bw-2,bh-2,gray2).draw_rectangle(2,2,bw-3,bh-3,gray).
-        draw_line(4,4,bw-5,4,black,0xAAAAAAAA).draw_line(bw-5,4,bw-5,bh-5,black,0xAAAAAAAA).
-        draw_line(bw-5,bh-5,4,bh-5,black,0xAAAAAAAA).draw_line(4,bh-5,4,4,black,0xAAAAAAAA);
-
-        cimglist_for(buttons,ll) {
-          cbuttons.insert(CImg<unsigned char>(cbutton).draw_image(buttons[ll],1+(bw-buttons[ll].dimx())/2,1+(bh-buttons[ll].dimy())/2));
-          sbuttons.insert(CImg<unsigned char>(sbutton).draw_image(buttons[ll],(bw-buttons[ll].dimx())/2,(bh-buttons[ll].dimy())/2));
-          buttons[ll] = CImg<unsigned char>(button).draw_image(buttons[ll],(bw-buttons[ll].dimx())/2,(bh-buttons[ll].dimy())/2);
-        }
-
-        CImg<unsigned char> canvas;
-        if (msg) canvas = CImg<unsigned char>().draw_text(msg,0,0,black,gray,13);
-        const unsigned int
-          bwall = (buttons.size-1)*(12+bw) + bw,
-          w = cimg::max(196U,36+logo.width+canvas.width, 24+bwall),
-          h = cimg::max(96U,36+canvas.height+bh,36+logo.height+bh),
-          lx = 12 + (canvas.data?0:((w-24-logo.width)/2)),
-          ly = (h-12-bh-logo.height)/2,
-          tx = lx+logo.width+12,
-          ty = (h-12-bh-canvas.height)/2,
-          bx = (w-bwall)/2,
-          by = h-12-bh;
-
-        if (canvas.data)
-          canvas = CImg<unsigned char>(w,h,1,3).
-            draw_rectangle(0,0,w-1,h-1,gray).
-            draw_line(0,0,w-1,0,white).draw_line(0,h-1,0,0,white).
-            draw_line(w-1,0,w-1,h-1,black).draw_line(w-1,h-1,0,h-1,black).
-            draw_image(canvas,tx,ty);
-        else
-          canvas = CImg<unsigned char>(w,h,1,3).
-            draw_rectangle(0,0,w-1,h-1,gray).
-            draw_line(0,0,w-1,0,white).draw_line(0,h-1,0,0,white).
-            draw_line(w-1,0,w-1,h-1,black).draw_line(w-1,h-1,0,h-1,black);
-        if (logo.data) canvas.draw_image(logo,lx,ly);
-
-        unsigned int xbuttons[6];
-        cimglist_for(buttons,lll) { xbuttons[lll] = bx+(bw+12)*lll; canvas.draw_image(buttons[lll],xbuttons[lll],by); }
-
-        // Open window and enter events loop
-        CImgDisplay disp(canvas,title?title:" ",0,3,false,centering?true:false);
-        if (centering) disp.move((CImgDisplay::screen_dimx()-disp.dimx())/2,
-                                 (CImgDisplay::screen_dimy()-disp.dimy())/2);
-        bool stopflag = false, refresh = false;
-        int oselected = -1, oclicked = -1, selected = -1, clicked = -1;
-        while (!disp.is_closed && !stopflag) {
-          if (refresh) {
-            if (clicked>=0) CImg<unsigned char>(canvas).draw_image(cbuttons[clicked],xbuttons[clicked],by).display(disp);
-            else {
-              if (selected>=0) CImg<unsigned char>(canvas).draw_image(sbuttons[selected],xbuttons[selected],by).display(disp);
-              else canvas.display(disp);
-            }
-            refresh = false;
-          }
-          disp.wait(15);
-          if (disp.is_resized) disp.resize(disp);
-
-          if (disp.button&1)  {
-            oclicked = clicked;
-            clicked = -1;
-            cimglist_for(buttons,l)
-              if (disp.mouse_y>=(int)by && disp.mouse_y<(int)(by+bh) &&
-                  disp.mouse_x>=(int)xbuttons[l] && disp.mouse_x<(int)(xbuttons[l]+bw)) {
-                clicked = selected = l;
-                refresh = true;
-              }
-            if (clicked!=oclicked) refresh = true;
-          } else if (clicked>=0) stopflag = true;
-
-          if (disp.key) {
-            oselected = selected;
-            switch (disp.key) {
-            case cimg::keyESC: selected=-1; stopflag=true; break;
-            case cimg::keyENTER: if (selected<0) selected=0; stopflag = true; break;
-            case cimg::keyTAB:
-            case cimg::keyARROWRIGHT:
-            case cimg::keyARROWDOWN: selected = (selected+1)%buttons.size; break;
-            case cimg::keyARROWLEFT:
-            case cimg::keyARROWUP: selected = (selected+buttons.size-1)%buttons.size; break;
-            }
-            disp.key = 0;
-            if (selected!=oselected) refresh = true;
-          }
-        }
-        if (disp.is_closed) selected = -1;
-        return selected;
-#else
-        std::fprintf(stderr,"<%s>\n\n%s\n\n",title,msg);
-        return -1+0*(int)(button1_txt-button2_txt+button3_txt-button4_txt+button5_txt-button6_txt+logo.width+(int)centering);
-#endif
-  }
-
-  inline int dialog(const char *title,const char *msg,
-                    const char *button1_txt,const char *button2_txt,const char *button3_txt,
-                    const char *button4_txt,const char *button5_txt,const char *button6_txt,
-                    const bool centering) {
-    return dialog(title,msg,button1_txt,button2_txt,button3_txt,button4_txt,button5_txt,button6_txt,
-                  CImg<unsigned char>::get_logo40x38(),centering);
-  }
-
-
-  // Inner routine used by the Marching cube algorithm
-  template<typename t> inline int _marching_cubes_indice(const unsigned int edge, const CImg<t>& indices1, const CImg<t>& indices2,
-                                                         const unsigned int x, const unsigned int y, const unsigned int nx, const unsigned int ny) {
-    switch (edge) {
-    case 0: return indices1(x,y,0);
-    case 1: return indices1(nx,y,1);
-    case 2: return indices1(x,ny,0);
-    case 3: return indices1(x,y,1);
-    case 4: return indices2(x,y,0);
-    case 5: return indices2(nx,y,1);
-    case 6: return indices2(x,ny,0);
-    case 7: return indices2(x,y,1);
-    case 8: return indices1(x,y,2);
-    case 9: return indices1(nx,y,2);
-    case 10: return indices1(nx,ny,2);
-    case 11: return indices1(x,ny,2);
-    }
-    return 0;
-  }
-
-  //! Polygonize an implicit function
-  // This function uses the Marching Cubes Tables published on the web page :
-  // http://astronomy.swin.edu.au/~pbourke/modelling/polygonise/
-  template<typename tfunc, typename tp, typename tf>
-  inline void marching_cubes(const tfunc& func, const float isovalue,
-                             const float x0,const float y0,const float z0,
-                             const float x1,const float y1,const float z1,
-                             const float resx,const float resy,const float resz,
-                             CImgList<tp>& points, CImgList<tf>& primitives,
-                             const bool invert_faces) {
-
-    static unsigned int edges[256]={
-      0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
-      0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
-      0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
-      0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
-      0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
-      0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
-      0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
-      0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc , 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
-      0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
-      0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
-      0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
-      0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
-      0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
-      0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
-      0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
-      0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x000 };
-
-    static int triangles[256][16] =
-      {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
-       {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
-       {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
-       {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1}, {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
-       {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
-       {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1}, {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
-       {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
-       {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1}, {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
-       {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1}, {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
-       {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1}, {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
-       {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
-       {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
-       {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1}, {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
-       {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
-       {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1}, {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
-       {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1}, {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
-       {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1}, {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
-       {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
-       {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1}, {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1}, {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
-       {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1}, {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
-       {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1}, {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
-       {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1}, {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
-       {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1}, {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
-       {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1}, {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
-       {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
-       {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1}, {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
-       {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
-       {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1}, {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
-       {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1}, {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
-       {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1}, {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
-       {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
-       {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1}, {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
-       {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1}, {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
-       {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1}, {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
-       {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1}, {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
-       {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1}, {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
-       {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1}, {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
-       {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1}, {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
-       {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
-       {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1}, {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
-       {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1}, {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
-       {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
-       {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1}, {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
-       {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1}, {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
-       {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1}, {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
-       {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1}, {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1}, {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
-       {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1}, {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
-       {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1}, {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
-       {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1}, {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1}, {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
-       {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1}, {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
-       {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1}, {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1}, {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
-       {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
-       {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1}, {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
-       {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
-       {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1}, {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
-       {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1}, {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
-       {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1}, {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
-       {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
-       {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1}, {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
-       {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1}, {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
-       {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1}, {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
-       {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1}, {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1}, {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
-       {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1}, {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
-       {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1}, {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
-       {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1}, {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
-       {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1}, {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
-       {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1}, {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
-       {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1}, {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
-       {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1}, {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
-       {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1}, {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
-       {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1}, {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
-       {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1}, {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
-       {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1}, {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
-       {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1}, {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
-       {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1}, {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
-       {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1}, {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
-       {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1}, {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1}, {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
-       {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
-       {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1}, {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
-       {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1}, {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
-       {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1}, {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
-       {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1}, {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
-       {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1}, {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
-       {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
-       {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1}, {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1}, {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
-       {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1}, {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
-       {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1}, {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
-       {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1}, {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1}, {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
-       {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1}, {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
-       {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1}, {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1}, {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1}, {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
-       {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1}, {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
-       {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1}, {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
-       {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1}, {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
-       {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1}, {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
-       {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1}, {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1}, {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
-       {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
-       {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1}, {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1}, {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
-       {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1}, {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1}, {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
-       {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};
-
-    const unsigned int
-      nx = (unsigned int)((x1-x0+1)/resx), nxm1 = nx-1,
-      ny = (unsigned int)((y1-y0+1)/resy), nym1 = ny-1,
-      nz = (unsigned int)((z1-z0+1)/resz), nzm1 = nz-1;
-
-    if (!nxm1 || !nym1 || !nzm1) return;
-
-    CImg<int> indices1(nx,ny,1,3,-1), indices2(indices1);
-    CImg<float> values1(nx,ny), values2(nx,ny);
-    float X=0, Y=0, Z=0, nX=0, nY=0, nZ=0;
-
-    // Fill the first plane with function values
-    Y=y0;
-    cimg_forY(values1,y) {
-      X = x0;
-      cimg_forX(values1,x) { values1(x,y) = (float)func(X,Y,z0); X+=resx; }
-      Y+=resy;
-    }
-
-    // Run Marching Cubes algorithm
-    Z = z0; nZ = Z + resz;
-    for (unsigned int zi=0; zi<nzm1; ++zi, Z=nZ, nZ+=resz) {
-      Y = y0; nY = Y + resy;
-      indices2.fill(-1);
-      for (unsigned int yi=0, nyi=1; yi<nym1; ++yi, ++nyi, Y=nY, nY+=resy) {
-        X = x0; nX = X + resx;
-        for (unsigned int xi=0, nxi=1; xi<nxm1; ++xi, ++nxi, X=nX, nX+=resx) {
-
-          // Determine cube configuration
-          const float
-            val0 = values1(xi,yi), val1 = values1(nxi,yi), val2 = values1(nxi,nyi), val3 = values1(xi,nyi),
-            val4 = values2(xi,yi) = (float)func(X,Y,nZ),
-            val5 = values2(nxi,yi) = (float)func(nX,Y,nZ),
-            val6 = values2(nxi,nyi) = (float)func(nX,nY,nZ),
-            val7 = values2(xi,nyi) = (float)func(X,nY,nZ);
-
-          const unsigned int configuration =
-            (val0<isovalue?1:0)  | (val1<isovalue?2:0)  | (val2<isovalue?4:0)  | (val3<isovalue?8:0) |
-            (val4<isovalue?16:0) | (val5<isovalue?32:0) | (val6<isovalue?64:0) | (val7<isovalue?128:0),
-            edge = edges[configuration];
-
-          // Compute intersection points
-          if (edge) {
-            if ((edge&1) && indices1(xi,yi,0)<0) {
-              const float Xi = X + (isovalue-val0)*resx/(val1-val0);
-              indices1(xi,yi,0) = points.size;
-              points.insert(CImg<tp>::vector(Xi,Y,Z));
-            }
-            if ((edge&2) && indices1(nxi,yi,1)<0) {
-              const float Yi = Y + (isovalue-val1)*resy/(val2-val1);
-              indices1(nxi,yi,1) = points.size;
-              points.insert(CImg<tp>::vector(nX,Yi,Z));
-            }
-            if ((edge&4) && indices1(xi,nyi,0)<0) {
-              const float Xi = X + (isovalue-val3)*resx/(val2-val3);
-              indices1(xi,nyi,0) = points.size;
-              points.insert(CImg<tp>::vector(Xi,nY,Z));
-            }
-            if ((edge&8) && indices1(xi,yi,1)<0) {
-              const float Yi = Y + (isovalue-val0)*resy/(val3-val0);
-              indices1(xi,yi,1) = points.size;
-              points.insert(CImg<tp>::vector(X,Yi,Z));
-            }
-            if ((edge&16) && indices2(xi,yi,0)<0) {
-              const float Xi = X + (isovalue-val4)*resx/(val5-val4);
-              indices2(xi,yi,0) = points.size;
-              points.insert(CImg<tp>::vector(Xi,Y,nZ));
-            }
-            if ((edge&32) && indices2(nxi,yi,1)<0) {
-              const float Yi = Y + (isovalue-val5)*resy/(val6-val5);
-              indices2(nxi,yi,1) = points.size;
-              points.insert(CImg<tp>::vector(nX,Yi,nZ));
-            }
-            if ((edge&64) && indices2(xi,nyi,0)<0) {
-              const float Xi = X + (isovalue-val7)*resx/(val6-val7);
-              indices2(xi,nyi,0) = points.size;
-              points.insert(CImg<tp>::vector(Xi,nY,nZ));
-            }
-            if ((edge&128) && indices2(xi,yi,1)<0)  {
-              const float Yi = Y + (isovalue-val4)*resy/(val7-val4);
-              indices2(xi,yi,1) = points.size;
-              points.insert(CImg<tp>::vector(X,Yi,nZ));
-            }
-            if ((edge&256) && indices1(xi,yi,2)<0) {
-              const float Zi = Z+ (isovalue-val0)*resz/(val4-val0);
-              indices1(xi,yi,2) = points.size;
-              points.insert(CImg<tp>::vector(X,Y,Zi));
-            }
-            if ((edge&512) && indices1(nxi,yi,2)<0)  {
-              const float Zi = Z + (isovalue-val1)*resz/(val5-val1);
-              indices1(nxi,yi,2) = points.size;
-              points.insert(CImg<tp>::vector(nX,Y,Zi));
-            }
-            if ((edge&1024) && indices1(nxi,nyi,2)<0) {
-              const float Zi = Z + (isovalue-val2)*resz/(val6-val2);
-              indices1(nxi,nyi,2) = points.size;
-              points.insert(CImg<tp>::vector(nX,nY,Zi));
-            }
-            if ((edge&2048) && indices1(xi,nyi,2)<0) {
-              const float Zi = Z + (isovalue-val3)*resz/(val7-val3);
-              indices1(xi,nyi,2) = points.size;
-              points.insert(CImg<tp>::vector(X,nY,Zi));
-            }
-
-            // Create triangles
-            for (int *triangle=triangles[configuration]; *triangle!=-1; ) {
-              const unsigned int p0 = *(triangle++), p1 = *(triangle++), p2 = *(triangle++);
-              const tf
-                i0 = (tf)(_marching_cubes_indice(p0,indices1,indices2,xi,yi,nxi,nyi)),
-                i1 = (tf)(_marching_cubes_indice(p1,indices1,indices2,xi,yi,nxi,nyi)),
-                i2 = (tf)(_marching_cubes_indice(p2,indices1,indices2,xi,yi,nxi,nyi));
-              if (invert_faces) primitives.insert(CImg<tf>::vector(i0,i1,i2));
-              else primitives.insert(CImg<tf>::vector(i0,i2,i1));
-            }
-          }
-        }
-      }
-      cimg::swap(values1,values2);
-      cimg::swap(indices1,indices2);
-    }
-  }
-
-  // Inner routine used by the Marching square algorithm
-  template<typename t> inline int _marching_squares_indice(const unsigned int edge, const CImg<t>& indices1, const CImg<t>& indices2,
-                                                           const unsigned int x, const unsigned int nx) {
-    switch (edge) {
-    case 0: return (int)indices1(x,0);
-    case 1: return (int)indices1(nx,1);
-    case 2: return (int)indices2(x,0);
-    case 3: return (int)indices1(x,1);
-    }
-    return 0;
-  }
-
-  //! Polygonize an implicit 2D function by the marching squares algorithm
-  template<typename tfunc, typename tp, typename tf>
-  inline void marching_squares(const tfunc& func, const float isovalue,
-                               const float x0,const float y0,
-                               const float x1,const float y1,
-                               const float resx,const float resy,
-                               CImgList<tp>& points, CImgList<tf>& primitives) {
-
-    static unsigned int edges[16]={ 0x0, 0x9, 0x3, 0xa, 0x6, 0xf, 0x5, 0xc, 0xc, 0x5, 0xf, 0x6, 0xa, 0x3, 0x9, 0x0 };
-    static int segments[16][4] = { { -1,-1,-1,-1 }, { 0,3,-1,-1 }, { 0,1,-1,-1 }, { 1,3,-1,-1 },
-                                   { 1,2,-1,-1 },   { 0,1,2,3 },   { 0,2,-1,-1 }, { 2,3,-1,-1 },
-                                   { 2,3,-1,-1 },   { 0,2,-1,-1},  { 0,3,1,2 },   { 1,2,-1,-1 },
-                                   { 1,3,-1,-1 },   { 0,1,-1,-1},  { 0,3,-1,-1},  { -1,-1,-1,-1 } };
-    const unsigned int
-      nx = (unsigned int)((x1-x0+1)/resx), nxm1 = nx-1,
-      ny = (unsigned int)((y1-y0+1)/resy), nym1 = ny-1;
-
-    if (!nxm1 || !nym1) return;
-
-    CImg<int> indices1(nx,1,1,2,-1), indices2(nx,1,1,2);
-    CImg<float> values1(nx), values2(nx);
-    float X = 0, Y = 0, nX = 0, nY = 0;
-
-    // Fill first line with values
-    cimg_forX(values1,x) { values1(x) = (float)func(X,Y); X+=resx; }
-
-    // Run the marching squares algorithm
-    Y = y0; nY = Y + resy;
-    for (unsigned int yi=0, nyi=1; yi<nym1; ++yi, ++nyi, Y=nY, nY+=resy) {
-      X = x0; nX = X + resx;
-      indices2.fill(-1);
-      for (unsigned int xi=0, nxi=1; xi<nxm1; ++xi, ++nxi, X=nX, nX+=resx) {
-
-        // Determine cube configuration
-        const float
-          val0 = values1(xi), val1 = values1(nxi),
-          val2 = values2(nxi) = (float)func(nX,nY),
-          val3 = values2(xi) = (float)func(X,nY);
-
-        const unsigned int configuration = (val0<isovalue?1:0)  | (val1<isovalue?2:0)  | (val2<isovalue?4:0)  | (val3<isovalue?8:0),
-          edge = edges[configuration];
-
-        // Compute intersection points
-        if (edge) {
-          if ((edge&1) && indices1(xi,0)<0) {
-            const float Xi = X + (isovalue-val0)*resx/(val1-val0);
-            indices1(xi,0) = points.size;
-            points.insert(CImg<tp>::vector(Xi,Y));
-          }
-          if ((edge&2) && indices1(nxi,1)<0) {
-            const float Yi = Y + (isovalue-val1)*resy/(val2-val1);
-            indices1(nxi,1) = points.size;
-            points.insert(CImg<tp>::vector(nX,Yi));
-          }
-          if ((edge&4) && indices2(xi,0)<0) {
-            const float Xi = X + (isovalue-val3)*resx/(val2-val3);
-            indices2(xi,0) = points.size;
-            points.insert(CImg<tp>::vector(Xi,nY));
-          }
-          if ((edge&8) && indices1(xi,1)<0) {
-            const float Yi = Y + (isovalue-val0)*resy/(val3-val0);
-            indices1(xi,1) = points.size;
-            points.insert(CImg<tp>::vector(X,Yi));
-          }
-
-          // Create segments
-          for (int *segment=segments[configuration]; *segment!=-1; ) {
-            const unsigned int p0 = *(segment++), p1 = *(segment++);
-            const tf
-              i0 = (tf)(_marching_squares_indice(p0,indices1,indices2,xi,nxi)),
-              i1 = (tf)(_marching_squares_indice(p1,indices1,indices2,xi,nxi));
-            primitives.insert(CImg<tf>::vector(i0,i1));
-          }
-        }
-      }
-      values1.swap(values2);
-      indices1.swap(indices2);
-    }
-  }
-
-  // End of cimg:: namespace
-}
-
-
-  // End of cimg_library:: namespace
-}
-
-#ifdef std
-#undef std
-#endif
-
-#endif
-
-// Local Variables:
-// mode: c++
-// End:
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/cimg/dummy2.cc vips-7.38.5/libvips/cimg/dummy2.cc
--- vips-7.38.5-vanilla/libvips/cimg/dummy2.cc	2014-07-17 23:48:36.231794473 -0400
+++ vips-7.38.5/libvips/cimg/dummy2.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,4 +0,0 @@
-/* mac os x libtool needs to link libraries containing c++ (eg. cimg) with 
- * g++ ... force this with a dummy c++ file at the top level
- */
-const int im__dummy_value = 42;
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/cimg/Makefile.am vips-7.38.5/libvips/cimg/Makefile.am
--- vips-7.38.5-vanilla/libvips/cimg/Makefile.am	2014-07-17 23:48:36.230794473 -0400
+++ vips-7.38.5/libvips/cimg/Makefile.am	1969-12-31 19:00:00.000000000 -0500
@@ -1,27 +0,0 @@
-noinst_LTLIBRARIES = libcimg.la
-
-libcimg_la_SOURCES = \
-	CImg.h \
-	cimg_dispatch.c \
-	cimg.cpp 
-
-# various cimg settings as well
-# we need to change these a bit for win32
-if OS_WIN32
-AM_CPPFLAGS = \
-	-Dcimg_strict \
-	-Dcimg_OS=0 \
-	-Dcimg_display_type=0 \
-	-DLOCALEDIR=\""$(LOCALEDIR)"\"
-else
-AM_CPPFLAGS = \
-	-Dcimg_strict \
-	-Dcimg_OS=1 \
-	-Dcimg_display_type=0 \
-	-DLOCALEDIR=\""$(LOCALEDIR)"\"
-endif
-
-# used by the final libvips link rather than us
-EXTRA_DIST = dummy2.cc
-
-AM_CPPFLAGS += -I${top_srcdir}/libvips/include @VIPS_CFLAGS@ @VIPS_INCLUDES@ 
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/cimg/Makefile.in vips-7.38.5/libvips/cimg/Makefile.in
--- vips-7.38.5-vanilla/libvips/cimg/Makefile.in	2014-07-17 23:48:36.230794473 -0400
+++ vips-7.38.5/libvips/cimg/Makefile.in	1969-12-31 19:00:00.000000000 -0500
@@ -1,747 +0,0 @@
-# Makefile.in generated by automake 1.13.3 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = libvips/cimg
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/depcomp
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/gtk-doc.m4 \
-	$(top_srcdir)/m4/introspection.m4 $(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-LTLIBRARIES = $(noinst_LTLIBRARIES)
-libcimg_la_LIBADD =
-am_libcimg_la_OBJECTS = cimg_dispatch.lo cimg.lo
-libcimg_la_OBJECTS = $(am_libcimg_la_OBJECTS)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-am__v_lt_1 = 
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-am__mv = mv -f
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-AM_V_CC = $(am__v_CC_@AM_V@)
-am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
-am__v_CC_0 = @echo "  CC      " $@;
-am__v_CC_1 = 
-CCLD = $(CC)
-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CCLD = $(am__v_CCLD_@AM_V@)
-am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
-am__v_CCLD_0 = @echo "  CCLD    " $@;
-am__v_CCLD_1 = 
-CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
-LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CXXFLAGS) $(CXXFLAGS)
-AM_V_CXX = $(am__v_CXX_@AM_V@)
-am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
-am__v_CXX_0 = @echo "  CXX     " $@;
-am__v_CXX_1 = 
-CXXLD = $(CXX)
-CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
-am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
-am__v_CXXLD_0 = @echo "  CXXLD   " $@;
-am__v_CXXLD_1 = 
-SOURCES = $(libcimg_la_SOURCES)
-DIST_SOURCES = $(libcimg_la_SOURCES)
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-# Read a list of newline-separated strings from the standard input,
-# and print each of them once, without duplicates.  Input order is
-# *not* preserved.
-am__uniquify_input = $(AWK) '\
-  BEGIN { nonempty = 0; } \
-  { items[$$0] = 1; nonempty = 1; } \
-  END { if (nonempty) { for (i in items) print i; }; } \
-'
-# Make sure the list of sources is unique.  This is necessary because,
-# e.g., the same source file might be shared among _SOURCES variables
-# for different programs/libraries.
-am__define_uniq_tagged_files = \
-  list='$(am__tagged_files)'; \
-  unique=`for i in $$list; do \
-    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-  done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AS = @AS@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFITSIO_CFLAGS = @CFITSIO_CFLAGS@
-CFITSIO_LIBS = @CFITSIO_LIBS@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DLLTOOL = @DLLTOOL@
-DLLWRAP = @DLLWRAP@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-EXIF_CFLAGS = @EXIF_CFLAGS@
-EXIF_LIBS = @EXIF_LIBS@
-FFTW_CFLAGS = @FFTW_CFLAGS@
-FFTW_LIBS = @FFTW_LIBS@
-FGREP = @FGREP@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GREP = @GREP@
-GTHREAD_CFLAGS = @GTHREAD_CFLAGS@
-GTHREAD_LIBS = @GTHREAD_LIBS@
-GTKDOC_CHECK = @GTKDOC_CHECK@
-GTKDOC_DEPS_CFLAGS = @GTKDOC_DEPS_CFLAGS@
-GTKDOC_DEPS_LIBS = @GTKDOC_DEPS_LIBS@
-GTKDOC_MKPDF = @GTKDOC_MKPDF@
-GTKDOC_REBASE = @GTKDOC_REBASE@
-HTML_DIR = @HTML_DIR@
-IMAGE_MAGICK_CFLAGS = @IMAGE_MAGICK_CFLAGS@
-IMAGE_MAGICK_LIBS = @IMAGE_MAGICK_LIBS@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTROSPECTION_CFLAGS = @INTROSPECTION_CFLAGS@
-INTROSPECTION_COMPILER = @INTROSPECTION_COMPILER@
-INTROSPECTION_GENERATE = @INTROSPECTION_GENERATE@
-INTROSPECTION_GIRDIR = @INTROSPECTION_GIRDIR@
-INTROSPECTION_LIBS = @INTROSPECTION_LIBS@
-INTROSPECTION_MAKEFILE = @INTROSPECTION_MAKEFILE@
-INTROSPECTION_SCANNER = @INTROSPECTION_SCANNER@
-INTROSPECTION_TYPELIBDIR = @INTROSPECTION_TYPELIBDIR@
-JPEG_INCLUDES = @JPEG_INCLUDES@
-JPEG_LIBS = @JPEG_LIBS@
-LCMS_CFLAGS = @LCMS_CFLAGS@
-LCMS_LIBS = @LCMS_LIBS@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBRARY_AGE = @LIBRARY_AGE@
-LIBRARY_CURRENT = @LIBRARY_CURRENT@
-LIBRARY_REVISION = @LIBRARY_REVISION@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIBWEBP_CFLAGS = @LIBWEBP_CFLAGS@
-LIBWEBP_LIBS = @LIBWEBP_LIBS@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAGICK_CFLAGS = @MAGICK_CFLAGS@
-MAGICK_LIBS = @MAGICK_LIBS@
-MAGICK_WAND_CFLAGS = @MAGICK_WAND_CFLAGS@
-MAGICK_WAND_LIBS = @MAGICK_WAND_LIBS@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MATIO_CFLAGS = @MATIO_CFLAGS@
-MATIO_LIBS = @MATIO_LIBS@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MONOTONIC_CFLAGS = @MONOTONIC_CFLAGS@
-MONOTONIC_LIBS = @MONOTONIC_LIBS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OPENEXR_CFLAGS = @OPENEXR_CFLAGS@
-OPENEXR_LIBS = @OPENEXR_LIBS@
-OPENSLIDE_CFLAGS = @OPENSLIDE_CFLAGS@
-OPENSLIDE_LIBS = @OPENSLIDE_LIBS@
-ORC_CFLAGS = @ORC_CFLAGS@
-ORC_LIBS = @ORC_LIBS@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGES_USED = @PACKAGES_USED@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PANGOFT2_CFLAGS = @PANGOFT2_CFLAGS@
-PANGOFT2_LIBS = @PANGOFT2_LIBS@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-PNG_CFLAGS = @PNG_CFLAGS@
-PNG_INCLUDES = @PNG_INCLUDES@
-PNG_LIBS = @PNG_LIBS@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-PYTHON = @PYTHON@
-PYTHON_EXEC_PREFIX = @PYTHON_EXEC_PREFIX@
-PYTHON_INCLUDES = @PYTHON_INCLUDES@
-PYTHON_PLATFORM = @PYTHON_PLATFORM@
-PYTHON_PREFIX = @PYTHON_PREFIX@
-PYTHON_VERSION = @PYTHON_VERSION@
-RANLIB = @RANLIB@
-REQUIRED_CFLAGS = @REQUIRED_CFLAGS@
-REQUIRED_LIBS = @REQUIRED_LIBS@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-THREADS_CFLAGS = @THREADS_CFLAGS@
-THREADS_LIBS = @THREADS_LIBS@
-TIFF_CFLAGS = @TIFF_CFLAGS@
-TIFF_INCLUDES = @TIFF_INCLUDES@
-TIFF_LIBS = @TIFF_LIBS@
-TYPE_INIT_CFLAGS = @TYPE_INIT_CFLAGS@
-TYPE_INIT_LIBS = @TYPE_INIT_LIBS@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-VIPS_CFLAGS = @VIPS_CFLAGS@
-VIPS_CXX_LIBS = @VIPS_CXX_LIBS@
-VIPS_EXEEXT = @VIPS_EXEEXT@
-VIPS_INCLUDES = @VIPS_INCLUDES@
-VIPS_LIBDIR = @VIPS_LIBDIR@
-VIPS_LIBS = @VIPS_LIBS@
-VIPS_MAJOR_VERSION = @VIPS_MAJOR_VERSION@
-VIPS_MICRO_VERSION = @VIPS_MICRO_VERSION@
-VIPS_MINOR_VERSION = @VIPS_MINOR_VERSION@
-VIPS_VERSION = @VIPS_VERSION@
-VIPS_VERSION_STRING = @VIPS_VERSION_STRING@
-XGETTEXT = @XGETTEXT@
-XMKMF = @XMKMF@
-X_CFLAGS = @X_CFLAGS@
-X_EXTRA_LIBS = @X_EXTRA_LIBS@
-X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
-ZIP_INCLUDES = @ZIP_INCLUDES@
-ZIP_LIBS = @ZIP_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-pkgpyexecdir = @pkgpyexecdir@
-pkgpythondir = @pkgpythondir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-pyexecdir = @pyexecdir@
-pythondir = @pythondir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-vips_introspection_sources = @vips_introspection_sources@
-noinst_LTLIBRARIES = libcimg.la
-libcimg_la_SOURCES = \
-	CImg.h \
-	cimg_dispatch.c \
-	cimg.cpp 
-
-@OS_WIN32_FALSE@AM_CPPFLAGS = -Dcimg_strict -Dcimg_OS=1 \
-@OS_WIN32_FALSE@	-Dcimg_display_type=0 \
-@OS_WIN32_FALSE@	-DLOCALEDIR=\""$(LOCALEDIR)"\" \
-@OS_WIN32_FALSE@	-I${top_srcdir}/libvips/include @VIPS_CFLAGS@ \
-@OS_WIN32_FALSE@	@VIPS_INCLUDES@ $(am__empty)
-
-# various cimg settings as well
-# we need to change these a bit for win32
-@OS_WIN32_TRUE@AM_CPPFLAGS = -Dcimg_strict -Dcimg_OS=0 \
-@OS_WIN32_TRUE@	-Dcimg_display_type=0 \
-@OS_WIN32_TRUE@	-DLOCALEDIR=\""$(LOCALEDIR)"\" \
-@OS_WIN32_TRUE@	-I${top_srcdir}/libvips/include @VIPS_CFLAGS@ \
-@OS_WIN32_TRUE@	@VIPS_INCLUDES@ $(am__empty)
-
-# used by the final libvips link rather than us
-EXTRA_DIST = dummy2.cc
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .cpp .lo .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign libvips/cimg/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign libvips/cimg/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-clean-noinstLTLIBRARIES:
-	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
-	@list='$(noinst_LTLIBRARIES)'; \
-	locs=`for p in $$list; do echo $$p; done | \
-	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
-	      sort -u`; \
-	test -z "$$locs" || { \
-	  echo rm -f $${locs}; \
-	  rm -f $${locs}; \
-	}
-
-libcimg.la: $(libcimg_la_OBJECTS) $(libcimg_la_DEPENDENCIES) $(EXTRA_libcimg_la_DEPENDENCIES) 
-	$(AM_V_CXXLD)$(CXXLINK)  $(libcimg_la_OBJECTS) $(libcimg_la_LIBADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cimg.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cimg_dispatch.Plo@am__quote@
-
-.c.o:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c $<
-
-.c.obj:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
-
-.cpp.o:
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<
-
-.cpp.obj:
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
-
-.cpp.lo:
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-ID: $(am__tagged_files)
-	$(am__define_uniq_tagged_files); mkid -fID $$unique
-tags: tags-am
-TAGS: tags
-
-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	set x; \
-	here=`pwd`; \
-	$(am__define_uniq_tagged_files); \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: ctags-am
-
-CTAGS: ctags
-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	$(am__define_uniq_tagged_files); \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-cscopelist: cscopelist-am
-
-cscopelist-am: $(am__tagged_files)
-	list='$(am__tagged_files)'; \
-	case "$(srcdir)" in \
-	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
-	  *) sdir=$(subdir)/$(srcdir) ;; \
-	esac; \
-	for i in $$list; do \
-	  if test -f "$$i"; then \
-	    echo "$(subdir)/$$i"; \
-	  else \
-	    echo "$$sdir/$$i"; \
-	  fi; \
-	done >> $(top_builddir)/cscope.files
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(LTLIBRARIES)
-installdirs:
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
-	mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am:
-
-.MAKE: install-am install-strip
-
-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
-	ctags-am distclean distclean-compile distclean-generic \
-	distclean-libtool distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags tags-am uninstall uninstall-am
-
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/Makefile.am vips-7.38.5/libvips/Makefile.am
--- vips-7.38.5-vanilla/libvips/Makefile.am	2014-07-17 23:48:36.231794473 -0400
+++ vips-7.38.5/libvips/Makefile.am	2014-07-17 23:49:32.819792979 -0400
@@ -1,13 +1,5 @@
-# only build in the cimg dir if C++ is enabled
-if ENABLE_CXX
-C_COMPILE_DIR = cimg
-C_DIST_DIR =
-C_LIB = cimg/libcimg.la
-else
 C_COMPILE_DIR =
-C_DIST_DIR = cimg
 C_LIB = 
-endif
 
 SUBDIRS = \
 	include \
@@ -34,14 +26,6 @@
 # empty means default to C linking
 libvips_la_SOURCES = 
 
-# if we have C++ components enabled, make sure we link the top-level with c++
-#
-# sadly the if/endif isn't enough to stop automake detecting a c++ link even
-# when c++ is disabled ... comment out this line if you have linking problems
-if ENABLE_CXX
-nodist_EXTRA_libvips_la_SOURCES = cimg/dummy2.cc
-endif
-
 # DLLs need dependant libs there too ... put @VIPS_LIBS@ at the end
 libvips_la_LIBADD = \
 	resample/libresample.la \
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/Makefile.in vips-7.38.5/libvips/Makefile.in
--- vips-7.38.5-vanilla/libvips/Makefile.in	2014-07-17 23:48:36.231794473 -0400
+++ vips-7.38.5/libvips/Makefile.in	2014-07-17 23:49:32.819792979 -0400
@@ -142,7 +142,7 @@
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
-libvips_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
+libvips_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
 	$(CXXFLAGS) $(libvips_la_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_P = $(am__v_P_@AM_V@)
@@ -163,7 +163,7 @@
 am__mv = mv -f
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
-LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
+LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) \
 	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
 	$(AM_CXXFLAGS) $(CXXFLAGS)
@@ -172,7 +172,7 @@
 am__v_CXX_0 = @echo "  CXX     " $@;
 am__v_CXX_1 = 
 CXXLD = $(CXX)
-CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
+CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
 	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
@@ -667,11 +667,11 @@
 @am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<
 
 dummy2.lo: cimg/dummy2.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT dummy2.lo -MD -MP -MF $(DEPDIR)/dummy2.Tpo -c -o dummy2.lo `test -f 'cimg/dummy2.cc' || echo '$(srcdir)/'`cimg/dummy2.cc
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT dummy2.lo -MD -MP -MF $(DEPDIR)/dummy2.Tpo -c -o dummy2.lo `test -f 'cimg/dummy2.cc' || echo '$(srcdir)/'`cimg/dummy2.cc
 @am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/dummy2.Tpo $(DEPDIR)/dummy2.Plo
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='cimg/dummy2.cc' object='dummy2.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o dummy2.lo `test -f 'cimg/dummy2.cc' || echo '$(srcdir)/'`cimg/dummy2.cc
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o dummy2.lo `test -f 'cimg/dummy2.cc' || echo '$(srcdir)/'`cimg/dummy2.cc
 
 mostlyclean-libtool:
 	-rm -f *.lo
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/resample/bicubic.cpp vips-7.38.5/libvips/resample/bicubic.cpp
--- vips-7.38.5-vanilla/libvips/resample/bicubic.cpp	2014-07-17 23:48:36.232794473 -0400
+++ vips-7.38.5/libvips/resample/bicubic.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,459 +0,0 @@
-/* bicubic (catmull-rom) interpolator
- *
- * 12/8/10
- * 	- revise window_size / window_offset stuff again
- */
-
-/*
-
-    This file is part of VIPS.
-
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-/* Bicubic (Catmull-Rom) interpolator derived from Nicolas Robidoux's
- * original YAFR resampler with permission and thanks.
- */
-
-/*
-#define DEBUG
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <vips/vips.h>
-#include <vips/internal.h>
-
-#include "templates.h"
-
-#ifdef WITH_DMALLOC
-#include <dmalloc.h>
-#endif /*WITH_DMALLOC*/
-
-#define VIPS_TYPE_INTERPOLATE_BICUBIC \
-	(vips_interpolate_bicubic_get_type())
-#define VIPS_INTERPOLATE_BICUBIC( obj ) \
-	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
-	VIPS_TYPE_INTERPOLATE_BICUBIC, VipsInterpolateBicubic ))
-#define VIPS_INTERPOLATE_BICUBIC_CLASS( klass ) \
-	(G_TYPE_CHECK_CLASS_CAST( (klass), \
-	VIPS_TYPE_INTERPOLATE_BICUBIC, VipsInterpolateBicubicClass))
-#define VIPS_IS_INTERPOLATE_BICUBIC( obj ) \
-	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_INTERPOLATE_BICUBIC ))
-#define VIPS_IS_INTERPOLATE_BICUBIC_CLASS( klass ) \
-	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_INTERPOLATE_BICUBIC ))
-#define VIPS_INTERPOLATE_BICUBIC_GET_CLASS( obj ) \
-	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
-	VIPS_TYPE_INTERPOLATE_BICUBIC, VipsInterpolateBicubicClass ))
-
-typedef VipsInterpolate VipsInterpolateBicubic;
-
-typedef VipsInterpolateClass VipsInterpolateBicubicClass;
-
-/* Precalculated interpolation matrices. int (used for pel
- * sizes up to short), and double (for all others). We go to
- * scale + 1 so we can round-to-nearest safely.
- */
-
-/* We could keep a large set of 2d 4x4 matricies, but this actually
- * works out slower since for many resizes the thing will no longer
- * fit in L1.
- */
-static int vips_bicubic_matrixi[VIPS_TRANSFORM_SCALE + 1][4];
-static double vips_bicubic_matrixf[VIPS_TRANSFORM_SCALE + 1][4];
-
-/* We need C linkage for this.
- */
-extern "C" {
-G_DEFINE_TYPE( VipsInterpolateBicubic, vips_interpolate_bicubic,
-	VIPS_TYPE_INTERPOLATE );
-}
-
-/* Pointers to write to / read from, number of bands,
- * how many bytes to add to move down a line.
- */
-
-/* T is the type of pixels we are reading and writing.
- */
-
-/* Fixed-point version, for 8 and 16-bit types.
- */
-template <typename T, int min_value, int max_value>
-static void inline
-bicubic_int_tab( void *pout, const VipsPel *pin,
-	const int bands, const int lskip,
-	const int *cx, const int *cy )
-{
-	T* restrict out = (T *) pout;
-	const T* restrict in = (T *) pin;
-
-	const int b1 = bands;
-	const int b2 = b1 + b1;
-	const int b3 = b1 + b2;
-
-	const int l1 = lskip / sizeof( T );
-	const int l2 = l1 + l1;
-	const int l3 = l1 + l2;
-
-        const int l1_plus_b1 = l1 + b1;
-        const int l1_plus_b2 = l1 + b2;
-        const int l1_plus_b3 = l1 + b3;
-        const int l2_plus_b1 = l2 + b1;
-        const int l2_plus_b2 = l2 + b2;
-        const int l2_plus_b3 = l2 + b3;
-        const int l3_plus_b1 = l3 + b1;
-        const int l3_plus_b2 = l3 + b2;
-        const int l3_plus_b3 = l3 + b3;
-
-	for( int z = 0; z < bands; z++ ) {
-		const T uno_one = in[0];
-		const T uno_two = in[b1];
-		const T uno_thr = in[b2];
-		const T uno_fou = in[b3];
-
-		const T dos_one = in[l1];
-		const T dos_two = in[l1_plus_b1];
-		const T dos_thr = in[l1_plus_b2];
-		const T dos_fou = in[l1_plus_b3];
-
-		const T tre_one = in[l2];
-		const T tre_two = in[l2_plus_b1];
-		const T tre_thr = in[l2_plus_b2];
-		const T tre_fou = in[l2_plus_b3];
-
-		const T qua_one = in[l3];
-		const T qua_two = in[l3_plus_b1];
-		const T qua_thr = in[l3_plus_b2];
-		const T qua_fou = in[l3_plus_b3];
-
-		int bicubic = bicubic_int<T>(
-			uno_one, uno_two, uno_thr, uno_fou,
-			dos_one, dos_two, dos_thr, dos_fou,
-			tre_one, tre_two, tre_thr, tre_fou,
-			qua_one, qua_two, qua_thr, qua_fou,
-			cx, cy );
-
-		if( bicubic < min_value )
-			bicubic = min_value;
-		else if( bicubic > max_value )
-			bicubic = max_value;
-
-		out[z] = bicubic;
-
-		in += 1;
-	}
-}
-
-/* Floating-point version, for int/float types.
- */
-template <typename T>
-static void inline
-bicubic_float_tab( void *pout, const VipsPel *pin,
-	const int bands, const int lskip,
-	const double *cx, const double *cy )
-{
-	T* restrict out = (T *) pout;
-	const T* restrict in = (T *) pin;
-
-	const int b1 = bands;
-	const int b2 = b1 + b1;
-	const int b3 = b1 + b2;
-
-	const int l1 = lskip / sizeof( T );
-	const int l2 = l1 + l1;
-	const int l3 = l1 + l2;
-
-        const int l1_plus_b1 = l1 + b1;
-        const int l1_plus_b2 = l1 + b2;
-        const int l1_plus_b3 = l1 + b3;
-        const int l2_plus_b1 = l2 + b1;
-        const int l2_plus_b2 = l2 + b2;
-        const int l2_plus_b3 = l2 + b3;
-        const int l3_plus_b1 = l3 + b1;
-        const int l3_plus_b2 = l3 + b2;
-        const int l3_plus_b3 = l3 + b3;
-
-	for( int z = 0; z < bands; z++ ) {
-		const T uno_one = in[0];
-		const T uno_two = in[b1];
-		const T uno_thr = in[b2];
-		const T uno_fou = in[b3];
-
-		const T dos_one = in[l1];
-		const T dos_two = in[l1_plus_b1];
-		const T dos_thr = in[l1_plus_b2];
-		const T dos_fou = in[l1_plus_b3];
-
-		const T tre_one = in[l2];
-		const T tre_two = in[l2_plus_b1];
-		const T tre_thr = in[l2_plus_b2];
-		const T tre_fou = in[l2_plus_b3];
-
-		const T qua_one = in[l3];
-		const T qua_two = in[l3_plus_b1];
-		const T qua_thr = in[l3_plus_b2];
-		const T qua_fou = in[l3_plus_b3];
-
-		const T bicubic = bicubic_float<T>(
-			uno_one, uno_two, uno_thr, uno_fou,
-			dos_one, dos_two, dos_thr, dos_fou,
-			tre_one, tre_two, tre_thr, tre_fou,
-			qua_one, qua_two, qua_thr, qua_fou,
-			cx, cy );
-
-		out[z] = bicubic;
-
-		in += 1;
-	}
-}
-
-/* Ultra-high-quality version for double images.
- */
-template <typename T>
-static void inline
-bicubic_notab( void *pout, const VipsPel *pin,
-	const int bands, const int lskip,
-	double x, double y )
-{
-	T* restrict out = (T *) pout;
-	const T* restrict in = (T *) pin;
-
-	const int b1 = bands;
-	const int b2 = b1 + b1;
-	const int b3 = b1 + b2;
-
-	const int l1 = lskip / sizeof( T );
-	const int l2 = l1 + l1;
-	const int l3 = l1 + l2;
-
-        const int l1_plus_b1 = l1 + b1;
-        const int l1_plus_b2 = l1 + b2;
-        const int l1_plus_b3 = l1 + b3;
-        const int l2_plus_b1 = l2 + b1;
-        const int l2_plus_b2 = l2 + b2;
-        const int l2_plus_b3 = l2 + b3;
-        const int l3_plus_b1 = l3 + b1;
-        const int l3_plus_b2 = l3 + b2;
-        const int l3_plus_b3 = l3 + b3;
-
-	double cx[4];
-	double cy[4];
-
-	calculate_coefficients_catmull( x, cx );
-	calculate_coefficients_catmull( y, cy );
-
-	for( int z = 0; z < bands; z++ ) {
-		const T uno_one = in[0];
-		const T uno_two = in[b1];
-		const T uno_thr = in[b2];
-		const T uno_fou = in[b3];
-
-		const T dos_one = in[l1];
-		const T dos_two = in[l1_plus_b1];
-		const T dos_thr = in[l1_plus_b2];
-		const T dos_fou = in[l1_plus_b3];
-
-		const T tre_one = in[l2];
-		const T tre_two = in[l2_plus_b1];
-		const T tre_thr = in[l2_plus_b2];
-		const T tre_fou = in[l2_plus_b3];
-
-		const T qua_one = in[l3];
-		const T qua_two = in[l3_plus_b1];
-		const T qua_thr = in[l3_plus_b2];
-		const T qua_fou = in[l3_plus_b3];
-
-		const T bicubic = bicubic_float<T>(
-			uno_one, uno_two, uno_thr, uno_fou,
-			dos_one, dos_two, dos_thr, dos_fou,
-			tre_one, tre_two, tre_thr, tre_fou,
-			qua_one, qua_two, qua_thr, qua_fou,
-			cx, cy );
-
-		out[z] = bicubic;
-
-		in += 1;
-	}
-}
-
-static void
-vips_interpolate_bicubic_interpolate( VipsInterpolate *interpolate,
-	void *out, VipsRegion *in, double x, double y )
-{
-	/* Find the mask index. We round-to-nearest, so we need to generate 
-	 * indexes in 0 to VIPS_TRANSFORM_SCALE, 2^n + 1 values. We multiply 
-	 * by 2 more than we need to, add one, mask, then shift down again to 
-	 * get the extra range.
-	 */
-	const int sx = x * VIPS_TRANSFORM_SCALE * 2;
-	const int sy = y * VIPS_TRANSFORM_SCALE * 2;
-
-	const int six = sx & (VIPS_TRANSFORM_SCALE * 2 - 1);
-	const int siy = sy & (VIPS_TRANSFORM_SCALE * 2 - 1);
-
-	const int tx = (six + 1) >> 1;
-	const int ty = (siy + 1) >> 1;
-
-	/* We know x/y are always positive, so we can just (int) them. 
-	 */
-	const int ix = (int) x;
-	const int iy = (int) y;
-
-	/* Back and up one to get the top-left of the 4x4.
-	 */
-	const VipsPel *p = VIPS_REGION_ADDR( in, ix - 1, iy - 1 ); 
-
-	/* Look up the tables we need.
-	 */
-	const int *cxi = vips_bicubic_matrixi[tx];
-	const int *cyi = vips_bicubic_matrixi[ty];
-	const double *cxf = vips_bicubic_matrixf[tx];
-	const double *cyf = vips_bicubic_matrixf[ty];
-
-	/* Pel size and line size.
-	 */
-	const int bands = in->im->Bands;
-	const int lskip = VIPS_REGION_LSKIP( in );
-
-#ifdef DEBUG
-	printf( "vips_interpolate_bicubic_interpolate: %g %g\n", x, y );
-	printf( "\tleft=%d, top=%d, width=%d, height=%d\n",
-		ix - 1, iy - 1, 4, 4 );
-	printf( "\tmaskx=%d, masky=%d\n", tx, ty );
-#endif /*DEBUG*/
-
-	switch( in->im->BandFmt ) {
-	case VIPS_FORMAT_UCHAR:
-		bicubic_int_tab<unsigned char, 0, UCHAR_MAX>(
-			out, p, bands, lskip,
-			cxi, cyi );
-	/*
-
-	   Handy for benchmarking
-
-		bicubic_float_tab<unsigned char>(
-			out, p, bands, lskip,
-			cxf, cyf );
-		bicubic_notab<unsigned char>(
-			out, p, bands, lskip,
-			x - ix, y - iy );
-
-	 */
-		break;
-
-	case VIPS_FORMAT_CHAR:
-		bicubic_int_tab<signed char, SCHAR_MIN, SCHAR_MAX>(
-			out, p, bands, lskip,
-			cxi, cyi );
-		break;
-
-	case VIPS_FORMAT_USHORT:
-		bicubic_int_tab<unsigned short, 0, USHRT_MAX>(
-			out, p, bands, lskip,
-			cxi, cyi );
-		break;
-
-	case VIPS_FORMAT_SHORT:
-		bicubic_int_tab<signed short, SHRT_MIN, SHRT_MAX>(
-			out, p, bands, lskip,
-			cxi, cyi );
-		break;
-
-	case VIPS_FORMAT_UINT:
-		bicubic_float_tab<unsigned int>( out, p, bands, lskip,
-			cxf, cyf );
-		break;
-
-	case VIPS_FORMAT_INT:
-		bicubic_float_tab<signed int>( out, p, bands, lskip,
-			cxf, cyf );
-		break;
-
-	case VIPS_FORMAT_FLOAT:
-		bicubic_float_tab<float>( out, p, bands, lskip,
-			cxf, cyf );
-		break;
-
-	case VIPS_FORMAT_DOUBLE:
-		bicubic_notab<double>( out, p, bands, lskip,
-			x - ix, y - iy );
-		break;
-
-	case VIPS_FORMAT_COMPLEX:
-		bicubic_float_tab<float>( out, p, bands * 2, lskip,
-			cxf, cyf );
-		break;
-
-	case VIPS_FORMAT_DPCOMPLEX:
-		bicubic_notab<double>( out, p, bands * 2, lskip,
-			x - ix, y - iy );
-		break;
-
-	default:
-		break;
-	}
-}
-
-static void
-vips_interpolate_bicubic_class_init( VipsInterpolateBicubicClass *iclass )
-{
-	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( iclass );
-	VipsInterpolateClass *interpolate_class =
-		VIPS_INTERPOLATE_CLASS( iclass );
-
-	object_class->nickname = "bicubic";
-	object_class->description = _( "Bicubic interpolation (Catmull-Rom)" );
-
-	interpolate_class->interpolate = vips_interpolate_bicubic_interpolate;
-	interpolate_class->window_size = 4;
-
-	/* Build the tables of pre-computed coefficients.
-	 */
-	for( int x = 0; x < VIPS_TRANSFORM_SCALE + 1; x++ ) {
-		calculate_coefficients_catmull(
-			(float) x / VIPS_TRANSFORM_SCALE,
-			vips_bicubic_matrixf[x] );
-
-		for( int i = 0; i < 4; i++ )
-			vips_bicubic_matrixi[x][i] =
-				vips_bicubic_matrixf[x][i] * 
-				VIPS_INTERPOLATE_SCALE;
-	}
-}
-
-static void
-vips_interpolate_bicubic_init( VipsInterpolateBicubic *bicubic )
-{
-#ifdef DEBUG
-	printf( "vips_interpolate_bicubic_init: " );
-	vips_object_print( VIPS_OBJECT( bicubic ) );
-#endif /*DEBUG*/
-
-}
-
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/resample/lbb.cpp vips-7.38.5/libvips/resample/lbb.cpp
--- vips-7.38.5-vanilla/libvips/resample/lbb.cpp	2014-07-17 23:48:36.232794473 -0400
+++ vips-7.38.5/libvips/resample/lbb.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,868 +0,0 @@
-/* lbb (locally bounded bicubic) resampler
- *
- * N. Robidoux, C. Racette and J. Cupitt, 23-28/03/2010
- *
- * N. Robidoux, 16-19/05/2010
- *
- * N. Robidoux, 22/11/2011
- */
-
-/*
-
-    This file is part of VIPS.
-
-    VIPS is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Lesser General Public License as
-    published by the Free Software Foundation; either version 2 of the
-    License, or (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301 USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-/*
- * 2010 (c) Nicolas Robidoux, Chantal Racette, John Cupitt.
- *
- * N. Robidoux thanks Adam Turcotte, Geert Jordaens, Ralf Meyer,
- * Øyvind Kolås, Minglun Gong, Eric Daoust and Sven Neumann for useful
- * comments and code.
- *
- * C. Racette's image resampling research and programming funded in
- * part by an NSERC (National Science and Engineering Research Council
- * of Canada) Alexander Graham Bell Canada Graduate Scholarship, by an
- * NSERC Discovery Grant awarded to Julien Dompierre (grant number
- * 20-61098) and by N. Robidoux's Laurentian University professional
- * allowance.
- */
-
-/*
- * LBB has two versions:
- *
- *   A "soft" version, which shows a little less staircasing and a
- *   little more haloing, and which is a little more expensive to
- *   compute. We recommend this as the default.
- *
- *   A "sharp" version, which shows a little more staircasing and a
- *   little less haloing, which is a little cheaper (it uses 6 less
- *   comparisons and 12 less "? :").
- *
- * The only difference between the two is that the "soft" versions
- * uses local minima and maxima computed over 3x3 square blocks, and
- * the "sharp" version uses local minima and maxima computed over 3x3
- * crosses.
- *
- * If you want to use the "sharp" version, comment out the following
- * three pre-processor code lines:
- */
-/*
-#ifndef __LBB_CHEAP_H__
-#define __LBB_CHEAP_H__
-#endif
-*/
-
-/*
- * LBB (Locally Bounded Bicubic) is a high quality nonlinear variant
- * of Catmull-Rom. Images resampled with LBB have much smaller halos
- * than images resampled with windowed sincs or other interpolatory
- * cubic spline filters. Specifically, LBB halos are narrower and the
- * over/undershoot amplitude is smaller. This is accomplished without
- * significantly affecting the smoothness of the result (compared to
- * Catmull-Rom).
- *
- * Another important property is that the resampled values are
- * contained within the range of nearby input values. Consequently, no
- * final clamping is needed to stay "in range" (e.g., 0-255 for
- * standard 8-bit images).
- *
- * LBB was developed by N. Robidoux and C. Racette at the Department
- * of Mathematics and Computer Science of Laurentian University in the
- * course of C. Racette's Masters thesis in Computational
- * Sciences. Preliminary work directly leading to the LBB method and
- * code was performed by C. Racette and N. Robidoux in the course of
- * her honours thesis, and by N. Robidoux, A. Turcotte and E. Daoust
- * during Google Summer of Code 2009 (through two awards made to GIMP
- * to improve GEGL).
- *
- * LBB is a novel method with the following properties:
- *
- * --LBB is a Hermite bicubic method: The bicubic surface is defined,
- *   one convex hull of four nearby input points at a time, using four
- *   point values, four x-derivatives, four y-derivatives, and four
- *   cross-derivatives.
- *
- * --The stencil for values in a square patch is the usual 4x4.
- *
- * --LBB is interpolatory.
- *
- * --It is C^1 with continuous cross derivatives.
- *
- * --When the limiters are inactive, LBB gives the same result as
- *   Catmull-Rom.
- *
- * --When used on binary images, LBB gives results similar to bicubic
- *   Hermite with all first derivatives---but not necessarily the
- *   cross derivatives (this last assertion needs to be double
- *   checked)--at input pixel locations set to zero.
- *
- * --The LBB reconstruction is locally bounded: Over each square
- *   patch, the surface is contained between the minimum and the
- *   maximum of the 16 nearest input pixel values.
- *
- * --Consequently, the LBB reconstruction is globally bounded between
- *   the very smallest input pixel value and the very largest input
- *   pixel value. It is not necessary to clamp results.
- *
- * The LBB method is based on the method of Ken Brodlie, Petros
- * Mashwama and Sohail Butt for constraining Hermite interpolants
- * between globally defined planes:
- *
- *   Visualization of surface data to preserve positivity and other
- *   simple constraints. Computer & Graphics, Vol. 19, Number 4, pages
- *   585-594, 1995. DOI: 10.1016/0097-8493(95)00036-C.
- *
- * Instead of forcing the reconstructed surface to lie between two
- * GLOBALLY defined planes, LBB constrains one patch at a time to lie
- * between LOCALLY defined planes. This is accomplished by
- * constraining the derivatives (x, y and cross) at each input pixel
- * location so that if the constraint was applied everywhere the
- * surface would fit between the min and max of the values at the 9
- * closest pixel locations. Because this is done with each of the four
- * pixel locations which define the bicubic patch, this forces the
- * reconstructed surface to lie between the min and max of the values
- * at the 16 closest values pixel locations. (Each corner defines its
- * own 3x3 subgroup of the 4x4 stencil. Consequently, the surface is
- * necessarily above the minimum of the four minima, which happens to
- * be the minimum over the 4x4. Similarly with the maxima.)
- *
- * The above paragraph described the "soft" version of LBB. The
- * "sharp" version is similar.
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <vips/vips.h>
-#include <vips/internal.h>
-
-#include "templates.h"
-
-#define VIPS_TYPE_INTERPOLATE_LBB \
-	(vips_interpolate_lbb_get_type())
-#define VIPS_INTERPOLATE_LBB( obj ) \
-	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
-	VIPS_TYPE_INTERPOLATE_LBB, VipsInterpolateLbb ))
-#define VIPS_INTERPOLATE_LBB_CLASS( klass ) \
-	(G_TYPE_CHECK_CLASS_CAST( (klass), \
-	VIPS_TYPE_INTERPOLATE_LBB, VipsInterpolateLbbClass))
-#define VIPS_IS_INTERPOLATE_LBB( obj ) \
-	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_INTERPOLATE_LBB ))
-#define VIPS_IS_INTERPOLATE_LBB_CLASS( klass ) \
-	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_INTERPOLATE_LBB ))
-#define VIPS_INTERPOLATE_LBB_GET_CLASS( obj ) \
-	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
-	VIPS_TYPE_INTERPOLATE_LBB, VipsInterpolateLbbClass ))
-
-typedef struct _VipsInterpolateLbb {
-	VipsInterpolate parent_object;
-
-} VipsInterpolateLbb;
-
-typedef struct _VipsInterpolateLbbClass {
-	VipsInterpolateClass parent_class;
-
-} VipsInterpolateLbbClass;
-
-/*
- * Absolute value and sign macros:
- */
-#define LBB_ABS(x)  ( ((x)>=0.) ? (x) : -(x) )
-#define LBB_SIGN(x) ( ((x)>=0.) ? 1.0 : -1.0 )
-/*
- * MIN and MAX macros set up so that I can put the likely winner in
- * the first argument (forward branch likely blah blah blah):
- */
-#define LBB_MIN(x,y) ( ((x)<=(y)) ? (x) : (y) )
-#define LBB_MAX(x,y) ( ((x)>=(y)) ? (x) : (y) )
-
-static inline double
-lbbicubic( const double c00,
-           const double c10,
-           const double c01,
-           const double c11,
-           const double c00dx,
-           const double c10dx,
-           const double c01dx,
-           const double c11dx,
-           const double c00dy,
-           const double c10dy,
-           const double c01dy,
-           const double c11dy,
-           const double c00dxdy,
-           const double c10dxdy,
-           const double c01dxdy,
-           const double c11dxdy,
-           const double uno_one,
-           const double uno_two,
-           const double uno_thr,
-           const double uno_fou,
-           const double dos_one,
-           const double dos_two,
-           const double dos_thr,
-           const double dos_fou,
-           const double tre_one,
-           const double tre_two,
-           const double tre_thr,
-           const double tre_fou,
-           const double qua_one,
-           const double qua_two,
-           const double qua_thr,
-           const double qua_fou )
-{
-  /*
-   * STENCIL (FOOTPRINT) OF INPUT VALUES:
-   *
-   * The stencil of LBB is the same as for any standard Hermite
-   * bicubic (e.g., Catmull-Rom):
-   *
-   *  (ix-1,iy-1)  (ix,iy-1)    (ix+1,iy-1)  (ix+2,iy-1)
-   *  = uno_one    = uno_two    = uno_thr    = uno_fou
-   *
-   *  (ix-1,iy)    (ix,iy)      (ix+1,iy)    (ix+2,iy)
-   *  = dos_one    = dos_two    = dos_thr    = dos_fou
-   *                        X
-   *  (ix-1,iy+1)  (ix,iy+1)    (ix+1,iy+1)  (ix+2,iy+1)
-   *  = tre_one    = tre_two    = tre_thr    = tre_fou
-   *
-   *  (ix-1,iy+2)  (ix,iy+2)    (ix+1,iy+2)  (ix+2,iy+2)
-   *  = qua_one    = qua_two    = qua_thr    = qua_fou
-   *
-   * where ix is the (pseudo-)floor of the requested left-to-right
-   * location ("X"), and iy is the floor of the requested up-to-down
-   * location.
-   */
-
-#if defined (__LBB_CHEAP_H__)
-  /*
-   * Computation of the four min and four max over 3x3 input data
-   * sub-crosses of the 4x4 input stencil, performed with only 22
-   * comparisons and 28 "? :". If you can figure out how to do this
-   * more efficiently, let us know.
-   *
-   * This is the cheaper (but arguably less desirable in terms of
-   * quality) version of the computation.
-   */
-  const double m1    = (dos_two <= dos_thr) ? dos_two : dos_thr  ;
-  const double M1    = (dos_two <= dos_thr) ? dos_thr : dos_two  ;
-  const double m2    = (tre_two <= tre_thr) ? tre_two : tre_thr  ;
-  const double M2    = (tre_two <= tre_thr) ? tre_thr : tre_two  ;
-  const double m3    = (uno_two <= dos_one) ? uno_two : dos_one  ;
-  const double M3    = (uno_two <= dos_one) ? dos_one : uno_two  ;
-  const double m4    = (uno_thr <= dos_fou) ? uno_thr : dos_fou  ;
-  const double M4    = (uno_thr <= dos_fou) ? dos_fou : uno_thr  ;
-  const double m5    = (tre_one <= qua_two) ? tre_one : qua_two  ;
-  const double M5    = (tre_one <= qua_two) ? qua_two : tre_one  ;
-  const double m6    = (tre_fou <= qua_thr) ? tre_fou : qua_thr  ;
-  const double M6    = (tre_fou <= qua_thr) ? qua_thr : tre_fou  ;
-  const double m7    = LBB_MIN(               m1,       tre_two );
-  const double M7    = LBB_MAX(               M1,       tre_two );
-  const double m8    = LBB_MIN(               m1,       tre_thr );
-  const double M8    = LBB_MAX(               M1,       tre_thr );
-  const double m9    = LBB_MIN(               m2,       dos_two );
-  const double M9    = LBB_MAX(               M2,       dos_two );
-  const double m10   = LBB_MIN(               m2,       dos_thr );
-  const double M10   = LBB_MAX(               M2,       dos_thr );
-  const double min00 = LBB_MIN(               m7,       m3      );
-  const double max00 = LBB_MAX(               M7,       M3      );
-  const double min10 = LBB_MIN(               m8,       m4      );
-  const double max10 = LBB_MAX(               M8,       M4      );
-  const double min01 = LBB_MIN(               m9,       m5      );
-  const double max01 = LBB_MAX(               M9,       M5      );
-  const double min11 = LBB_MIN(              m10,       m6      );
-  const double max11 = LBB_MAX(              M10,       M6      );
-#else
-  /*
-   * Computation of the four min and four max over 3x3 input data
-   * sub-blocks of the 4x4 input stencil, performed with only 28
-   * comparisons and 34 "? :". If you can figure how to do this more
-   * efficiently, let us know.
-   */
-  const double m1    = (dos_two <= dos_thr) ? dos_two : dos_thr  ;
-  const double M1    = (dos_two <= dos_thr) ? dos_thr : dos_two  ;
-  const double m2    = (tre_two <= tre_thr) ? tre_two : tre_thr  ;
-  const double M2    = (tre_two <= tre_thr) ? tre_thr : tre_two  ;
-  const double m6    = (dos_one <= tre_one) ? dos_one : tre_one  ;
-  const double M6    = (dos_one <= tre_one) ? tre_one : dos_one  ;
-  const double m7    = (dos_fou <= tre_fou) ? dos_fou : tre_fou  ;
-  const double M7    = (dos_fou <= tre_fou) ? tre_fou : dos_fou  ;
-  const double m3    = (uno_two <= uno_thr) ? uno_two : uno_thr  ;
-  const double M3    = (uno_two <= uno_thr) ? uno_thr : uno_two  ;
-  const double m4    = (qua_two <= qua_thr) ? qua_two : qua_thr  ;
-  const double M4    = (qua_two <= qua_thr) ? qua_thr : qua_two  ;
-  const double m5    = LBB_MIN(               m1,       m2      );
-  const double M5    = LBB_MAX(               M1,       M2      );
-  const double m10   = LBB_MIN(               m6,       uno_one );
-  const double M10   = LBB_MAX(               M6,       uno_one );
-  const double m11   = LBB_MIN(               m6,       qua_one );
-  const double M11   = LBB_MAX(               M6,       qua_one );
-  const double m12   = LBB_MIN(               m7,       uno_fou );
-  const double M12   = LBB_MAX(               M7,       uno_fou );
-  const double m13   = LBB_MIN(               m7,       qua_fou );
-  const double M13   = LBB_MAX(               M7,       qua_fou );
-  const double m8    = LBB_MIN(               m5,       m3      );
-  const double M8    = LBB_MAX(               M5,       M3      );
-  const double m9    = LBB_MIN(               m5,       m4      );
-  const double M9    = LBB_MAX(               M5,       M4      );
-  const double min00 = LBB_MIN(               m8,       m10     );
-  const double max00 = LBB_MAX(               M8,       M10     );
-  const double min10 = LBB_MIN(               m8,       m12     );
-  const double max10 = LBB_MAX(               M8,       M12     );
-  const double min01 = LBB_MIN(               m9,       m11     );
-  const double max01 = LBB_MAX(               M9,       M11     );
-  const double min11 = LBB_MIN(               m9,       m13     );
-  const double max11 = LBB_MAX(               M9,       M13     );
-#endif
-
-  /*
-   * The remainder of the "per channel" computation involves the
-   * computation of:
-   *
-   * --8 conditional moves,
-   *
-   * --8 signs (in which the sign of zero is unimportant),
-   *
-   * --12 minima of two values,
-   *
-   * --8 maxima of two values,
-   *
-   * --8 absolute values,
-   *
-   * for a grand total of 29 minima, 25 maxima, 8 conditional moves, 8
-   * signs, and 8 absolute values. If everything is done with
-   * conditional moves, "only" 28+8+8+12+8+8=72 flags are involved
-   * (because initial min and max can be computed with one flag).
-   *
-   * The "per channel" part of the computation also involves 107
-   * arithmetic operations (54 *, 21 +, 42 -).
-   */
-
-  /*
-   * Distances to the local min and max:
-   */
-  const double u00 = dos_two - min00;
-  const double v00 = max00 - dos_two;
-  const double u10 = dos_thr - min10;
-  const double v10 = max10 - dos_thr;
-  const double u01 = tre_two - min01;
-  const double v01 = max01 - tre_two;
-  const double u11 = tre_thr - min11;
-  const double v11 = max11 - tre_thr;
-
-  /*
-   * Initial values of the derivatives computed with centered
-   * differences. Factors of 1/2 are left out because they are folded
-   * in later:
-   */
-  const double dble_dzdx00i = dos_thr - dos_one;
-  const double dble_dzdy11i = qua_thr - dos_thr;
-  const double dble_dzdx10i = dos_fou - dos_two;
-  const double dble_dzdy01i = qua_two - dos_two;
-  const double dble_dzdx01i = tre_thr - tre_one;
-  const double dble_dzdy10i = tre_thr - uno_thr;
-  const double dble_dzdx11i = tre_fou - tre_two;
-  const double dble_dzdy00i = tre_two - uno_two;
-
-  /*
-   * Signs of the derivatives. The upcoming clamping does not change
-   * them (except if the clamping sends a negative derivative to 0, in
-   * which case the sign does not matter anyway).
-   */
-  const double sign_dzdx00 = LBB_SIGN( dble_dzdx00i );
-  const double sign_dzdx10 = LBB_SIGN( dble_dzdx10i );
-  const double sign_dzdx01 = LBB_SIGN( dble_dzdx01i );
-  const double sign_dzdx11 = LBB_SIGN( dble_dzdx11i );
-
-  const double sign_dzdy00 = LBB_SIGN( dble_dzdy00i );
-  const double sign_dzdy10 = LBB_SIGN( dble_dzdy10i );
-  const double sign_dzdy01 = LBB_SIGN( dble_dzdy01i );
-  const double sign_dzdy11 = LBB_SIGN( dble_dzdy11i );
-
-  /*
-   * Initial values of the cross-derivatives. Factors of 1/4 are left
-   * out because folded in later:
-   */
-  const double quad_d2zdxdy00i = uno_one - uno_thr + dble_dzdx01i;
-  const double quad_d2zdxdy10i = uno_two - uno_fou + dble_dzdx11i;
-  const double quad_d2zdxdy01i = qua_thr - qua_one - dble_dzdx00i;
-  const double quad_d2zdxdy11i = qua_fou - qua_two - dble_dzdx10i;
-
-  /*
-   * Slope limiters. The key multiplier is 3 but we fold a factor of
-   * 2, hence 6:
-   */
-  const double dble_slopelimit_00 = 6.0 * LBB_MIN( u00, v00 );
-  const double dble_slopelimit_10 = 6.0 * LBB_MIN( u10, v10 );
-  const double dble_slopelimit_01 = 6.0 * LBB_MIN( u01, v01 );
-  const double dble_slopelimit_11 = 6.0 * LBB_MIN( u11, v11 );
-
-  /*
-   * Clamped first derivatives:
-   */
-  const double dble_dzdx00 =
-    ( sign_dzdx00 * dble_dzdx00i <= dble_slopelimit_00 )
-    ? dble_dzdx00i :  sign_dzdx00 * dble_slopelimit_00;
-  const double dble_dzdy00 =
-    ( sign_dzdy00 * dble_dzdy00i <= dble_slopelimit_00 )
-    ? dble_dzdy00i :  sign_dzdy00 * dble_slopelimit_00;
-  const double dble_dzdx10 =
-    ( sign_dzdx10 * dble_dzdx10i <= dble_slopelimit_10 )
-    ? dble_dzdx10i :  sign_dzdx10 * dble_slopelimit_10;
-  const double dble_dzdy10 =
-    ( sign_dzdy10 * dble_dzdy10i <= dble_slopelimit_10 )
-    ? dble_dzdy10i :  sign_dzdy10 * dble_slopelimit_10;
-  const double dble_dzdx01 =
-    ( sign_dzdx01 * dble_dzdx01i <= dble_slopelimit_01 )
-    ? dble_dzdx01i :  sign_dzdx01 * dble_slopelimit_01;
-  const double dble_dzdy01 =
-    ( sign_dzdy01 * dble_dzdy01i <= dble_slopelimit_01 )
-    ? dble_dzdy01i :  sign_dzdy01 * dble_slopelimit_01;
-  const double dble_dzdx11 =
-    ( sign_dzdx11 * dble_dzdx11i <= dble_slopelimit_11 )
-    ? dble_dzdx11i :  sign_dzdx11 * dble_slopelimit_11;
-  const double dble_dzdy11 =
-    ( sign_dzdy11 * dble_dzdy11i <= dble_slopelimit_11 )
-    ? dble_dzdy11i :  sign_dzdy11 * dble_slopelimit_11;
-
-  /*
-   * Sums and differences of first derivatives:
-   */
-  const double twelve_sum00 = 6.0 * ( dble_dzdx00 + dble_dzdy00 );
-  const double twelve_dif00 = 6.0 * ( dble_dzdx00 - dble_dzdy00 );
-  const double twelve_sum10 = 6.0 * ( dble_dzdx10 + dble_dzdy10 );
-  const double twelve_dif10 = 6.0 * ( dble_dzdx10 - dble_dzdy10 );
-  const double twelve_sum01 = 6.0 * ( dble_dzdx01 + dble_dzdy01 );
-  const double twelve_dif01 = 6.0 * ( dble_dzdx01 - dble_dzdy01 );
-  const double twelve_sum11 = 6.0 * ( dble_dzdx11 + dble_dzdy11 );
-  const double twelve_dif11 = 6.0 * ( dble_dzdx11 - dble_dzdy11 );
-
-  /*
-   * Absolute values of the sums:
-   */
-  const double twelve_abs_sum00 = LBB_ABS( twelve_sum00 );
-  const double twelve_abs_sum10 = LBB_ABS( twelve_sum10 );
-  const double twelve_abs_sum01 = LBB_ABS( twelve_sum01 );
-  const double twelve_abs_sum11 = LBB_ABS( twelve_sum11 );
-
-  /*
-   * Scaled distances to the min:
-   */
-  const double u00_times_36 = 36.0 * u00;
-  const double u10_times_36 = 36.0 * u10;
-  const double u01_times_36 = 36.0 * u01;
-  const double u11_times_36 = 36.0 * u11;
-
-  /*
-   * First cross-derivative limiter:
-   */
-  const double first_limit00 = twelve_abs_sum00 - u00_times_36;
-  const double first_limit10 = twelve_abs_sum10 - u10_times_36;
-  const double first_limit01 = twelve_abs_sum01 - u01_times_36;
-  const double first_limit11 = twelve_abs_sum11 - u11_times_36;
-
-  const double quad_d2zdxdy00ii = LBB_MAX( quad_d2zdxdy00i, first_limit00 );
-  const double quad_d2zdxdy10ii = LBB_MAX( quad_d2zdxdy10i, first_limit10 );
-  const double quad_d2zdxdy01ii = LBB_MAX( quad_d2zdxdy01i, first_limit01 );
-  const double quad_d2zdxdy11ii = LBB_MAX( quad_d2zdxdy11i, first_limit11 );
-
-  /*
-   * Scaled distances to the max:
-   */
-  const double v00_times_36 = 36.0 * v00;
-  const double v10_times_36 = 36.0 * v10;
-  const double v01_times_36 = 36.0 * v01;
-  const double v11_times_36 = 36.0 * v11;
-
-  /*
-   * Second cross-derivative limiter:
-   */
-  const double second_limit00 = v00_times_36 - twelve_abs_sum00;
-  const double second_limit10 = v10_times_36 - twelve_abs_sum10;
-  const double second_limit01 = v01_times_36 - twelve_abs_sum01;
-  const double second_limit11 = v11_times_36 - twelve_abs_sum11;
-
-  const double quad_d2zdxdy00iii = LBB_MIN( quad_d2zdxdy00ii, second_limit00 );
-  const double quad_d2zdxdy10iii = LBB_MIN( quad_d2zdxdy10ii, second_limit10 );
-  const double quad_d2zdxdy01iii = LBB_MIN( quad_d2zdxdy01ii, second_limit01 );
-  const double quad_d2zdxdy11iii = LBB_MIN( quad_d2zdxdy11ii, second_limit11 );
-
-  /*
-   * Absolute values of the differences:
-   */
-  const double twelve_abs_dif00 = LBB_ABS( twelve_dif00 );
-  const double twelve_abs_dif10 = LBB_ABS( twelve_dif10 );
-  const double twelve_abs_dif01 = LBB_ABS( twelve_dif01 );
-  const double twelve_abs_dif11 = LBB_ABS( twelve_dif11 );
-
-  /*
-   * Third cross-derivative limiter:
-   */
-  const double third_limit00 = twelve_abs_dif00 - v00_times_36;
-  const double third_limit10 = twelve_abs_dif10 - v10_times_36;
-  const double third_limit01 = twelve_abs_dif01 - v01_times_36;
-  const double third_limit11 = twelve_abs_dif11 - v11_times_36;
-
-  const double quad_d2zdxdy00iiii = LBB_MAX( quad_d2zdxdy00iii, third_limit00);
-  const double quad_d2zdxdy10iiii = LBB_MAX( quad_d2zdxdy10iii, third_limit10);
-  const double quad_d2zdxdy01iiii = LBB_MAX( quad_d2zdxdy01iii, third_limit01);
-  const double quad_d2zdxdy11iiii = LBB_MAX( quad_d2zdxdy11iii, third_limit11);
-
-  /*
-   * Fourth cross-derivative limiter:
-   */
-  const double fourth_limit00 = u00_times_36 - twelve_abs_dif00;
-  const double fourth_limit10 = u10_times_36 - twelve_abs_dif10;
-  const double fourth_limit01 = u01_times_36 - twelve_abs_dif01;
-  const double fourth_limit11 = u11_times_36 - twelve_abs_dif11;
-
-  const double quad_d2zdxdy00 = LBB_MIN( quad_d2zdxdy00iiii, fourth_limit00);
-  const double quad_d2zdxdy10 = LBB_MIN( quad_d2zdxdy10iiii, fourth_limit10);
-  const double quad_d2zdxdy01 = LBB_MIN( quad_d2zdxdy01iiii, fourth_limit01);
-  const double quad_d2zdxdy11 = LBB_MIN( quad_d2zdxdy11iiii, fourth_limit11);
-
-  /*
-   * Part of the result which does not need derivatives:
-   */
-  const double newval1 = c00 * dos_two + c10 * dos_thr +
-                         c01 * tre_two + c11 * tre_thr;
-
-  /*
-   * Twice the part of the result which only needs first derivatives.
-   */
-  const double newval2 = c00dx * dble_dzdx00 + c10dx * dble_dzdx10 +
-                         c01dx * dble_dzdx01 + c11dx * dble_dzdx11 +
-                         c00dy * dble_dzdy00 + c10dy * dble_dzdy10 +
-                         c01dy * dble_dzdy01 + c11dy * dble_dzdy11;
-
-  /*
-   * Four times the part of the result which only uses cross
-   * derivatives:
-   */
-  const double newval3 = c00dxdy * quad_d2zdxdy00 + c10dxdy * quad_d2zdxdy10 +
-                         c01dxdy * quad_d2zdxdy01 + c11dxdy * quad_d2zdxdy11;
-
-  const double newval = newval1 + .5 * newval2 + .25 * newval3;
-
-  return newval;
-}
-
-/*
- * Call lbb with a type conversion operator as a parameter.
- *
- * It would be nice to do this with templates but we can't figure out
- * how to do it cleanly. Suggestions welcome!
- */
-#define LBB_CONVERSION( conversion )                     \
-  template <typename T> static void inline               \
-  lbb_ ## conversion(       void*      restrict pout,    \
-                      const VipsPel*   restrict pin,     \
-                      const int             bands,       \
-                      const int             lskip,       \
-                      const double          relative_x,  \
-                      const double          relative_y ) \
-  { \
-    T* restrict out = (T *) pout; \
-    \
-    const T* restrict in = (T *) pin; \
-    \
-    const int one_shift     =  -bands; \
-    const int thr_shift     =   bands; \
-    const int fou_shift     = 2*bands; \
-    \
-    const int uno_two_shift =  -lskip; \
-    \
-    const int tre_two_shift =   lskip; \
-    const int qua_two_shift = 2*lskip; \
-    \
-    const int uno_one_shift = uno_two_shift + one_shift; \
-    const int dos_one_shift =                 one_shift; \
-    const int tre_one_shift = tre_two_shift + one_shift; \
-    const int qua_one_shift = qua_two_shift + one_shift; \
-    \
-    const int uno_thr_shift = uno_two_shift + thr_shift; \
-    const int dos_thr_shift =                 thr_shift; \
-    const int tre_thr_shift = tre_two_shift + thr_shift; \
-    const int qua_thr_shift = qua_two_shift + thr_shift; \
-    \
-    const int uno_fou_shift = uno_two_shift + fou_shift; \
-    const int dos_fou_shift =                 fou_shift; \
-    const int tre_fou_shift = tre_two_shift + fou_shift; \
-    const int qua_fou_shift = qua_two_shift + fou_shift; \
-    \
-    const double xp1over2   = relative_x; \
-    const double xm1over2   = xp1over2 - 1.0; \
-    const double onepx      = 0.5 + xp1over2; \
-    const double onemx      = 1.5 - xp1over2; \
-    const double xp1over2sq = xp1over2 * xp1over2; \
-    \
-    const double yp1over2   = relative_y; \
-    const double ym1over2   = yp1over2 - 1.0; \
-    const double onepy      = 0.5 + yp1over2; \
-    const double onemy      = 1.5 - yp1over2; \
-    const double yp1over2sq = yp1over2 * yp1over2; \
-    \
-    const double xm1over2sq = xm1over2 * xm1over2; \
-    const double ym1over2sq = ym1over2 * ym1over2; \
-    \
-    const double twice1px = onepx + onepx; \
-    const double twice1py = onepy + onepy; \
-    const double twice1mx = onemx + onemx; \
-    const double twice1my = onemy + onemy; \
-    \
-    const double xm1over2sq_times_ym1over2sq = xm1over2sq * ym1over2sq; \
-    const double xp1over2sq_times_ym1over2sq = xp1over2sq * ym1over2sq; \
-    const double xp1over2sq_times_yp1over2sq = xp1over2sq * yp1over2sq; \
-    const double xm1over2sq_times_yp1over2sq = xm1over2sq * yp1over2sq; \
-    \
-    const double four_times_1px_times_1py = twice1px * twice1py; \
-    const double four_times_1mx_times_1py = twice1mx * twice1py; \
-    const double twice_xp1over2_times_1py = xp1over2 * twice1py; \
-    const double twice_xm1over2_times_1py = xm1over2 * twice1py; \
-    \
-    const double twice_xm1over2_times_1my = xm1over2 * twice1my; \
-    const double twice_xp1over2_times_1my = xp1over2 * twice1my; \
-    const double four_times_1mx_times_1my = twice1mx * twice1my; \
-    const double four_times_1px_times_1my = twice1px * twice1my; \
-    \
-    const double twice_1px_times_ym1over2 = twice1px * ym1over2; \
-    const double twice_1mx_times_ym1over2 = twice1mx * ym1over2; \
-    const double xp1over2_times_ym1over2  = xp1over2 * ym1over2; \
-    const double xm1over2_times_ym1over2  = xm1over2 * ym1over2; \
-    \
-    const double xm1over2_times_yp1over2  = xm1over2 * yp1over2; \
-    const double xp1over2_times_yp1over2  = xp1over2 * yp1over2; \
-    const double twice_1mx_times_yp1over2 = twice1mx * yp1over2; \
-    const double twice_1px_times_yp1over2 = twice1px * yp1over2; \
-    \
-    const double c00 = \
-      four_times_1px_times_1py * xm1over2sq_times_ym1over2sq; \
-    const double c00dx = \
-      twice_xp1over2_times_1py * xm1over2sq_times_ym1over2sq; \
-    const double c00dy = \
-      twice_1px_times_yp1over2 * xm1over2sq_times_ym1over2sq; \
-    const double c00dxdy = \
-       xp1over2_times_yp1over2 * xm1over2sq_times_ym1over2sq; \
-    \
-    const double c10 = \
-      four_times_1mx_times_1py * xp1over2sq_times_ym1over2sq; \
-    const double c10dx = \
-      twice_xm1over2_times_1py * xp1over2sq_times_ym1over2sq; \
-    const double c10dy = \
-      twice_1mx_times_yp1over2 * xp1over2sq_times_ym1over2sq; \
-    const double c10dxdy = \
-       xm1over2_times_yp1over2 * xp1over2sq_times_ym1over2sq; \
-    \
-    const double c01 = \
-      four_times_1px_times_1my * xm1over2sq_times_yp1over2sq; \
-    const double c01dx = \
-      twice_xp1over2_times_1my * xm1over2sq_times_yp1over2sq; \
-    const double c01dy = \
-      twice_1px_times_ym1over2 * xm1over2sq_times_yp1over2sq; \
-    const double c01dxdy = \
-       xp1over2_times_ym1over2 * xm1over2sq_times_yp1over2sq; \
-    \
-    const double c11 = \
-      four_times_1mx_times_1my * xp1over2sq_times_yp1over2sq; \
-    const double c11dx = \
-      twice_xm1over2_times_1my * xp1over2sq_times_yp1over2sq; \
-    const double c11dy = \
-      twice_1mx_times_ym1over2 * xp1over2sq_times_yp1over2sq; \
-    const double c11dxdy = \
-       xm1over2_times_ym1over2 * xp1over2sq_times_yp1over2sq; \
-    \
-    int band = bands; \
-    \
-    do \
-      { \
-        const double double_result =        \
-          lbbicubic( c00,                   \
-                     c10,                   \
-                     c01,                   \
-                     c11,                   \
-                     c00dx,                 \
-                     c10dx,                 \
-                     c01dx,                 \
-                     c11dx,                 \
-                     c00dy,                 \
-                     c10dy,                 \
-                     c01dy,                 \
-                     c11dy,                 \
-                     c00dxdy,               \
-                     c10dxdy,               \
-                     c01dxdy,               \
-                     c11dxdy,               \
-                     in[ uno_one_shift ],   \
-                     in[ uno_two_shift ],   \
-                     in[ uno_thr_shift ],   \
-                     in[ uno_fou_shift ],   \
-                     in[ dos_one_shift ],   \
-                     in[             0 ],   \
-                     in[ dos_thr_shift ],   \
-                     in[ dos_fou_shift ],   \
-                     in[ tre_one_shift ],   \
-                     in[ tre_two_shift ],   \
-                     in[ tre_thr_shift ],   \
-                     in[ tre_fou_shift ],   \
-                     in[ qua_one_shift ],   \
-                     in[ qua_two_shift ],   \
-                     in[ qua_thr_shift ],   \
-                     in[ qua_fou_shift ] ); \
-        \
-        const T result = to_ ## conversion<T>( double_result ); \
-        in++; \
-        *out++ = result; \
-      } while (--band); \
-  }
-
-LBB_CONVERSION( fptypes )
-LBB_CONVERSION( withsign )
-LBB_CONVERSION( nosign )
-
-#define CALL( T, conversion )          \
-  lbb_ ## conversion<T>( out,          \
-                         p,            \
-                         bands,        \
-                         lskip,        \
-                         relative_x,   \
-                         relative_y );
-
-/*
- * We need C linkage:
- */
-extern "C" {
-G_DEFINE_TYPE( VipsInterpolateLbb, vips_interpolate_lbb,
-	VIPS_TYPE_INTERPOLATE );
-}
-
-static void
-vips_interpolate_lbb_interpolate( VipsInterpolate* restrict interpolate,
-                                  void*            restrict out,
-                                  VipsRegion*      restrict in,
-                                  double                    absolute_x,
-                                  double                    absolute_y )
-{
-  /* absolute_x and absolute_y are always >= 1.0 (see double-check assert
-   * below), so we don't need floor(). 
-   *
-   * It's 1 not 0 since have a window_offset of 1.
-   */
-  const int ix = (int) absolute_x;
-  const int iy = (int) absolute_y;
-
-  /*
-   * Move the pointer to (the first band of) the top/left pixel of the
-   * 2x2 group of pixel centers which contains the sampling location
-   * in its convex hull:
-   */
-  const VipsPel* restrict p = VIPS_REGION_ADDR( in, ix, iy );
-
-  const double relative_x = absolute_x - ix;
-  const double relative_y = absolute_y - iy;
-
-  /*
-   * VIPS versions of Nicolas's pixel addressing values.
-   */
-  const int lskip = VIPS_REGION_LSKIP( in ) / 
-	  VIPS_IMAGE_SIZEOF_ELEMENT( in->im );
-  /*
-   * Double the bands for complex images to account for the real and
-   * imaginary parts being computed independently:
-   */
-  const int actual_bands = in->im->Bands;
-  const int bands =
-    vips_bandfmt_iscomplex( in->im->BandFmt ) ? 2 * actual_bands : actual_bands;
-
-  /* Confirm that absolute_x and absolute_y are >= 1, see above. 
-   */
-  g_assert( absolute_x >= 1.0 );
-  g_assert( absolute_y >= 1.0 );
-
-  switch( in->im->BandFmt ) {
-  case VIPS_FORMAT_UCHAR:
-    CALL( unsigned char, nosign );
-    break;
-
-  case VIPS_FORMAT_CHAR:
-    CALL( signed char, withsign );
-    break;
-
-  case VIPS_FORMAT_USHORT:
-    CALL( unsigned short, nosign );
-    break;
-
-  case VIPS_FORMAT_SHORT:
-    CALL( signed short, withsign );
-    break;
-
-  case VIPS_FORMAT_UINT:
-    CALL( unsigned int, nosign );
-    break;
-
-  case VIPS_FORMAT_INT:
-    CALL( signed int, withsign );
-    break;
-
-  /*
-   * Complex images are handled by doubling of bands.
-   */
-  case VIPS_FORMAT_FLOAT:
-  case VIPS_FORMAT_COMPLEX:
-    CALL( float, fptypes );
-    break;
-
-  case VIPS_FORMAT_DOUBLE:
-  case VIPS_FORMAT_DPCOMPLEX:
-    CALL( double, fptypes );
-    break;
-
-  default:
-    g_assert( 0 );
-    break;
-  }
-}
-
-static void
-vips_interpolate_lbb_class_init( VipsInterpolateLbbClass *klass )
-{
-  VipsObjectClass *object_class = VIPS_OBJECT_CLASS( klass );
-  VipsInterpolateClass *interpolate_class =
-    VIPS_INTERPOLATE_CLASS( klass );
-
-  object_class->nickname    = "lbb";
-  object_class->description = _( "Reduced halo bicubic" );
-
-  interpolate_class->interpolate   = vips_interpolate_lbb_interpolate;
-  interpolate_class->window_size   = 4;
-}
-
-static void
-vips_interpolate_lbb_init( VipsInterpolateLbb *lbb )
-{
-}
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/resample/Makefile.am vips-7.38.5/libvips/resample/Makefile.am
--- vips-7.38.5-vanilla/libvips/resample/Makefile.am	2014-07-17 23:48:36.232794473 -0400
+++ vips-7.38.5/libvips/resample/Makefile.am	2014-07-17 23:49:32.820792979 -0400
@@ -13,10 +13,6 @@
 	shrink.c \
 	interpolate.c \
 	transform.c \
-	bicubic.cpp \
-	lbb.cpp \
-	nohalo.cpp \
-	vsqbs.cpp \
 	templates.h 
 
 else
@@ -32,10 +28,6 @@
 	transform.c 
 
 EXTRA_DIST = \
-	bicubic.cpp \
-	lbb.cpp \
-	nohalo.cpp \
-	vsqbs.cpp \
 	templates.h 
 
 endif
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/resample/Makefile.in vips-7.38.5/libvips/resample/Makefile.in
--- vips-7.38.5-vanilla/libvips/resample/Makefile.in	2014-07-17 23:48:36.232794473 -0400
+++ vips-7.38.5/libvips/resample/Makefile.in	2014-07-17 23:49:32.820792979 -0400
@@ -505,7 +505,7 @@
 	}
 
 libresample.la: $(libresample_la_OBJECTS) $(libresample_la_DEPENDENCIES) $(EXTRA_libresample_la_DEPENDENCIES) 
-	$(AM_V_CXXLD)$(CXXLINK)  $(libresample_la_OBJECTS) $(libresample_la_LIBADD) $(LIBS)
+	$(AM_V_CXXLD)$(LINK)  $(libresample_la_OBJECTS) $(libresample_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/resample/nohalo.cpp vips-7.38.5/libvips/resample/nohalo.cpp
--- vips-7.38.5-vanilla/libvips/resample/nohalo.cpp	2014-07-17 23:48:36.232794473 -0400
+++ vips-7.38.5/libvips/resample/nohalo.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,1590 +0,0 @@
-/* nohalo subdivision followed by lbb (locally bounded bicubic)
- * interpolation resampler
- *
- * Nohalo level 1 with bilinear finishing scheme hacked for VIPS by
- * J. Cupitt based on code by N. Robidoux, 20/1/09
- *
- * N. Robidoux and J. Cupitt, 4-17/3/09
- *
- * N. Robidoux, 1/4-29/5/2009
- *
- * Nohalo level 2 with bilinear finishing scheme by N. Robidoux based
- * on code by N. Robidoux, A. Turcotte and J. Cupitt, 27/1/2010
- *
- * Nohalo level 1 with LBB finishing scheme by N. Robidoux and
- * C. Racette, 11-18/5/2010
- */
-
-/*
-
-    This file is part of VIPS.
-
-    VIPS is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Lesser General Public License as
-    published by the Free Software Foundation; either version 2 of the
-    License, or (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301 USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-/*
- * 2009-2010 (c) Nicolas Robidoux, Chantal Racette, John Cupitt and
- * Adam Turcotte
- *
- * N. Robidoux thanks Geert Jordaens, Ralf Meyer, Øyvind Kolås,
- * Minglun Gong, Eric Daoust and Sven Neumann for useful comments and
- * code.
- *
- * N. Robidoux's early research on Nohalo funded in part by an NSERC
- * (National Science and Engineering Research Council of Canada)
- * Discovery Grant awarded to him (298424--2004).
- *
- * C. Racette's image resampling research and programming funded in
- * part by an NSERC (National Science and Engineering Research Council
- * of Canada) Alexander Graham Bell Canada Graduate Scholarship, by an
- * NSERC Discovery Grant awarded to Julien Dompierre (grant number
- * 20-61098) and by N. Robidoux's Laurentian University professional
- * allowance.
- *
- * A. Turcotte's image resampling research on reduced halo funded in
- * part by an NSERC Alexander Graham Bell Canada Graduate Scholarhip
- * awarded to him and by a Google Summer of Code 2010 award awarded to
- * GIMP (Gnu Image Manipulation Program).
- *
- * Nohalo with LBB finishing scheme was developed by N. Robidoux and
- * C. Racette at the Department of Mathematics and Computer Science of
- * Laurentian University in the course of C. Racette's Masters thesis
- * in Computational Sciences. Preliminary work on Nohalo and monotone
- * interpolation was performed by C. Racette and N. Robidoux in the
- * course of her honours thesis, by N. Robidoux, A. Turcotte and
- * E. Daoust during Google Summer of Code 2009 (through two awards
- * made to GIMP to improve GEGL), and, earlier, by N. Robidoux,
- * A. Turcotte, J. Cupitt, M. Gong and K. Martinez.
- */
-
-/*
- * Nohalo with LBB as finishing scheme has two versions, which are
- * only different in the way LBB is implemented:
- *
- *   A "soft" version, which shows a little less staircasing and a
- *   little more haloing, and which is a little more expensive to
- *   compute. We recommend this as the default.
- *
- *   A "sharp" version, which shows a little more staircasing and a
- *   little less haloing, and which is a little cheaper (it uses 6
- *   less comparisons and 12 less "? :").
- *
- * The only difference between the two is that the "soft" versions
- * uses local minima and maxima computed over 3x3 square blocks, and
- * the "sharp" version uses local minima and maxima computed over 3x3
- * crosses.
- *
- * The "sharp" version is (a little) faster. We don't know yet for
- * sure, but it appears that the "soft" version gives marginally
- * better results.
- *
- * If you want to use the "sharp" (cheaper) version, uncomment the
- * following three pre-processor code lines:
- */
-
-/*
-#ifndef __NOHALO_CHEAP_H__
-#define __NOHALO_CHEAP_H__
-#endif
- */
-
-/*
- * ================
- * NOHALO RESAMPLER
- * ================
- *
- * "Nohalo" is a resampler with a mission: smoothly straightening
- * oblique lines without undesirable side-effects. In particular,
- * without much blurring and with no added haloing.
- *
- * In this code, one Nohalo subdivision is performed. The
- * interpolation is finished with LBB (Locally Bounded Bicubic).
- *
- * Key properties:
- *
- * =======================
- * Nohalo is interpolatory
- * =======================
- *
- * That is, Nohalo preserves point values: If asked for the value at
- * the center of an input pixel, the sampler returns the corresponding
- * value, unchanged. In addition, because Nohalo is continuous, if
- * asked for a value at a location "very close" to the center of an
- * input pixel, then the sampler returns a value "very close" to
- * it. (Nohalo is not smoothing like, say, B-Spline
- * pseudo-interpolation.)
- *
- * ====================================================================
- * Nohalo subdivision is co-monotone (this is why it's called "no-halo")
- * ====================================================================
- *
- * One consequence of monotonicity is that additional subdivided
- * values are in the range of the four closest input values, which is
- * a form of local boundedness.  (Note: plain vanilla bilinear and
- * nearest neighbour are also co-monotone.) LBB is also locally
- * bounded. Consequently, Nohalo subdivision followed by LBB is
- * locally bounded. When used as a finishing scheme for Nohalo, the
- * standard LBB bounds imply that the final interpolated value is in
- * the range of the nine closest input values. This property is why
- * there is very little added haloing, even when a finishing scheme
- * which is not strictly monotone. Another consequence of local
- * boundedness is that clamping is unnecessary (provided abyss values
- * are within the range of acceptable values, which is "always" the
- * case).
- *
- * Note: If the abyss policy is an extrapolating one---for example,
- * linear or bilinear extrapolation---clamping is still unnecessary
- * UNLESS one attempts to resample outside of the convex hull of the
- * input pixel positions. Consequence: the "corner" image size
- * convention does not require clamping when using linear
- * extrapolation abyss policy when performing image resizing, but the
- * "center" one does, when upscaling, at locations very close to the
- * boundary. If computing values at locations outside of the convex
- * hull of the pixel locations of the input image, nearest neighbour
- * abyss policy is most likely better anyway, because linear
- * extrapolation produces "streaks" if positions far outside the
- * original image boundary are resampled.
- *
- * ========================
- * Nohalo is a local method
- * ========================
- *
- * The interpolated pixel value when using Nohalo subdivision followed
- * by LBB only depends on the 21 (5x5 minus the four corners) closest
- * input values.
- *
- * ===============================
- * Nohalo is second order accurate
- * ===============================
- *
- * (Except possibly near the boundary: it is easy to make this
- * property carry over everywhere but this requires a tuned abyss
- * policy---linear extrapolation, say---or building the boundary
- * conditions inside the sampler.)  Nohalo+LBB is exact on linear
- * intensity profiles, meaning that if the input pixel values (in the
- * stencil) are obtained from a function of the form f(x,y) = a + b*x
- * + c*y (a, b, c constants), then the computed pixel value is exactly
- * the value of f(x,y) at the asked-for sampling location. The
- * boundary condition which is emulated by VIPS through the "extend"
- * extension of the input image---this corresponds to the nearest
- * neighbour abyss policy---does NOT make this resampler exact on
- * linears near the boundary. It does, however, guarantee that no
- * clamping is required even when resampled values are computed at
- * positions outside of the extent of the input image (when
- * extrapolation is required).
- *
- * ===================
- * Nohalo is nonlinear
- * ===================
- *
- * Both Nohalo and LBB are nonlinear, consequently their composition
- * is nonlinear.  In particular, resampling a sum of images may not be
- * the same as summing the resamples. (This occurs even without taking
- * into account over and underflow issues: images can only take values
- * within a banded range, and consequently no sampler is truly
- * linear.)
- *
- * ====================
- * Weaknesses of Nohalo
- * ====================
- *
- * In some cases, the initial subdivision computation is wasted:
- *
- * If a region is bi-chromatic, the nonlinear component of Nohalo
- * subdivision is zero in the interior of the region, and consequently
- * Nohalo subdivision boils down to bilinear. For such images, LBB is
- * probably a better choice.
- *
- * =========================
- * Bibliographical reference
- * =========================
- *
- * For more information about Nohalo (a prototype version with
- * bilinear finish instead of LBB), see
- *
- * CPU, SMP and GPU implementations of Nohalo level 1, a fast
- * co-convex antialiasing image resampler by Nicolas Robidoux, Minglun
- * Gong, John Cupitt, Adam Turcotte, and Kirk Martinez, in C3S2E '09:
- * Proceedings of the 2nd Canadian Conference on Computer Science and
- * Software Engineering, p. 185--195, ACM, New York, NY, USA, 2009.
- * http://doi.acm.org/10.1145/1557626.1557657.
- */
-
-/* Uncomment to enable bounds checking for VIPS_REGION_ADDR().
- */
-#define DEBUG
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <vips/vips.h>
-#include <vips/internal.h>
-
-#include "templates.h"
-
-#define VIPS_TYPE_INTERPOLATE_NOHALO \
-	(vips_interpolate_nohalo_get_type())
-#define VIPS_INTERPOLATE_NOHALO( obj ) \
-	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
-	VIPS_TYPE_INTERPOLATE_NOHALO, VipsInterpolateNohalo ))
-#define VIPS_INTERPOLATE_NOHALO_CLASS( klass ) \
-	(G_TYPE_CHECK_CLASS_CAST( (klass), \
-	VIPS_TYPE_INTERPOLATE_NOHALO, VipsInterpolateNohaloClass))
-#define VIPS_IS_INTERPOLATE_NOHALO( obj ) \
-	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_INTERPOLATE_NOHALO ))
-#define VIPS_IS_INTERPOLATE_NOHALO_CLASS( klass ) \
-	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_INTERPOLATE_NOHALO ))
-#define VIPS_INTERPOLATE_NOHALO_GET_CLASS( obj ) \
-	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
-	VIPS_TYPE_INTERPOLATE_NOHALO, VipsInterpolateNohaloClass ))
-
-typedef struct _VipsInterpolateNohalo {
-	VipsInterpolate parent_object;
-
-} VipsInterpolateNohalo;
-
-typedef struct _VipsInterpolateNohaloClass {
-	VipsInterpolateClass parent_class;
-
-} VipsInterpolateNohaloClass;
-
-/*
- * NOHALO_MINMOD is an implementation of the minmod function which
- * only needs two "conditional moves."
- * NOHALO_MINMOD(a,b,a_times_a,a_times_b) "returns"
- * minmod(a,b). The macro parameter ("input") a_times_a is assumed to
- * contain the square of a; a_times_b, the product of a and b.
- *
- * For uncompressed natural images in high bit depth (images for which
- * the slopes a and b are unlikely to be equal to zero or be equal to
- * each other), or chips with good branch prediction, the following
- * version of the minmod function may work well:
- *
- * ( (a_times_b)>=0. ? ( (a_times_b)<(a_times_a) ? (b) : (a) ) : 0. )
- *
- * In this version, the forward branch of the second conditional move
- * is taken when |b|>|a| and when a*b<0. However, the "else" branch is
- * taken when a=0 (or when a=b), which is why the above version is not
- * as effective for images with regions with constant pixel values (or
- * regions with pixel values which vary linearly or bilinearly) since
- * we apply minmod to pairs of differences.
- *
- * The following version is more suitable for images with flat
- * (constant) colour areas, since a, which is a pixel difference, will
- * often be 0, in which case both forward branches are likely. This
- * may be preferable if "branch flag look ahead" does not work so
- * well.
- *
- * ( (a_times_b)>=0. ? ( (a_times_a)<=(a_times_b) ? (a) : (b) ) : 0. )
- *
- * This last version appears to be slightly better than the former in
- * speed tests performed on a recent multicore Intel chip, especially
- * when enlarging a sharp image by a large factor, hence the choice.
- */
-#define NOHALO_MINMOD(a,b,a_times_a,a_times_b) \
-  ( ( (a_times_b)>=0. ) ? ( (a_times_a)<=(a_times_b) ? (a) : (b) ) : 0. )
-
-/*
- * Absolute value and sign macros:
- */
-#define NOHALO_ABS(x)  ( ((x)>=0.) ? (x) : -(x) )
-#define NOHALO_SIGN(x) ( ((x)>=0.) ? 1.  : -1.  )
-
-/*
- * MIN and MAX macros set up so that I can put the likely winner in
- * the first argument (forward branch likely blah blah blah):
- */
-#define NOHALO_MIN(x,y) ( ((x)<=(y)) ? (x) : (y) )
-#define NOHALO_MAX(x,y) ( ((x)>=(y)) ? (x) : (y) )
-
-
-static void inline
-nohalo_subdivision (const double           uno_two,
-                    const double           uno_thr,
-                    const double           uno_fou,
-                    const double           dos_one,
-                    const double           dos_two,
-                    const double           dos_thr,
-                    const double           dos_fou,
-                    const double           dos_fiv,
-                    const double           tre_one,
-                    const double           tre_two,
-                    const double           tre_thr,
-                    const double           tre_fou,
-                    const double           tre_fiv,
-                    const double           qua_one,
-                    const double           qua_two,
-                    const double           qua_thr,
-                    const double           qua_fou,
-                    const double           qua_fiv,
-                    const double           cin_two,
-                    const double           cin_thr,
-                    const double           cin_fou,
-                          double* restrict uno_one_1,
-                          double* restrict uno_two_1,
-                          double* restrict uno_thr_1,
-                          double* restrict uno_fou_1,
-                          double* restrict dos_one_1,
-                          double* restrict dos_two_1,
-                          double* restrict dos_thr_1,
-                          double* restrict dos_fou_1,
-                          double* restrict tre_one_1,
-                          double* restrict tre_two_1,
-                          double* restrict tre_thr_1,
-                          double* restrict tre_fou_1,
-                          double* restrict qua_one_1,
-                          double* restrict qua_two_1,
-                          double* restrict qua_thr_1,
-                          double* restrict qua_fou_1)
-{
-  /*
-   * nohalo_subdivision calculates the missing twelve double density
-   * pixel values, and also returns the "already known" four, so that
-   * the sixteen values which make up the stencil of LBB are
-   * available.
-   */
-  /*
-   * THE STENCIL OF INPUT VALUES:
-   *
-   * Pointer arithmetic is used to implicitly reflect the input
-   * stencil about tre_thr---assumed closer to the sampling location
-   * than other pixels (ties are OK)---in such a way that after
-   * reflection the sampling point is to the bottom right of tre_thr.
-   *
-   * The following code and picture assumes that the stencil reflexion
-   * has already been performed.
-   *
-   *               (ix-1,iy-2)  (ix,iy-2)    (ix+1,iy-2)
-   *               =uno_two     = uno_thr    = uno_fou
-   *
-   *
-   *
-   *  (ix-2,iy-1)  (ix-1,iy-1)  (ix,iy-1)    (ix+1,iy-1)  (ix+2,iy-1)
-   *  = dos_one    = dos_two    = dos_thr    = dos_fou    = dos_fiv
-   *
-   *
-   *
-   *  (ix-2,iy)    (ix-1,iy)    (ix,iy)      (ix+1,iy)    (ix+2,iy)
-   *  = tre_one    = tre_two    = tre_thr    = tre_fou    = tre_fiv
-   *                                    X
-   *
-   *
-   *  (ix-2,iy+1)  (ix-1,iy+1)  (ix,iy+1)    (ix+1,iy+1)  (ix+2,iy+1)
-   *  = qua_one    = qua_two    = qua_thr    = qua_fou    = qua_fiv
-   *
-   *
-   *
-   *               (ix-1,iy+2)  (ix,iy+2)    (ix+1,iy+2)
-   *               = cin_two    = cin_thr    = cin_fou
-   *
-   *
-   * The above input pixel values are the ones needed in order to make
-   * available the following values, needed by LBB:
-   *
-   *  uno_one_1 =      uno_two_1 =  uno_thr_1 =      uno_fou_1 =
-   *  (ix-1/2,iy-1/2)  (ix,iy-1/2)  (ix+1/2,iy-1/2)  (ix+1,iy-1/2)
-   *
-   *
-   *
-   *
-   *  dos_one_1 =      dos_two_1 =  dos_thr_1 =      dos_fou_1 =
-   *  (ix-1/2,iy)      (ix,iy)      (ix+1/2,iy)      (ix+1,iy)
-   *
-   *                             X
-   *
-   *
-   *  tre_one_1 =      tre_two_1 =  tre_thr_1 =      tre_fou_1 =
-   *  (ix-1/2,iy+1/2)  (ix,iy+1/2)  (ix+1/2,iy+1/2)  (ix+1,iy+1/2)
-   *
-   *
-   *
-   *
-   *  qua_one_1 =      qua_two_1 =  qua_thr_1 =      qua_fou_1 =
-   *  (ix-1/2,iy+1)    (ix,iy+1)    (ix+1/2,iy+1)    (ix+1,iy+1)
-   *
-   */
-
-  /*
-   * Computation of the nonlinear slopes: If two consecutive pixel
-   * value differences have the same sign, the smallest one (in
-   * absolute value) is taken to be the corresponding slope; if the
-   * two consecutive pixel value differences don't have the same sign,
-   * the corresponding slope is set to 0.
-   *
-   * In other words: Apply minmod to consecutive differences.
-   */
-  /*
-   * Two vertical simple differences:
-   */
-  const double d_unodos_two = dos_two - uno_two;
-  const double d_dostre_two = tre_two - dos_two;
-  const double d_trequa_two = qua_two - tre_two;
-  const double d_quacin_two = cin_two - qua_two;
-  /*
-   * Thr(ee) vertical differences:
-   */
-  const double d_unodos_thr = dos_thr - uno_thr;
-  const double d_dostre_thr = tre_thr - dos_thr;
-  const double d_trequa_thr = qua_thr - tre_thr;
-  const double d_quacin_thr = cin_thr - qua_thr;
-  /*
-   * Fou(r) vertical differences:
-   */
-  const double d_unodos_fou = dos_fou - uno_fou;
-  const double d_dostre_fou = tre_fou - dos_fou;
-  const double d_trequa_fou = qua_fou - tre_fou;
-  const double d_quacin_fou = cin_fou - qua_fou;
-  /*
-   * Dos horizontal differences:
-   */
-  const double d_dos_onetwo = dos_two - dos_one;
-  const double d_dos_twothr = dos_thr - dos_two;
-  const double d_dos_thrfou = dos_fou - dos_thr;
-  const double d_dos_foufiv = dos_fiv - dos_fou;
-  /*
-   * Tre(s) horizontal differences:
-   */
-  const double d_tre_onetwo = tre_two - tre_one;
-  const double d_tre_twothr = tre_thr - tre_two;
-  const double d_tre_thrfou = tre_fou - tre_thr;
-  const double d_tre_foufiv = tre_fiv - tre_fou;
-  /*
-   * Qua(ttro) horizontal differences:
-   */
-  const double d_qua_onetwo = qua_two - qua_one;
-  const double d_qua_twothr = qua_thr - qua_two;
-  const double d_qua_thrfou = qua_fou - qua_thr;
-  const double d_qua_foufiv = qua_fiv - qua_fou;
-
-  /*
-   * Recyclable vertical products and squares:
-   */
-  const double d_unodos_times_dostre_two = d_unodos_two * d_dostre_two;
-  const double d_dostre_two_sq           = d_dostre_two * d_dostre_two;
-  const double d_dostre_times_trequa_two = d_dostre_two * d_trequa_two;
-  const double d_trequa_times_quacin_two = d_quacin_two * d_trequa_two;
-  const double d_quacin_two_sq           = d_quacin_two * d_quacin_two;
-
-  const double d_unodos_times_dostre_thr = d_unodos_thr * d_dostre_thr;
-  const double d_dostre_thr_sq           = d_dostre_thr * d_dostre_thr;
-  const double d_dostre_times_trequa_thr = d_trequa_thr * d_dostre_thr;
-  const double d_trequa_times_quacin_thr = d_trequa_thr * d_quacin_thr;
-  const double d_quacin_thr_sq           = d_quacin_thr * d_quacin_thr;
-
-  const double d_unodos_times_dostre_fou = d_unodos_fou * d_dostre_fou;
-  const double d_dostre_fou_sq           = d_dostre_fou * d_dostre_fou;
-  const double d_dostre_times_trequa_fou = d_trequa_fou * d_dostre_fou;
-  const double d_trequa_times_quacin_fou = d_trequa_fou * d_quacin_fou;
-  const double d_quacin_fou_sq           = d_quacin_fou * d_quacin_fou;
-  /*
-   * Recyclable horizontal products and squares:
-   */
-  const double d_dos_onetwo_times_twothr = d_dos_onetwo * d_dos_twothr;
-  const double d_dos_twothr_sq           = d_dos_twothr * d_dos_twothr;
-  const double d_dos_twothr_times_thrfou = d_dos_twothr * d_dos_thrfou;
-  const double d_dos_thrfou_times_foufiv = d_dos_thrfou * d_dos_foufiv;
-  const double d_dos_foufiv_sq           = d_dos_foufiv * d_dos_foufiv;
-
-  const double d_tre_onetwo_times_twothr = d_tre_onetwo * d_tre_twothr;
-  const double d_tre_twothr_sq           = d_tre_twothr * d_tre_twothr;
-  const double d_tre_twothr_times_thrfou = d_tre_thrfou * d_tre_twothr;
-  const double d_tre_thrfou_times_foufiv = d_tre_thrfou * d_tre_foufiv;
-  const double d_tre_foufiv_sq           = d_tre_foufiv * d_tre_foufiv;
-
-  const double d_qua_onetwo_times_twothr = d_qua_onetwo * d_qua_twothr;
-  const double d_qua_twothr_sq           = d_qua_twothr * d_qua_twothr;
-  const double d_qua_twothr_times_thrfou = d_qua_thrfou * d_qua_twothr;
-  const double d_qua_thrfou_times_foufiv = d_qua_thrfou * d_qua_foufiv;
-  const double d_qua_foufiv_sq           = d_qua_foufiv * d_qua_foufiv;
-
-  /*
-   * Minmod slopes and first level pixel values:
-   */
-  const double dos_thr_y = NOHALO_MINMOD( d_dostre_thr, d_unodos_thr,
-                                          d_dostre_thr_sq,
-                                          d_unodos_times_dostre_thr );
-  const double tre_thr_y = NOHALO_MINMOD( d_dostre_thr, d_trequa_thr,
-                                          d_dostre_thr_sq,
-                                          d_dostre_times_trequa_thr );
-
-  const double newval_uno_two =
-    .5 * ( dos_thr + tre_thr )
-    +
-    .25 * ( dos_thr_y - tre_thr_y );
-
-  const double qua_thr_y = NOHALO_MINMOD( d_quacin_thr, d_trequa_thr,
-                                          d_quacin_thr_sq,
-                                          d_trequa_times_quacin_thr );
-
-  const double newval_tre_two =
-    .5 * ( tre_thr + qua_thr )
-    +
-    .25 * ( tre_thr_y - qua_thr_y );
-
-  const double tre_fou_y = NOHALO_MINMOD( d_dostre_fou, d_trequa_fou,
-                                          d_dostre_fou_sq,
-                                          d_dostre_times_trequa_fou );
-  const double qua_fou_y = NOHALO_MINMOD( d_quacin_fou, d_trequa_fou,
-                                          d_quacin_fou_sq,
-                                          d_trequa_times_quacin_fou );
-
-  const double newval_tre_fou =
-    .5 * ( tre_fou + qua_fou )
-    +
-    .25 * ( tre_fou_y - qua_fou_y );
-
-  const double dos_fou_y = NOHALO_MINMOD( d_dostre_fou, d_unodos_fou,
-                                          d_dostre_fou_sq,
-                                          d_unodos_times_dostre_fou );
-
-  const double newval_uno_fou =
-     .5 * ( dos_fou + tre_fou )
-     +
-     .25 * (dos_fou_y - tre_fou_y );
-
-  const double tre_two_x = NOHALO_MINMOD( d_tre_twothr, d_tre_onetwo,
-                                          d_tre_twothr_sq,
-                                          d_tre_onetwo_times_twothr );
-  const double tre_thr_x = NOHALO_MINMOD( d_tre_twothr, d_tre_thrfou,
-                                          d_tre_twothr_sq,
-                                          d_tre_twothr_times_thrfou );
-
-  const double newval_dos_one =
-    .5 * ( tre_two + tre_thr )
-    +
-    .25 * ( tre_two_x - tre_thr_x );
-
-  const double tre_fou_x = NOHALO_MINMOD( d_tre_foufiv, d_tre_thrfou,
-                                          d_tre_foufiv_sq,
-                                          d_tre_thrfou_times_foufiv );
-
-  const double tre_thr_x_minus_tre_fou_x =
-    tre_thr_x - tre_fou_x;
-
-  const double newval_dos_thr =
-    .5 * ( tre_thr + tre_fou )
-    +
-    .25 * tre_thr_x_minus_tre_fou_x;
-
-  const double qua_thr_x = NOHALO_MINMOD( d_qua_twothr, d_qua_thrfou,
-                                          d_qua_twothr_sq,
-                                          d_qua_twothr_times_thrfou );
-  const double qua_fou_x = NOHALO_MINMOD( d_qua_foufiv, d_qua_thrfou,
-                                          d_qua_foufiv_sq,
-                                          d_qua_thrfou_times_foufiv );
-
-  const double qua_thr_x_minus_qua_fou_x =
-    qua_thr_x - qua_fou_x;
-
-  const double newval_qua_thr =
-    .5 * ( qua_thr + qua_fou )
-    +
-    .25 * qua_thr_x_minus_qua_fou_x;
-
-  const double qua_two_x = NOHALO_MINMOD( d_qua_twothr, d_qua_onetwo,
-                                          d_qua_twothr_sq,
-                                          d_qua_onetwo_times_twothr );
-
-  const double newval_qua_one =
-    .5 * ( qua_two + qua_thr )
-    +
-    .25 * ( qua_two_x - qua_thr_x );
-
-  const double newval_tre_thr =
-    .125 * ( tre_thr_x_minus_tre_fou_x + qua_thr_x_minus_qua_fou_x )
-    +
-    .5 * ( newval_tre_two + newval_tre_fou );
-
-  const double dos_thr_x = NOHALO_MINMOD( d_dos_twothr, d_dos_thrfou,
-                                          d_dos_twothr_sq,
-                                          d_dos_twothr_times_thrfou );
-  const double dos_fou_x = NOHALO_MINMOD( d_dos_foufiv, d_dos_thrfou,
-                                          d_dos_foufiv_sq,
-                                          d_dos_thrfou_times_foufiv );
-
-  const double newval_uno_thr =
-    .25 * ( dos_fou - tre_thr )
-    +
-    .125 * ( dos_fou_y - tre_fou_y + dos_thr_x - dos_fou_x )
-    +
-    .5 * ( newval_uno_two + newval_dos_thr );
-
-  const double tre_two_y = NOHALO_MINMOD( d_dostre_two, d_trequa_two,
-                                          d_dostre_two_sq,
-                                          d_dostre_times_trequa_two );
-  const double qua_two_y = NOHALO_MINMOD( d_quacin_two, d_trequa_two,
-                                          d_quacin_two_sq,
-                                          d_trequa_times_quacin_two );
-
-  const double newval_tre_one =
-    .25 * ( qua_two - tre_thr )
-    +
-    .125 * ( qua_two_x - qua_thr_x + tre_two_y - qua_two_y )
-    +
-    .5 * ( newval_dos_one + newval_tre_two );
-
-  const double dos_two_x = NOHALO_MINMOD( d_dos_twothr, d_dos_onetwo,
-                                          d_dos_twothr_sq,
-                                          d_dos_onetwo_times_twothr );
-
-  const double dos_two_y = NOHALO_MINMOD( d_dostre_two, d_unodos_two,
-                                          d_dostre_two_sq,
-                                          d_unodos_times_dostre_two );
-
-  const double newval_uno_one =
-    .25 * ( dos_two + dos_thr + tre_two + tre_thr )
-    +
-    .125 * ( dos_two_x - dos_thr_x + tre_two_x - tre_thr_x
-             +
-             dos_two_y + dos_thr_y - tre_two_y - tre_thr_y );
-
-  /*
-   * Return the sixteen LBB stencil values:
-   */
-  *uno_one_1 = newval_uno_one;
-  *uno_two_1 = newval_uno_two;
-  *uno_thr_1 = newval_uno_thr;
-  *uno_fou_1 = newval_uno_fou;
-  *dos_one_1 = newval_dos_one;
-  *dos_two_1 =        tre_thr;
-  *dos_thr_1 = newval_dos_thr;
-  *dos_fou_1 =        tre_fou;
-  *tre_one_1 = newval_tre_one;
-  *tre_two_1 = newval_tre_two;
-  *tre_thr_1 = newval_tre_thr;
-  *tre_fou_1 = newval_tre_fou;
-  *qua_one_1 = newval_qua_one;
-  *qua_two_1 =        qua_thr;
-  *qua_thr_1 = newval_qua_thr;
-  *qua_fou_1 =        qua_fou;
-}
-
-/*
- * LBB (Locally Bounded Bicubic) is a high quality nonlinear variant
- * of Catmull-Rom. Images resampled with LBB have much smaller halos
- * than images resampled with windowed sincs or other interpolatory
- * cubic spline filters. Specifically, LBB halos are narrower and the
- * over/undershoot amplitude is smaller. This is accomplished without
- * a significant reduction in the smoothness of the result (compared
- * to Catmull-Rom).
- *
- * Another important property is that the resampled values are
- * contained within the range of nearby input values. Consequently, no
- * final clamping is needed to stay "in range" (e.g., 0-255 for
- * standard 8-bit images).
- *
- * LBB was developed by N. Robidoux and C. Racette of the Department
- * of Mathematics and Computer Science of Laurentian University in the
- * course of C.'s Masters Thesis in Computational Sciences.
- */
-
-/*
- * LBB is a novel method with the following properties:
- *
- * --LBB is a Hermite bicubic method: The bicubic surface is defined,
- *   one convex hull of four nearby input points at a time, using four
- *   point values, four x-derivatives, four y-derivatives, and four
- *   cross-derivatives.
- *
- * --The stencil for values in a square patch is the usual 4x4.
- *
- * --LBB is interpolatory.
- *
- * --It is C^1 with continuous cross derivatives.
- *
- * --When the limiters are inactive, LBB gives the same results as
- *   Catmull-Rom.
- *
- * --When used on binary images, LBB gives results similar to bicubic
- *   Hermite with all first derivatives---but not necessarily the
- *   cross derivatives--at the input pixel locations set to zero.
- *
- * --The LBB reconstruction is locally bounded: Over each square
- *   patch, the surface is contained between the minimum and the
- *   maximum values among the 16 nearest input pixel values (those in
- *   the stencil).
- *
- * --Consequently, the LBB reconstruction is globally bounded between
- *   the very smallest input pixel value and the very largest input
- *   pixel value. (It is not necessary to clamp results.)
- *
- * The LBB method is based on the method of Ken Brodlie, Petros
- * Mashwama and Sohail Butt for constraining Hermite interpolants
- * between globally defined planes:
- *
- *   Visualization of surface data to preserve positivity and other
- *   simple constraints. Computer & Graphics, Vol. 19, Number 4, pages
- *   585-594, 1995. DOI: 10.1016/0097-8493(95)00036-C.
- *
- * Instead of forcing the reconstructed surface to lie between two
- * GLOBALLY defined planes, LBB constrains one patch at a time to lie
- * between LOCALLY defined planes. This is accomplished by
- * constraining the derivatives (x, y and cross) at each input pixel
- * location so that if the constraint was applied everywhere the
- * surface would fit between the min and max of the values at the 9
- * closest pixel locations. Because this is done with each of the four
- * pixel locations which define the bicubic patch, this forces the
- * reconstructed surface to lie between the min and max of the values
- * at the 16 closest values pixel locations. (Each corner defines its
- * own 3x3 subgroup of the 4x4 stencil. Consequently, the surface is
- * necessarily above the minimum of the four minima, which happens to
- * be the minimum over the 4x4. Similarly with the maxima.)
- *
- * The above paragraph described the "soft" version of LBB. The
- * "sharp" version is similar.
- */
-
-static inline double
-lbbicubic( const double c00,
-           const double c10,
-           const double c01,
-           const double c11,
-           const double c00dx,
-           const double c10dx,
-           const double c01dx,
-           const double c11dx,
-           const double c00dy,
-           const double c10dy,
-           const double c01dy,
-           const double c11dy,
-           const double c00dxdy,
-           const double c10dxdy,
-           const double c01dxdy,
-           const double c11dxdy,
-           const double uno_one,
-           const double uno_two,
-           const double uno_thr,
-           const double uno_fou,
-           const double dos_one,
-           const double dos_two,
-           const double dos_thr,
-           const double dos_fou,
-           const double tre_one,
-           const double tre_two,
-           const double tre_thr,
-           const double tre_fou,
-           const double qua_one,
-           const double qua_two,
-           const double qua_thr,
-           const double qua_fou )
-{
-  /*
-   * STENCIL (FOOTPRINT) OF INPUT VALUES:
-   *
-   * The stencil of LBB is the same as for any standard Hermite
-   * bicubic (e.g., Catmull-Rom):
-   *
-   *  (ix-1,iy-1)  (ix,iy-1)    (ix+1,iy-1)  (ix+2,iy-1)
-   *  = uno_one    = uno_two    = uno_thr    = uno_fou
-   *
-   *  (ix-1,iy)    (ix,iy)      (ix+1,iy)    (ix+2,iy)
-   *  = dos_one    = dos_two    = dos_thr    = dos_fou
-   *                        X
-   *  (ix-1,iy+1)  (ix,iy+1)    (ix+1,iy+1)  (ix+2,iy+1)
-   *  = tre_one    = tre_two    = tre_thr    = tre_fou
-   *
-   *  (ix-1,iy+2)  (ix,iy+2)    (ix+1,iy+2)  (ix+2,iy+2)
-   *  = qua_one    = qua_two    = qua_thr    = qua_fou
-   *
-   * where ix is the (pseudo-)floor of the requested left-to-right
-   * location ("X"), and iy is the floor of the requested up-to-down
-   * location.
-   */
-
-#if defined (__NOHALO_CHEAP_H__)
-  /*
-   * Computation of the four min and four max over 3x3 input data
-   * sub-crosses of the 4x4 input stencil.
-   *
-   * We exploit the fact that the data comes from the (co-monotone)
-   * method Nohalo so that it is known ahead of time that
-   *
-   *  dos_thr is between dos_two and dos_fou
-   *
-   *  tre_two is between dos_two and qua_two
-   *
-   *  tre_fou is between dos_fou and qua_fou
-   *
-   *  qua_thr is between qua_two and qua_fou
-   *
-   *  tre_thr is in the convex hull of dos_two, dos_fou, qua_two and qua_fou
-   *
-   *  to minimize the number of flags and conditional moves.
-   *
-   * (The "between" are not strict: "a between b and c" means
-   *
-   * "min(b,c) <= a <= max(b,c)".)
-   *
-   * We have, however, succeeded in eliminating one flag computation
-   * (one comparison) and one use of an intermediate result. See the
-   * two commented out lines below.
-   *
-   * Overall, only 20 comparisons and 28 "? :" are needed (to compute
-   * 4 mins and 4 maxes). If you can figure how to do this more
-   * efficiently, let us know.
-   */
-  const double m1    = (uno_two <= tre_two) ? uno_two : tre_two  ;
-  const double M1    = (uno_two <= tre_two) ? tre_two : uno_two  ;
-  const double m2    = (dos_thr <= qua_thr) ? dos_thr : qua_thr  ;
-  const double M2    = (dos_thr <= qua_thr) ? qua_thr : dos_thr  ;
-  const double m3    = (dos_two <= dos_fou) ? dos_two : dos_fou  ;
-  const double M3    = (dos_two <= dos_fou) ? dos_fou : dos_two  ;
-  const double m4    = (uno_thr <= tre_thr) ? uno_thr : tre_thr  ;
-  const double M4    = (uno_thr <= tre_thr) ? tre_thr : uno_thr  ;
-  const double m5    = (dos_two <= qua_two) ? dos_two : qua_two  ;
-  const double M5    = (dos_two <= qua_two) ? qua_two : dos_two  ;
-  const double m6    = (tre_one <= tre_thr) ? tre_one : tre_thr  ;
-  const double M6    = (tre_one <= tre_thr) ? tre_thr : tre_one  ;
-  const double m7    = (dos_one <= dos_thr) ? dos_one : dos_thr  ;
-  const double M7    = (dos_one <= dos_thr) ? dos_thr : dos_one  ;
-  const double m8    = (tre_two <= tre_fou) ? tre_two : tre_fou  ;
-  const double M8    = (tre_two <= tre_fou) ? tre_fou : tre_two  ;
-  const double m9    = NOHALO_MIN(            m1,       dos_two );
-  const double M9    = NOHALO_MAX(            M1,       dos_two );
-  const double m10   = NOHALO_MIN(            m2,       tre_thr );
-  const double M10   = NOHALO_MAX(            M2,       tre_thr );
-  const double min10 = NOHALO_MIN(            m3,       m4      );
-  const double max10 = NOHALO_MAX(            M3,       M4      );
-  const double min01 = NOHALO_MIN(            m5,       m6      );
-  const double max01 = NOHALO_MAX(            M5,       M6      );
-  const double min00 = NOHALO_MIN(            m9,       m7      );
-  const double max00 = NOHALO_MAX(            M9,       M7      );
-  const double min11 = NOHALO_MIN(           m10,       m8      );
-  const double max11 = NOHALO_MAX(           M10,       M8      );
-#else
-  /*
-   * Computation of the four min and four max over 3x3 input data
-   * sub-blocks of the 4x4 input stencil.
-   *
-   * Surprisingly, we have not succeeded in reducing the number of "?
-   * :" needed by using the fact that the data comes from the
-   * (co-monotone) method Nohalo so that it is known ahead of time
-   * that
-   *
-   *  dos_thr is between dos_two and dos_fou
-   *
-   *  tre_two is between dos_two and qua_two
-   *
-   *  tre_fou is between dos_fou and qua_fou
-   *
-   *  qua_thr is between qua_two and qua_fou
-   *
-   *  tre_thr is in the convex hull of dos_two, dos_fou, qua_two and qua_fou
-   *
-   *  to minimize the number of flags and conditional moves.
-   *
-   * (The "between" are not strict: "a between b and c" means
-   *
-   * "min(b,c) <= a <= max(b,c)".)
-   *
-   * We have, however, succeeded in eliminating one flag computation
-   * (one comparison) and one use of an intermediate result. See the
-   * two commented out lines below.
-   *
-   * Overall, only 27 comparisons are needed (to compute 4 mins and 4
-   * maxes!). Without the simplification, 28 comparisons would be
-   * used. Either way, the number of "? :" used is 34. If you can
-   * figure how to do this more efficiently, let us know.
-   */
-  const double m1    = (dos_two <= dos_thr) ? dos_two : dos_thr  ;
-  const double M1    = (dos_two <= dos_thr) ? dos_thr : dos_two  ;
-  const double m2    = (tre_two <= tre_thr) ? tre_two : tre_thr  ;
-  const double M2    = (tre_two <= tre_thr) ? tre_thr : tre_two  ;
-  const double m4    = (qua_two <= qua_thr) ? qua_two : qua_thr  ;
-  const double M4    = (qua_two <= qua_thr) ? qua_thr : qua_two  ;
-  const double m3    = (uno_two <= uno_thr) ? uno_two : uno_thr  ;
-  const double M3    = (uno_two <= uno_thr) ? uno_thr : uno_two  ;
-  const double m5    = NOHALO_MIN(            m1,       m2      );
-  const double M5    = NOHALO_MAX(            M1,       M2      );
-  const double m6    = (dos_one <= tre_one) ? dos_one : tre_one  ;
-  const double M6    = (dos_one <= tre_one) ? tre_one : dos_one  ;
-  const double m7    = (dos_fou <= tre_fou) ? dos_fou : tre_fou  ;
-  const double M7    = (dos_fou <= tre_fou) ? tre_fou : dos_fou  ;
-  const double m13   = (dos_fou <= qua_fou) ? dos_fou : qua_fou  ;
-  const double M13   = (dos_fou <= qua_fou) ? qua_fou : dos_fou  ;
-  /*
-   * Because the data comes from Nohalo subdivision, the following two
-   * lines can be replaced by the above, simpler, two lines without
-   * changing the results.
-   *
-   * const double m13   = NOHALO_MIN(               m7,       qua_fou );
-   * const double M13   = NOHALO_MAX(               M7,       qua_fou );
-   *
-   * This also allows reodering the comparisons to put space between
-   * the computation of a result and its use.
-   */
-  const double m9    = NOHALO_MIN(            m5,       m4      );
-  const double M9    = NOHALO_MAX(            M5,       M4      );
-  const double m11   = NOHALO_MIN(            m6,       qua_one );
-  const double M11   = NOHALO_MAX(            M6,       qua_one );
-  const double m10   = NOHALO_MIN(            m6,       uno_one );
-  const double M10   = NOHALO_MAX(            M6,       uno_one );
-  const double m8    = NOHALO_MIN(            m5,       m3      );
-  const double M8    = NOHALO_MAX(            M5,       M3      );
-  const double m12   = NOHALO_MIN(            m7,       uno_fou );
-  const double M12   = NOHALO_MAX(            M7,       uno_fou );
-  const double min11 = NOHALO_MIN(            m9,       m13     );
-  const double max11 = NOHALO_MAX(            M9,       M13     );
-  const double min01 = NOHALO_MIN(            m9,       m11     );
-  const double max01 = NOHALO_MAX(            M9,       M11     );
-  const double min00 = NOHALO_MIN(            m8,       m10     );
-  const double max00 = NOHALO_MAX(            M8,       M10     );
-  const double min10 = NOHALO_MIN(            m8,       m12     );
-  const double max10 = NOHALO_MAX(            M8,       M12     );
-#endif
-
-  /*
-   * The remainder of the "per channel" computation involves the
-   * computation of:
-   *
-   * --8 conditional moves,
-   *
-   * --8 signs (in which the sign of zero is unimportant),
-   *
-   * --12 minima of two values,
-   *
-   * --8 maxima of two values,
-   *
-   * --8 absolute values,
-   *
-   * for a grand total of 29 minima, 25 maxima, 8 conditional moves, 8
-   * signs, and 8 absolute values. If everything is done with
-   * conditional moves, "only" 28+8+8+12+8+8=72 flags are involved
-   * (because initial min and max can be computed with one flag).
-   *
-   * The "per channel" part of the computation also involves 107
-   * arithmetic operations (54 *, 21 +, 42 -).
-   */
-
-  /*
-   * Distances to the local min and max:
-   */
-  const double u11 = tre_thr - min11;
-  const double v11 = max11 - tre_thr;
-  const double u01 = tre_two - min01;
-  const double v01 = max01 - tre_two;
-  const double u00 = dos_two - min00;
-  const double v00 = max00 - dos_two;
-  const double u10 = dos_thr - min10;
-  const double v10 = max10 - dos_thr;
-
-  /*
-   * Initial values of the derivatives computed with centered
-   * differences. Factors of 1/2 are left out because they are folded
-   * in later:
-   */
-  const double dble_dzdx00i = dos_thr - dos_one;
-  const double dble_dzdy11i = qua_thr - dos_thr;
-  const double dble_dzdx10i = dos_fou - dos_two;
-  const double dble_dzdy01i = qua_two - dos_two;
-  const double dble_dzdx01i = tre_thr - tre_one;
-  const double dble_dzdy10i = tre_thr - uno_thr;
-  const double dble_dzdx11i = tre_fou - tre_two;
-  const double dble_dzdy00i = tre_two - uno_two;
-
-  /*
-   * Signs of the derivatives. The upcoming clamping does not change
-   * them (except if the clamping sends a negative derivative to 0, in
-   * which case the sign does not matter anyway).
-   */
-  const double sign_dzdx00 = NOHALO_SIGN( dble_dzdx00i );
-  const double sign_dzdx10 = NOHALO_SIGN( dble_dzdx10i );
-  const double sign_dzdx01 = NOHALO_SIGN( dble_dzdx01i );
-  const double sign_dzdx11 = NOHALO_SIGN( dble_dzdx11i );
-
-  const double sign_dzdy00 = NOHALO_SIGN( dble_dzdy00i );
-  const double sign_dzdy10 = NOHALO_SIGN( dble_dzdy10i );
-  const double sign_dzdy01 = NOHALO_SIGN( dble_dzdy01i );
-  const double sign_dzdy11 = NOHALO_SIGN( dble_dzdy11i );
-
-  /*
-   * Initial values of the cross-derivatives. Factors of 1/4 are left
-   * out because folded in later:
-   */
-  const double quad_d2zdxdy00i = uno_one - uno_thr + dble_dzdx01i;
-  const double quad_d2zdxdy10i = uno_two - uno_fou + dble_dzdx11i;
-  const double quad_d2zdxdy01i = qua_thr - qua_one - dble_dzdx00i;
-  const double quad_d2zdxdy11i = qua_fou - qua_two - dble_dzdx10i;
-
-  /*
-   * Slope limiters. The key multiplier is 3 but we fold a factor of
-   * 2, hence 6:
-   */
-  const double dble_slopelimit_00 = 6.0 * NOHALO_MIN( u00, v00 );
-  const double dble_slopelimit_10 = 6.0 * NOHALO_MIN( u10, v10 );
-  const double dble_slopelimit_01 = 6.0 * NOHALO_MIN( u01, v01 );
-  const double dble_slopelimit_11 = 6.0 * NOHALO_MIN( u11, v11 );
-
-  /*
-   * Clamped first derivatives:
-   */
-  const double dble_dzdx00 =
-    ( sign_dzdx00 * dble_dzdx00i <= dble_slopelimit_00 )
-    ? dble_dzdx00i :  sign_dzdx00 * dble_slopelimit_00;
-  const double dble_dzdy00 =
-    ( sign_dzdy00 * dble_dzdy00i <= dble_slopelimit_00 )
-    ? dble_dzdy00i :  sign_dzdy00 * dble_slopelimit_00;
-  const double dble_dzdx10 =
-    ( sign_dzdx10 * dble_dzdx10i <= dble_slopelimit_10 )
-    ? dble_dzdx10i :  sign_dzdx10 * dble_slopelimit_10;
-  const double dble_dzdy10 =
-    ( sign_dzdy10 * dble_dzdy10i <= dble_slopelimit_10 )
-    ? dble_dzdy10i :  sign_dzdy10 * dble_slopelimit_10;
-  const double dble_dzdx01 =
-    ( sign_dzdx01 * dble_dzdx01i <= dble_slopelimit_01 )
-    ? dble_dzdx01i :  sign_dzdx01 * dble_slopelimit_01;
-  const double dble_dzdy01 =
-    ( sign_dzdy01 * dble_dzdy01i <= dble_slopelimit_01 )
-    ? dble_dzdy01i :  sign_dzdy01 * dble_slopelimit_01;
-  const double dble_dzdx11 =
-    ( sign_dzdx11 * dble_dzdx11i <= dble_slopelimit_11 )
-    ? dble_dzdx11i :  sign_dzdx11 * dble_slopelimit_11;
-  const double dble_dzdy11 =
-    ( sign_dzdy11 * dble_dzdy11i <= dble_slopelimit_11 )
-    ? dble_dzdy11i :  sign_dzdy11 * dble_slopelimit_11;
-
-  /*
-   * Sums and differences of first derivatives:
-   */
-  const double twelve_sum00 = 6.0 * ( dble_dzdx00 + dble_dzdy00 );
-  const double twelve_dif00 = 6.0 * ( dble_dzdx00 - dble_dzdy00 );
-  const double twelve_sum10 = 6.0 * ( dble_dzdx10 + dble_dzdy10 );
-  const double twelve_dif10 = 6.0 * ( dble_dzdx10 - dble_dzdy10 );
-  const double twelve_sum01 = 6.0 * ( dble_dzdx01 + dble_dzdy01 );
-  const double twelve_dif01 = 6.0 * ( dble_dzdx01 - dble_dzdy01 );
-  const double twelve_sum11 = 6.0 * ( dble_dzdx11 + dble_dzdy11 );
-  const double twelve_dif11 = 6.0 * ( dble_dzdx11 - dble_dzdy11 );
-
-  /*
-   * Absolute values of the sums:
-   */
-  const double twelve_abs_sum00 = NOHALO_ABS( twelve_sum00 );
-  const double twelve_abs_sum10 = NOHALO_ABS( twelve_sum10 );
-  const double twelve_abs_sum01 = NOHALO_ABS( twelve_sum01 );
-  const double twelve_abs_sum11 = NOHALO_ABS( twelve_sum11 );
-
-  /*
-   * Scaled distances to the min:
-   */
-  const double u00_times_36 = 36.0 * u00;
-  const double u10_times_36 = 36.0 * u10;
-  const double u01_times_36 = 36.0 * u01;
-  const double u11_times_36 = 36.0 * u11;
-
-  /*
-   * First cross-derivative limiter:
-   */
-  const double first_limit00 = twelve_abs_sum00 - u00_times_36;
-  const double first_limit10 = twelve_abs_sum10 - u10_times_36;
-  const double first_limit01 = twelve_abs_sum01 - u01_times_36;
-  const double first_limit11 = twelve_abs_sum11 - u11_times_36;
-
-  const double quad_d2zdxdy00ii = NOHALO_MAX( quad_d2zdxdy00i, first_limit00 );
-  const double quad_d2zdxdy10ii = NOHALO_MAX( quad_d2zdxdy10i, first_limit10 );
-  const double quad_d2zdxdy01ii = NOHALO_MAX( quad_d2zdxdy01i, first_limit01 );
-  const double quad_d2zdxdy11ii = NOHALO_MAX( quad_d2zdxdy11i, first_limit11 );
-
-  /*
-   * Scaled distances to the max:
-   */
-  const double v00_times_36 = 36.0 * v00;
-  const double v10_times_36 = 36.0 * v10;
-  const double v01_times_36 = 36.0 * v01;
-  const double v11_times_36 = 36.0 * v11;
-
-  /*
-   * Second cross-derivative limiter:
-   */
-  const double second_limit00 = v00_times_36 - twelve_abs_sum00;
-  const double second_limit10 = v10_times_36 - twelve_abs_sum10;
-  const double second_limit01 = v01_times_36 - twelve_abs_sum01;
-  const double second_limit11 = v11_times_36 - twelve_abs_sum11;
-
-  const double quad_d2zdxdy00iii =
-    NOHALO_MIN( quad_d2zdxdy00ii, second_limit00 );
-  const double quad_d2zdxdy10iii =
-    NOHALO_MIN( quad_d2zdxdy10ii, second_limit10 );
-  const double quad_d2zdxdy01iii =
-    NOHALO_MIN( quad_d2zdxdy01ii, second_limit01 );
-  const double quad_d2zdxdy11iii =
-    NOHALO_MIN( quad_d2zdxdy11ii, second_limit11 );
-
-  /*
-   * Absolute values of the differences:
-   */
-  const double twelve_abs_dif00 = NOHALO_ABS( twelve_dif00 );
-  const double twelve_abs_dif10 = NOHALO_ABS( twelve_dif10 );
-  const double twelve_abs_dif01 = NOHALO_ABS( twelve_dif01 );
-  const double twelve_abs_dif11 = NOHALO_ABS( twelve_dif11 );
-
-  /*
-   * Third cross-derivative limiter:
-   */
-  const double third_limit00 = twelve_abs_dif00 - v00_times_36;
-  const double third_limit10 = twelve_abs_dif10 - v10_times_36;
-  const double third_limit01 = twelve_abs_dif01 - v01_times_36;
-  const double third_limit11 = twelve_abs_dif11 - v11_times_36;
-
-  const double quad_d2zdxdy00iiii =
-    NOHALO_MAX( quad_d2zdxdy00iii, third_limit00);
-  const double quad_d2zdxdy10iiii =
-    NOHALO_MAX( quad_d2zdxdy10iii, third_limit10);
-  const double quad_d2zdxdy01iiii =
-    NOHALO_MAX( quad_d2zdxdy01iii, third_limit01);
-  const double quad_d2zdxdy11iiii =
-    NOHALO_MAX( quad_d2zdxdy11iii, third_limit11);
-
-  /*
-   * Fourth cross-derivative limiter:
-   */
-  const double fourth_limit00 = u00_times_36 - twelve_abs_dif00;
-  const double fourth_limit10 = u10_times_36 - twelve_abs_dif10;
-  const double fourth_limit01 = u01_times_36 - twelve_abs_dif01;
-  const double fourth_limit11 = u11_times_36 - twelve_abs_dif11;
-
-  const double quad_d2zdxdy00 = NOHALO_MIN( quad_d2zdxdy00iiii, fourth_limit00);
-  const double quad_d2zdxdy10 = NOHALO_MIN( quad_d2zdxdy10iiii, fourth_limit10);
-  const double quad_d2zdxdy01 = NOHALO_MIN( quad_d2zdxdy01iiii, fourth_limit01);
-  const double quad_d2zdxdy11 = NOHALO_MIN( quad_d2zdxdy11iiii, fourth_limit11);
-
-  /*
-   * Part of the result which does not need derivatives:
-   */
-  const double newval1 = c00 * dos_two
-                         +
-                         c10 * dos_thr
-                         +
-                         c01 * tre_two
-                         +
-                         c11 * tre_thr;
-
-  /*
-   * Twice the part of the result which only needs first derivatives.
-   */
-  const double newval2 = c00dx * dble_dzdx00
-                         +
-                         c10dx * dble_dzdx10
-                         +
-                         c01dx * dble_dzdx01
-                         +
-                         c11dx * dble_dzdx11
-                         +
-                         c00dy * dble_dzdy00
-                         +
-                         c10dy * dble_dzdy10
-                         +
-                         c01dy * dble_dzdy01
-                         +
-                         c11dy * dble_dzdy11;
-
-  /*
-   * Four times the part of the result which only uses cross
-   * derivatives:
-   */
-  const double newval3 = c00dxdy * quad_d2zdxdy00
-                         +
-                         c10dxdy * quad_d2zdxdy10
-                         +
-                         c01dxdy * quad_d2zdxdy01
-                         +
-                         c11dxdy * quad_d2zdxdy11;
-
-  const double newval = newval1 + .5 * newval2 + .25 * newval3;
-
-  return newval;
-}
-
-/*
- * Call Nohalo+LBB with a careful type conversion as a parameter.
- *
- * It would be nice to do this with templates somehow---for one thing
- * this would allow code comments!---but we can't figure a clean way
- * to do it.
- */
-#define NOHALO_CONVERSION( conversion )               \
-  template <typename T> static void inline            \
-  nohalo_ ## conversion(       void*  restrict pout,  \
-                         const void*  restrict pin,   \
-                         const int             bands, \
-                         const int             lskip, \
-                         const double          x_0,   \
-                         const double          y_0 )  \
-  { \
-    T* restrict out = (T *) pout; \
-    \
-    const T* restrict in = (T *) pin; \
-    \
-    \
-    const int sign_of_x_0 = 2 * ( x_0 >= 0. ) - 1; \
-    const int sign_of_y_0 = 2 * ( y_0 >= 0. ) - 1; \
-    \
-    \
-    const int shift_forw_1_pix = sign_of_x_0 * bands; \
-    const int shift_forw_1_row = sign_of_y_0 * lskip; \
-    \
-    const int shift_back_1_pix = -shift_forw_1_pix; \
-    const int shift_back_1_row = -shift_forw_1_row; \
-    \
-    const int shift_back_2_pix = 2 * shift_back_1_pix; \
-    const int shift_back_2_row = 2 * shift_back_1_row; \
-    const int shift_forw_2_pix = 2 * shift_forw_1_pix; \
-    const int shift_forw_2_row = 2 * shift_forw_1_row; \
-    \
-    \
-    const int uno_two_shift = shift_back_1_pix + shift_back_2_row; \
-    const int uno_thr_shift =                    shift_back_2_row; \
-    const int uno_fou_shift = shift_forw_1_pix + shift_back_2_row; \
-    \
-    const int dos_one_shift = shift_back_2_pix + shift_back_1_row; \
-    const int dos_two_shift = shift_back_1_pix + shift_back_1_row; \
-    const int dos_thr_shift =                    shift_back_1_row; \
-    const int dos_fou_shift = shift_forw_1_pix + shift_back_1_row; \
-    const int dos_fiv_shift = shift_forw_2_pix + shift_back_1_row; \
-    \
-    const int tre_one_shift = shift_back_2_pix; \
-    const int tre_two_shift = shift_back_1_pix; \
-    const int tre_thr_shift = 0;                \
-    const int tre_fou_shift = shift_forw_1_pix; \
-    const int tre_fiv_shift = shift_forw_2_pix; \
-    \
-    const int qua_one_shift = shift_back_2_pix + shift_forw_1_row; \
-    const int qua_two_shift = shift_back_1_pix + shift_forw_1_row; \
-    const int qua_thr_shift =                    shift_forw_1_row; \
-    const int qua_fou_shift = shift_forw_1_pix + shift_forw_1_row; \
-    const int qua_fiv_shift = shift_forw_2_pix + shift_forw_1_row; \
-    \
-    const int cin_two_shift = shift_back_1_pix + shift_forw_2_row; \
-    const int cin_thr_shift =                    shift_forw_2_row; \
-    const int cin_fou_shift = shift_forw_1_pix + shift_forw_2_row; \
-    \
-    \
-    const double xp1over2   = ( 2 * sign_of_x_0 ) * x_0; \
-    const double xm1over2   = xp1over2 - 1.0; \
-    const double onepx      = 0.5 + xp1over2; \
-    const double onemx      = 1.5 - xp1over2; \
-    const double xp1over2sq = xp1over2 * xp1over2; \
-    \
-    const double yp1over2   = ( 2 * sign_of_y_0 ) * y_0; \
-    const double ym1over2   = yp1over2 - 1.0; \
-    const double onepy      = 0.5 + yp1over2; \
-    const double onemy      = 1.5 - yp1over2; \
-    const double yp1over2sq = yp1over2 * yp1over2; \
-    \
-    const double xm1over2sq = xm1over2 * xm1over2; \
-    const double ym1over2sq = ym1over2 * ym1over2; \
-    \
-    const double twice1px = onepx + onepx; \
-    const double twice1py = onepy + onepy; \
-    const double twice1mx = onemx + onemx; \
-    const double twice1my = onemy + onemy; \
-    \
-    const double xm1over2sq_times_ym1over2sq = xm1over2sq * ym1over2sq; \
-    const double xp1over2sq_times_ym1over2sq = xp1over2sq * ym1over2sq; \
-    const double xp1over2sq_times_yp1over2sq = xp1over2sq * yp1over2sq; \
-    const double xm1over2sq_times_yp1over2sq = xm1over2sq * yp1over2sq; \
-    \
-    const double four_times_1px_times_1py = twice1px * twice1py; \
-    const double four_times_1mx_times_1py = twice1mx * twice1py; \
-    const double twice_xp1over2_times_1py = xp1over2 * twice1py; \
-    const double twice_xm1over2_times_1py = xm1over2 * twice1py; \
-    \
-    const double twice_xm1over2_times_1my = xm1over2 * twice1my; \
-    const double twice_xp1over2_times_1my = xp1over2 * twice1my; \
-    const double four_times_1mx_times_1my = twice1mx * twice1my; \
-    const double four_times_1px_times_1my = twice1px * twice1my; \
-    \
-    const double twice_1px_times_ym1over2 = twice1px * ym1over2; \
-    const double twice_1mx_times_ym1over2 = twice1mx * ym1over2; \
-    const double xp1over2_times_ym1over2  = xp1over2 * ym1over2; \
-    const double xm1over2_times_ym1over2  = xm1over2 * ym1over2; \
-    \
-    const double xm1over2_times_yp1over2  = xm1over2 * yp1over2; \
-    const double xp1over2_times_yp1over2  = xp1over2 * yp1over2; \
-    const double twice_1mx_times_yp1over2 = twice1mx * yp1over2; \
-    const double twice_1px_times_yp1over2 = twice1px * yp1over2; \
-    \
-    \
-    const double c00 = \
-      four_times_1px_times_1py * xm1over2sq_times_ym1over2sq; \
-    const double c00dx = \
-      twice_xp1over2_times_1py * xm1over2sq_times_ym1over2sq; \
-    const double c00dy = \
-      twice_1px_times_yp1over2 * xm1over2sq_times_ym1over2sq; \
-    const double c00dxdy = \
-       xp1over2_times_yp1over2 * xm1over2sq_times_ym1over2sq; \
-    \
-    const double c10 = \
-      four_times_1mx_times_1py * xp1over2sq_times_ym1over2sq; \
-    const double c10dx = \
-      twice_xm1over2_times_1py * xp1over2sq_times_ym1over2sq; \
-    const double c10dy = \
-      twice_1mx_times_yp1over2 * xp1over2sq_times_ym1over2sq; \
-    const double c10dxdy = \
-       xm1over2_times_yp1over2 * xp1over2sq_times_ym1over2sq; \
-    \
-    const double c01 = \
-      four_times_1px_times_1my * xm1over2sq_times_yp1over2sq; \
-    const double c01dx = \
-      twice_xp1over2_times_1my * xm1over2sq_times_yp1over2sq; \
-    const double c01dy = \
-      twice_1px_times_ym1over2 * xm1over2sq_times_yp1over2sq; \
-    const double c01dxdy = \
-       xp1over2_times_ym1over2 * xm1over2sq_times_yp1over2sq; \
-    \
-    const double c11 = \
-      four_times_1mx_times_1my * xp1over2sq_times_yp1over2sq; \
-    const double c11dx = \
-      twice_xm1over2_times_1my * xp1over2sq_times_yp1over2sq; \
-    const double c11dy = \
-      twice_1mx_times_ym1over2 * xp1over2sq_times_yp1over2sq; \
-    const double c11dxdy = \
-       xm1over2_times_ym1over2 * xp1over2sq_times_yp1over2sq; \
-    \
-    \
-    int band = bands; \
-    \
-    \
-    do \
-      { \
-        double uno_one, uno_two, uno_thr, uno_fou;  \
-        double dos_one, dos_two, dos_thr, dos_fou;  \
-        double tre_one, tre_two, tre_thr, tre_fou;  \
-        double qua_one, qua_two, qua_thr, qua_fou;  \
-        \
-        nohalo_subdivision( in[ uno_two_shift ], \
-                            in[ uno_thr_shift ], \
-                            in[ uno_fou_shift ], \
-                            in[ dos_one_shift ], \
-                            in[ dos_two_shift ], \
-                            in[ dos_thr_shift ], \
-                            in[ dos_fou_shift ], \
-                            in[ dos_fiv_shift ], \
-                            in[ tre_one_shift ], \
-                            in[ tre_two_shift ], \
-                            in[ tre_thr_shift ], \
-                            in[ tre_fou_shift ], \
-                            in[ tre_fiv_shift ], \
-                            in[ qua_one_shift ], \
-                            in[ qua_two_shift ], \
-                            in[ qua_thr_shift ], \
-                            in[ qua_fou_shift ], \
-                            in[ qua_fiv_shift ], \
-                            in[ cin_two_shift ], \
-                            in[ cin_thr_shift ], \
-                            in[ cin_fou_shift ], \
-                            &uno_one,            \
-                            &uno_two,            \
-                            &uno_thr,            \
-                            &uno_fou,            \
-                            &dos_one,            \
-                            &dos_two,            \
-                            &dos_thr,            \
-                            &dos_fou,            \
-                            &tre_one,            \
-                            &tre_two,            \
-                            &tre_thr,            \
-                            &tre_fou,            \
-                            &qua_one,            \
-                            &qua_two,            \
-                            &qua_thr,            \
-                            &qua_fou );          \
-        \
-        const double double_result =        \
-          lbbicubic( c00,                   \
-                     c10,                   \
-                     c01,                   \
-                     c11,                   \
-                     c00dx,                 \
-                     c10dx,                 \
-                     c01dx,                 \
-                     c11dx,                 \
-                     c00dy,                 \
-                     c10dy,                 \
-                     c01dy,                 \
-                     c11dy,                 \
-                     c00dxdy,               \
-                     c10dxdy,               \
-                     c01dxdy,               \
-                     c11dxdy,               \
-                     uno_one,               \
-                     uno_two,               \
-                     uno_thr,               \
-                     uno_fou,               \
-                     dos_one,               \
-                     dos_two,               \
-                     dos_thr,               \
-                     dos_fou,               \
-                     tre_one,               \
-                     tre_two,               \
-                     tre_thr,               \
-                     tre_fou,               \
-                     qua_one,               \
-                     qua_two,               \
-                     qua_thr,               \
-                     qua_fou );             \
-        \
-        {                                                         \
-          const T result = to_ ## conversion<T>( double_result ); \
-          in++;                                                   \
-          *out++ = result;                                        \
-        }                                                         \
-        \
-      } while (--band); \
-  }
-
-
-NOHALO_CONVERSION( fptypes )
-NOHALO_CONVERSION( withsign )
-NOHALO_CONVERSION( nosign )
-
-
-#define CALL( T, conversion )             \
-  nohalo_ ## conversion<T>( out,          \
-                            p,            \
-                            bands,        \
-                            lskip,        \
-                            relative_x,   \
-                            relative_y );
-
-
-/*
- * We need C linkage:
- */
-extern "C" {
-G_DEFINE_TYPE( VipsInterpolateNohalo, vips_interpolate_nohalo,
-	VIPS_TYPE_INTERPOLATE );
-}
-
-
-static void
-vips_interpolate_nohalo_interpolate( VipsInterpolate* restrict interpolate,
-                                     void*            restrict out,
-                                     VipsRegion*      restrict in,
-                                     double                    absolute_x,
-                                     double                    absolute_y )
-{
-  /* absolute_x and absolute_y are always >= 2.0 (see double-check assert
-   * below), so we don't need floor(). 
-   *
-   * It's 2 not 0 since we ask for a window_offset of 2 at the bottom.
-   */
-  const int ix = (int) (absolute_x + 0.5);
-  const int iy = (int) (absolute_y + 0.5);
-
-  /*
-   * Move the pointer to (the first band of) the top/left pixel of the
-   * 2x2 group of pixel centers which contains the sampling location
-   * in its convex hull:
-   */
-  const VipsPel* restrict p = VIPS_REGION_ADDR( in, ix, iy );
-
-  const double relative_x = absolute_x - ix;
-  const double relative_y = absolute_y - iy;
-
-  /*
-   * VIPS versions of Nicolas's pixel addressing values.
-   */
-  const int lskip = VIPS_REGION_LSKIP( in ) / 
-	  VIPS_IMAGE_SIZEOF_ELEMENT( in->im );
-
-  /*
-   * Double the bands for complex images to account for the real and
-   * imaginary parts being computed independently:
-   */
-  const int actual_bands = in->im->Bands;
-  const int bands =
-    vips_bandfmt_iscomplex( in->im->BandFmt ) ? 2 * actual_bands : actual_bands;
-
-  /* Confirm that absolute_x and absolute_y are >= 2, see above. 
-   */
-  g_assert( absolute_x >= 2.0 );
-  g_assert( absolute_y >= 2.0 );
-
-  switch( in->im->BandFmt ) {
-  case VIPS_FORMAT_UCHAR:
-    CALL( unsigned char, nosign );
-    break;
-
-  case VIPS_FORMAT_CHAR:
-    CALL( signed char, withsign );
-    break;
-
-  case VIPS_FORMAT_USHORT:
-    CALL( unsigned short, nosign );
-    break;
-
-  case VIPS_FORMAT_SHORT:
-    CALL( signed short, withsign );
-    break;
-
-  case VIPS_FORMAT_UINT:
-    CALL( unsigned int, nosign );
-    break;
-
-  case VIPS_FORMAT_INT:
-    CALL( signed int, withsign );
-    break;
-
-  /*
-   * Complex images are handled by doubling of bands.
-   */
-  case VIPS_FORMAT_FLOAT:
-  case VIPS_FORMAT_COMPLEX:
-    CALL( float, fptypes );
-    break;
-
-  case VIPS_FORMAT_DOUBLE:
-  case VIPS_FORMAT_DPCOMPLEX:
-    CALL( double, fptypes );
-    break;
-
-  default:
-    g_assert( 0 );
-    break;
-  }
-}
-
-static void
-vips_interpolate_nohalo_class_init( VipsInterpolateNohaloClass *klass )
-{
-  VipsObjectClass *object_class = VIPS_OBJECT_CLASS( klass );
-  VipsInterpolateClass *interpolate_class = VIPS_INTERPOLATE_CLASS( klass );
-
-  object_class->nickname    = "nohalo";
-  object_class->description =
-    _( "Edge sharpening resampler with halo reduction" );
-
-  interpolate_class->interpolate   = vips_interpolate_nohalo_interpolate;
-  interpolate_class->window_size   = 5;
-  interpolate_class->window_offset = 2;
-}
-
-static void
-vips_interpolate_nohalo_init( VipsInterpolateNohalo *nohalo )
-{
-}
diff -u --recursive --new-file vips-7.38.5-vanilla/libvips/resample/vsqbs.cpp vips-7.38.5/libvips/resample/vsqbs.cpp
--- vips-7.38.5-vanilla/libvips/resample/vsqbs.cpp	2014-07-17 23:48:36.232794473 -0400
+++ vips-7.38.5/libvips/resample/vsqbs.cpp	1969-12-31 19:00:00.000000000 -0500
@@ -1,409 +0,0 @@
-/* vertex-split subdivision followed by quadratic b-spline smoothing
- *
- * C. Racette 23-28/05/2010 based on code by N. Robidoux and J. Cupitt
- *
- * N. Robidoux 29-30/05/2010
- */
-
-/*
-
-    This file is part of VIPS.
-
-    VIPS is free software; you can redistribute it and/or modify it
-    under the terms of the GNU Lesser General Public License as
-    published by the Free Software Foundation; either version 2 of the
-    License, or (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301 USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-/*
- * 2010 (c) Chantal Racette, Nicolas Robidoux, John Cupitt.
- *
- * Nicolas Robidoux thanks Adam Turcotte, Geert Jordaens, Ralf Meyer,
- * Øyvind Kolås, Minglun Gong and Eric Daoust for useful comments and
- * code.
- *
- * Chantal Racette's image resampling research and programming funded
- * in part by a NSERC Discovery Grant awarded to Julien Dompierre
- * (20-61098).
- */
-
-/*
- * Vertex-Split Quadratic B-Splines (VSQBS) is a brand new method
- * which consists of vertex-split subdivision, a subdivision method
- * with the (as yet unknown?) property that data which is (locally)
- * constant on diagonals is subdivided into data which is (locally)
- * constant on diagonals, followed by quadratic B-Spline smoothing.
- * Because both methods are linear, their combination can be
- * implemented as if there is no subdivision.
- *
- * At high enlargement ratios, VSQBS is very effective at "masking"
- * that the original has pixels uniformly distributed on a grid. In
- * particular, VSQBS produces resamples with only very mild
- * staircasing. Like cubic B-Spline smoothing, however, VSQBS is not
- * an interpolatory method. For example, using VSQBS to perform the
- * identity geometric transformation (enlargement by a scaling factor
- * equal to 1) on an image does not return the original: VSQBS
- * effectively smooths out the image with the convolution mask
- *
- *     1/8
- * 1/8 1/2 1/8
- *     1/8
- *
- * which is a fairly moderate blur (although the checkerboard mode is
- * in its nullspace).
- *
- * By blending VSQBS with an interpolatory method (bilinear, say) in a
- * transformation adaptive environment (current GEGL, for example), it
- * is quite easy to restore that resampling for identity geometric
- * transformation is equivalent to the identity, and rotations are not
- * affected by the above, implicit, blur. Contact N. Robidoux for
- * details.
- *
- * An article on VSQBS is forthcoming.
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <vips/vips.h>
-#include <vips/internal.h>
-
-#include "templates.h"
-
-#define VIPS_TYPE_INTERPOLATE_VSQBS \
-	(vips_interpolate_vsqbs_get_type())
-#define VIPS_INTERPOLATE_VSQBS( obj ) \
-	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
-	VIPS_TYPE_INTERPOLATE_VSQBS, VipsInterpolateVsqbs ))
-#define VIPS_INTERPOLATE_VSQBS_CLASS( klass ) \
-	(G_TYPE_CHECK_CLASS_CAST( (klass), \
-	VIPS_TYPE_INTERPOLATE_VSQBS, VipsInterpolateVsqbsClass))
-#define VIPS_IS_INTERPOLATE_VSQBS( obj ) \
-	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_INTERPOLATE_VSQBS ))
-#define VIPS_IS_INTERPOLATE_VSQBS_CLASS( klass ) \
-	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_INTERPOLATE_VSQBS ))
-#define VIPS_INTERPOLATE_VSQBS_GET_CLASS( obj ) \
-	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
-	VIPS_TYPE_INTERPOLATE_VSQBS, VipsInterpolateVsqbsClass ))
-
-typedef struct _VipsInterpolateVsqbs {
-	VipsInterpolate parent_object;
-
-} VipsInterpolateVsqbs;
-
-typedef struct _VipsInterpolateVsqbsClass {
-	VipsInterpolateClass parent_class;
-
-} VipsInterpolateVsqbsClass;
-
-/*
- * THE STENCIL OF INPUT VALUES:
- *
- * Pointer arithmetic is used to implicitly reflect the input stencil
- * about dos_two---assumed closer to the sampling location than other
- * pixels (ties are OK)---in such a way that after reflection the
- * sampling point is to the bottom right of dos_two.
- *
- * The following code and picture assumes that the stencil reflexion
- * has already been performed. (X is the sampling location.)
- *
- *
- *               (ix,iy-1)    (ix+1,iy-1)
- *               = uno_two    = uno_thr
- *
- *
- *
- *  (ix-1,iy)    (ix,iy)      (ix+1,iy)
- *  = dos_one    = dos_two    = dos_thr
- *                       X
- *
- *
- *  (ix-1,iy+1)  (ix,iy+1)    (ix+1,iy+1)
- *  = tre_one    = tre_two    = tre_thr
- *
- *
- * The above input pixel values are the ones needed in order to
- * IMPLICITLY make available the following values, needed by quadratic
- * B-Splines, which is performed on (shifted) double density data:
- *
- *
- *  uno_one_1 =      uno_two_1 =      uno_thr_1 =
- *  (ix-1/4,iy-1/4)  (ix+1/4,iy-1/4)  (ix+3/4,iy-1/4)
- *
- *
- *
- *                 X            or X
- *  dos_one_1 =      dos_two_1 =      dos_thr_1 =
- *  (ix-1/4,iy+1/4)  (ix+1/4,iy+1/4)  (ix+3/4,iy+1/4)
- *              or X            or X
- *
- *
- *
- *  tre_one_1 =      tre_two_1 =      tre_thr_1 =
- *  (ix-1/4,iy+3/4)  (ix+1/4,iy+3/4)  (ix+3/4,iy+3/4)
- *
- *
- * In the coefficient computations, we fix things so that coordinates
- * are relative to dos_two_1, and so that distances are rescaled so
- * that double density pixel locations are at a distance of 1.
- */
-
-/*
- * Call vertex-split + quadratic B-splines with a careful type
- * conversion as a parameter. (It would be nice to do this with
- * templates somehow---for one thing this would allow code
- * comments---but we can't figure a clean way to do it.)
- */
-#define VSQBS_CONVERSION( conversion )               \
-  template <typename T> static void inline           \
-  vsqbs_ ## conversion(       void*    restrict pout, \
-                        const VipsPel* restrict pin,  \
-                        const int             bands, \
-                        const int             lskip, \
-                        const double          x_0,   \
-                        const double          y_0 )  \
-  { \
-    T* restrict out = (T *) pout; \
-    \
-    const T* restrict in = (T *) pin; \
-    \
-    const int sign_of_x_0 = 2 * ( x_0 >= 0. ) - 1; \
-    const int sign_of_y_0 = 2 * ( y_0 >= 0. ) - 1; \
-    \
-    const int shift_forw_1_pix = sign_of_x_0 * bands; \
-    const int shift_forw_1_row = sign_of_y_0 * lskip; \
-    \
-    const int shift_back_1_pix = -shift_forw_1_pix; \
-    const int shift_back_1_row = -shift_forw_1_row; \
-    \
-    const int uno_two_shift =                    shift_back_1_row; \
-    const int uno_thr_shift = shift_forw_1_pix + shift_back_1_row; \
-    \
-    const int dos_one_shift = shift_back_1_pix; \
-    const int dos_two_shift = 0;                \
-    const int dos_thr_shift = shift_forw_1_pix; \
-    \
-    const int tre_one_shift = shift_back_1_pix + shift_forw_1_row; \
-    const int tre_two_shift =                    shift_forw_1_row; \
-    const int tre_thr_shift = shift_forw_1_pix + shift_forw_1_row; \
-    \
-    \
-    const double twice_abs_x_0 = ( 2 * sign_of_x_0 ) * x_0; \
-    const double twice_abs_y_0 = ( 2 * sign_of_y_0 ) * y_0; \
-    const double x             = twice_abs_x_0 + -0.5;      \
-    const double y             = twice_abs_y_0 + -0.5;      \
-    const double cent          = 0.75 - x * x;              \
-    const double mid           = 0.75 - y * y;              \
-    const double left          = -0.5 * ( x + cent ) + 0.5; \
-    const double top           = -0.5 * ( y + mid  ) + 0.5; \
-    const double left_p_cent   = left + cent;               \
-    const double top_p_mid     = top  + mid;                \
-    const double cent_p_rite   = 1.0 - left;                \
-    const double mid_p_bot     = 1.0 - top;                 \
-    const double rite          = 1.0 - left_p_cent;         \
-    const double bot           = 1.0 - top_p_mid;           \
-    \
-    const double four_c_uno_two = left_p_cent * top;                    \
-    const double four_c_dos_one = left        * top_p_mid;              \
-    const double four_c_dos_two = left_p_cent + top_p_mid;              \
-    const double four_c_dos_thr = cent_p_rite * top_p_mid + rite;       \
-    const double four_c_tre_two = mid_p_bot * left_p_cent + bot;        \
-    const double four_c_tre_thr = mid_p_bot * rite + cent_p_rite * bot; \
-    const double four_c_uno_thr = top  - four_c_uno_two;                \
-    const double four_c_tre_one = left - four_c_dos_one;                \
-    \
-    \
-    int band = bands; \
-    \
-    do \
-      { \
-        const double double_result =               \
-          (                                        \
-            (                                      \
-              (                                    \
-                four_c_uno_two * in[uno_two_shift] \
-                +                                  \
-                four_c_dos_one * in[dos_one_shift] \
-              )                                    \
-              +                                    \
-              (                                    \
-                four_c_dos_two * in[dos_two_shift] \
-                +                                  \
-                four_c_dos_thr * in[dos_thr_shift] \
-              )                                    \
-            )                                      \
-            +                                      \
-            (                                      \
-              (                                    \
-                four_c_tre_two * in[tre_two_shift] \
-                +                                  \
-                four_c_tre_thr * in[tre_thr_shift] \
-              )                                    \
-              +                                    \
-              (                                    \
-                four_c_uno_thr * in[uno_thr_shift] \
-                +                                  \
-                four_c_tre_one * in[tre_one_shift] \
-              )                                    \
-            )                                      \
-          ) * 0.25;                                \
-        \
-        const T result = to_ ## conversion<T>( double_result ); \
-        in++;                                                   \
-        *out++ = result;                                        \
-        \
-      } while (--band); \
-  }
-
-
-VSQBS_CONVERSION( fptypes )
-VSQBS_CONVERSION( withsign )
-VSQBS_CONVERSION( nosign )
-
-
-#define CALL( T, conversion )               \
-  vsqbs_ ## conversion<T>( out,             \
-                              p,            \
-                              bands,        \
-                              lskip,        \
-                              relative_x,   \
-                              relative_y );
-
-
-/*
- * We need C linkage:
- */
-extern "C" {
-  G_DEFINE_TYPE( VipsInterpolateVsqbs, vips_interpolate_vsqbs,
-                 VIPS_TYPE_INTERPOLATE );
-}
-
-
-static void
-vips_interpolate_vsqbs_interpolate( VipsInterpolate* restrict interpolate,
-                                    void*            restrict out,
-                                    REGION*          restrict in,
-                                    double                    absolute_x,
-                                    double                    absolute_y )
-{
-  /* absolute_x and absolute_y are always >= 1.0 (see double-check assert
-   * below), so we don't need floor(). 
-   *
-   * It's 1 not 0 since we ask for a window_offset of 1 at the bottom.
-   */
-  const int ix = (int) (absolute_x + 0.5);
-  const int iy = (int) (absolute_y + 0.5);
-
-  /*
-   * Move the pointer to (the first band of) the top/left pixel of the
-   * 2x2 group of pixel centers which contains the sampling location
-   * in its convex hull:
-   */
-  const VipsPel* restrict p = VIPS_REGION_ADDR( in, ix, iy );
-
-  const double relative_x = absolute_x - ix;
-  const double relative_y = absolute_y - iy;
-
-  /*
-   * VIPS versions of Nicolas's pixel addressing values.
-   */
-  const int lskip = VIPS_REGION_LSKIP( in ) / 
-	  VIPS_IMAGE_SIZEOF_ELEMENT( in->im );
-
-  /*
-   * Double the bands for complex images to account for the real and
-   * imaginary parts being computed independently:
-   */
-  const int actual_bands = in->im->Bands;
-  const int bands =
-    vips_bandfmt_iscomplex( in->im->BandFmt ) ? 2 * actual_bands : actual_bands;
-
-  /* Confirm that absolute_x and absolute_y are >= 1, see above. 
-   */
-  g_assert( absolute_x >= 1.0 );
-  g_assert( absolute_y >= 1.0 );
-
-  switch( in->im->BandFmt ) {
-  case VIPS_FORMAT_UCHAR:
-    CALL( unsigned char, nosign );
-    break;
-
-  case VIPS_FORMAT_CHAR:
-    CALL( signed char, withsign );
-    break;
-
-  case VIPS_FORMAT_USHORT:
-    CALL( unsigned short, nosign );
-    break;
-
-  case VIPS_FORMAT_SHORT:
-    CALL( signed short, withsign );
-    break;
-
-  case VIPS_FORMAT_UINT:
-    CALL( unsigned int, nosign );
-    break;
-
-  case VIPS_FORMAT_INT:
-    CALL( signed int, withsign );
-    break;
-
-  /*
-   * Complex images are handled by doubling bands:
-   */
-  case VIPS_FORMAT_FLOAT:
-  case VIPS_FORMAT_COMPLEX:
-    CALL( float, fptypes );
-    break;
-
-  case VIPS_FORMAT_DOUBLE:
-  case VIPS_FORMAT_DPCOMPLEX:
-    CALL( double, fptypes );
-    break;
-
-  default:
-    g_assert( 0 );
-    break;
-  }
-}
-
-static void
-vips_interpolate_vsqbs_class_init( VipsInterpolateVsqbsClass *klass )
-{
-  VipsObjectClass           *object_class =      VIPS_OBJECT_CLASS( klass );
-  VipsInterpolateClass *interpolate_class = VIPS_INTERPOLATE_CLASS( klass );
-
-  object_class->nickname    = "vsqbs";
-  object_class->description = _( "B-Splines with antialiasing smoothing" );
-
-  interpolate_class->interpolate   = vips_interpolate_vsqbs_interpolate;
-  interpolate_class->window_size   = 3;
-  interpolate_class->window_offset = 1;
-}
-
-static void
-vips_interpolate_vsqbs_init( VipsInterpolateVsqbs *vsqbs )
-{
-}
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/Makefile.am vips-7.38.5/libvipsCC/include/Makefile.am
--- vips-7.38.5-vanilla/libvipsCC/include/Makefile.am	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/Makefile.am	1969-12-31 19:00:00.000000000 -0500
@@ -1,2 +0,0 @@
-
-SUBDIRS = vips
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/Makefile.in vips-7.38.5/libvipsCC/include/Makefile.in
--- vips-7.38.5-vanilla/libvipsCC/include/Makefile.in	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/Makefile.in	1969-12-31 19:00:00.000000000 -0500
@@ -1,719 +0,0 @@
-# Makefile.in generated by automake 1.13.3 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = libvipsCC/include
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/gtk-doc.m4 \
-	$(top_srcdir)/m4/introspection.m4 $(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-SOURCES =
-DIST_SOURCES =
-RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
-	ctags-recursive dvi-recursive html-recursive info-recursive \
-	install-data-recursive install-dvi-recursive \
-	install-exec-recursive install-html-recursive \
-	install-info-recursive install-pdf-recursive \
-	install-ps-recursive install-recursive installcheck-recursive \
-	installdirs-recursive pdf-recursive ps-recursive \
-	tags-recursive uninstall-recursive
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
-am__recursive_targets = \
-  $(RECURSIVE_TARGETS) \
-  $(RECURSIVE_CLEAN_TARGETS) \
-  $(am__extra_recursive_targets)
-AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
-	distdir
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-# Read a list of newline-separated strings from the standard input,
-# and print each of them once, without duplicates.  Input order is
-# *not* preserved.
-am__uniquify_input = $(AWK) '\
-  BEGIN { nonempty = 0; } \
-  { items[$$0] = 1; nonempty = 1; } \
-  END { if (nonempty) { for (i in items) print i; }; } \
-'
-# Make sure the list of sources is unique.  This is necessary because,
-# e.g., the same source file might be shared among _SOURCES variables
-# for different programs/libraries.
-am__define_uniq_tagged_files = \
-  list='$(am__tagged_files)'; \
-  unique=`for i in $$list; do \
-    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-  done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
-DIST_SUBDIRS = $(SUBDIRS)
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-am__relativize = \
-  dir0=`pwd`; \
-  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
-  sed_rest='s,^[^/]*/*,,'; \
-  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
-  sed_butlast='s,/*[^/]*$$,,'; \
-  while test -n "$$dir1"; do \
-    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
-    if test "$$first" != "."; then \
-      if test "$$first" = ".."; then \
-        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
-        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
-      else \
-        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
-        if test "$$first2" = "$$first"; then \
-          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
-        else \
-          dir2="../$$dir2"; \
-        fi; \
-        dir0="$$dir0"/"$$first"; \
-      fi; \
-    fi; \
-    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
-  done; \
-  reldir="$$dir2"
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AS = @AS@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFITSIO_CFLAGS = @CFITSIO_CFLAGS@
-CFITSIO_LIBS = @CFITSIO_LIBS@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DLLTOOL = @DLLTOOL@
-DLLWRAP = @DLLWRAP@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-EXIF_CFLAGS = @EXIF_CFLAGS@
-EXIF_LIBS = @EXIF_LIBS@
-FFTW_CFLAGS = @FFTW_CFLAGS@
-FFTW_LIBS = @FFTW_LIBS@
-FGREP = @FGREP@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GREP = @GREP@
-GTHREAD_CFLAGS = @GTHREAD_CFLAGS@
-GTHREAD_LIBS = @GTHREAD_LIBS@
-GTKDOC_CHECK = @GTKDOC_CHECK@
-GTKDOC_DEPS_CFLAGS = @GTKDOC_DEPS_CFLAGS@
-GTKDOC_DEPS_LIBS = @GTKDOC_DEPS_LIBS@
-GTKDOC_MKPDF = @GTKDOC_MKPDF@
-GTKDOC_REBASE = @GTKDOC_REBASE@
-HTML_DIR = @HTML_DIR@
-IMAGE_MAGICK_CFLAGS = @IMAGE_MAGICK_CFLAGS@
-IMAGE_MAGICK_LIBS = @IMAGE_MAGICK_LIBS@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTROSPECTION_CFLAGS = @INTROSPECTION_CFLAGS@
-INTROSPECTION_COMPILER = @INTROSPECTION_COMPILER@
-INTROSPECTION_GENERATE = @INTROSPECTION_GENERATE@
-INTROSPECTION_GIRDIR = @INTROSPECTION_GIRDIR@
-INTROSPECTION_LIBS = @INTROSPECTION_LIBS@
-INTROSPECTION_MAKEFILE = @INTROSPECTION_MAKEFILE@
-INTROSPECTION_SCANNER = @INTROSPECTION_SCANNER@
-INTROSPECTION_TYPELIBDIR = @INTROSPECTION_TYPELIBDIR@
-JPEG_INCLUDES = @JPEG_INCLUDES@
-JPEG_LIBS = @JPEG_LIBS@
-LCMS_CFLAGS = @LCMS_CFLAGS@
-LCMS_LIBS = @LCMS_LIBS@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBRARY_AGE = @LIBRARY_AGE@
-LIBRARY_CURRENT = @LIBRARY_CURRENT@
-LIBRARY_REVISION = @LIBRARY_REVISION@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIBWEBP_CFLAGS = @LIBWEBP_CFLAGS@
-LIBWEBP_LIBS = @LIBWEBP_LIBS@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAGICK_CFLAGS = @MAGICK_CFLAGS@
-MAGICK_LIBS = @MAGICK_LIBS@
-MAGICK_WAND_CFLAGS = @MAGICK_WAND_CFLAGS@
-MAGICK_WAND_LIBS = @MAGICK_WAND_LIBS@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MATIO_CFLAGS = @MATIO_CFLAGS@
-MATIO_LIBS = @MATIO_LIBS@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MONOTONIC_CFLAGS = @MONOTONIC_CFLAGS@
-MONOTONIC_LIBS = @MONOTONIC_LIBS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OPENEXR_CFLAGS = @OPENEXR_CFLAGS@
-OPENEXR_LIBS = @OPENEXR_LIBS@
-OPENSLIDE_CFLAGS = @OPENSLIDE_CFLAGS@
-OPENSLIDE_LIBS = @OPENSLIDE_LIBS@
-ORC_CFLAGS = @ORC_CFLAGS@
-ORC_LIBS = @ORC_LIBS@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGES_USED = @PACKAGES_USED@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PANGOFT2_CFLAGS = @PANGOFT2_CFLAGS@
-PANGOFT2_LIBS = @PANGOFT2_LIBS@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-PNG_CFLAGS = @PNG_CFLAGS@
-PNG_INCLUDES = @PNG_INCLUDES@
-PNG_LIBS = @PNG_LIBS@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-PYTHON = @PYTHON@
-PYTHON_EXEC_PREFIX = @PYTHON_EXEC_PREFIX@
-PYTHON_INCLUDES = @PYTHON_INCLUDES@
-PYTHON_PLATFORM = @PYTHON_PLATFORM@
-PYTHON_PREFIX = @PYTHON_PREFIX@
-PYTHON_VERSION = @PYTHON_VERSION@
-RANLIB = @RANLIB@
-REQUIRED_CFLAGS = @REQUIRED_CFLAGS@
-REQUIRED_LIBS = @REQUIRED_LIBS@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-THREADS_CFLAGS = @THREADS_CFLAGS@
-THREADS_LIBS = @THREADS_LIBS@
-TIFF_CFLAGS = @TIFF_CFLAGS@
-TIFF_INCLUDES = @TIFF_INCLUDES@
-TIFF_LIBS = @TIFF_LIBS@
-TYPE_INIT_CFLAGS = @TYPE_INIT_CFLAGS@
-TYPE_INIT_LIBS = @TYPE_INIT_LIBS@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-VIPS_CFLAGS = @VIPS_CFLAGS@
-VIPS_CXX_LIBS = @VIPS_CXX_LIBS@
-VIPS_EXEEXT = @VIPS_EXEEXT@
-VIPS_INCLUDES = @VIPS_INCLUDES@
-VIPS_LIBDIR = @VIPS_LIBDIR@
-VIPS_LIBS = @VIPS_LIBS@
-VIPS_MAJOR_VERSION = @VIPS_MAJOR_VERSION@
-VIPS_MICRO_VERSION = @VIPS_MICRO_VERSION@
-VIPS_MINOR_VERSION = @VIPS_MINOR_VERSION@
-VIPS_VERSION = @VIPS_VERSION@
-VIPS_VERSION_STRING = @VIPS_VERSION_STRING@
-XGETTEXT = @XGETTEXT@
-XMKMF = @XMKMF@
-X_CFLAGS = @X_CFLAGS@
-X_EXTRA_LIBS = @X_EXTRA_LIBS@
-X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
-ZIP_INCLUDES = @ZIP_INCLUDES@
-ZIP_LIBS = @ZIP_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-pkgpyexecdir = @pkgpyexecdir@
-pkgpythondir = @pkgpythondir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-pyexecdir = @pyexecdir@
-pythondir = @pythondir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-vips_introspection_sources = @vips_introspection_sources@
-SUBDIRS = vips
-all: all-recursive
-
-.SUFFIXES:
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign libvipsCC/include/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign libvipsCC/include/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-# This directory's subdirectories are mostly independent; you can cd
-# into them and run 'make' without going through this Makefile.
-# To change the values of 'make' variables: instead of editing Makefiles,
-# (1) if the variable is set in 'config.status', edit 'config.status'
-#     (which will cause the Makefiles to be regenerated when you run 'make');
-# (2) otherwise, pass the desired values on the 'make' command line.
-$(am__recursive_targets):
-	@fail=; \
-	if $(am__make_keepgoing); then \
-	  failcom='fail=yes'; \
-	else \
-	  failcom='exit 1'; \
-	fi; \
-	dot_seen=no; \
-	target=`echo $@ | sed s/-recursive//`; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	for subdir in $$list; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    dot_seen=yes; \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done; \
-	if test "$$dot_seen" = "no"; then \
-	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
-	fi; test -z "$$fail"
-
-ID: $(am__tagged_files)
-	$(am__define_uniq_tagged_files); mkid -fID $$unique
-tags: tags-recursive
-TAGS: tags
-
-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	set x; \
-	here=`pwd`; \
-	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
-	  include_option=--etags-include; \
-	  empty_fix=.; \
-	else \
-	  include_option=--include; \
-	  empty_fix=; \
-	fi; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
-	    test ! -f $$subdir/TAGS || \
-	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
-	  fi; \
-	done; \
-	$(am__define_uniq_tagged_files); \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: ctags-recursive
-
-CTAGS: ctags
-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	$(am__define_uniq_tagged_files); \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-cscopelist: cscopelist-recursive
-
-cscopelist-am: $(am__tagged_files)
-	list='$(am__tagged_files)'; \
-	case "$(srcdir)" in \
-	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
-	  *) sdir=$(subdir)/$(srcdir) ;; \
-	esac; \
-	for i in $$list; do \
-	  if test -f "$$i"; then \
-	    echo "$(subdir)/$$i"; \
-	  else \
-	    echo "$$sdir/$$i"; \
-	  fi; \
-	done >> $(top_builddir)/cscope.files
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
-	    $(am__make_dryrun) \
-	      || test -d "$(distdir)/$$subdir" \
-	      || $(MKDIR_P) "$(distdir)/$$subdir" \
-	      || exit 1; \
-	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
-	    $(am__relativize); \
-	    new_distdir=$$reldir; \
-	    dir1=$$subdir; dir2="$(top_distdir)"; \
-	    $(am__relativize); \
-	    new_top_distdir=$$reldir; \
-	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
-	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
-	    ($(am__cd) $$subdir && \
-	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir="$$new_top_distdir" \
-	        distdir="$$new_distdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
-		am__skip_mode_fix=: \
-	        distdir) \
-	      || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-recursive
-all-am: Makefile
-installdirs: installdirs-recursive
-installdirs-am:
-install: install-recursive
-install-exec: install-exec-recursive
-install-data: install-data-recursive
-uninstall: uninstall-recursive
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-recursive
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-recursive
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-recursive
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-tags
-
-dvi: dvi-recursive
-
-dvi-am:
-
-html: html-recursive
-
-html-am:
-
-info: info-recursive
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-recursive
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-recursive
-
-install-html-am:
-
-install-info: install-info-recursive
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-recursive
-
-install-pdf-am:
-
-install-ps: install-ps-recursive
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-recursive
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-recursive
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-recursive
-
-pdf-am:
-
-ps: ps-recursive
-
-ps-am:
-
-uninstall-am:
-
-.MAKE: $(am__recursive_targets) install-am install-strip
-
-.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
-	check-am clean clean-generic clean-libtool cscopelist-am ctags \
-	ctags-am distclean distclean-generic distclean-libtool \
-	distclean-tags distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	installdirs-am maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
-	ps ps-am tags tags-am uninstall uninstall-am
-
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/vips/Makefile.am vips-7.38.5/libvipsCC/include/vips/Makefile.am
--- vips-7.38.5-vanilla/libvipsCC/include/vips/Makefile.am	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/vips/Makefile.am	1969-12-31 19:00:00.000000000 -0500
@@ -1,21 +0,0 @@
-pkginclude_HEADERS = \
-	VDisplay.h \
-	VError.h \
-	VImage.h \
-	VMask.h \
-	vipscpp.h \
-	vips \
-	vipsc++.h 
-
-# swap the 'awk' line for this:
-# awk '{if($$1!="deprecated") print $$1}'` ; \
-# to not generate the wrappers for deprecated functions
-vipsc++.h:
-	packages=`vips list packages | \
-	  awk '{print $$1}'` ; \
-	  echo > vipsc++.h ; \
-	  for name in $$packages; do \
-	    echo "// headers for package $$name" >> vipsc++.h ; \
-	    vips cpph $$name >> vipsc++.h ; \
-	    echo >> vipsc++.h ; \
-	  done 
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/vips/Makefile.in vips-7.38.5/libvipsCC/include/vips/Makefile.in
--- vips-7.38.5-vanilla/libvipsCC/include/vips/Makefile.in	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/vips/Makefile.in	1969-12-31 19:00:00.000000000 -0500
@@ -1,681 +0,0 @@
-# Makefile.in generated by automake 1.13.3 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = libvipsCC/include/vips
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(pkginclude_HEADERS)
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/gtk-doc.m4 \
-	$(top_srcdir)/m4/introspection.m4 $(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-SOURCES =
-DIST_SOURCES =
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__uninstall_files_from_dir = { \
-  test -z "$$files" \
-    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
-    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
-         $(am__cd) "$$dir" && rm -f $$files; }; \
-  }
-am__installdirs = "$(DESTDIR)$(pkgincludedir)"
-HEADERS = $(pkginclude_HEADERS)
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-# Read a list of newline-separated strings from the standard input,
-# and print each of them once, without duplicates.  Input order is
-# *not* preserved.
-am__uniquify_input = $(AWK) '\
-  BEGIN { nonempty = 0; } \
-  { items[$$0] = 1; nonempty = 1; } \
-  END { if (nonempty) { for (i in items) print i; }; } \
-'
-# Make sure the list of sources is unique.  This is necessary because,
-# e.g., the same source file might be shared among _SOURCES variables
-# for different programs/libraries.
-am__define_uniq_tagged_files = \
-  list='$(am__tagged_files)'; \
-  unique=`for i in $$list; do \
-    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-  done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AS = @AS@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFITSIO_CFLAGS = @CFITSIO_CFLAGS@
-CFITSIO_LIBS = @CFITSIO_LIBS@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DLLTOOL = @DLLTOOL@
-DLLWRAP = @DLLWRAP@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-EXIF_CFLAGS = @EXIF_CFLAGS@
-EXIF_LIBS = @EXIF_LIBS@
-FFTW_CFLAGS = @FFTW_CFLAGS@
-FFTW_LIBS = @FFTW_LIBS@
-FGREP = @FGREP@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GREP = @GREP@
-GTHREAD_CFLAGS = @GTHREAD_CFLAGS@
-GTHREAD_LIBS = @GTHREAD_LIBS@
-GTKDOC_CHECK = @GTKDOC_CHECK@
-GTKDOC_DEPS_CFLAGS = @GTKDOC_DEPS_CFLAGS@
-GTKDOC_DEPS_LIBS = @GTKDOC_DEPS_LIBS@
-GTKDOC_MKPDF = @GTKDOC_MKPDF@
-GTKDOC_REBASE = @GTKDOC_REBASE@
-HTML_DIR = @HTML_DIR@
-IMAGE_MAGICK_CFLAGS = @IMAGE_MAGICK_CFLAGS@
-IMAGE_MAGICK_LIBS = @IMAGE_MAGICK_LIBS@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTROSPECTION_CFLAGS = @INTROSPECTION_CFLAGS@
-INTROSPECTION_COMPILER = @INTROSPECTION_COMPILER@
-INTROSPECTION_GENERATE = @INTROSPECTION_GENERATE@
-INTROSPECTION_GIRDIR = @INTROSPECTION_GIRDIR@
-INTROSPECTION_LIBS = @INTROSPECTION_LIBS@
-INTROSPECTION_MAKEFILE = @INTROSPECTION_MAKEFILE@
-INTROSPECTION_SCANNER = @INTROSPECTION_SCANNER@
-INTROSPECTION_TYPELIBDIR = @INTROSPECTION_TYPELIBDIR@
-JPEG_INCLUDES = @JPEG_INCLUDES@
-JPEG_LIBS = @JPEG_LIBS@
-LCMS_CFLAGS = @LCMS_CFLAGS@
-LCMS_LIBS = @LCMS_LIBS@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBRARY_AGE = @LIBRARY_AGE@
-LIBRARY_CURRENT = @LIBRARY_CURRENT@
-LIBRARY_REVISION = @LIBRARY_REVISION@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIBWEBP_CFLAGS = @LIBWEBP_CFLAGS@
-LIBWEBP_LIBS = @LIBWEBP_LIBS@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAGICK_CFLAGS = @MAGICK_CFLAGS@
-MAGICK_LIBS = @MAGICK_LIBS@
-MAGICK_WAND_CFLAGS = @MAGICK_WAND_CFLAGS@
-MAGICK_WAND_LIBS = @MAGICK_WAND_LIBS@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MATIO_CFLAGS = @MATIO_CFLAGS@
-MATIO_LIBS = @MATIO_LIBS@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MONOTONIC_CFLAGS = @MONOTONIC_CFLAGS@
-MONOTONIC_LIBS = @MONOTONIC_LIBS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OPENEXR_CFLAGS = @OPENEXR_CFLAGS@
-OPENEXR_LIBS = @OPENEXR_LIBS@
-OPENSLIDE_CFLAGS = @OPENSLIDE_CFLAGS@
-OPENSLIDE_LIBS = @OPENSLIDE_LIBS@
-ORC_CFLAGS = @ORC_CFLAGS@
-ORC_LIBS = @ORC_LIBS@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGES_USED = @PACKAGES_USED@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PANGOFT2_CFLAGS = @PANGOFT2_CFLAGS@
-PANGOFT2_LIBS = @PANGOFT2_LIBS@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-PNG_CFLAGS = @PNG_CFLAGS@
-PNG_INCLUDES = @PNG_INCLUDES@
-PNG_LIBS = @PNG_LIBS@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-PYTHON = @PYTHON@
-PYTHON_EXEC_PREFIX = @PYTHON_EXEC_PREFIX@
-PYTHON_INCLUDES = @PYTHON_INCLUDES@
-PYTHON_PLATFORM = @PYTHON_PLATFORM@
-PYTHON_PREFIX = @PYTHON_PREFIX@
-PYTHON_VERSION = @PYTHON_VERSION@
-RANLIB = @RANLIB@
-REQUIRED_CFLAGS = @REQUIRED_CFLAGS@
-REQUIRED_LIBS = @REQUIRED_LIBS@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-THREADS_CFLAGS = @THREADS_CFLAGS@
-THREADS_LIBS = @THREADS_LIBS@
-TIFF_CFLAGS = @TIFF_CFLAGS@
-TIFF_INCLUDES = @TIFF_INCLUDES@
-TIFF_LIBS = @TIFF_LIBS@
-TYPE_INIT_CFLAGS = @TYPE_INIT_CFLAGS@
-TYPE_INIT_LIBS = @TYPE_INIT_LIBS@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-VIPS_CFLAGS = @VIPS_CFLAGS@
-VIPS_CXX_LIBS = @VIPS_CXX_LIBS@
-VIPS_EXEEXT = @VIPS_EXEEXT@
-VIPS_INCLUDES = @VIPS_INCLUDES@
-VIPS_LIBDIR = @VIPS_LIBDIR@
-VIPS_LIBS = @VIPS_LIBS@
-VIPS_MAJOR_VERSION = @VIPS_MAJOR_VERSION@
-VIPS_MICRO_VERSION = @VIPS_MICRO_VERSION@
-VIPS_MINOR_VERSION = @VIPS_MINOR_VERSION@
-VIPS_VERSION = @VIPS_VERSION@
-VIPS_VERSION_STRING = @VIPS_VERSION_STRING@
-XGETTEXT = @XGETTEXT@
-XMKMF = @XMKMF@
-X_CFLAGS = @X_CFLAGS@
-X_EXTRA_LIBS = @X_EXTRA_LIBS@
-X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
-ZIP_INCLUDES = @ZIP_INCLUDES@
-ZIP_LIBS = @ZIP_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-pkgpyexecdir = @pkgpyexecdir@
-pkgpythondir = @pkgpythondir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-pyexecdir = @pyexecdir@
-pythondir = @pythondir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-vips_introspection_sources = @vips_introspection_sources@
-pkginclude_HEADERS = \
-	VDisplay.h \
-	VError.h \
-	VImage.h \
-	VMask.h \
-	vipscpp.h \
-	vips \
-	vipsc++.h 
-
-all: all-am
-
-.SUFFIXES:
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign libvipsCC/include/vips/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign libvipsCC/include/vips/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-install-pkgincludeHEADERS: $(pkginclude_HEADERS)
-	@$(NORMAL_INSTALL)
-	@list='$(pkginclude_HEADERS)'; test -n "$(pkgincludedir)" || list=; \
-	if test -n "$$list"; then \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(pkgincludedir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(pkgincludedir)" || exit 1; \
-	fi; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  echo "$$d$$p"; \
-	done | $(am__base_list) | \
-	while read files; do \
-	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(pkgincludedir)'"; \
-	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(pkgincludedir)" || exit $$?; \
-	done
-
-uninstall-pkgincludeHEADERS:
-	@$(NORMAL_UNINSTALL)
-	@list='$(pkginclude_HEADERS)'; test -n "$(pkgincludedir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	dir='$(DESTDIR)$(pkgincludedir)'; $(am__uninstall_files_from_dir)
-
-ID: $(am__tagged_files)
-	$(am__define_uniq_tagged_files); mkid -fID $$unique
-tags: tags-am
-TAGS: tags
-
-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	set x; \
-	here=`pwd`; \
-	$(am__define_uniq_tagged_files); \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: ctags-am
-
-CTAGS: ctags
-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	$(am__define_uniq_tagged_files); \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-cscopelist: cscopelist-am
-
-cscopelist-am: $(am__tagged_files)
-	list='$(am__tagged_files)'; \
-	case "$(srcdir)" in \
-	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
-	  *) sdir=$(subdir)/$(srcdir) ;; \
-	esac; \
-	for i in $$list; do \
-	  if test -f "$$i"; then \
-	    echo "$(subdir)/$$i"; \
-	  else \
-	    echo "$$sdir/$$i"; \
-	  fi; \
-	done >> $(top_builddir)/cscope.files
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(HEADERS)
-installdirs:
-	for dir in "$(DESTDIR)$(pkgincludedir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-am
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am: install-pkgincludeHEADERS
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-pkgincludeHEADERS
-
-.MAKE: install-am install-strip
-
-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
-	clean-libtool cscopelist-am ctags ctags-am distclean \
-	distclean-generic distclean-libtool distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-pkgincludeHEADERS install-ps \
-	install-ps-am install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
-	ps ps-am tags tags-am uninstall uninstall-am \
-	uninstall-pkgincludeHEADERS
-
-
-# swap the 'awk' line for this:
-# awk '{if($$1!="deprecated") print $$1}'` ; \
-# to not generate the wrappers for deprecated functions
-vipsc++.h:
-	packages=`vips list packages | \
-	  awk '{print $$1}'` ; \
-	  echo > vipsc++.h ; \
-	  for name in $$packages; do \
-	    echo "// headers for package $$name" >> vipsc++.h ; \
-	    vips cpph $$name >> vipsc++.h ; \
-	    echo >> vipsc++.h ; \
-	  done 
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/vips/VDisplay.h vips-7.38.5/libvipsCC/include/vips/VDisplay.h
--- vips-7.38.5-vanilla/libvipsCC/include/vips/VDisplay.h	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/vips/VDisplay.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,114 +0,0 @@
-/* VIPS display class.
- *
- * Hide details of im_col_display API.
- */
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifndef IM_VDISPLAY_H
-#define IM_VDISPLAY_H
-
-/* SWIG includes this file directly rather than going through vipscpp.h ... so
- * we have to define these macros here as well.
- */
-#ifdef SWIG
-#define VIPS_NAMESPACE_START namespace vips {
-#define VIPS_NAMESPACE_END }
-#endif /*SWIG*/
-
-/* Wrap pointers to these, but we don't want to import all the old C API. Just 
- * declare them.
- */
-extern "C" {
-	struct im_col_display;
-	struct im_col_tab_disp;
-}
-
-VIPS_NAMESPACE_START
-
-// Wrapper over im_col_display with ref counting
-class VDisplay {
-	struct refblock {
-		im_col_display *disp;	// im_col_display struct
-		im_col_tab_disp *luts;	// luts built from this display
-		int priv;		// disp is ours, or system
-		int nrefs;		// Refs to us
-
-		// Invalidate lut
-		void cleanlut();
-
-		// Break attached stuff
-		void cleanref();
-
-		// Get ready to write
-		void wready() throw( VError );
-
-		// Check that luts are up-to-date
-		void cluts() throw( VError );
-
-		refblock() : disp(0), luts(0), priv(0), nrefs(1) {}
-		~refblock() { cleanref(); }
-	};
-
-	refblock *ref;
-
-public:
-	enum VDisplayType {
-		BARCO,			// Does many corrections for us
-		DUMB			// Needs many corrections
-	};
-
-	// Get named display
-	VDisplay( const char *name ) throw( VError );
-
-	// Get default display
-	VDisplay();
-
-	// Copy constructor 
-	VDisplay( const VDisplay &a ) { ref = a.ref; ref->nrefs++; }
-
-	// Assignment
-	VDisplay &operator=( const VDisplay &a );
-
-	// Destructor
-	virtual ~VDisplay();
-
-	// The matrix type we use
-	typedef float matrix[3][3];
-
-	// Extract display pointer
-	void *disp() const { return( ref->disp ); }
-
-	// Extract luts pointer, rebuilding luts if necessary
-	im_col_tab_disp *luts() const throw( VError ) 
-		{ ref->cluts(); return( ref->luts ); }
-};
-
-VIPS_NAMESPACE_END
-
-#endif /*IM_VDISPLAY_H*/
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/vips/VError.h vips-7.38.5/libvipsCC/include/vips/VError.h
--- vips-7.38.5-vanilla/libvipsCC/include/vips/VError.h	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/vips/VError.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,83 +0,0 @@
-// Header for error type
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifndef IM_VERROR_H
-#define IM_VERROR_H
-
-/* SWIG includes this file directly rather than going through vipscpp.h ... so
- * we have to define these macros here as well.
- */
-#ifdef SWIG
-#define VIPS_NAMESPACE_START namespace vips {
-#define VIPS_NAMESPACE_END }
-#endif /*SWIG*/
-
-/* Don't include these when parsing for SWIG.
- */
-#ifndef SWIG
-# include <string>
-# include <iosfwd>
-# include <exception>
-#endif /*!SWIG*/
-
-VIPS_NAMESPACE_START
-
-// Error type
-class VError : public std::exception {
-	std::string _what;
-
-public:
-	VError( std::string what ) : _what( what ) {}
-	VError() {}
-	virtual ~VError() throw() {}
-
-	// Print message and exit
-	void perror( const char * );
-	void perror();
-
-	// Append some more text to the message
-	VError &app( std::string txt );
-	VError &app( const int i );
-
-	// Extract string
-	virtual const char *what() const throw() { return _what.c_str(); }
-	void ostream_print( std::ostream & ) const;
-};
-
-inline std::ostream &operator<<( std::ostream &file, const VError &err )
-{
-	err.ostream_print( file );
-	return( file );
-}
-
-void verror( std::string str = "" ) throw( VError );
-
-VIPS_NAMESPACE_END
-
-#endif /*IM_VERROR_H*/
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/vips/VImage.h vips-7.38.5/libvipsCC/include/vips/VImage.h
--- vips-7.38.5-vanilla/libvipsCC/include/vips/VImage.h	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/vips/VImage.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,457 +0,0 @@
-// VIPS image wrapper
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifndef IM_VIMAGE_H
-#define IM_VIMAGE_H
-
-/* SWIG includes this file directly rather than going through vipscpp.h ... so
- * we have to define these macros here as well.
- */
-#ifdef SWIG
-# define VIPS_NAMESPACE_START namespace vips {
-# define VIPS_NAMESPACE_END }
-#endif /*SWIG*/
-
-/* Don't include these when parsing for SWIG.
- */
-#ifndef SWIG
-# include <list>
-# include <complex>
-# include <vector>
-#endif /*!SWIG*/
-
-/* Wrap pointers to these, but we don't want to import all the old C API. Just 
- * declare them.
- */
-extern "C" {
-	struct _VipsImage;
-
-	/* Needed by Vargv, see below.
-	 */
-	struct im__function;
-	typedef void *im__object;
-}
-
-VIPS_NAMESPACE_START
-
-/* vips_init() and vips_shutdown as namespaced C++ functions.
- */
-bool init( const char *argv0 = "nothing" );
-void shutdown( void ); 
-
-/* A VIPS callback, our name for im_callback_fn.
- */
-typedef int (*VCallback)( void *, void * );
-
-/* VIPS image class.
- *
- * Slightly tricky: we have two sorts of sharing. Several VImage can share one
- * refblock (while results are being returned from functions, for example),
- * and several other refblocks can have IMAGEs which depend upon this IMAGE
- * for their result.
- */
-class VImage {
-	/* We'd like this to be protected so that user subclasses can define
-	 * their own member wrappers. But sadly C++ doesn't work like that:
-	 * subclasses of VImage can only refer to protected members via
-	 * this->, which isn't what we need. Just make it public and hope no
-	 * one touches it.
-	 */
-public:
-/* Doesn't need to be wrapped.
- */
-#ifndef SWIG
-	// Count ref etc. in one of these. One for each open VIPS image.
-	struct refblock {
-		_VipsImage *im;			// IMAGE pointer
-		int close_on_delete;		// Set if we must im_close()
-		int nrefs;			// Number of refs to us
-		std::list<refblock*> orefs;	// Refs im makes 
-
-		// Construct/destruct
-		refblock();
-		virtual ~refblock() throw( VError );
-
-		// Add a ref - this (output image) depends upon IMAGE in
-		void addref( refblock *in ) throw( VError );
-
-		// Remove a ref
-		void removeref() throw( VError );
-
-		// Debugging
-		void debug_print();
-
-		// Linked list needs "==" -- use address equivalence
-		friend int operator==( const refblock &left, 
-			const refblock &right ) { return( &left == &right ); }
-	};
-
-	refblock *_ref;
-#endif /*!SWIG*/
-
-public:
-#ifdef DEBUG
-	/* All the refblocks in the world.
-	 */
-	static std::list<refblock*> all_refblock;
-#endif /*DEBUG*/
-
-	/* Print all refblocks ... debugging. Compile with DEBUG to enable
-	 * this.
-	 */
-	static void print_all();
-
-	/* Typedefs and enums we need.
-	 */
-
-	// Type type
-	enum TType {
-		MULTIBAND      = 0,
-		B_W            = 1,
-		LUMINACE       = 2,
-		XRAY           = 3,
-		IR             = 4,
-		YUV            = 5,
-		RED_ONLY       = 6,
-		GREEN_ONLY     = 7,
-		BLUE_ONLY      = 8,
-		POWER_SPECTRUM = 9,
-		HISTOGRAM      = 10,
-		LUT            = 11,
-		XYZ            = 12,
-		LAB            = 13,
-		CMC            = 14,
-		CMYK           = 15,
-		LABQ           = 16,
-		RGB            = 17,
-		UCS            = 18,
-		LCH            = 19,
-		LABS           = 21,
-		sRGB	       = 22,
-		YXY	       = 23,
-		FOURIER	       = 24,
-		RGB16	       = 25,
-		GREY16	       = 26
-	};
-
-	// Format type
-	enum TBandFmt {
-		FMTNOTSET      = -1,
-		FMTUCHAR       = 0,
-		FMTCHAR        = 1,
-		FMTUSHORT      = 2,
-		FMTSHORT       = 3,
-		FMTUINT        = 4,
-		FMTINT         = 5,
-		FMTFLOAT       = 6,
-		FMTCOMPLEX     = 7,
-		FMTDOUBLE      = 8,
-		FMTDPCOMPLEX   = 9
-	};
-
-	// Coding type
-	enum TCoding {
-		NOCODING              = 0,
-		COLQUANT              = 1,
-		LABPACK               = 2,
-		LABPACK_COMPRESSED    = 3,
-		RGB_COMPRESSED        = 4,
-		LUM_COMPRESSED        = 5,
-		RAD        	      = 6
-	};
-
-	// Compression type
-	enum TCompression {
-		NO_COMPRESSION        = 0,
-		TCSF_COMPRESSION      = 1,
-		JPEG_COMPRESSION      = 2
-	};
-
-	/* Start of wrappers for iofuncs.
-	 */
-
-	// Plain constructors
-	VImage( const char *name, const char *mode = "rd" ) throw( VError );
-	VImage( void *data, int width, int height, 
-		int bands, TBandFmt format ) throw( VError );
-	VImage( _VipsImage *image );
-	VImage() throw( VError );
-
-	// Convert to a disc file, eg:
-	// 	VImage fred = VImage::convert2disc( "im_jpeg2vips", 
-	// 		"file.jpg", "temp.v" );
-	// Runs im_jpeg2vips to the temp file, then opens that and returns
-	// it. Useful for opening very large files without using a lot of RAM.
-	// Now superseded by the format API, though that's not yet wrapped in
-	// C++
-	// Also replaced by the new default "rd" mode
-	static VImage convert2disc( const char* convert, 
-		const char* in, const char* disc ) throw( VError );
-
-	// Copy constructor 
-	VImage( const VImage &a );
-
-	// Assignment - delete old ref
-	VImage &operator=( const VImage &a ) throw( VError );
-
-	// Destructor
-	virtual ~VImage() throw( VError ) { _ref->removeref(); }
-
-	// Extract underlying IMAGE* pointer
-	_VipsImage *image() const { return( _ref->im ); }
-
-	// Extract underlying data pointer
-	void *data() const throw( VError );
-
-	// Write this to another VImage, to a file, or to a mem buffer
-	VImage write( VImage out ) throw( VError );
-	VImage write( const char *name ) throw( VError );
-	VImage write() throw( VError );
-
-	// Debugging ... print header fields
-	void debug_print();
-
-	// Projection functions to get header fields
-	int Xsize();
-	int Ysize();
-	int Bands();
-	TBandFmt BandFmt();
-	TCoding Coding();
-	TType Type();
-	float Xres();
-	float Yres();
-	int Length();
-	TCompression Compression();
-	short Level();
-	int Xoffset();
-	int Yoffset();
-
-	// Derived fields
-	const char *filename();
-	const char *Hist();
-
-	// metadata
-#ifndef SWIG
-	// base functionality
-	// we don't wrap GValue, so we can't wrap these for now
-	void meta_set( const char *field, GValue *value ) throw( VError );
-	void meta_get( const char *field, GValue *value_copy ) throw( VError );
-#endif /*SWIG*/
-
-	// We can wrap these, fwiw
-	gboolean meta_remove( const char *field );
-	GType meta_get_typeof( const char *field );
-
-	// convenience functions
-	int meta_get_int( const char *field ) throw( VError );
-	double meta_get_double( const char *field ) throw( VError );
-	const char *meta_get_string( const char *field ) throw( VError );
-	void *meta_get_area( const char *field ) throw( VError );
-	void *meta_get_blob( const char *field, size_t *length ) 
-		throw( VError );
-
-	void meta_set( const char *field, int value ) throw( VError );
-	void meta_set( const char *field, double value ) throw( VError );
-	void meta_set( const char *field, const char *value ) throw( VError );
-
-#ifndef SWIG
-	// we don't wrap callbacks yet, so we can't wrap these for now
-	void meta_set( const char *field, 
-		VCallback free_fn, void *value ) 
-		throw( VError );
-	void meta_set( const char *field, 
-		VCallback free_fn, void *value, size_t length ) 
-		throw( VError );
-#endif /*SWIG*/
-
-	// Set header fields
-	void initdesc( int, int, int, TBandFmt, TCoding, TType, 
-		float = 1.0, float = 1.0, int = 0, int = 0 ) throw( VError );
-
-	/* Insert automatically generated headers.
-	 */
-#include "vipsc++.h"
-
-/* No point getting SWIG to wrap these ... we do this by hand later so we can
- * handle things like "a + 12" correctly.
- */
-#ifndef SWIG
-	// And some in-line operator equivalences done by hand
-	friend VImage operator+( VImage a, VImage b ) throw( VError ) 
-		{ return( a.add( b ) ); }
-	friend VImage operator+( double a, VImage b ) throw( VError )
-		{ return( b.lin( 1.0, a ) ); }
-	friend VImage operator+( VImage a, double b ) throw( VError )
-		{ return( a.lin( 1.0, b ) ); }
-
-	friend VImage operator-( VImage a, VImage b ) throw( VError )
-		{ return( a.subtract( b ) ); }
-	friend VImage operator-( double a, VImage b ) throw( VError )
-		{ return( b.lin( -1.0, a ) ); }
-	friend VImage operator-( VImage a, double b ) throw( VError )
-		{ return( a.lin( 1.0, -b ) ); }
-
-	friend VImage operator*( VImage a, VImage b ) throw( VError )
-		{ return( a.multiply( b ) ); }
-	friend VImage operator*( double a, VImage b ) throw( VError )
-		{ return( b.lin( a, 0.0 ) ); }
-	friend VImage operator*( VImage a, double b ) throw( VError )
-		{ return( a.lin( b, 0.0 ) ); }
-
-	friend VImage operator/( VImage a, VImage b ) throw( VError )
-		{ return( a.divide( b ) ); }
-	friend VImage operator/( double a, VImage b ) throw( VError )
-		{ return( b.pow( -1.0 ).lin( a, 0.0 ) ); }
-	friend VImage operator/( VImage a, double b ) throw( VError )
-		{ return( a.lin( 1.0/b, 0.0 ) ); }
-
-	friend VImage operator%( VImage a, VImage b ) throw( VError )
-		{ return( a.remainder( b ) ); }
-	friend VImage operator%( VImage a, double b ) throw( VError )
-		{ return( a.remainder( b ) ); }
-
-	friend VImage operator<( VImage a, VImage b ) throw( VError )
-		{ return( a.less( b ) ); }
-	friend VImage operator<( double a, VImage b ) throw( VError )
-		{ return( b.more( a ) ); }
-	friend VImage operator<( VImage a, double b ) throw( VError )
-		{ return( a.less( b ) ); }
-
-	friend VImage operator<=( VImage a, VImage b ) throw( VError )
-		{ return( a.lesseq( b ) ); }
-	friend VImage operator<=( double a, VImage b ) throw( VError )
-		{ return( b.moreeq( a ) ); }
-	friend VImage operator<=( VImage a, double b ) throw( VError )
-		{ return( a.lesseq( b ) ); }
-
-	friend VImage operator>( VImage a, VImage b ) throw( VError )
-		{ return( a.more( b ) ); }
-	friend VImage operator>( double a, VImage b ) throw( VError )
-		{ return( b.less( a ) ); }
-	friend VImage operator>( VImage a, double b ) throw( VError )
-		{ return( a.more( b ) ); }
-
-	friend VImage operator>=( VImage a, VImage b ) throw( VError )
-		{ return( a.moreeq( b ) ); }
-	friend VImage operator>=( double a, VImage b ) throw( VError )
-		{ return( b.lesseq( a ) ); }
-	friend VImage operator>=( VImage a, double b ) throw( VError )
-		{ return( a.moreeq( b ) ); }
-
-	friend VImage operator==( VImage a, VImage b ) throw( VError )
-		{ return( a.equal( b ) ); }
-	friend VImage operator==( double a, VImage b ) throw( VError )
-		{ return( b.equal( a ) ); }
-	friend VImage operator==( VImage a, double b ) throw( VError )
-		{ return( a.equal( b ) ); }
-
-	friend VImage operator!=( VImage a, VImage b ) throw( VError )
-		{ return( a.notequal( b ) ); }
-	friend VImage operator!=( double a, VImage b ) throw( VError )
-		{ return( b.notequal( a ) ); }
-	friend VImage operator!=( VImage a, double b ) throw( VError )
-		{ return( a.notequal( b ) ); }
-
-	friend VImage operator&( VImage a, VImage b ) throw( VError )
-		{ return( a.andimage( b ) ); }
-	friend VImage operator&( int a, VImage b ) throw( VError )
-		{ return( b.andimage( a ) ); }
-	friend VImage operator&( VImage a, int b ) throw( VError )
-		{ return( a.andimage( b ) ); }
-
-	friend VImage operator|( VImage a, VImage b ) throw( VError )
-		{ return( a.orimage( b ) ); }
-	friend VImage operator|( int a, VImage b ) throw( VError )
-		{ return( b.orimage( a ) ); }
-	friend VImage operator|( VImage a, int b ) throw( VError )
-		{ return( a.orimage( b ) ); }
-
-	friend VImage operator^( VImage a, VImage b ) throw( VError )
-		{ return( a.eorimage( b ) ); }
-	friend VImage operator^( int a, VImage b ) throw( VError )
-		{ return( b.eorimage( a ) ); }
-	friend VImage operator^( VImage a, int b ) throw( VError )
-		{ return( a.eorimage( b ) ); }
-
-	friend VImage operator<<( VImage a, int b ) throw( VError )
-		{ return( a.shiftleft( b ) ); }
-	friend VImage operator>>( VImage a, int b ) throw( VError )
-		{ return( a.shiftright( b ) ); }
-
-	friend VImage operator-( VImage a ) throw( VError )
-		{ return( a * -1 ); }
-
-	// Type conversion: VImage to VDMask and VIMask
-	operator VDMask() throw( VError ) 
-		{ return( this->vips2mask() ); }
-	operator VIMask() throw( VError ) 
-		{ return( VIMask( VDMask( *this ) ) ); }
-#endif /*!SWIG*/
-};
-
-/* Don't include these when parsing for SWIG.
- */
-#ifndef SWIG
-
-/* Class wrapping up a vargv. Member function wrappers need this. It needs to
- * be part of the public API in case people subclass VImage and add their own
- * members.
- */
-class Vargv {
-	// Function we are args to
-	im__function *fn;
-
-	// Base of object vector
-	im__object *base;
-
-public:
-	Vargv( const char *name );
-	~Vargv();
-
-	// Reference to element of base
-	im__object &data( int i = 0 ) { return( base[i] ); };
-
-	// Invoke function
-	void call();
-};
-
-#endif /*!SWIG*/
-
-VIPS_NAMESPACE_END
-
-// Other VIPS protos we need 
-extern "C" {
-extern int im_init_world( const char *argv0 ); 
-extern void im__print_all(); 
-extern void im_col_Lab2XYZ( 
-	float, float, float,
-	float *, float *, float * );
-}
-
-#endif /*IM_VIMAGE_H*/
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/vips/vips vips-7.38.5/libvipsCC/include/vips/vips
--- vips-7.38.5-vanilla/libvipsCC/include/vips/vips	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/vips/vips	1969-12-31 19:00:00.000000000 -0500
@@ -1,110 +0,0 @@
-// Include file to get all VIPS C++ bindings
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifndef IM_VIPS
-#define IM_VIPS
-
-#include <vips/version.h>
-
-// VImage.h uses GValue for metadata
-#include <glib-object.h>
-
-// If we have already #included the C vips headers, we have to undef a load of
-// stuff to stop vips's stupid macros messing up our enums
-#ifdef IM_VIPS_H
-#ifdef IM_ENABLE_DEPRECATED
-
-#undef MULTIBAND
-#undef B_W
-#undef LUMINACE
-#undef XRAY
-#undef IR
-#undef YUV
-#undef RED_ONLY
-#undef GREEN_ONLY
-#undef BLUE_ONLY
-#undef POWER_SPECTRUM
-#undef HISTOGRAM
-
-#undef LUT
-#undef XYZ
-#undef LAB
-#undef CMC
-#undef CMYK
-#undef LABQ
-#undef RGB
-#undef UCS
-#undef LCH
-#undef LABS
-#undef sRGB
-
-#undef FMTNOTSET
-#undef FMTUCHAR
-#undef FMTCHAR
-#undef FMTUSHORT
-#undef FMTSHORT
-#undef FMTUINT
-#undef FMTINT
-#undef FMTFLOAT
-#undef FMTCOMPLEX
-#undef FMTDOUBLE
-#undef FMTDPCOMPLEX
-
-#undef NOCODING
-#undef COLQUANT
-#undef LABPACK
-#undef LABPACK_COMPRESSED
-#undef RGB_COMPRESSED
-#undef LUM_COMPRESSED
-
-#undef NO_COMPRESSION
-#undef TCSF_COMPRESSION
-#undef JPEG_COMPRESSION
-
-#endif /*IM_ENABLE_DEPRECATED*/
-#endif /*IM_VIPS_H*/
-
-#ifdef IM_RECT_H
-#ifdef IM_ENABLE_DEPRECATED
-
-#undef right
-#undef bottom
-
-#endif /*IM_ENABLE_DEPRECATED*/
-#endif /*IM_RECT_H*/
-
-#define VIPS_NAMESPACE_START namespace vips {
-#define VIPS_NAMESPACE_END }
-
-#include <vips/VError.h>
-#include <vips/VDisplay.h>
-#include <vips/VMask.h>
-#include <vips/VImage.h>
-
-#endif /*IM_VIPS*/
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/vips/vipsc++.h vips-7.38.5/libvipsCC/include/vips/vipsc++.h
--- vips-7.38.5-vanilla/libvipsCC/include/vips/vipsc++.h	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/vips/vipsc++.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,418 +0,0 @@
-
-// headers for package arithmetic
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-VImage abs() throw( VError );
-VImage acos() throw( VError );
-VImage add( VImage add_in2 ) throw( VError );
-VImage asin() throw( VError );
-VImage atan() throw( VError );
-double avg() throw( VError );
-double point( char* point_interpolate, double point_x, double point_y, int point_band ) throw( VError );
-double point_bilinear( double point_bilinear_x, double point_bilinear_y, int point_bilinear_band ) throw( VError );
-VImage bandmean() throw( VError );
-VImage ceil() throw( VError );
-VImage cos() throw( VError );
-VImage cross_phase( VImage cross_phase_in2 ) throw( VError );
-double deviate() throw( VError );
-VImage divide( VImage divide_in2 ) throw( VError );
-VImage exp10() throw( VError );
-VImage expn( double expn_x ) throw( VError );
-VImage expn( std::vector<double> expn_v ) throw( VError );
-VImage exp() throw( VError );
-VImage floor() throw( VError );
-VImage invert() throw( VError );
-VImage lin( double lin_a, double lin_b ) throw( VError );
-static VImage linreg( std::vector<VImage> linreg_ins, std::vector<double> linreg_xs ) throw( VError );
-VImage lin( std::vector<double> lin_a, std::vector<double> lin_b ) throw( VError );
-VImage log10() throw( VError );
-VImage log() throw( VError );
-double max() throw( VError );
-std::complex<double> maxpos() throw( VError );
-double maxpos_avg( double& maxpos_avg_y, double& maxpos_avg_out ) throw( VError );
-VDMask measure( int measure_x, int measure_y, int measure_w, int measure_h, int measure_h_patches, int measure_v_patches ) throw( VError );
-double min() throw( VError );
-std::complex<double> minpos() throw( VError );
-VImage multiply( VImage multiply_in2 ) throw( VError );
-VImage pow( double pow_x ) throw( VError );
-VImage pow( std::vector<double> pow_v ) throw( VError );
-VImage recomb( VDMask recomb_matrix ) throw( VError );
-VImage remainder( VImage remainder_in2 ) throw( VError );
-VImage remainder( double remainder_x ) throw( VError );
-VImage remainder( std::vector<double> remainder_x ) throw( VError );
-VImage rint() throw( VError );
-VImage sign() throw( VError );
-VImage sin() throw( VError );
-VDMask stats() throw( VError );
-VImage subtract( VImage subtract_in2 ) throw( VError );
-VImage tan() throw( VError );
-
-// headers for package cimg
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-VImage greyc( int greyc_iterations, double greyc_amplitude, double greyc_sharpness, double greyc_anisotropy, double greyc_alpha, double greyc_sigma, double greyc_dl, double greyc_da, double greyc_gauss_prec, int greyc_interpolation, int greyc_fast_approx ) throw( VError );
-VImage greyc_mask( VImage greyc_mask_mask, int greyc_mask_iterations, double greyc_mask_amplitude, double greyc_mask_sharpness, double greyc_mask_anisotropy, double greyc_mask_alpha, double greyc_mask_sigma, double greyc_mask_dl, double greyc_mask_da, double greyc_mask_gauss_prec, int greyc_mask_interpolation, int greyc_mask_fast_approx ) throw( VError );
-
-// headers for package colour
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-VImage LCh2Lab() throw( VError );
-VImage LCh2UCS() throw( VError );
-VImage Lab2LCh() throw( VError );
-VImage Lab2LabQ() throw( VError );
-VImage Lab2LabS() throw( VError );
-VImage Lab2UCS() throw( VError );
-VImage Lab2XYZ() throw( VError );
-VImage Lab2XYZ_temp( double Lab2XYZ_temp_X0, double Lab2XYZ_temp_Y0, double Lab2XYZ_temp_Z0 ) throw( VError );
-VImage Lab2disp( VDisplay Lab2disp_disp ) throw( VError );
-VImage LabQ2LabS() throw( VError );
-VImage LabQ2Lab() throw( VError );
-VImage LabQ2XYZ() throw( VError );
-VImage LabQ2disp( VDisplay LabQ2disp_disp ) throw( VError );
-VImage LabS2LabQ() throw( VError );
-VImage LabS2Lab() throw( VError );
-VImage UCS2LCh() throw( VError );
-VImage UCS2Lab() throw( VError );
-VImage UCS2XYZ() throw( VError );
-VImage XYZ2Lab() throw( VError );
-VImage XYZ2Lab_temp( double XYZ2Lab_temp_X0, double XYZ2Lab_temp_Y0, double XYZ2Lab_temp_Z0 ) throw( VError );
-VImage XYZ2UCS() throw( VError );
-VImage XYZ2Yxy() throw( VError );
-VImage XYZ2disp( VDisplay XYZ2disp_disp ) throw( VError );
-VImage XYZ2sRGB() throw( VError );
-VImage Yxy2XYZ() throw( VError );
-VImage dE00_fromLab( VImage dE00_fromLab_in2 ) throw( VError );
-VImage dECMC_fromLab( VImage dECMC_fromLab_in2 ) throw( VError );
-VImage dECMC_fromdisp( VImage dECMC_fromdisp_in2, VDisplay dECMC_fromdisp_disp ) throw( VError );
-VImage dE_fromLab( VImage dE_fromLab_in2 ) throw( VError );
-VImage dE_fromXYZ( VImage dE_fromXYZ_in2 ) throw( VError );
-VImage dE_fromdisp( VImage dE_fromdisp_in2, VDisplay dE_fromdisp_disp ) throw( VError );
-VImage disp2Lab( VDisplay disp2Lab_disp ) throw( VError );
-VImage disp2XYZ( VDisplay disp2XYZ_disp ) throw( VError );
-VImage float2rad() throw( VError );
-VImage icc_ac2rc( char* icc_ac2rc_profile ) throw( VError );
-VImage icc_export_depth( int icc_export_depth_depth, char* icc_export_depth_output_profile, int icc_export_depth_intent ) throw( VError );
-VImage icc_import( char* icc_import_input_profile, int icc_import_intent ) throw( VError );
-VImage icc_import_embedded( int icc_import_embedded_intent ) throw( VError );
-VImage icc_transform( char* icc_transform_input_profile, char* icc_transform_output_profile, int icc_transform_intent ) throw( VError );
-VImage lab_morph( VDMask lab_morph_greyscale, double lab_morph_L_offset, double lab_morph_L_scale, double lab_morph_a_scale, double lab_morph_b_scale ) throw( VError );
-VImage rad2float() throw( VError );
-VImage sRGB2XYZ() throw( VError );
-
-// headers for package conversion
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-static VImage gaussnoise( int gaussnoise_xsize, int gaussnoise_ysize, double gaussnoise_mean, double gaussnoise_sigma ) throw( VError );
-VImage bandjoin( VImage bandjoin_in2 ) throw( VError );
-static VImage black( int black_x_size, int black_y_size, int black_bands ) throw( VError );
-VImage c2amph() throw( VError );
-VImage c2imag() throw( VError );
-VImage c2real() throw( VError );
-VImage c2rect() throw( VError );
-VImage clip2fmt( int clip2fmt_ofmt ) throw( VError );
-VImage copy() throw( VError );
-VImage copy_file() throw( VError );
-VImage copy_morph( int copy_morph_Bands, int copy_morph_BandFmt, int copy_morph_Coding ) throw( VError );
-VImage copy_swap() throw( VError );
-VImage copy_set( int copy_set_Type, double copy_set_Xres, double copy_set_Yres, int copy_set_Xoffset, int copy_set_Yoffset ) throw( VError );
-VImage extract_area( int extract_area_left, int extract_area_top, int extract_area_width, int extract_area_height ) throw( VError );
-VImage extract_areabands( int extract_areabands_left, int extract_areabands_top, int extract_areabands_width, int extract_areabands_height, int extract_areabands_band, int extract_areabands_nbands ) throw( VError );
-VImage extract_band( int extract_band_band ) throw( VError );
-VImage extract_bands( int extract_bands_band, int extract_bands_nbands ) throw( VError );
-VImage extract( int extract_left, int extract_top, int extract_width, int extract_height, int extract_band ) throw( VError );
-VImage falsecolour() throw( VError );
-VImage fliphor() throw( VError );
-VImage flipver() throw( VError );
-static VImage gbandjoin( std::vector<VImage> gbandjoin_in ) throw( VError );
-VImage grid( int grid_tile_height, int grid_across, int grid_down ) throw( VError );
-VImage insert( VImage insert_sub, int insert_x, int insert_y ) throw( VError );
-VImage insert( VImage insert_sub, std::vector<int> insert_x, std::vector<int> insert_y ) throw( VError );
-VImage insert_noexpand( VImage insert_noexpand_sub, int insert_noexpand_x, int insert_noexpand_y ) throw( VError );
-VImage embed( int embed_type, int embed_x, int embed_y, int embed_width, int embed_height ) throw( VError );
-VImage lrjoin( VImage lrjoin_in2 ) throw( VError );
-VImage msb() throw( VError );
-VImage msb_band( int msb_band_band ) throw( VError );
-VImage replicate( int replicate_across, int replicate_down ) throw( VError );
-VImage ri2c( VImage ri2c_in2 ) throw( VError );
-VImage rot180() throw( VError );
-VImage rot270() throw( VError );
-VImage rot90() throw( VError );
-VImage scale() throw( VError );
-VImage scaleps() throw( VError );
-VImage subsample( int subsample_xshrink, int subsample_yshrink ) throw( VError );
-char* system( char* system_command ) throw( VError );
-VImage system_image( char* system_image_in_format, char* system_image_out_format, char* system_image_command, char*& system_image_log ) throw( VError );
-VImage tbjoin( VImage tbjoin_in2 ) throw( VError );
-static VImage text( char* text_text, char* text_font, int text_width, int text_alignment, int text_dpi ) throw( VError );
-VImage wrap( int wrap_x, int wrap_y ) throw( VError );
-VImage zoom( int zoom_xfac, int zoom_yfac ) throw( VError );
-
-// headers for package convolution
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-VImage aconvsep( VDMask aconvsep_matrix, int aconvsep_n_layers ) throw( VError );
-VImage aconv( VDMask aconv_matrix, int aconv_n_layers, int aconv_cluster ) throw( VError );
-VImage addgnoise( double addgnoise_sigma ) throw( VError );
-VImage compass( VIMask compass_matrix ) throw( VError );
-VImage contrast_surface( int contrast_surface_half_win_size, int contrast_surface_spacing ) throw( VError );
-VImage conv( VIMask conv_matrix ) throw( VError );
-VImage conv( VDMask conv_matrix ) throw( VError );
-VImage convsep( VIMask convsep_matrix ) throw( VError );
-VImage convsep( VDMask convsep_matrix ) throw( VError );
-VImage fastcor( VImage fastcor_in2 ) throw( VError );
-VImage gradcor( VImage gradcor_in2 ) throw( VError );
-VImage gradient( VIMask gradient_matrix ) throw( VError );
-VImage grad_x() throw( VError );
-VImage grad_y() throw( VError );
-VImage lindetect( VIMask lindetect_matrix ) throw( VError );
-VImage sharpen( int sharpen_mask_size, double sharpen_x1, double sharpen_y2, double sharpen_y3, double sharpen_m1, double sharpen_m2 ) throw( VError );
-VImage spcor( VImage spcor_in2 ) throw( VError );
-
-// headers for package deprecated
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-VImage argb2rgba() throw( VError );
-VImage flood_copy( int flood_copy_start_x, int flood_copy_start_y, std::vector<double> flood_copy_ink ) throw( VError );
-VImage flood_blob_copy( int flood_blob_copy_start_x, int flood_blob_copy_start_y, std::vector<double> flood_blob_copy_ink ) throw( VError );
-VImage flood_other_copy( VImage flood_other_copy_mark, int flood_other_copy_start_x, int flood_other_copy_start_y, int flood_other_copy_serial ) throw( VError );
-VImage clip() throw( VError );
-VImage c2ps() throw( VError );
-VImage resize_linear( int resize_linear_X, int resize_linear_Y ) throw( VError );
-VImage cmulnorm( VImage cmulnorm_in2 ) throw( VError );
-VImage fav4( VImage fav4_in2, VImage fav4_in3, VImage fav4_in4 ) throw( VError );
-VImage gadd( double gadd_a, double gadd_b, VImage gadd_in2, double gadd_c ) throw( VError );
-VImage icc_export( char* icc_export_output_profile, int icc_export_intent ) throw( VError );
-VImage litecor( VImage litecor_white, int litecor_clip, double litecor_factor ) throw( VError );
-VImage affine( double affine_a, double affine_b, double affine_c, double affine_d, double affine_dx, double affine_dy, int affine_x, int affine_y, int affine_w, int affine_h ) throw( VError );
-VImage clip2c() throw( VError );
-VImage clip2cm() throw( VError );
-VImage clip2d() throw( VError );
-VImage clip2dcm() throw( VError );
-VImage clip2f() throw( VError );
-VImage clip2i() throw( VError );
-VImage convsub( VIMask convsub_matrix, int convsub_xskip, int convsub_yskip ) throw( VError );
-VImage convf( VDMask convf_matrix ) throw( VError );
-VImage convsepf( VDMask convsepf_matrix ) throw( VError );
-VImage clip2s() throw( VError );
-VImage clip2ui() throw( VError );
-VImage insertplace( VImage insertplace_sub, std::vector<int> insertplace_x, std::vector<int> insertplace_y ) throw( VError );
-VImage clip2us() throw( VError );
-VImage slice( double slice_thresh1, double slice_thresh2 ) throw( VError );
-VImage segment( int& segment_segments ) throw( VError );
-void line( int line_x1, int line_y1, int line_x2, int line_y2, int line_pelval ) throw( VError );
-VImage thresh( double thresh_threshold ) throw( VError );
-VImage convf_raw( VDMask convf_raw_matrix ) throw( VError );
-VImage conv_raw( VIMask conv_raw_matrix ) throw( VError );
-VImage contrast_surface_raw( int contrast_surface_raw_half_win_size, int contrast_surface_raw_spacing ) throw( VError );
-VImage convsepf_raw( VDMask convsepf_raw_matrix ) throw( VError );
-VImage convsep_raw( VIMask convsep_raw_matrix ) throw( VError );
-VImage fastcor_raw( VImage fastcor_raw_in2 ) throw( VError );
-VImage gradcor_raw( VImage gradcor_raw_in2 ) throw( VError );
-VImage spcor_raw( VImage spcor_raw_in2 ) throw( VError );
-VImage lhisteq_raw( int lhisteq_raw_width, int lhisteq_raw_height ) throw( VError );
-VImage stdif_raw( double stdif_raw_a, double stdif_raw_m0, double stdif_raw_b, double stdif_raw_s0, int stdif_raw_xw, int stdif_raw_yw ) throw( VError );
-VImage rank_raw( int rank_raw_xsize, int rank_raw_ysize, int rank_raw_n ) throw( VError );
-VImage dilate_raw( VIMask dilate_raw_mask ) throw( VError );
-VImage erode_raw( VIMask erode_raw_mask ) throw( VError );
-VImage similarity_area( double similarity_area_a, double similarity_area_b, double similarity_area_dx, double similarity_area_dy, int similarity_area_x, int similarity_area_y, int similarity_area_w, int similarity_area_h ) throw( VError );
-VImage similarity( double similarity_a, double similarity_b, double similarity_dx, double similarity_dy ) throw( VError );
-static VImage mask2vips( VDMask mask2vips_input ) throw( VError );
-VDMask vips2mask() throw( VError );
-void insertplace( VImage insertplace_sub, int insertplace_x, int insertplace_y ) throw( VError );
-void circle( int circle_cx, int circle_cy, int circle_radius, int circle_intensity ) throw( VError );
-VImage andimage( VImage andimage_in2 ) throw( VError );
-VImage andimage( int andimage_c ) throw( VError );
-VImage andimage( std::vector<double> andimage_vec ) throw( VError );
-VImage orimage( VImage orimage_in2 ) throw( VError );
-VImage orimage( int orimage_c ) throw( VError );
-VImage orimage( std::vector<double> orimage_vec ) throw( VError );
-VImage eorimage( VImage eorimage_in2 ) throw( VError );
-VImage eorimage( int eorimage_c ) throw( VError );
-VImage eorimage( std::vector<double> eorimage_vec ) throw( VError );
-VImage shiftleft( std::vector<double> shiftleft_vec ) throw( VError );
-VImage shiftleft( int shiftleft_c ) throw( VError );
-VImage shiftright( std::vector<double> shiftright_vec ) throw( VError );
-VImage shiftright( int shiftright_c ) throw( VError );
-VImage blend( VImage blend_in1, VImage blend_in2 ) throw( VError );
-VImage equal( VImage equal_in2 ) throw( VError );
-VImage equal( std::vector<double> equal_vec ) throw( VError );
-VImage equal( double equal_c ) throw( VError );
-VImage ifthenelse( VImage ifthenelse_in1, VImage ifthenelse_in2 ) throw( VError );
-VImage less( VImage less_in2 ) throw( VError );
-VImage less( std::vector<double> less_vec ) throw( VError );
-VImage less( double less_c ) throw( VError );
-VImage lesseq( VImage lesseq_in2 ) throw( VError );
-VImage lesseq( std::vector<double> lesseq_vec ) throw( VError );
-VImage lesseq( double lesseq_c ) throw( VError );
-VImage more( VImage more_in2 ) throw( VError );
-VImage more( std::vector<double> more_vec ) throw( VError );
-VImage more( double more_c ) throw( VError );
-VImage moreeq( VImage moreeq_in2 ) throw( VError );
-VImage moreeq( std::vector<double> moreeq_vec ) throw( VError );
-VImage moreeq( double moreeq_c ) throw( VError );
-VImage notequal( VImage notequal_in2 ) throw( VError );
-VImage notequal( std::vector<double> notequal_vec ) throw( VError );
-VImage notequal( double notequal_c ) throw( VError );
-VImage quadratic( VImage quadratic_coeff ) throw( VError );
-
-// headers for package format
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-static VImage csv2vips( char* csv2vips_filename ) throw( VError );
-static VImage fits2vips( char* fits2vips_in ) throw( VError );
-static VImage jpeg2vips( char* jpeg2vips_in ) throw( VError );
-static VImage magick2vips( char* magick2vips_in ) throw( VError );
-static VImage png2vips( char* png2vips_in ) throw( VError );
-static VImage exr2vips( char* exr2vips_in ) throw( VError );
-static VImage ppm2vips( char* ppm2vips_filename ) throw( VError );
-static VImage analyze2vips( char* analyze2vips_filename ) throw( VError );
-static VImage tiff2vips( char* tiff2vips_in ) throw( VError );
-void vips2csv( char* vips2csv_filename ) throw( VError );
-void vips2dz( char* vips2dz_out ) throw( VError );
-void vips2jpeg( char* vips2jpeg_out ) throw( VError );
-void vips2mimejpeg( int vips2mimejpeg_qfac ) throw( VError );
-void vips2png( char* vips2png_out ) throw( VError );
-void vips2ppm( char* vips2ppm_filename ) throw( VError );
-void vips2tiff( char* vips2tiff_out ) throw( VError );
-
-// headers for package freq_filt
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-static VImage create_fmask( int create_fmask_width, int create_fmask_height, int create_fmask_type, double create_fmask_p1, double create_fmask_p2, double create_fmask_p3, double create_fmask_p4, double create_fmask_p5 ) throw( VError );
-VImage disp_ps() throw( VError );
-VImage flt_image_freq( int flt_image_freq_type, double flt_image_freq_p1, double flt_image_freq_p2, double flt_image_freq_p3, double flt_image_freq_p4, double flt_image_freq_p5 ) throw( VError );
-static VImage fractsurf( int fractsurf_size, double fractsurf_dimension ) throw( VError );
-VImage freqflt( VImage freqflt_mask ) throw( VError );
-VImage fwfft() throw( VError );
-VImage rotquad() throw( VError );
-VImage invfft() throw( VError );
-VImage phasecor_fft( VImage phasecor_fft_in2 ) throw( VError );
-VImage invfftr() throw( VError );
-
-// headers for package histograms_lut
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-VImage gammacorrect( double gammacorrect_exponent ) throw( VError );
-VImage heq( int heq_band_number ) throw( VError );
-VImage hist( int hist_band_number ) throw( VError );
-VImage histcum() throw( VError );
-VImage histeq() throw( VError );
-VImage hist_indexed( VImage hist_indexed_value ) throw( VError );
-VImage histgr( int histgr_band_number ) throw( VError );
-VImage histnD( int histnD_bins ) throw( VError );
-VImage histnorm() throw( VError );
-VImage histplot() throw( VError );
-VImage histspec( VImage histspec_ref ) throw( VError );
-VImage hsp( VImage hsp_ref ) throw( VError );
-static VImage identity( int identity_nbands ) throw( VError );
-static VImage identity_ushort( int identity_ushort_nbands, int identity_ushort_size ) throw( VError );
-int ismonotonic() throw( VError );
-VImage lhisteq( int lhisteq_width, int lhisteq_height ) throw( VError );
-int mpercent( double mpercent_percent ) throw( VError );
-static VImage invertlut( VDMask invertlut_measures, int invertlut_lut_size ) throw( VError );
-static VImage buildlut( VDMask buildlut_xyes ) throw( VError );
-VImage maplut( VImage maplut_lut ) throw( VError );
-VImage project( VImage& project_vout ) throw( VError );
-VImage stdif( double stdif_a, double stdif_m0, double stdif_b, double stdif_s0, int stdif_xw, int stdif_yw ) throw( VError );
-VImage tone_analyse( double tone_analyse_Ps, double tone_analyse_Pm, double tone_analyse_Ph, double tone_analyse_S, double tone_analyse_M, double tone_analyse_H ) throw( VError );
-static VImage tone_build( double tone_build_Lb, double tone_build_Lw, double tone_build_Ps, double tone_build_Pm, double tone_build_Ph, double tone_build_S, double tone_build_M, double tone_build_H ) throw( VError );
-static VImage tone_build_range( int tone_build_range_in_max, int tone_build_range_out_max, double tone_build_range_Lb, double tone_build_range_Lw, double tone_build_range_Ps, double tone_build_range_Pm, double tone_build_range_Ph, double tone_build_range_S, double tone_build_range_M, double tone_build_range_H ) throw( VError );
-VImage tone_map( VImage tone_map_lut ) throw( VError );
-
-// headers for package inplace
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-void draw_circle( int draw_circle_cx, int draw_circle_cy, int draw_circle_radius, int draw_circle_fill, std::vector<double> draw_circle_ink ) throw( VError );
-void draw_rect( int draw_rect_left, int draw_rect_top, int draw_rect_width, int draw_rect_height, int draw_rect_fill, std::vector<double> draw_rect_ink ) throw( VError );
-void draw_line( int draw_line_x1, int draw_line_y1, int draw_line_x2, int draw_line_y2, std::vector<double> draw_line_ink ) throw( VError );
-void draw_point( int draw_point_x, int draw_point_y, std::vector<double> draw_point_ink ) throw( VError );
-void draw_smudge( int draw_smudge_left, int draw_smudge_top, int draw_smudge_width, int draw_smudge_height ) throw( VError );
-void draw_flood( int draw_flood_x, int draw_flood_y, std::vector<double> draw_flood_ink ) throw( VError );
-void draw_flood_blob( int draw_flood_blob_x, int draw_flood_blob_y, std::vector<double> draw_flood_blob_ink ) throw( VError );
-void draw_flood_other( VImage draw_flood_other_test, int draw_flood_other_x, int draw_flood_other_y, int draw_flood_other_serial ) throw( VError );
-void draw_image( VImage draw_image_sub, int draw_image_x, int draw_image_y ) throw( VError );
-void draw_mask( VImage draw_mask_mask, int draw_mask_x, int draw_mask_y, std::vector<double> draw_mask_ink ) throw( VError );
-VImage line( VImage line_mask, VImage line_ink, std::vector<int> line_x1, std::vector<int> line_y1, std::vector<int> line_x2, std::vector<int> line_y2 ) throw( VError );
-
-// headers for package iofuncs
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-static VImage binfile( char* binfile_filename, int binfile_width, int binfile_height, int binfile_bands, int binfile_offset ) throw( VError );
-VImage cache( int cache_tile_width, int cache_tile_height, int cache_max_tiles ) throw( VError );
-char* getext() throw( VError );
-int header_get_typeof( char* header_get_typeof_field ) throw( VError );
-int header_int( char* header_int_field ) throw( VError );
-double header_double( char* header_double_field ) throw( VError );
-char* header_string( char* header_string_field ) throw( VError );
-char* history_get() throw( VError );
-void printdesc() throw( VError );
-
-// headers for package mask
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-
-// headers for package morphology
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-double cntlines( int cntlines_direction ) throw( VError );
-VImage dilate( VIMask dilate_mask ) throw( VError );
-VImage rank( int rank_xsize, int rank_ysize, int rank_n ) throw( VError );
-static VImage rank_image( std::vector<VImage> rank_image_in, int rank_image_index ) throw( VError );
-static VImage maxvalue( std::vector<VImage> maxvalue_in ) throw( VError );
-VImage label_regions( int& label_regions_segments ) throw( VError );
-VImage zerox( int zerox_flag ) throw( VError );
-VImage erode( VIMask erode_mask ) throw( VError );
-VImage profile( int profile_direction ) throw( VError );
-
-// headers for package mosaicing
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-VImage align_bands() throw( VError );
-double correl( VImage correl_sec, int correl_xref, int correl_yref, int correl_xsec, int correl_ysec, int correl_hwindowsize, int correl_hsearchsize, int& correl_x, int& correl_y ) throw( VError );
-int _find_lroverlap( VImage _find_lroverlap_sec, int _find_lroverlap_bandno, int _find_lroverlap_xr, int _find_lroverlap_yr, int _find_lroverlap_xs, int _find_lroverlap_ys, int _find_lroverlap_halfcorrelation, int _find_lroverlap_halfarea, int& _find_lroverlap_dy0, double& _find_lroverlap_scale1, double& _find_lroverlap_angle1, double& _find_lroverlap_dx1, double& _find_lroverlap_dy1 ) throw( VError );
-int _find_tboverlap( VImage _find_tboverlap_sec, int _find_tboverlap_bandno, int _find_tboverlap_xr, int _find_tboverlap_yr, int _find_tboverlap_xs, int _find_tboverlap_ys, int _find_tboverlap_halfcorrelation, int _find_tboverlap_halfarea, int& _find_tboverlap_dy0, double& _find_tboverlap_scale1, double& _find_tboverlap_angle1, double& _find_tboverlap_dx1, double& _find_tboverlap_dy1 ) throw( VError );
-VImage global_balance( double global_balance_gamma ) throw( VError );
-VImage global_balancef( double global_balancef_gamma ) throw( VError );
-VImage lrmerge( VImage lrmerge_sec, int lrmerge_dx, int lrmerge_dy, int lrmerge_mwidth ) throw( VError );
-VImage lrmerge1( VImage lrmerge1_sec, int lrmerge1_xr1, int lrmerge1_yr1, int lrmerge1_xs1, int lrmerge1_ys1, int lrmerge1_xr2, int lrmerge1_yr2, int lrmerge1_xs2, int lrmerge1_ys2, int lrmerge1_mwidth ) throw( VError );
-VImage lrmosaic( VImage lrmosaic_sec, int lrmosaic_bandno, int lrmosaic_xr, int lrmosaic_yr, int lrmosaic_xs, int lrmosaic_ys, int lrmosaic_halfcorrelation, int lrmosaic_halfarea, int lrmosaic_balancetype, int lrmosaic_mwidth ) throw( VError );
-VImage lrmosaic1( VImage lrmosaic1_sec, int lrmosaic1_bandno, int lrmosaic1_xr1, int lrmosaic1_yr1, int lrmosaic1_xs1, int lrmosaic1_ys1, int lrmosaic1_xr2, int lrmosaic1_yr2, int lrmosaic1_xs2, int lrmosaic1_ys2, int lrmosaic1_halfcorrelation, int lrmosaic1_halfarea, int lrmosaic1_balancetype, int lrmosaic1_mwidth ) throw( VError );
-VImage match_linear( VImage match_linear_sec, int match_linear_xref1, int match_linear_yref1, int match_linear_xsec1, int match_linear_ysec1, int match_linear_xref2, int match_linear_yref2, int match_linear_xsec2, int match_linear_ysec2 ) throw( VError );
-VImage match_linear_search( VImage match_linear_search_sec, int match_linear_search_xref1, int match_linear_search_yref1, int match_linear_search_xsec1, int match_linear_search_ysec1, int match_linear_search_xref2, int match_linear_search_yref2, int match_linear_search_xsec2, int match_linear_search_ysec2, int match_linear_search_hwindowsize, int match_linear_search_hsearchsize ) throw( VError );
-double maxpos_subpel( double& maxpos_subpel_y ) throw( VError );
-VImage remosaic( char* remosaic_old_str, char* remosaic_new_str ) throw( VError );
-VImage tbmerge( VImage tbmerge_sec, int tbmerge_dx, int tbmerge_dy, int tbmerge_mwidth ) throw( VError );
-VImage tbmerge1( VImage tbmerge1_sec, int tbmerge1_xr1, int tbmerge1_yr1, int tbmerge1_xs1, int tbmerge1_ys1, int tbmerge1_xr2, int tbmerge1_yr2, int tbmerge1_xs2, int tbmerge1_ys2, int tbmerge1_mwidth ) throw( VError );
-VImage tbmosaic( VImage tbmosaic_sec, int tbmosaic_bandno, int tbmosaic_xr, int tbmosaic_yr, int tbmosaic_xs, int tbmosaic_ys, int tbmosaic_halfcorrelation, int tbmosaic_halfarea, int tbmosaic_balancetype, int tbmosaic_mwidth ) throw( VError );
-VImage tbmosaic1( VImage tbmosaic1_sec, int tbmosaic1_bandno, int tbmosaic1_xr1, int tbmosaic1_yr1, int tbmosaic1_xs1, int tbmosaic1_ys1, int tbmosaic1_xr2, int tbmosaic1_yr2, int tbmosaic1_xs2, int tbmosaic1_ys2, int tbmosaic1_halfcorrelation, int tbmosaic1_halfarea, int tbmosaic1_balancetype, int tbmosaic1_mwidth ) throw( VError );
-
-// headers for package other
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-VImage benchmark() throw( VError );
-double benchmark2() throw( VError );
-VImage benchmarkn( int benchmarkn_n ) throw( VError );
-static VImage eye( int eye_xsize, int eye_ysize, double eye_factor ) throw( VError );
-static VImage grey( int grey_xsize, int grey_ysize ) throw( VError );
-static VImage feye( int feye_xsize, int feye_ysize, double feye_factor ) throw( VError );
-static VImage fgrey( int fgrey_xsize, int fgrey_ysize ) throw( VError );
-static VImage fzone( int fzone_size ) throw( VError );
-static VImage make_xy( int make_xy_xsize, int make_xy_ysize ) throw( VError );
-static VImage sines( int sines_xsize, int sines_ysize, double sines_horfreq, double sines_verfreq ) throw( VError );
-static VImage zone( int zone_size ) throw( VError );
-
-// headers for package resample
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-VImage rightshift_size( int rightshift_size_xshift, int rightshift_size_yshift, int rightshift_size_band_fmt ) throw( VError );
-VImage shrink( double shrink_xfac, double shrink_yfac ) throw( VError );
-VImage stretch3( double stretch3_xdisp, double stretch3_ydisp ) throw( VError );
-VImage affinei( char* affinei_interpolate, double affinei_a, double affinei_b, double affinei_c, double affinei_d, double affinei_dx, double affinei_dy, int affinei_x, int affinei_y, int affinei_w, int affinei_h ) throw( VError );
-VImage affinei_all( char* affinei_all_interpolate, double affinei_all_a, double affinei_all_b, double affinei_all_c, double affinei_all_d, double affinei_all_dx, double affinei_all_dy ) throw( VError );
-
-// headers for package video
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-static VImage video_test( int video_test_brightness, int video_test_error ) throw( VError );
-static VImage video_v4l1( char* video_v4l1_device, int video_v4l1_channel, int video_v4l1_brightness, int video_v4l1_colour, int video_v4l1_contrast, int video_v4l1_hue, int video_v4l1_ngrabs ) throw( VError );
-
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/vips/vipscpp.h vips-7.38.5/libvipsCC/include/vips/vipscpp.h
--- vips-7.38.5-vanilla/libvipsCC/include/vips/vipscpp.h	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/vips/vipscpp.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,40 +0,0 @@
-// Include file to get all VIPS C++ bindings
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-/* This header is just for compatibility with the pre-namespace C++ bindings.
- */
-
-#ifndef IM_VIPSCPP_H
-#define IM_VIPSCPP_H
-
-#include <vips/vips>
-
-using namespace vips;
-
-#endif /*IM_VIPSCPP_H*/
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/include/vips/VMask.h vips-7.38.5/libvipsCC/include/vips/VMask.h
--- vips-7.38.5-vanilla/libvipsCC/include/vips/VMask.h	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/include/vips/VMask.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,411 +0,0 @@
-/* VIPS mask class.
- *
- * Just like VImage, but we don't need dependency stuff. Instead, have a base
- * wrapper over *MASK, derive VMaskD and VMaskI from that, and then put
- * refcounting over all of them.
- */
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifndef IM_VMASK_H
-#define IM_VMASK_H
-
-/* SWIG includes this file directly rather than going through vipscpp.h ... so
- * we have to define these macros here as well.
- */
-#ifdef SWIG
-# define VIPS_NAMESPACE_START namespace vips {
-# define VIPS_NAMESPACE_END }
-#endif /*SWIG*/
-
-/* Don't include these when parsing for SWIG.
- */
-#ifndef SWIG
-# include <cstdarg>
-# include <iosfwd>
-# include <vector>
-#endif /*!SWIG*/
-
-/* Wrap pointers to these, but we don't want to import all the old C API. Just 
- * declare them.
- */
-extern "C" {
-	struct im__INTMASK;
-	struct im__DOUBLEMASK;
-}
-
-VIPS_NAMESPACE_START
-
-/* This first section is private. Only expose the non-P versions of these
- * classes later on. Don't need to wrap then in SWIG either.
- */
-#ifndef SWIG
-namespace _private_detail { 
-
-union MASKUNION {
-       im__INTMASK *iptr;
-       im__DOUBLEMASK *dptr;
-}; 
-
-// Private wrapper over *MASK - user does not see this
-class VPMask {
-	friend class VMask;
-
-public:
-	// Track type of mask with this
-	enum VMaskType {
-		UNASSIGNED,		// Not yet set
-		INT,			// mask points to INTMASK
-		DOUBLE			// mask points to DOUBLEMASK
-	};
-
-	MASKUNION data;			// Mask pointer - INT or DOUBLE
-	VMaskType type;			// Track type too, for safety
-
-	virtual ~VPMask() {};
-
-	// Duplicate
-	virtual VPMask *dup() const = 0;
-
-	// Projection functions to get MASK fields
-	virtual int xsize() const = 0;
-	virtual int ysize() const = 0;
-	virtual const char *filename() const = 0;
-
-	// Output
-	virtual void ostream_print( std::ostream & ) const = 0;
-};
-
-// Specialise for INTMASK
-class VPIMask : public VPMask {
-public:
-	VPIMask( int xsize, int ysize ) throw( VError );
-	VPIMask( int xsize, int ysize, int scale, int offset, 
-		std::vector<int> coeff ) throw( VError );
-	VPIMask( const char * )
-		throw( VError );
-	VPIMask( im__INTMASK * );
-	VPIMask();
-	virtual ~VPIMask();
-
-	VPMask *dup() const throw( VError );
-	void embed( im__INTMASK * ) throw( VError );
-
-	int xsize() const throw( VError );
-	int ysize() const throw( VError );
-	int scale() const throw( VError );
-	int offset() const throw( VError );
-	const char *filename() const throw( VError );
-
-	// Output
-	virtual void ostream_print( std::ostream & ) const throw( VError );
-
-	// Extract start of array of ints
-	int *array() const;
-};
-
-// Specialise for DOUBLEMASK
-class VPDMask : public VPMask {
-public:
-	VPDMask( int xsize, int ysize ) throw( VError );
-	VPDMask( int xsize, int ysize, 
-		double scale, double offset, std::vector<double> coeff ) 
-		throw( VError );
-	VPDMask( const char * ) throw( VError );
-	VPDMask( im__DOUBLEMASK * );
-	VPDMask();
-	virtual ~VPDMask();
-
-	VPMask *dup() const throw( VError );
-	void embed( im__DOUBLEMASK * ) throw( VError );
-
-	int xsize() const throw( VError );
-	int ysize() const throw( VError );
-	double scale() const throw( VError );
-	double offset() const throw( VError );
-	const char *filename() const throw( VError );
-
-	// Output
-	virtual void ostream_print( std::ostream & ) const throw( VError );
-
-	// Extract start of array of doubles
-	double *array() const;
-};
-
-} // end of namespace _private_detail
-
-inline std::ostream &operator<<( std::ostream &file, 
-	const _private_detail::VPMask &msk )
-{ 
-	msk.ostream_print( file ); 
-	return( file ); 
-}
-
-#endif /*!SWIG*/
-
-// Wrapper over VP?Mask with ref counting
-class VMask {
-protected:
-	struct refblock {
-		_private_detail::VPMask *pmask;	// Mask: double or int
-		int nrefs;		// Refs to us
-
-		refblock() : pmask(0), nrefs(1) {}
-		virtual ~refblock() { delete pmask; }
-	};
-
-	refblock *ref;
-
-	// Make sure this is a private copy of pmask --- dup if nrefs != 1
-	void make_private();
-
-public:
-	// Constructor leaves msk uninitialised
-	VMask() { ref = new refblock; }
-
-	// Copy constructor 
-	VMask( const VMask &a ) { ref = a.ref; ref->nrefs++; }
-
-	// Assignment
-	VMask &operator=( const VMask &a );
-
-	// Destructor
-	virtual ~VMask();
-
-	int xsize() const throw( VError ) 
-		{ return( ref->pmask->xsize() ); }
-	int ysize() const throw( VError ) 
-		{ return( ref->pmask->ysize() ); }
-	int size() const throw( VError ) 
-		{ return( xsize() * ysize() ); }
-	const char *filename() const throw( VError ) 
-		{ return( ref->pmask->filename() ); }
-
-	// Extract underlying type
-	_private_detail::VPMask::VMaskType type() const 
-		{ return( ref->pmask->type ); }
-
-	// Extract underlying VIPS pointer
-	_private_detail::MASKUNION mask() const { return( ref->pmask->data ); }
-
-	void ostream_print( std::ostream & ) const;
-};
-
-inline std::ostream &operator<<( std::ostream &file, const VMask &msk )
-{
-	msk.ostream_print( file );
-	return( file );
-}
-
-// Need to forward ref these
-class VDMask;
-class VImage;
-
-// Wrapper over _private_detail::VPIMask with ref counting
-class VIMask : public VMask {
-public:
-	VIMask( int xsize, int ysize )
-	{
-		ref->pmask = new _private_detail::VPIMask( xsize, ysize );
-	}
-
-/* Don't wrap the varargs constructor. We want Python to use the vector one.
- */
-#ifndef SWIG
-	VIMask( int xsize, int ysize, int scale, int offset, ... )
-	{
-		va_list ap;
-		int i;
-		std::vector<int> coeff( xsize * ysize );
-
-		va_start( ap, offset );
-		for( i = 0; i < xsize * ysize; i++ )
-			coeff[i] = va_arg( ap, int );
-		va_end( ap );
-
-		ref->pmask = new _private_detail::VPIMask( xsize, ysize, 
-			scale, offset, coeff );
-	}
-#endif /*!SWIG*/
-
-	VIMask( int xsize, int ysize, int scale, int offset, 
-		std::vector<int> coeff )
-	{
-		ref->pmask = new _private_detail::VPIMask( xsize, ysize, 
-			scale, offset, coeff );
-	}
-
-	VIMask( const char *name )
-	{
-		ref->pmask = new _private_detail::VPIMask( name );
-	}
-
-	// No mask there yet
-	VIMask() {}
-
-	int scale() 
-	{ 
-		return( ((_private_detail::VPIMask *)ref->pmask)->scale() ); 
-	}
-	
-	int offset() 
-	{ 
-		return( ((_private_detail::VPIMask *)ref->pmask)->offset() ); 
-	}
-
-	// Embed INTMASK in VIMask
-	void embed( im__INTMASK * ) throw( VError );
-
-	// Overload [] to get linear array subscript.
-	int &operator[]( int ) throw( VError );
-
-	// Overload () to get matrix subscript.
-	int &operator()( int x, int y ) throw( VError ) 
-		{ return( (*this)[x + y*xsize()] ); }
-
-	// and as a function call that SWIG can wrap
-	int get( int i ) throw( VError ) 
-		{ return( (*this)[i] ); }
-
-	// Type conversion: INTMASK->DOUBLEMASK
-	operator VDMask();
-
-	// Type conversion: INTMASK->image
-	operator VImage();
-
-	// VIMask build functions
-	static VIMask gauss( double, double ) throw( VError );
-	static VIMask gauss_sep( double, double ) throw( VError );
-	static VIMask log( double, double ) throw( VError );
-
-	// VIMask manipulation
-	VIMask rotate45() throw( VError );
-	VIMask rotate90() throw( VError );
-
-	// Arithmetic ... cast to double, and use VDMask funcs. For some
-	// reason, the compiler won't let us do casts to VDImage yet, so no
-	// inlines.
-	VDMask trn() throw( VError );
-	VDMask inv() throw( VError );
-	VDMask cat( VDMask ) throw( VError );
-	VDMask mul( VDMask ) throw( VError );
-};
-
-// Wrapper over _private_detail::VPDMask with ref counting
-class VDMask : public VMask {
-public:
-	VDMask( int xsize, int ysize )
-	{
-		ref->pmask = new _private_detail::VPDMask( xsize, ysize );
-	}
-
-/* Don't wrap the varargs constructor. We want Python to use the vector one.
- */
-#ifndef SWIG
-	VDMask( int xsize, int ysize, double scale, double offset, ... )
-	{
-		va_list ap;
-		int i;
-		std::vector<double> coeff( xsize * ysize );
-
-		va_start( ap, offset );
-		for( i = 0; i < xsize * ysize; i++ )
-			coeff[i] = va_arg( ap, double );
-		va_end( ap );
-
-		ref->pmask = new _private_detail::VPDMask( xsize, ysize, 
-			scale, offset, coeff );
-	}
-#endif /*!SWIG*/
-
-	VDMask( int xsize, int ysize, double scale, double offset, 
-		std::vector<double> coeff )
-	{
-		ref->pmask = new _private_detail::VPDMask( xsize, ysize, 
-			scale, offset, coeff );
-	}
-
-	VDMask( const char *name )
-	{
-		ref->pmask = new _private_detail::VPDMask( name );
-	}
-
-	// No mask yet
-	VDMask() { }
-
-	// Embed DOUBLEMASK in VDMask
-	void embed( im__DOUBLEMASK * ) throw( VError );
-
-	double scale() throw( VError )
-	{ 
-		return( ((_private_detail::VPDMask *)ref->pmask)->scale() ); 
-	}
-
-	double offset() throw( VError )
-	{ 
-		return( ((_private_detail::VPDMask *)ref->pmask)->offset() ); 
-	}
-
-	// Overload [] to get linear array subscript.
-	double &operator[]( int ) throw( VError );
-
-	// Overload () to get matrix subscript.
-	double &operator()( int x, int y ) throw( VError )
-		{ return( (*this)[x + y*xsize()] ); }
-
-	// and as a function call that SWIG can wrap
-	double get( int i ) throw( VError ) 
-		{ return( (*this)[i] ); }
-
-	// Type conversion: double->int
-	operator VIMask();
-
-	// Type conversion: DOUBLEMASK->image
-	operator VImage() throw( VError );
-
-	// VDMask build functions
-	static VDMask gauss( double, double ) throw( VError );
-	static VDMask log( double, double ) throw( VError );
-
-	// VDMask manipulation
-	VDMask rotate45() throw( VError );
-	VDMask rotate90() throw( VError ); 
-
-	// Scale to intmask
-	VIMask scalei() throw( VError );
-
-	// Simple arithmetic
-	VDMask trn() throw( VError );
-	VDMask inv() throw( VError );
-	VDMask cat( VDMask ) throw( VError );
-	VDMask mul( VDMask ) throw( VError );
-};
-
-VIPS_NAMESPACE_END
-
-#endif /*IM_VMASK_H*/
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/Makefile.am vips-7.38.5/libvipsCC/Makefile.am
--- vips-7.38.5-vanilla/libvipsCC/Makefile.am	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/Makefile.am	1969-12-31 19:00:00.000000000 -0500
@@ -1,37 +0,0 @@
-SUBDIRS = \
-	include 
-
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/libvips/include \
-	-I$(top_srcdir)/libvipsCC/include \
-	@VIPS_CFLAGS@ 
-
-lib_LTLIBRARIES = libvipsCC.la
-
-libvipsCC_la_SOURCES = \
-	VImage.cc \
-	VError.cc \
-	VDisplay.cc \
-	VMask.cc
-
-libvipsCC_la_LDFLAGS = \
-	-no-undefined \
-	-version-info @LIBRARY_CURRENT@:@LIBRARY_REVISION@:@LIBRARY_AGE@
-
-libvipsCC_la_LIBADD = \
-	$(top_builddir)/libvips/libvips.la @VIPS_LIBS@
-
-# swap the 'awk' line for this:
-# awk '{if($$1!="deprecated") print $$1}'` ; \
-# to not generate the wrappers for deprecated functions
-vipsc++.cc:
-	packages=`vips list packages | \
-	  awk '{print $$1}'` ; \
-	  echo > vipsc++.cc ; \
-	  for name in $$packages; do \
-	    echo "// bodies for package $$name" >> vipsc++.cc ; \
-	    vips cppc $$name >> vipsc++.cc ; \
-	    echo >> vipsc++.cc ; \
-	  done 
-
-EXTRA_DIST = vipsc++.cc
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/Makefile.in vips-7.38.5/libvipsCC/Makefile.in
--- vips-7.38.5-vanilla/libvipsCC/Makefile.in	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/Makefile.in	1969-12-31 19:00:00.000000000 -0500
@@ -1,898 +0,0 @@
-# Makefile.in generated by automake 1.13.3 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = libvipsCC
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/depcomp
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/gtk-doc.m4 \
-	$(top_srcdir)/m4/introspection.m4 $(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__uninstall_files_from_dir = { \
-  test -z "$$files" \
-    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
-    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
-         $(am__cd) "$$dir" && rm -f $$files; }; \
-  }
-am__installdirs = "$(DESTDIR)$(libdir)"
-LTLIBRARIES = $(lib_LTLIBRARIES)
-libvipsCC_la_DEPENDENCIES = $(top_builddir)/libvips/libvips.la
-am_libvipsCC_la_OBJECTS = VImage.lo VError.lo VDisplay.lo VMask.lo
-libvipsCC_la_OBJECTS = $(am_libvipsCC_la_OBJECTS)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-am__v_lt_1 = 
-libvipsCC_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
-	$(CXXFLAGS) $(libvipsCC_la_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-am__mv = mv -f
-CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
-LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CXXFLAGS) $(CXXFLAGS)
-AM_V_CXX = $(am__v_CXX_@AM_V@)
-am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
-am__v_CXX_0 = @echo "  CXX     " $@;
-am__v_CXX_1 = 
-CXXLD = $(CXX)
-CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
-am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
-am__v_CXXLD_0 = @echo "  CXXLD   " $@;
-am__v_CXXLD_1 = 
-SOURCES = $(libvipsCC_la_SOURCES)
-DIST_SOURCES = $(libvipsCC_la_SOURCES)
-RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
-	ctags-recursive dvi-recursive html-recursive info-recursive \
-	install-data-recursive install-dvi-recursive \
-	install-exec-recursive install-html-recursive \
-	install-info-recursive install-pdf-recursive \
-	install-ps-recursive install-recursive installcheck-recursive \
-	installdirs-recursive pdf-recursive ps-recursive \
-	tags-recursive uninstall-recursive
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
-am__recursive_targets = \
-  $(RECURSIVE_TARGETS) \
-  $(RECURSIVE_CLEAN_TARGETS) \
-  $(am__extra_recursive_targets)
-AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
-	distdir
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-# Read a list of newline-separated strings from the standard input,
-# and print each of them once, without duplicates.  Input order is
-# *not* preserved.
-am__uniquify_input = $(AWK) '\
-  BEGIN { nonempty = 0; } \
-  { items[$$0] = 1; nonempty = 1; } \
-  END { if (nonempty) { for (i in items) print i; }; } \
-'
-# Make sure the list of sources is unique.  This is necessary because,
-# e.g., the same source file might be shared among _SOURCES variables
-# for different programs/libraries.
-am__define_uniq_tagged_files = \
-  list='$(am__tagged_files)'; \
-  unique=`for i in $$list; do \
-    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-  done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
-DIST_SUBDIRS = $(SUBDIRS)
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-am__relativize = \
-  dir0=`pwd`; \
-  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
-  sed_rest='s,^[^/]*/*,,'; \
-  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
-  sed_butlast='s,/*[^/]*$$,,'; \
-  while test -n "$$dir1"; do \
-    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
-    if test "$$first" != "."; then \
-      if test "$$first" = ".."; then \
-        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
-        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
-      else \
-        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
-        if test "$$first2" = "$$first"; then \
-          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
-        else \
-          dir2="../$$dir2"; \
-        fi; \
-        dir0="$$dir0"/"$$first"; \
-      fi; \
-    fi; \
-    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
-  done; \
-  reldir="$$dir2"
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AS = @AS@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFITSIO_CFLAGS = @CFITSIO_CFLAGS@
-CFITSIO_LIBS = @CFITSIO_LIBS@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DLLTOOL = @DLLTOOL@
-DLLWRAP = @DLLWRAP@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-EXIF_CFLAGS = @EXIF_CFLAGS@
-EXIF_LIBS = @EXIF_LIBS@
-FFTW_CFLAGS = @FFTW_CFLAGS@
-FFTW_LIBS = @FFTW_LIBS@
-FGREP = @FGREP@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GREP = @GREP@
-GTHREAD_CFLAGS = @GTHREAD_CFLAGS@
-GTHREAD_LIBS = @GTHREAD_LIBS@
-GTKDOC_CHECK = @GTKDOC_CHECK@
-GTKDOC_DEPS_CFLAGS = @GTKDOC_DEPS_CFLAGS@
-GTKDOC_DEPS_LIBS = @GTKDOC_DEPS_LIBS@
-GTKDOC_MKPDF = @GTKDOC_MKPDF@
-GTKDOC_REBASE = @GTKDOC_REBASE@
-HTML_DIR = @HTML_DIR@
-IMAGE_MAGICK_CFLAGS = @IMAGE_MAGICK_CFLAGS@
-IMAGE_MAGICK_LIBS = @IMAGE_MAGICK_LIBS@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTROSPECTION_CFLAGS = @INTROSPECTION_CFLAGS@
-INTROSPECTION_COMPILER = @INTROSPECTION_COMPILER@
-INTROSPECTION_GENERATE = @INTROSPECTION_GENERATE@
-INTROSPECTION_GIRDIR = @INTROSPECTION_GIRDIR@
-INTROSPECTION_LIBS = @INTROSPECTION_LIBS@
-INTROSPECTION_MAKEFILE = @INTROSPECTION_MAKEFILE@
-INTROSPECTION_SCANNER = @INTROSPECTION_SCANNER@
-INTROSPECTION_TYPELIBDIR = @INTROSPECTION_TYPELIBDIR@
-JPEG_INCLUDES = @JPEG_INCLUDES@
-JPEG_LIBS = @JPEG_LIBS@
-LCMS_CFLAGS = @LCMS_CFLAGS@
-LCMS_LIBS = @LCMS_LIBS@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBRARY_AGE = @LIBRARY_AGE@
-LIBRARY_CURRENT = @LIBRARY_CURRENT@
-LIBRARY_REVISION = @LIBRARY_REVISION@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIBWEBP_CFLAGS = @LIBWEBP_CFLAGS@
-LIBWEBP_LIBS = @LIBWEBP_LIBS@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAGICK_CFLAGS = @MAGICK_CFLAGS@
-MAGICK_LIBS = @MAGICK_LIBS@
-MAGICK_WAND_CFLAGS = @MAGICK_WAND_CFLAGS@
-MAGICK_WAND_LIBS = @MAGICK_WAND_LIBS@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MATIO_CFLAGS = @MATIO_CFLAGS@
-MATIO_LIBS = @MATIO_LIBS@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MONOTONIC_CFLAGS = @MONOTONIC_CFLAGS@
-MONOTONIC_LIBS = @MONOTONIC_LIBS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OPENEXR_CFLAGS = @OPENEXR_CFLAGS@
-OPENEXR_LIBS = @OPENEXR_LIBS@
-OPENSLIDE_CFLAGS = @OPENSLIDE_CFLAGS@
-OPENSLIDE_LIBS = @OPENSLIDE_LIBS@
-ORC_CFLAGS = @ORC_CFLAGS@
-ORC_LIBS = @ORC_LIBS@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGES_USED = @PACKAGES_USED@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PANGOFT2_CFLAGS = @PANGOFT2_CFLAGS@
-PANGOFT2_LIBS = @PANGOFT2_LIBS@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-PNG_CFLAGS = @PNG_CFLAGS@
-PNG_INCLUDES = @PNG_INCLUDES@
-PNG_LIBS = @PNG_LIBS@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-PYTHON = @PYTHON@
-PYTHON_EXEC_PREFIX = @PYTHON_EXEC_PREFIX@
-PYTHON_INCLUDES = @PYTHON_INCLUDES@
-PYTHON_PLATFORM = @PYTHON_PLATFORM@
-PYTHON_PREFIX = @PYTHON_PREFIX@
-PYTHON_VERSION = @PYTHON_VERSION@
-RANLIB = @RANLIB@
-REQUIRED_CFLAGS = @REQUIRED_CFLAGS@
-REQUIRED_LIBS = @REQUIRED_LIBS@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-THREADS_CFLAGS = @THREADS_CFLAGS@
-THREADS_LIBS = @THREADS_LIBS@
-TIFF_CFLAGS = @TIFF_CFLAGS@
-TIFF_INCLUDES = @TIFF_INCLUDES@
-TIFF_LIBS = @TIFF_LIBS@
-TYPE_INIT_CFLAGS = @TYPE_INIT_CFLAGS@
-TYPE_INIT_LIBS = @TYPE_INIT_LIBS@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-VIPS_CFLAGS = @VIPS_CFLAGS@
-VIPS_CXX_LIBS = @VIPS_CXX_LIBS@
-VIPS_EXEEXT = @VIPS_EXEEXT@
-VIPS_INCLUDES = @VIPS_INCLUDES@
-VIPS_LIBDIR = @VIPS_LIBDIR@
-VIPS_LIBS = @VIPS_LIBS@
-VIPS_MAJOR_VERSION = @VIPS_MAJOR_VERSION@
-VIPS_MICRO_VERSION = @VIPS_MICRO_VERSION@
-VIPS_MINOR_VERSION = @VIPS_MINOR_VERSION@
-VIPS_VERSION = @VIPS_VERSION@
-VIPS_VERSION_STRING = @VIPS_VERSION_STRING@
-XGETTEXT = @XGETTEXT@
-XMKMF = @XMKMF@
-X_CFLAGS = @X_CFLAGS@
-X_EXTRA_LIBS = @X_EXTRA_LIBS@
-X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
-ZIP_INCLUDES = @ZIP_INCLUDES@
-ZIP_LIBS = @ZIP_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-pkgpyexecdir = @pkgpyexecdir@
-pkgpythondir = @pkgpythondir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-pyexecdir = @pyexecdir@
-pythondir = @pythondir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-vips_introspection_sources = @vips_introspection_sources@
-SUBDIRS = \
-	include 
-
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/libvips/include \
-	-I$(top_srcdir)/libvipsCC/include \
-	@VIPS_CFLAGS@ 
-
-lib_LTLIBRARIES = libvipsCC.la
-libvipsCC_la_SOURCES = \
-	VImage.cc \
-	VError.cc \
-	VDisplay.cc \
-	VMask.cc
-
-libvipsCC_la_LDFLAGS = \
-	-no-undefined \
-	-version-info @LIBRARY_CURRENT@:@LIBRARY_REVISION@:@LIBRARY_AGE@
-
-libvipsCC_la_LIBADD = \
-	$(top_builddir)/libvips/libvips.la @VIPS_LIBS@
-
-EXTRA_DIST = vipsc++.cc
-all: all-recursive
-
-.SUFFIXES:
-.SUFFIXES: .cc .lo .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign libvipsCC/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign libvipsCC/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-install-libLTLIBRARIES: $(lib_LTLIBRARIES)
-	@$(NORMAL_INSTALL)
-	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
-	list2=; for p in $$list; do \
-	  if test -f $$p; then \
-	    list2="$$list2 $$p"; \
-	  else :; fi; \
-	done; \
-	test -z "$$list2" || { \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(libdir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
-	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'"; \
-	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(libdir)"; \
-	}
-
-uninstall-libLTLIBRARIES:
-	@$(NORMAL_UNINSTALL)
-	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
-	for p in $$list; do \
-	  $(am__strip_dir) \
-	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$f'"; \
-	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libdir)/$$f"; \
-	done
-
-clean-libLTLIBRARIES:
-	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
-	@list='$(lib_LTLIBRARIES)'; \
-	locs=`for p in $$list; do echo $$p; done | \
-	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
-	      sort -u`; \
-	test -z "$$locs" || { \
-	  echo rm -f $${locs}; \
-	  rm -f $${locs}; \
-	}
-
-libvipsCC.la: $(libvipsCC_la_OBJECTS) $(libvipsCC_la_DEPENDENCIES) $(EXTRA_libvipsCC_la_DEPENDENCIES) 
-	$(AM_V_CXXLD)$(libvipsCC_la_LINK) -rpath $(libdir) $(libvipsCC_la_OBJECTS) $(libvipsCC_la_LIBADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/VDisplay.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/VError.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/VImage.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/VMask.Plo@am__quote@
-
-.cc.o:
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<
-
-.cc.obj:
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
-
-.cc.lo:
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-# This directory's subdirectories are mostly independent; you can cd
-# into them and run 'make' without going through this Makefile.
-# To change the values of 'make' variables: instead of editing Makefiles,
-# (1) if the variable is set in 'config.status', edit 'config.status'
-#     (which will cause the Makefiles to be regenerated when you run 'make');
-# (2) otherwise, pass the desired values on the 'make' command line.
-$(am__recursive_targets):
-	@fail=; \
-	if $(am__make_keepgoing); then \
-	  failcom='fail=yes'; \
-	else \
-	  failcom='exit 1'; \
-	fi; \
-	dot_seen=no; \
-	target=`echo $@ | sed s/-recursive//`; \
-	case "$@" in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	for subdir in $$list; do \
-	  echo "Making $$target in $$subdir"; \
-	  if test "$$subdir" = "."; then \
-	    dot_seen=yes; \
-	    local_target="$$target-am"; \
-	  else \
-	    local_target="$$target"; \
-	  fi; \
-	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	  || eval $$failcom; \
-	done; \
-	if test "$$dot_seen" = "no"; then \
-	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
-	fi; test -z "$$fail"
-
-ID: $(am__tagged_files)
-	$(am__define_uniq_tagged_files); mkid -fID $$unique
-tags: tags-recursive
-TAGS: tags
-
-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	set x; \
-	here=`pwd`; \
-	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
-	  include_option=--etags-include; \
-	  empty_fix=.; \
-	else \
-	  include_option=--include; \
-	  empty_fix=; \
-	fi; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
-	    test ! -f $$subdir/TAGS || \
-	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
-	  fi; \
-	done; \
-	$(am__define_uniq_tagged_files); \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: ctags-recursive
-
-CTAGS: ctags
-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	$(am__define_uniq_tagged_files); \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-cscopelist: cscopelist-recursive
-
-cscopelist-am: $(am__tagged_files)
-	list='$(am__tagged_files)'; \
-	case "$(srcdir)" in \
-	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
-	  *) sdir=$(subdir)/$(srcdir) ;; \
-	esac; \
-	for i in $$list; do \
-	  if test -f "$$i"; then \
-	    echo "$(subdir)/$$i"; \
-	  else \
-	    echo "$$sdir/$$i"; \
-	  fi; \
-	done >> $(top_builddir)/cscope.files
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
-	  if test "$$subdir" = .; then :; else \
-	    $(am__make_dryrun) \
-	      || test -d "$(distdir)/$$subdir" \
-	      || $(MKDIR_P) "$(distdir)/$$subdir" \
-	      || exit 1; \
-	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
-	    $(am__relativize); \
-	    new_distdir=$$reldir; \
-	    dir1=$$subdir; dir2="$(top_distdir)"; \
-	    $(am__relativize); \
-	    new_top_distdir=$$reldir; \
-	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
-	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
-	    ($(am__cd) $$subdir && \
-	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir="$$new_top_distdir" \
-	        distdir="$$new_distdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
-		am__skip_mode_fix=: \
-	        distdir) \
-	      || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-recursive
-all-am: Makefile $(LTLIBRARIES)
-installdirs: installdirs-recursive
-installdirs-am:
-	for dir in "$(DESTDIR)$(libdir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: install-recursive
-install-exec: install-exec-recursive
-install-data: install-data-recursive
-uninstall: uninstall-recursive
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-recursive
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-recursive
-
-clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
-	mostlyclean-am
-
-distclean: distclean-recursive
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-recursive
-
-dvi-am:
-
-html: html-recursive
-
-html-am:
-
-info: info-recursive
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-recursive
-
-install-dvi-am:
-
-install-exec-am: install-libLTLIBRARIES
-
-install-html: install-html-recursive
-
-install-html-am:
-
-install-info: install-info-recursive
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-recursive
-
-install-pdf-am:
-
-install-ps: install-ps-recursive
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-recursive
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-recursive
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-recursive
-
-pdf-am:
-
-ps: ps-recursive
-
-ps-am:
-
-uninstall-am: uninstall-libLTLIBRARIES
-
-.MAKE: $(am__recursive_targets) install-am install-strip
-
-.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
-	check-am clean clean-generic clean-libLTLIBRARIES \
-	clean-libtool cscopelist-am ctags ctags-am distclean \
-	distclean-compile distclean-generic distclean-libtool \
-	distclean-tags distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am \
-	install-libLTLIBRARIES install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs installdirs-am maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags tags-am uninstall uninstall-am uninstall-libLTLIBRARIES
-
-
-# swap the 'awk' line for this:
-# awk '{if($$1!="deprecated") print $$1}'` ; \
-# to not generate the wrappers for deprecated functions
-vipsc++.cc:
-	packages=`vips list packages | \
-	  awk '{print $$1}'` ; \
-	  echo > vipsc++.cc ; \
-	  for name in $$packages; do \
-	    echo "// bodies for package $$name" >> vipsc++.cc ; \
-	    vips cppc $$name >> vipsc++.cc ; \
-	    echo >> vipsc++.cc ; \
-	  done 
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/VDisplay.cc vips-7.38.5/libvipsCC/VDisplay.cc
--- vips-7.38.5-vanilla/libvipsCC/VDisplay.cc	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/VDisplay.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,152 +0,0 @@
-// Object part of VDisplay class
-
-/*
-
-    Copyright (C) 1991-2001 The National Gallery
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <cstdlib>
-#include <cstring>
-
-#include <vips/vips.h>
-#include <vips/internal.h>
-
-#include <vips/vipscpp.h>
-
-#ifdef WITH_DMALLOC
-#include <dmalloc.h>
-#endif /*WITH_DMALLOC*/
-
-VIPS_NAMESPACE_START
-
-/* Refcounting stuff first.
- */
-
-// Free an im_col_display
-static void
-free_display( im_col_display *d )
-{
-}
-
-// Dupe an im_col_display
-static im_col_display *
-dup_display( im_col_display *in ) throw( VError )
-{
-	return( in );
-}
-
-// Remove lut
-void VDisplay::refblock::cleanlut()
-{
-	if( luts ) {
-		im_free( luts );
-		luts = 0;
-	}
-}
-
-// Remove attached things
-void VDisplay::refblock::cleanref()
-{
-	if( disp && priv ) {
-		free_display( disp );
-		disp = 0;
-		priv = 0;
-	}
-	cleanlut();
-}
-
-// Get ready to write to disp
-void VDisplay::refblock::wready() throw( VError )
-{
-	cleanlut();
-	if( !priv ) {
-		disp = dup_display( disp );
-		priv = 1;
-	}
-}
-
-// Check that luts are up-to-date
-void VDisplay::refblock::cluts() throw( VError )
-{
-}
-
-VDisplay::~VDisplay()
-{
-	ref->nrefs--;
-	if( !ref->nrefs ) 
-		delete ref;
-}
-
-VDisplay &VDisplay::operator=( const VDisplay &a )
-{ 
-	ref->nrefs--;
-
-	if( ref->nrefs > 0 ) 
-		// Need fresh
-		ref = new refblock;
-	else 
-		// Recycle old
-		ref->cleanref();
-
-	ref = a.ref; 
-	ref->nrefs++; 
-	
-	return( *this ); 
-}
-
-VDisplay::VDisplay( const char *name ) throw( VError )
-{
-	// Install display
-	ref = new refblock;
-	ref->disp = NULL;
-}
-
-VDisplay::VDisplay()
-{
-	// Just use sRGB
-	ref = new refblock;
-	ref->disp = im_col_displays( 7 );
-}
-
-/*
-
-Setters and getters. We used to have a lot of code of the form:
- 
-float &VDisplay::YCW()
-	{ ref->wready(); return( ((im_col_display*)ref->disp)->d_YCW ); }
-
-This should be split to separate setters/getters so we can exploit const. Too 
-annoying to do this on such a useless class (I'm certain no one used these 
-functions anyway), fix in vips8.
-
- */
-
-VIPS_NAMESPACE_END
-
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/VError.cc vips-7.38.5/libvipsCC/VError.cc
--- vips-7.38.5-vanilla/libvipsCC/VError.cc	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/VError.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,100 +0,0 @@
-// Code for error type
-
-/*
-
-    Copyright (C) 1991-2001 The National Gallery
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <cstdio>
-#include <cstdlib>
-
-#include <iostream>
-
-#include <vips/vips.h>
-
-#include <vips/vipscpp.h>
-
-#ifdef WITH_DMALLOC
-#include <dmalloc.h>
-#endif /*WITH_DMALLOC*/
-
-VIPS_NAMESPACE_START
-
-void VError::perror() 
-{ 
-	std::cerr << _what; 
-	exit( 1 );
-}
-
-void VError::perror( const char *name ) 
-{ 
-	std::cerr << name << ": " << _what; 
-	exit( 1 );
-}
-
-// Add a new bit to the end of the error buffer
-VError &VError::app( const int i )
-{ 
-	char buf[ 256 ];
-
-	sprintf( buf, "%d", i );
-	_what += buf;
-
-	return( *this );
-}
-
-VError &VError::app( std::string txt ) 
-{ 
-	_what += txt; 
-
-	return( *this );
-}; 
-
-void VError::ostream_print( std::ostream &file ) const
-{
-	file << _what;
-}
-
-void verror( std::string str ) throw( VError )
-{
-	VError err;
-
-	err.app( "VIPS error: " );
-	if( str == "" ) {
-		err.app( im_error_buffer() );
-		im_error_clear();
-	}
-	else 
-		err.app( str ).app( "\n" );
-
-	throw( err );
-}
-
-VIPS_NAMESPACE_END
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/VImage.cc vips-7.38.5/libvipsCC/VImage.cc
--- vips-7.38.5-vanilla/libvipsCC/VImage.cc	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/VImage.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,524 +0,0 @@
-// Object part of VImage class
-
-/*
-
-    Copyright (C) 1991-2001 The National Gallery
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <cstdlib>
-#include <cstring>
-#include <cstdio>
-
-#include <vips/vips.h>
-#include <vips/internal.h>
-#include <vips/debug.h>
-
-#include <vips/vipscpp.h>
-
-#ifdef WITH_DMALLOC
-#include <dmalloc.h>
-#endif /*WITH_DMALLOC*/
-
-/*
-#define DEBUG
- */
-
-VIPS_NAMESPACE_START
-
-/* Useful to have these as C++ functions.
- */
-bool init( const char *argv0 )
-{
-	return( vips_init( argv0 ) == 0 ); 
-}
-
-void shutdown()
-{
-	vips_shutdown(); 
-}
-
-void VImage::refblock::debug_print()
-{
-	std::list<refblock *>::iterator i;
-
-	printf( "refblock %p:\n", this );
-	printf( "  im = %p", im );
-	if( im && im->filename ) 
-		printf( " (im->filename = \"%s\")", im->filename );
-	printf( "\n" );
-	printf( "  close_on_delete = %d\n", close_on_delete );
-	printf( "  nrefs (refs to us) = %d\n", nrefs );
-	printf( "  orefs (refs we make) = refblocks " );
-	for( i = orefs.begin(); i != orefs.end(); i++ )
-		printf( "%p ", *i );
-	printf( "\n" );
-}
-
-// dump all refblocks for debugging
-void VImage::print_all()
-{
-#ifdef DEBUG
-	std::list<VImage::refblock *>::iterator i;
-
-	printf( "*** VImage::refblock::print_all() start\n" );
-	for( i = all_refblock.begin(); i != all_refblock.end(); i++ )
-		(*i)->debug_print();
-	printf( "*** VImage::refblock::print_all() end\n" );
-#endif /*DEBUG*/
-}
-
-// easy call from C version
-void im__ccp_print_all()
-{
-	VImage::print_all();
-}
-
-// constructor
-VImage::refblock::refblock() 
-{
-	im = 0; 
-	close_on_delete = 1; 
-	nrefs = 1; 
-
-#ifdef DEBUG
-	all_refblock.push_front( this );
-#endif /*DEBUG*/
-}
-
-// Add a ref - this (output image) depends upon VipsImage in
-void VImage::refblock::addref( refblock *in ) throw( VError )
-{
-	if( this == in )
-		verror( "sanity failure" );
-
-	in->nrefs++;
-	orefs.push_front( in );
-}
-
-VImage::refblock::~refblock() throw( VError )
-{
-#ifdef DEBUG
-	printf( "VImage::refblock::removeref(): death!\n" );
-	debug_print();
-#endif /*DEBUG*/
-
-	std::list<refblock *>::iterator i;
-
-	if( close_on_delete && im ) {
-		if( im_close( im ) )
-			verror();
-		im = 0;
-	}
-
-	// remove any refs we have ... may trigger other destructs in turn
-	for( i = orefs.begin(); i != orefs.end(); i++ )
-		(*i)->removeref();
-
-#ifdef DEBUG
-	all_refblock.remove( this );
-#endif /*DEBUG*/
-}
-
-// Remove a ref
-void VImage::refblock::removeref() throw( VError )
-{
-	nrefs--;
-	if( nrefs < 0 )
-		verror( "too many closes!" );		
-	if( nrefs == 0 ) 
-		delete this;
-}
-
-// Init with name ... mode defaults to "rd"
-VImage::VImage( const char *name, const char *mode ) throw( VError )
-{
-	_ref = new refblock;
-
-	if( !(_ref->im = im_open( name, mode )) )
-		verror();
-	_ref->close_on_delete = 1;
-
-#ifdef DEBUG
-	printf( "VImage::VImage( \"%s\", \"%s\" )\n", name, mode );
-	_ref->debug_print();
-#endif /*DEBUG*/
-}
-
-// Build a VImage from an VipsImage structure
-VImage::VImage( _VipsImage *in )
-{
-	_ref = new refblock;
-	
-	_ref->im = in;
-	_ref->close_on_delete = 0;
-
-#ifdef DEBUG
-	printf( "VImage::VImage( VipsImage* %p )\n", in );
-	_ref->debug_print();
-#endif /*DEBUG*/
-}
-
-// Build from memory buffer
-VImage::VImage( void *buffer, int width, int height, 
-	int bands, TBandFmt format ) throw( VError )
-{
-	_ref = new refblock;
-
-	if( !(_ref->im = im_image( buffer, width, height, 
-		bands, VipsBandFmt( format ) )) )
-		verror();
-	_ref->close_on_delete = 1;
-
-#ifdef DEBUG
-	printf( "VImage::VImage( void* %p, %d, %d )\n", 
-		buffer, width, height );
-	_ref->debug_print();
-#endif /*DEBUG*/
-}
-
-// Empty init ... means open intermediate
-VImage::VImage() throw( VError )
-{
-	static int id = 0;
-	char filename[256];
-
-	_ref = new refblock;
-
-	/* This is not 100% safe if VIPS threading is not implemented on this
-	 * platform ... but it doesn't really matter.
-	 */
-	g_mutex_lock( im__global_lock );
-	im_snprintf( filename, 256, "intermediate image #%d", id++ );
-	g_mutex_unlock( im__global_lock );
-
-	if( !(_ref->im = im_open( filename, "p" )) )
-		verror();
-	_ref->close_on_delete = 1;
-
-#ifdef DEBUG
-	printf( "VImage::VImage()\n" ); 
-	_ref->debug_print();
-#endif /*DEBUG*/
-}
-
-// Copy constructor
-VImage::VImage( const VImage &a ) 
-{ 
-	_ref = a._ref; 
-	_ref->nrefs++; 
-}
-
-// Assignment
-VImage &VImage::operator=( const VImage &a ) throw( VError )
-{ 
-	_ref->removeref(); 
-	_ref = a._ref; 
-	_ref->nrefs++; 
-	
-	return( *this ); 
-}
-
-// Extract underlying data pointer
-void *VImage::data() const throw( VError )
-{
-	if( im_incheck( _ref->im ) )
-		verror();
-	
-	return( (void *) _ref->im->data );
-}
-
-void VImage::debug_print()
-{
-	im_printdesc( image() );
-}
-
-// Like jpeg2vips, but convert to a disc file rather than to memory
-// We can handle huge files without running out of RAM
-VImage VImage::convert2disc( const char* convert, 
-	const char* in, const char* disc ) throw( VError )
-{
-	VImage out( disc, "w" );
-
-	Vargv _vec( convert );
-
-	_vec.data(0) = (im_object) in;
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// Write this to a VImage
-VImage VImage::write( VImage out ) throw( VError )
-{
-	if( im_copy( _ref->im, out._ref->im ) )
-		verror();
-	out._ref->addref( _ref );
-
-	return( out );
-}
-
-VImage VImage::write( const char *name ) throw( VError )
-{
-	VImage out( name, "w" );
-
-	if( im_copy( _ref->im, out._ref->im ) )
-		verror();
-	out._ref->addref( _ref );
-
-	return( out );
-}
-
-VImage VImage::write() throw( VError )
-{
-	VImage out( "VImage:w1", "t" );
-
-	if( im_copy( _ref->im, out._ref->im ) )
-		verror();
-	out._ref->addref( _ref );
-
-	return( out );
-}
-
-// Projection functions to get header fields
-int VImage::Xsize() { return( _ref->im->Xsize ); }
-int VImage::Ysize() { return( _ref->im->Ysize ); }
-int VImage::Bands() { return( _ref->im->Bands ); }
-VImage::TBandFmt VImage::BandFmt() 
-	{ return( (TBandFmt) _ref->im->BandFmt ); }
-VImage::TCoding VImage::Coding() 
-	{ return( (TCoding) _ref->im->Coding ); }
-VImage::TType VImage::Type() { return( (TType) _ref->im->Type ); }
-float VImage::Xres() { return( _ref->im->Xres ); }
-float VImage::Yres() { return( _ref->im->Yres ); }
-int VImage::Length() { return( _ref->im->Length ); }
-VImage::TCompression VImage::Compression() 
-	{ return( (TCompression) _ref->im->Compression ); }
-short VImage::Level() { return( _ref->im->Level ); }
-int VImage::Xoffset() { return( _ref->im->Xoffset ); }
-int VImage::Yoffset() { return( _ref->im->Yoffset ); }
-
-// Derived fields
-const char *VImage::filename() { return( _ref->im->filename ); }
-const char *VImage::Hist() { return( im_history_get( _ref->im ) ); }
-
-// metadata
-
-// base functionality
-void VImage::meta_set( const char *field, GValue *value ) throw( VError )
-{
-	if( im_meta_set( _ref->im, field, value ) )
-		verror();
-}
-
-gboolean VImage::meta_remove( const char *field ) 
-{
-	return( im_meta_remove( _ref->im, field ) );
-}
-
-void VImage::meta_get( const char *field, GValue *value_copy ) throw( VError )
-{
-	if( im_meta_get( _ref->im, field, value_copy ) )
-		verror();
-}
-
-GType VImage::meta_get_typeof( const char *field ) 
-{
-	return( im_meta_get_typeof( _ref->im, field ) );
-}
-
-// convenience functions
-int VImage::meta_get_int( const char *field ) 
-	throw( VError )
-{
-	int result;
-
-	if( im_meta_get_int( _ref->im, field, &result ) )
-		verror();
-
-	return( result );
-}
-
-double VImage::meta_get_double( const char *field ) 
-	throw( VError )
-{
-	double result;
-
-	if( im_meta_get_double( _ref->im, field, &result ) )
-		verror();
-
-	return( result );
-}
-
-const char *VImage::meta_get_string( const char *field ) 
-	throw( VError )
-{
-	const char *result;
-
-	if( im_meta_get_string( _ref->im, field, &result ) )
-		verror();
-
-	return( result );
-}
-
-void *VImage::meta_get_area( const char *field ) throw( VError )
-{
-	void *result;
-
-	if( im_meta_get_area( _ref->im, field, &result ) )
-		verror();
-
-	return( result );
-}
-
-void *VImage::meta_get_blob( const char *field, size_t *length ) throw( VError )
-{
-	void *result;
-
-	if( im_meta_get_blob( _ref->im, field, &result, length ) )
-		verror();
-
-	return( result );
-}
-
-void VImage::meta_set( const char *field, int value ) 
-	throw( VError )
-{
-	if( im_meta_set_int( _ref->im, field, value ) )
-		verror();
-}
-
-void VImage::meta_set( const char *field, double value ) 
-	throw( VError )
-{
-	if( im_meta_set_double( _ref->im, field, value ) )
-		verror();
-}
-
-void VImage::meta_set( const char *field, const char *value ) 
-	throw( VError )
-{
-	if( im_meta_set_string( _ref->im, field, value ) )
-		verror();
-}
-
-void VImage::meta_set( const char *field, 
-	VCallback free_fn, void *value ) 
-	throw( VError )
-{
-	if( im_meta_set_area( _ref->im, field, free_fn, value ) )
-		verror();
-}
-
-void VImage::meta_set( const char *field, 
-	VCallback free_fn, void *value, size_t length ) 
-	throw( VError )
-{
-	if( im_meta_set_blob( _ref->im, field, free_fn, value, length ) )
-		verror();
-}
-
-// Set header fields and setbuf() in one go.
-void VImage::initdesc( int x, int y, int b,
-	TBandFmt f, TCoding c, TType t, float xr, float yr, int xo, int yo )
-	throw( VError )
-{
-	im_initdesc( _ref->im, x, y, b, 0, 
-		VipsBandFmt( f ), VipsCoding( c ), VipsType( t ), 
-		xr, yr, xo, yo );
-	if( im_setupout( _ref->im ) )
-		verror();
-}
-
-// Create a Vargv from a name
-Vargv::Vargv( const char *name )
-{
-	im_function *f = im_find_function( (char *) name );
-	
-	if( !f )
-		verror();
-
-	fn = (im__function *) f;
-	base = new im_object[f->argc]; 
-	if( im_allocate_vargv( f, base ) ) {
-		delete[] base;
-		verror();
-	}
-}
-
-// Destroy a Vargv
-Vargv::~Vargv()
-{
-	im_function *f = (im_function *) fn;
-
-	// free any memory allocated for input vectors
-	// this is the stuff allocated in each function during _object* build,
-	// see vipsc++.cc
-	for( int i = 0; i < f->argc; i++ ) {
-		im_type_desc *ty = f->argv[i].desc;
-
-		if( !(ty->flags & IM_TYPE_OUTPUT) ) {
-			if( strcmp( ty->type, IM_TYPE_IMAGEVEC ) == 0 ||
-				strcmp( ty->type, IM_TYPE_DOUBLEVEC ) == 0 ||
-				strcmp( ty->type, IM_TYPE_INTVEC ) == 0 ) {
-				// will work for doublevec and intvec too
-				im_imagevec_object *io = 
-					(im_imagevec_object *) base[i];
-
-				if( io->vec ) {
-					delete[] io->vec;
-					io->vec = NULL;
-				}
-			}
-			else if( strcmp( ty->type, IM_TYPE_INTERPOLATE ) == 0 )
-				g_object_unref( base[i] );
-		}
-	}
-
-	im_free_vargv( f, base );
-	delete[] base;
-}
-
-// Call the function
-void
-Vargv::call()
-{
-	im_function *f = (im_function *) fn;
-
-	if( f->disp( base ) ) 
-		verror();
-}
-
-/* Insert automatically generated wrappers for VIPS image processing 
- * functions.
- */
-#include "vipsc++.cc"
-
-VIPS_NAMESPACE_END
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/vipsc++.cc vips-7.38.5/libvipsCC/vipsc++.cc
--- vips-7.38.5-vanilla/libvipsCC/vipsc++.cc	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/vipsc++.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,6202 +0,0 @@
-
-// bodies for package arithmetic
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_abs: absolute value
-VImage VImage::abs() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_abs" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_acostra: acos of image (result in degrees)
-VImage VImage::acos() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_acostra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_add: add two images
-VImage VImage::add( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_add" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_asintra: asin of image (result in degrees)
-VImage VImage::asin() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_asintra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_atantra: atan of image (result in degrees)
-VImage VImage::atan() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_atantra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_avg: average value of image
-double VImage::avg() throw( VError )
-{
-	VImage in = *this;
-	double value;
-
-	Vargv _vec( "im_avg" );
-
-	_vec.data(0) = in.image();
-	_vec.call();
-	value = *((double*)_vec.data(1));
-
-	return( value );
-}
-
-// im_point: interpolate value at single point
-double VImage::point( char* interpolate, double x, double y, int band ) throw( VError )
-{
-	VImage in = *this;
-	double out;
-
-	Vargv _vec( "im_point" );
-
-	_vec.data(0) = in.image();
-	if( vips__input_interpolate_init( &_vec.data(1), interpolate ) )
-		verror();
-	*((double*) _vec.data(2)) = x;
-	*((double*) _vec.data(3)) = y;
-	*((int*) _vec.data(4)) = band;
-	_vec.call();
-	out = *((double*)_vec.data(5));
-
-	return( out );
-}
-
-// im_point_bilinear: interpolate value at single point, linearly
-double VImage::point_bilinear( double x, double y, int band ) throw( VError )
-{
-	VImage in = *this;
-	double val;
-
-	Vargv _vec( "im_point_bilinear" );
-
-	_vec.data(0) = in.image();
-	*((double*) _vec.data(1)) = x;
-	*((double*) _vec.data(2)) = y;
-	*((int*) _vec.data(3)) = band;
-	_vec.call();
-	val = *((double*)_vec.data(4));
-
-	return( val );
-}
-
-// im_bandmean: average image bands
-VImage VImage::bandmean() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_bandmean" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_ceil: round to smallest integer value not less than
-VImage VImage::ceil() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_ceil" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_costra: cos of image (angles in degrees)
-VImage VImage::cos() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_costra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_cross_phase: phase of cross power spectrum of two complex images
-VImage VImage::cross_phase( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_cross_phase" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_deviate: standard deviation of image
-double VImage::deviate() throw( VError )
-{
-	VImage in = *this;
-	double value;
-
-	Vargv _vec( "im_deviate" );
-
-	_vec.data(0) = in.image();
-	_vec.call();
-	value = *((double*)_vec.data(1));
-
-	return( value );
-}
-
-// im_divide: divide two images
-VImage VImage::divide( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_divide" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_exp10tra: 10^pel of image
-VImage VImage::exp10() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_exp10tra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_expntra: x^pel of image
-VImage VImage::expn( double x ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_expntra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = x;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_expntra_vec: [x,y,z]^pel of image
-VImage VImage::expn( std::vector<double> v ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_expntra_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = v.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[v.size()];
-	for( unsigned int i = 0; i < v.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = v[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_exptra: e^pel of image
-VImage VImage::exp() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_exptra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_floor: round to largest integer value not greater than
-VImage VImage::floor() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_floor" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_invert: photographic negative
-VImage VImage::invert() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_invert" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_lintra: calculate a*in + b = outfile
-VImage VImage::lin( double a, double b ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_lintra" );
-
-	*((double*) _vec.data(0)) = a;
-	_vec.data(1) = in.image();
-	*((double*) _vec.data(2)) = b;
-	_vec.data(3) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_linreg: pixelwise linear regression
-VImage VImage::linreg( std::vector<VImage> ins, std::vector<double> xs ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_linreg" );
-
-	((im_imagevec_object*) _vec.data(0))->n = ins.size();
-	((im_imagevec_object*) _vec.data(0))->vec = new IMAGE *[ins.size()];
-	for( unsigned int i = 0; i < ins.size(); i++ )
-		((im_imagevec_object*) _vec.data(0))->vec[i] = ins[i].image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = xs.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[xs.size()];
-	for( unsigned int i = 0; i < xs.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = xs[i];
-	_vec.call();
-	for( unsigned int i = 0; i < ins.size(); i++ )
-		out._ref->addref( ins[i]._ref );
-
-	return( out );
-}
-
-// im_lintra_vec: calculate a*in + b -> out, a and b vectors
-VImage VImage::lin( std::vector<double> a, std::vector<double> b ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_lintra_vec" );
-
-	((im_doublevec_object*) _vec.data(0))->n = a.size();
-	((im_doublevec_object*) _vec.data(0))->vec = new double[a.size()];
-	for( unsigned int i = 0; i < a.size(); i++ )
-		((im_doublevec_object*) _vec.data(0))->vec[i] = a[i];
-	_vec.data(1) = in.image();
-	((im_doublevec_object*) _vec.data(2))->n = b.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[b.size()];
-	for( unsigned int i = 0; i < b.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = b[i];
-	_vec.data(3) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_log10tra: log10 of image
-VImage VImage::log10() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_log10tra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_logtra: ln of image
-VImage VImage::log() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_logtra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_max: maximum value of image
-double VImage::max() throw( VError )
-{
-	VImage in = *this;
-	double value;
-
-	Vargv _vec( "im_max" );
-
-	_vec.data(0) = in.image();
-	_vec.call();
-	value = *((double*)_vec.data(1));
-
-	return( value );
-}
-
-// im_maxpos: position of maximum value of image
-std::complex<double> VImage::maxpos() throw( VError )
-{
-	VImage in = *this;
-	std::complex<double> position;
-
-	Vargv _vec( "im_maxpos" );
-
-	_vec.data(0) = in.image();
-	_vec.call();
-	position = *((std::complex<double>*)_vec.data(1));
-
-	return( position );
-}
-
-// im_maxpos_avg: position of maximum value of image, averaging in case of draw
-double VImage::maxpos_avg( double& y, double& out ) throw( VError )
-{
-	VImage in = *this;
-	double x;
-
-	Vargv _vec( "im_maxpos_avg" );
-
-	_vec.data(0) = in.image();
-	_vec.call();
-	x = *((double*)_vec.data(1));
-	y = *((double*)_vec.data(2));
-	out = *((double*)_vec.data(3));
-
-	return( x );
-}
-
-// im_measure: measure averages of a grid of patches
-VDMask VImage::measure( int x, int y, int w, int h, int h_patches, int v_patches ) throw( VError )
-{
-	VImage in = *this;
-	VDMask mask;
-
-	Vargv _vec( "im_measure" );
-
-	_vec.data(0) = in.image();
-	((im_mask_object*) _vec.data(1))->name = (char*)"noname";
-	*((int*) _vec.data(2)) = x;
-	*((int*) _vec.data(3)) = y;
-	*((int*) _vec.data(4)) = w;
-	*((int*) _vec.data(5)) = h;
-	*((int*) _vec.data(6)) = h_patches;
-	*((int*) _vec.data(7)) = v_patches;
-	_vec.call();
-	mask.embed( (DOUBLEMASK *)((im_mask_object*)_vec.data(1))->mask );
-
-	return( mask );
-}
-
-// im_min: minimum value of image
-double VImage::min() throw( VError )
-{
-	VImage in = *this;
-	double value;
-
-	Vargv _vec( "im_min" );
-
-	_vec.data(0) = in.image();
-	_vec.call();
-	value = *((double*)_vec.data(1));
-
-	return( value );
-}
-
-// im_minpos: position of minimum value of image
-std::complex<double> VImage::minpos() throw( VError )
-{
-	VImage in = *this;
-	std::complex<double> position;
-
-	Vargv _vec( "im_minpos" );
-
-	_vec.data(0) = in.image();
-	_vec.call();
-	position = *((std::complex<double>*)_vec.data(1));
-
-	return( position );
-}
-
-// im_multiply: multiply two images
-VImage VImage::multiply( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_multiply" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_powtra: pel^x of image
-VImage VImage::pow( double x ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_powtra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = x;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_powtra_vec: pel^[x,y,z] of image
-VImage VImage::pow( std::vector<double> v ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_powtra_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = v.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[v.size()];
-	for( unsigned int i = 0; i < v.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = v[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_recomb: linear recombination with mask
-VImage VImage::recomb( VDMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_recomb" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().dptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_remainder: remainder after integer division
-VImage VImage::remainder( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_remainder" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_remainderconst: remainder after integer division by a constant
-VImage VImage::remainder( double x ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_remainderconst" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = x;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_remainder_vec: remainder after integer division by a vector of constants
-VImage VImage::remainder( std::vector<double> x ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_remainder_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = x.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[x.size()];
-	for( unsigned int i = 0; i < x.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = x[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_rint: round to nearest integer value
-VImage VImage::rint() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_rint" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_sign: unit vector in direction of value
-VImage VImage::sign() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_sign" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_sintra: sin of image (angles in degrees)
-VImage VImage::sin() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_sintra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_stats: many image statistics in one pass
-VDMask VImage::stats() throw( VError )
-{
-	VImage in = *this;
-	VDMask statistics;
-
-	Vargv _vec( "im_stats" );
-
-	_vec.data(0) = in.image();
-	((im_mask_object*) _vec.data(1))->name = (char*)"noname";
-	_vec.call();
-	statistics.embed( (DOUBLEMASK *)((im_mask_object*)_vec.data(1))->mask );
-
-	return( statistics );
-}
-
-// im_subtract: subtract two images
-VImage VImage::subtract( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_subtract" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_tantra: tan of image (angles in degrees)
-VImage VImage::tan() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_tantra" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-
-// bodies for package cimg
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_greyc: noise-removing filter
-VImage VImage::greyc( int iterations, double amplitude, double sharpness, double anisotropy, double alpha, double sigma, double dl, double da, double gauss_prec, int interpolation, int fast_approx ) throw( VError )
-{
-	VImage src = *this;
-	VImage dst;
-
-	Vargv _vec( "im_greyc" );
-
-	_vec.data(0) = src.image();
-	_vec.data(1) = dst.image();
-	*((int*) _vec.data(2)) = iterations;
-	*((double*) _vec.data(3)) = amplitude;
-	*((double*) _vec.data(4)) = sharpness;
-	*((double*) _vec.data(5)) = anisotropy;
-	*((double*) _vec.data(6)) = alpha;
-	*((double*) _vec.data(7)) = sigma;
-	*((double*) _vec.data(8)) = dl;
-	*((double*) _vec.data(9)) = da;
-	*((double*) _vec.data(10)) = gauss_prec;
-	*((int*) _vec.data(11)) = interpolation;
-	*((int*) _vec.data(12)) = fast_approx;
-	_vec.call();
-	dst._ref->addref( src._ref );
-
-	return( dst );
-}
-
-// im_greyc_mask: noise-removing filter, with a mask
-VImage VImage::greyc_mask( VImage mask, int iterations, double amplitude, double sharpness, double anisotropy, double alpha, double sigma, double dl, double da, double gauss_prec, int interpolation, int fast_approx ) throw( VError )
-{
-	VImage src = *this;
-	VImage dst;
-
-	Vargv _vec( "im_greyc_mask" );
-
-	_vec.data(0) = src.image();
-	_vec.data(1) = dst.image();
-	_vec.data(2) = mask.image();
-	*((int*) _vec.data(3)) = iterations;
-	*((double*) _vec.data(4)) = amplitude;
-	*((double*) _vec.data(5)) = sharpness;
-	*((double*) _vec.data(6)) = anisotropy;
-	*((double*) _vec.data(7)) = alpha;
-	*((double*) _vec.data(8)) = sigma;
-	*((double*) _vec.data(9)) = dl;
-	*((double*) _vec.data(10)) = da;
-	*((double*) _vec.data(11)) = gauss_prec;
-	*((int*) _vec.data(12)) = interpolation;
-	*((int*) _vec.data(13)) = fast_approx;
-	_vec.call();
-	dst._ref->addref( src._ref );
-	dst._ref->addref( mask._ref );
-
-	return( dst );
-}
-
-
-// bodies for package colour
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_LCh2Lab: convert LCh to Lab
-VImage VImage::LCh2Lab() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_LCh2Lab" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_LCh2UCS: convert LCh to UCS
-VImage VImage::LCh2UCS() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_LCh2UCS" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_Lab2LCh: convert Lab to LCh
-VImage VImage::Lab2LCh() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_Lab2LCh" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_Lab2LabQ: convert Lab to LabQ
-VImage VImage::Lab2LabQ() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_Lab2LabQ" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_Lab2LabS: convert Lab to LabS
-VImage VImage::Lab2LabS() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_Lab2LabS" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_Lab2UCS: convert Lab to UCS
-VImage VImage::Lab2UCS() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_Lab2UCS" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_Lab2XYZ: convert D65 Lab to XYZ
-VImage VImage::Lab2XYZ() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_Lab2XYZ" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_Lab2XYZ_temp: convert Lab to XYZ, with a specified colour temperature
-VImage VImage::Lab2XYZ_temp( double X0, double Y0, double Z0 ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_Lab2XYZ_temp" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = X0;
-	*((double*) _vec.data(3)) = Y0;
-	*((double*) _vec.data(4)) = Z0;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_Lab2disp: convert Lab to displayable
-VImage VImage::Lab2disp( VDisplay disp ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_Lab2disp" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = disp.disp();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_LabQ2LabS: convert LabQ to LabS
-VImage VImage::LabQ2LabS() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_LabQ2LabS" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_LabQ2Lab: convert LabQ to Lab
-VImage VImage::LabQ2Lab() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_LabQ2Lab" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_LabQ2XYZ: convert LabQ to XYZ
-VImage VImage::LabQ2XYZ() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_LabQ2XYZ" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_LabQ2disp: convert LabQ to displayable
-VImage VImage::LabQ2disp( VDisplay disp ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_LabQ2disp" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = disp.disp();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_LabS2LabQ: convert LabS to LabQ
-VImage VImage::LabS2LabQ() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_LabS2LabQ" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_LabS2Lab: convert LabS to Lab
-VImage VImage::LabS2Lab() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_LabS2Lab" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_UCS2LCh: convert UCS to LCh
-VImage VImage::UCS2LCh() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_UCS2LCh" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_UCS2Lab: convert UCS to Lab
-VImage VImage::UCS2Lab() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_UCS2Lab" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_UCS2XYZ: convert UCS to XYZ
-VImage VImage::UCS2XYZ() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_UCS2XYZ" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_XYZ2Lab: convert D65 XYZ to Lab
-VImage VImage::XYZ2Lab() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_XYZ2Lab" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_XYZ2Lab_temp: convert XYZ to Lab, with a specified colour temperature
-VImage VImage::XYZ2Lab_temp( double X0, double Y0, double Z0 ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_XYZ2Lab_temp" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = X0;
-	*((double*) _vec.data(3)) = Y0;
-	*((double*) _vec.data(4)) = Z0;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_XYZ2UCS: convert XYZ to UCS
-VImage VImage::XYZ2UCS() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_XYZ2UCS" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_XYZ2Yxy: convert XYZ to Yxy
-VImage VImage::XYZ2Yxy() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_XYZ2Yxy" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_XYZ2disp: convert XYZ to displayble
-VImage VImage::XYZ2disp( VDisplay disp ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_XYZ2disp" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = disp.disp();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_XYZ2sRGB: convert XYZ to sRGB
-VImage VImage::XYZ2sRGB() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_XYZ2sRGB" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_Yxy2XYZ: convert Yxy to XYZ
-VImage VImage::Yxy2XYZ() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_Yxy2XYZ" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_dE00_fromLab: calculate delta-E CIE2000 for two Lab images
-VImage VImage::dE00_fromLab( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_dE00_fromLab" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_dECMC_fromLab: calculate delta-E CMC(1:1) for two Lab images
-VImage VImage::dECMC_fromLab( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_dECMC_fromLab" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_dECMC_fromdisp: calculate delta-E CMC(1:1) for two displayable images
-VImage VImage::dECMC_fromdisp( VImage in2, VDisplay disp ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_dECMC_fromdisp" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.data(3) = disp.disp();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_dE_fromLab: calculate delta-E for two Lab images
-VImage VImage::dE_fromLab( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_dE_fromLab" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_dE_fromXYZ: calculate delta-E for two XYZ images
-VImage VImage::dE_fromXYZ( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_dE_fromXYZ" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_dE_fromdisp: calculate delta-E for two displayable images
-VImage VImage::dE_fromdisp( VImage in2, VDisplay disp ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_dE_fromdisp" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.data(3) = disp.disp();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_disp2Lab: convert displayable to Lab
-VImage VImage::disp2Lab( VDisplay disp ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_disp2Lab" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = disp.disp();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_disp2XYZ: convert displayable to XYZ
-VImage VImage::disp2XYZ( VDisplay disp ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_disp2XYZ" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = disp.disp();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_float2rad: convert float to Radiance packed
-VImage VImage::float2rad() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_float2rad" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_icc_ac2rc: convert LAB from AC to RC using an ICC profile
-VImage VImage::icc_ac2rc( char* profile ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_icc_ac2rc" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = (im_object) profile;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_icc_export_depth: convert a float LAB to device space with an ICC profile
-VImage VImage::icc_export_depth( int depth, char* output_profile, int intent ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_icc_export_depth" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = depth;
-	_vec.data(3) = (im_object) output_profile;
-	*((int*) _vec.data(4)) = intent;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_icc_import: convert a device image to float LAB with an ICC profile
-VImage VImage::icc_import( char* input_profile, int intent ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_icc_import" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = (im_object) input_profile;
-	*((int*) _vec.data(3)) = intent;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_icc_import_embedded: convert a device image to float LAB using the embedded profile
-VImage VImage::icc_import_embedded( int intent ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_icc_import_embedded" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = intent;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_icc_transform: convert between two device images with a pair of ICC profiles
-VImage VImage::icc_transform( char* input_profile, char* output_profile, int intent ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_icc_transform" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = (im_object) input_profile;
-	_vec.data(3) = (im_object) output_profile;
-	*((int*) _vec.data(4)) = intent;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_lab_morph: morph colourspace of a LAB image
-VImage VImage::lab_morph( VDMask greyscale, double L_offset, double L_scale, double a_scale, double b_scale ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_lab_morph" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = greyscale.mask().dptr;
-	*((double*) _vec.data(3)) = L_offset;
-	*((double*) _vec.data(4)) = L_scale;
-	*((double*) _vec.data(5)) = a_scale;
-	*((double*) _vec.data(6)) = b_scale;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_rad2float: convert Radiance packed to float
-VImage VImage::rad2float() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_rad2float" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_sRGB2XYZ: convert sRGB to XYZ
-VImage VImage::sRGB2XYZ() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_sRGB2XYZ" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-
-// bodies for package conversion
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_gaussnoise: generate image of gaussian noise with specified statistics
-VImage VImage::gaussnoise( int xsize, int ysize, double mean, double sigma ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_gaussnoise" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = xsize;
-	*((int*) _vec.data(2)) = ysize;
-	*((double*) _vec.data(3)) = mean;
-	*((double*) _vec.data(4)) = sigma;
-	_vec.call();
-
-	return( out );
-}
-
-// im_bandjoin: bandwise join of two images
-VImage VImage::bandjoin( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_bandjoin" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_black: generate black image
-VImage VImage::black( int x_size, int y_size, int bands ) throw( VError )
-{
-	VImage output;
-
-	Vargv _vec( "im_black" );
-
-	_vec.data(0) = output.image();
-	*((int*) _vec.data(1)) = x_size;
-	*((int*) _vec.data(2)) = y_size;
-	*((int*) _vec.data(3)) = bands;
-	_vec.call();
-
-	return( output );
-}
-
-// im_c2amph: convert real and imaginary to phase and amplitude
-VImage VImage::c2amph() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_c2amph" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_c2imag: extract imaginary part of complex image
-VImage VImage::c2imag() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_c2imag" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_c2real: extract real part of complex image
-VImage VImage::c2real() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_c2real" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_c2rect: convert phase and amplitude to real and imaginary
-VImage VImage::c2rect() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_c2rect" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_clip2fmt: convert image format to ofmt
-VImage VImage::clip2fmt( int ofmt ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2fmt" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = ofmt;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_copy: copy image
-VImage VImage::copy() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_copy" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_copy_file: copy image to a file and return that
-VImage VImage::copy_file() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_copy_file" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_copy_morph: copy image, setting pixel layout
-VImage VImage::copy_morph( int Bands, int BandFmt, int Coding ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_copy_morph" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = Bands;
-	*((int*) _vec.data(3)) = BandFmt;
-	*((int*) _vec.data(4)) = Coding;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-// im_copy_swap: copy image, swapping byte order
-VImage VImage::copy_swap() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_copy_swap" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_copy_set: copy image, setting informational fields
-VImage VImage::copy_set( int Type, double Xres, double Yres, int Xoffset, int Yoffset ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_copy_set" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = Type;
-	*((double*) _vec.data(3)) = Xres;
-	*((double*) _vec.data(4)) = Yres;
-	*((int*) _vec.data(5)) = Xoffset;
-	*((int*) _vec.data(6)) = Yoffset;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-// im_extract_area: extract area
-VImage VImage::extract_area( int left, int top, int width, int height ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_extract_area" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = left;
-	*((int*) _vec.data(3)) = top;
-	*((int*) _vec.data(4)) = width;
-	*((int*) _vec.data(5)) = height;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-// im_extract_areabands: extract area and bands
-VImage VImage::extract_areabands( int left, int top, int width, int height, int band, int nbands ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_extract_areabands" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = left;
-	*((int*) _vec.data(3)) = top;
-	*((int*) _vec.data(4)) = width;
-	*((int*) _vec.data(5)) = height;
-	*((int*) _vec.data(6)) = band;
-	*((int*) _vec.data(7)) = nbands;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-// im_extract_band: extract band
-VImage VImage::extract_band( int band ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_extract_band" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = band;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-// im_extract_bands: extract several bands
-VImage VImage::extract_bands( int band, int nbands ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_extract_bands" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = band;
-	*((int*) _vec.data(3)) = nbands;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-// im_extract: extract area/band
-VImage VImage::extract( int left, int top, int width, int height, int band ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_extract" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = left;
-	*((int*) _vec.data(3)) = top;
-	*((int*) _vec.data(4)) = width;
-	*((int*) _vec.data(5)) = height;
-	*((int*) _vec.data(6)) = band;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-// im_falsecolour: turn luminance changes into chrominance changes
-VImage VImage::falsecolour() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_falsecolour" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_fliphor: flip image left-right
-VImage VImage::fliphor() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_fliphor" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_flipver: flip image top-bottom
-VImage VImage::flipver() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_flipver" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_gbandjoin: bandwise join of many images
-VImage VImage::gbandjoin( std::vector<VImage> in ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_gbandjoin" );
-
-	((im_imagevec_object*) _vec.data(0))->n = in.size();
-	((im_imagevec_object*) _vec.data(0))->vec = new IMAGE *[in.size()];
-	for( unsigned int i = 0; i < in.size(); i++ )
-		((im_imagevec_object*) _vec.data(0))->vec[i] = in[i].image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	for( unsigned int i = 0; i < in.size(); i++ )
-		out._ref->addref( in[i]._ref );
-
-	return( out );
-}
-
-// im_grid: chop a tall thin image into a grid of images
-VImage VImage::grid( int tile_height, int across, int down ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_grid" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = tile_height;
-	*((int*) _vec.data(3)) = across;
-	*((int*) _vec.data(4)) = down;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-// im_insert: insert sub-image into main image at position
-VImage VImage::insert( VImage sub, int x, int y ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_insert" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = sub.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = x;
-	*((int*) _vec.data(4)) = y;
-	_vec.call();
-	out._ref->addref( in._ref );
-	out._ref->addref( sub._ref );
-
-	return( out );
-}
-
-// im_insertset: insert sub into main at every position in x, y
-VImage VImage::insert( VImage sub, std::vector<int> x, std::vector<int> y ) throw( VError )
-{
-	VImage main = *this;
-	VImage out;
-
-	Vargv _vec( "im_insertset" );
-
-	_vec.data(0) = main.image();
-	_vec.data(1) = sub.image();
-	_vec.data(2) = out.image();
-	((im_intvec_object*) _vec.data(3))->n = x.size();
-	((im_intvec_object*) _vec.data(3))->vec = new int[x.size()];
-	for( unsigned int i = 0; i < x.size(); i++ )
-		((im_intvec_object*) _vec.data(3))->vec[i] = x[i];
-	((im_intvec_object*) _vec.data(4))->n = y.size();
-	((im_intvec_object*) _vec.data(4))->vec = new int[y.size()];
-	for( unsigned int i = 0; i < y.size(); i++ )
-		((im_intvec_object*) _vec.data(4))->vec[i] = y[i];
-	_vec.call();
-
-	return( out );
-}
-
-// im_insert_noexpand: insert sub-image into main image at position, no expansion
-VImage VImage::insert_noexpand( VImage sub, int x, int y ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_insert_noexpand" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = sub.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = x;
-	*((int*) _vec.data(4)) = y;
-	_vec.call();
-	out._ref->addref( in._ref );
-	out._ref->addref( sub._ref );
-
-	return( out );
-}
-
-// im_embed: embed in within a set of borders
-VImage VImage::embed( int type, int x, int y, int width, int height ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_embed" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = type;
-	*((int*) _vec.data(3)) = x;
-	*((int*) _vec.data(4)) = y;
-	*((int*) _vec.data(5)) = width;
-	*((int*) _vec.data(6)) = height;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_lrjoin: join two images left-right
-VImage VImage::lrjoin( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_lrjoin" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_msb: convert to uchar by discarding bits
-VImage VImage::msb() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_msb" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_msb_band: convert to single band uchar by discarding bits
-VImage VImage::msb_band( int band ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_msb_band" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = band;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_replicate: replicate an image horizontally and vertically
-VImage VImage::replicate( int across, int down ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_replicate" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = across;
-	*((int*) _vec.data(3)) = down;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-// im_ri2c: join two non-complex images to form complex
-VImage VImage::ri2c( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_ri2c" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_rot180: rotate image 180 degrees
-VImage VImage::rot180() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_rot180" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_rot270: rotate image 270 degrees clockwise
-VImage VImage::rot270() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_rot270" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_rot90: rotate image 90 degrees clockwise
-VImage VImage::rot90() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_rot90" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_scale: scale image linearly to fit range 0-255
-VImage VImage::scale() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_scale" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_scaleps: logarithmic scale of image to fit range 0-255
-VImage VImage::scaleps() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_scaleps" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_subsample: subsample image by integer factors
-VImage VImage::subsample( int xshrink, int yshrink ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_subsample" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = xshrink;
-	*((int*) _vec.data(3)) = yshrink;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_system: run command on image
-char* VImage::system( char* command ) throw( VError )
-{
-	VImage im = *this;
-	char* output;
-
-	Vargv _vec( "im_system" );
-
-	_vec.data(0) = im.image();
-	_vec.data(1) = (im_object) command;
-	_vec.call();
-	output = (char*) _vec.data(2);
-
-	return( output );
-}
-
-// im_system_image: run command on image, with image output
-VImage VImage::system_image( char* in_format, char* out_format, char* command, char*& log ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_system_image" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = (im_object) in_format;
-	_vec.data(3) = (im_object) out_format;
-	_vec.data(4) = (im_object) command;
-	_vec.call();
-	log = (char*) _vec.data(5);
-
-	return( out );
-}
-
-// im_tbjoin: join two images top-bottom
-VImage VImage::tbjoin( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_tbjoin" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_text: generate text image
-VImage VImage::text( char* text, char* font, int width, int alignment, int dpi ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_text" );
-
-	_vec.data(0) = out.image();
-	_vec.data(1) = (im_object) text;
-	_vec.data(2) = (im_object) font;
-	*((int*) _vec.data(3)) = width;
-	*((int*) _vec.data(4)) = alignment;
-	*((int*) _vec.data(5)) = dpi;
-	_vec.call();
-
-	return( out );
-}
-
-// im_wrap: shift image origin, wrapping at sides
-VImage VImage::wrap( int x, int y ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_wrap" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = x;
-	*((int*) _vec.data(3)) = y;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_zoom: simple zoom of an image by integer factors
-VImage VImage::zoom( int xfac, int yfac ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_zoom" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((int*) _vec.data(2)) = xfac;
-	*((int*) _vec.data(3)) = yfac;
-	_vec.call();
-	output._ref->addref( input._ref );
-
-	return( output );
-}
-
-
-// bodies for package convolution
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_aconvsep: approximate separable convolution
-VImage VImage::aconvsep( VDMask matrix, int n_layers ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_aconvsep" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().dptr;
-	*((int*) _vec.data(3)) = n_layers;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_aconv: approximate convolution
-VImage VImage::aconv( VDMask matrix, int n_layers, int cluster ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_aconv" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().dptr;
-	*((int*) _vec.data(3)) = n_layers;
-	*((int*) _vec.data(4)) = cluster;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_addgnoise: add gaussian noise with mean 0 and std. dev. sigma
-VImage VImage::addgnoise( double sigma ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_addgnoise" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = sigma;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_compass: convolve with 8-way rotating integer mask
-VImage VImage::compass( VIMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_compass" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_contrast_surface: find high-contrast points in an image
-VImage VImage::contrast_surface( int half_win_size, int spacing ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_contrast_surface" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = half_win_size;
-	*((int*) _vec.data(3)) = spacing;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_conv: convolve
-VImage VImage::conv( VIMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_conv" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_conv_f: convolve, with DOUBLEMASK
-VImage VImage::conv( VDMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_conv_f" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().dptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_convsep: seperable convolution
-VImage VImage::convsep( VIMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_convsep" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_convsep_f: seperable convolution, with DOUBLEMASK
-VImage VImage::convsep( VDMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_convsep_f" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().dptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_fastcor: fast correlate in2 within in1
-VImage VImage::fastcor( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_fastcor" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_gradcor: non-normalised correlation of gradient of in2 within in1
-VImage VImage::gradcor( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_gradcor" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_gradient: convolve with 2-way rotating mask
-VImage VImage::gradient( VIMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_gradient" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_grad_x: horizontal difference image
-VImage VImage::grad_x() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_grad_x" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_grad_y: vertical difference image
-VImage VImage::grad_y() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_grad_y" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_lindetect: convolve with 4-way rotating mask
-VImage VImage::lindetect( VIMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_lindetect" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_sharpen: sharpen high frequencies of L channel of LabQ
-VImage VImage::sharpen( int mask_size, double x1, double y2, double y3, double m1, double m2 ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_sharpen" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = mask_size;
-	*((double*) _vec.data(3)) = x1;
-	*((double*) _vec.data(4)) = y2;
-	*((double*) _vec.data(5)) = y3;
-	*((double*) _vec.data(6)) = m1;
-	*((double*) _vec.data(7)) = m2;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_spcor: normalised correlation of in2 within in1
-VImage VImage::spcor( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_spcor" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-
-// bodies for package deprecated
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_argb2rgba: convert pre-multipled argb to png-style rgba
-VImage VImage::argb2rgba() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_argb2rgba" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_flood_copy: flood with ink from start_x, start_y while pixel == start pixel
-VImage VImage::flood_copy( int start_x, int start_y, std::vector<double> ink ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_flood_copy" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = start_x;
-	*((int*) _vec.data(3)) = start_y;
-	((im_doublevec_object*) _vec.data(4))->n = ink.size();
-	((im_doublevec_object*) _vec.data(4))->vec = new double[ink.size()];
-	for( unsigned int i = 0; i < ink.size(); i++ )
-		((im_doublevec_object*) _vec.data(4))->vec[i] = ink[i];
-	_vec.call();
-
-	return( out );
-}
-
-// im_flood_blob_copy: flood with ink from start_x, start_y while pixel == start pixel
-VImage VImage::flood_blob_copy( int start_x, int start_y, std::vector<double> ink ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_flood_blob_copy" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = start_x;
-	*((int*) _vec.data(3)) = start_y;
-	((im_doublevec_object*) _vec.data(4))->n = ink.size();
-	((im_doublevec_object*) _vec.data(4))->vec = new double[ink.size()];
-	for( unsigned int i = 0; i < ink.size(); i++ )
-		((im_doublevec_object*) _vec.data(4))->vec[i] = ink[i];
-	_vec.call();
-
-	return( out );
-}
-
-// im_flood_other_copy: flood mark with serial from start_x, start_y while pixel == start pixel
-VImage VImage::flood_other_copy( VImage mark, int start_x, int start_y, int serial ) throw( VError )
-{
-	VImage test = *this;
-	VImage out;
-
-	Vargv _vec( "im_flood_other_copy" );
-
-	_vec.data(0) = test.image();
-	_vec.data(1) = mark.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = start_x;
-	*((int*) _vec.data(4)) = start_y;
-	*((int*) _vec.data(5)) = serial;
-	_vec.call();
-
-	return( out );
-}
-
-// im_clip: convert to unsigned 8-bit integer
-VImage VImage::clip() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_c2ps: find power spectrum of complex image
-VImage VImage::c2ps() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_c2ps" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_resize_linear: resize to X by Y pixels with linear interpolation
-VImage VImage::resize_linear( int X, int Y ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_resize_linear" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = X;
-	*((int*) _vec.data(3)) = Y;
-	_vec.call();
-
-	return( out );
-}
-
-// im_cmulnorm: multiply two complex images, normalising output
-VImage VImage::cmulnorm( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_cmulnorm" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_fav4: average of 4 images
-VImage VImage::fav4( VImage in2, VImage in3, VImage in4 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_fav4" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = in3.image();
-	_vec.data(3) = in4.image();
-	_vec.data(4) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_gadd: calculate a*in1 + b*in2 + c = outfile
-VImage VImage::gadd( double a, double b, VImage in2, double c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_gadd" );
-
-	*((double*) _vec.data(0)) = a;
-	_vec.data(1) = in1.image();
-	*((double*) _vec.data(2)) = b;
-	_vec.data(3) = in2.image();
-	*((double*) _vec.data(4)) = c;
-	_vec.data(5) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_icc_export: convert a float LAB to an 8-bit device image with an ICC profile
-VImage VImage::icc_export( char* output_profile, int intent ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_icc_export" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = (im_object) output_profile;
-	*((int*) _vec.data(3)) = intent;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_litecor: calculate max(white)*factor*(in/white), if clip == 1
-VImage VImage::litecor( VImage white, int clip, double factor ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_litecor" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = white.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = clip;
-	*((double*) _vec.data(4)) = factor;
-	_vec.call();
-
-	return( out );
-}
-
-// im_affine: affine transform
-VImage VImage::affine( double a, double b, double c, double d, double dx, double dy, int x, int y, int w, int h ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_affine" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = a;
-	*((double*) _vec.data(3)) = b;
-	*((double*) _vec.data(4)) = c;
-	*((double*) _vec.data(5)) = d;
-	*((double*) _vec.data(6)) = dx;
-	*((double*) _vec.data(7)) = dy;
-	*((int*) _vec.data(8)) = x;
-	*((int*) _vec.data(9)) = y;
-	*((int*) _vec.data(10)) = w;
-	*((int*) _vec.data(11)) = h;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_clip2c: convert to signed 8-bit integer
-VImage VImage::clip2c() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2c" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_clip2cm: convert to complex
-VImage VImage::clip2cm() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2cm" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_clip2d: convert to double-precision float
-VImage VImage::clip2d() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2d" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_clip2dcm: convert to double complex
-VImage VImage::clip2dcm() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2dcm" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_clip2f: convert to single-precision float
-VImage VImage::clip2f() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2f" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_clip2i: convert to signed 32-bit integer
-VImage VImage::clip2i() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2i" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_convsub: convolve uchar to uchar, sub-sampling by xskip, yskip
-VImage VImage::convsub( VIMask matrix, int xskip, int yskip ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_convsub" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().iptr;
-	*((int*) _vec.data(3)) = xskip;
-	*((int*) _vec.data(4)) = yskip;
-	_vec.call();
-
-	return( out );
-}
-
-// im_convf: convolve, with DOUBLEMASK
-VImage VImage::convf( VDMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_convf" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().dptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_convsepf: seperable convolution, with DOUBLEMASK
-VImage VImage::convsepf( VDMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_convsepf" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().dptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_clip2s: convert to signed 16-bit integer
-VImage VImage::clip2s() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2s" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_clip2ui: convert to unsigned 32-bit integer
-VImage VImage::clip2ui() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2ui" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_insertplaceset: insert sub into main at every position in x, y
-VImage VImage::insertplace( VImage sub, std::vector<int> x, std::vector<int> y ) throw( VError )
-{
-	VImage main = *this;
-	VImage out;
-
-	Vargv _vec( "im_insertplaceset" );
-
-	_vec.data(0) = main.image();
-	_vec.data(1) = sub.image();
-	_vec.data(2) = out.image();
-	((im_intvec_object*) _vec.data(3))->n = x.size();
-	((im_intvec_object*) _vec.data(3))->vec = new int[x.size()];
-	for( unsigned int i = 0; i < x.size(); i++ )
-		((im_intvec_object*) _vec.data(3))->vec[i] = x[i];
-	((im_intvec_object*) _vec.data(4))->n = y.size();
-	((im_intvec_object*) _vec.data(4))->vec = new int[y.size()];
-	for( unsigned int i = 0; i < y.size(); i++ )
-		((im_intvec_object*) _vec.data(4))->vec[i] = y[i];
-	_vec.call();
-
-	return( out );
-}
-
-// im_clip2us: convert to unsigned 16-bit integer
-VImage VImage::clip2us() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_clip2us" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_slice: slice an image using two thresholds
-VImage VImage::slice( double thresh1, double thresh2 ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_slice" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((double*) _vec.data(2)) = thresh1;
-	*((double*) _vec.data(3)) = thresh2;
-	_vec.call();
-
-	return( output );
-}
-
-// im_segment: number continuous regions in an image
-VImage VImage::segment( int& segments ) throw( VError )
-{
-	VImage test = *this;
-	VImage mask;
-
-	Vargv _vec( "im_segment" );
-
-	_vec.data(0) = test.image();
-	_vec.data(1) = mask.image();
-	_vec.call();
-	segments = *((int*)_vec.data(2));
-
-	return( mask );
-}
-
-// im_line: draw line between points (x1,y1) and (x2,y2)
-void VImage::line( int x1, int y1, int x2, int y2, int pelval ) throw( VError )
-{
-	VImage im = *this;
-	Vargv _vec( "im_line" );
-
-	_vec.data(0) = im.image();
-	*((int*) _vec.data(1)) = x1;
-	*((int*) _vec.data(2)) = y1;
-	*((int*) _vec.data(3)) = x2;
-	*((int*) _vec.data(4)) = y2;
-	*((int*) _vec.data(5)) = pelval;
-	_vec.call();
-}
-
-// im_thresh: slice an image at a threshold
-VImage VImage::thresh( double threshold ) throw( VError )
-{
-	VImage input = *this;
-	VImage output;
-
-	Vargv _vec( "im_thresh" );
-
-	_vec.data(0) = input.image();
-	_vec.data(1) = output.image();
-	*((double*) _vec.data(2)) = threshold;
-	_vec.call();
-
-	return( output );
-}
-
-// im_convf_raw: convolve, with DOUBLEMASK, no border
-VImage VImage::convf_raw( VDMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_convf_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().dptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_conv_raw: convolve, no border
-VImage VImage::conv_raw( VIMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_conv_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_contrast_surface_raw: find high-contrast points in an image
-VImage VImage::contrast_surface_raw( int half_win_size, int spacing ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_contrast_surface_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = half_win_size;
-	*((int*) _vec.data(3)) = spacing;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_convsepf_raw: seperable convolution, with DOUBLEMASK, no border
-VImage VImage::convsepf_raw( VDMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_convsepf_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().dptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_convsep_raw: seperable convolution, no border
-VImage VImage::convsep_raw( VIMask matrix ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_convsep_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = matrix.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_fastcor_raw: fast correlate in2 within in1, no border
-VImage VImage::fastcor_raw( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_fastcor_raw" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_gradcor_raw: non-normalised correlation of gradient of in2 within in1, no padding
-VImage VImage::gradcor_raw( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_gradcor_raw" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_spcor_raw: normalised correlation of in2 within in1, no black padding
-VImage VImage::spcor_raw( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_spcor_raw" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_lhisteq_raw: local histogram equalisation, no border
-VImage VImage::lhisteq_raw( int width, int height ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_lhisteq_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = width;
-	*((int*) _vec.data(3)) = height;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_stdif_raw: statistical differencing, no border
-VImage VImage::stdif_raw( double a, double m0, double b, double s0, int xw, int yw ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_stdif_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = a;
-	*((double*) _vec.data(3)) = m0;
-	*((double*) _vec.data(4)) = b;
-	*((double*) _vec.data(5)) = s0;
-	*((int*) _vec.data(6)) = xw;
-	*((int*) _vec.data(7)) = yw;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_rank_raw: rank filter nth element of xsize/ysize window, no border
-VImage VImage::rank_raw( int xsize, int ysize, int n ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_rank_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = xsize;
-	*((int*) _vec.data(3)) = ysize;
-	*((int*) _vec.data(4)) = n;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_dilate_raw: dilate image with mask
-VImage VImage::dilate_raw( VIMask mask ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_dilate_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = mask.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_erode_raw: erode image with mask
-VImage VImage::erode_raw( VIMask mask ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_erode_raw" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = mask.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_similarity_area: output area xywh of similarity transformation
-VImage VImage::similarity_area( double a, double b, double dx, double dy, int x, int y, int w, int h ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_similarity_area" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = a;
-	*((double*) _vec.data(3)) = b;
-	*((double*) _vec.data(4)) = dx;
-	*((double*) _vec.data(5)) = dy;
-	*((int*) _vec.data(6)) = x;
-	*((int*) _vec.data(7)) = y;
-	*((int*) _vec.data(8)) = w;
-	*((int*) _vec.data(9)) = h;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_similarity: similarity transformation
-VImage VImage::similarity( double a, double b, double dx, double dy ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_similarity" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = a;
-	*((double*) _vec.data(3)) = b;
-	*((double*) _vec.data(4)) = dx;
-	*((double*) _vec.data(5)) = dy;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_mask2vips: convert DOUBLEMASK to VIPS image
-VImage VImage::mask2vips( VDMask input ) throw( VError )
-{
-	VImage output;
-
-	Vargv _vec( "im_mask2vips" );
-
-	((im_mask_object*) _vec.data(0))->mask = input.mask().dptr;
-	_vec.data(1) = output.image();
-	_vec.call();
-
-	return( output );
-}
-
-// im_vips2mask: convert VIPS image to DOUBLEMASK
-VDMask VImage::vips2mask() throw( VError )
-{
-	VImage input = *this;
-	VDMask output;
-
-	Vargv _vec( "im_vips2mask" );
-
-	_vec.data(0) = input.image();
-	((im_mask_object*) _vec.data(1))->name = (char*)"noname";
-	_vec.call();
-	output.embed( (DOUBLEMASK *)((im_mask_object*)_vec.data(1))->mask );
-
-	return( output );
-}
-
-// im_insertplace: draw image sub inside image main at position (x,y)
-void VImage::insertplace( VImage sub, int x, int y ) throw( VError )
-{
-	VImage main = *this;
-	Vargv _vec( "im_insertplace" );
-
-	_vec.data(0) = main.image();
-	_vec.data(1) = sub.image();
-	*((int*) _vec.data(2)) = x;
-	*((int*) _vec.data(3)) = y;
-	_vec.call();
-}
-
-// im_circle: plot circle on image
-void VImage::circle( int cx, int cy, int radius, int intensity ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_circle" );
-
-	_vec.data(0) = image.image();
-	*((int*) _vec.data(1)) = cx;
-	*((int*) _vec.data(2)) = cy;
-	*((int*) _vec.data(3)) = radius;
-	*((int*) _vec.data(4)) = intensity;
-	_vec.call();
-}
-
-// im_andimage: bitwise and of two images
-VImage VImage::andimage( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_andimage" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_andimageconst: bitwise and of an image with a constant
-VImage VImage::andimage( int c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_andimageconst" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_andimage_vec: bitwise and of an image with a vector constant
-VImage VImage::andimage( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_andimage_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_orimage: bitwise or of two images
-VImage VImage::orimage( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_orimage" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_orimageconst: bitwise or of an image with a constant
-VImage VImage::orimage( int c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_orimageconst" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_orimage_vec: bitwise or of an image with a vector constant
-VImage VImage::orimage( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_orimage_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_eorimage: bitwise eor of two images
-VImage VImage::eorimage( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_eorimage" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_eorimageconst: bitwise eor of an image with a constant
-VImage VImage::eorimage( int c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_eorimageconst" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_eorimage_vec: bitwise eor of an image with a vector constant
-VImage VImage::eorimage( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_eorimage_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_shiftleft_vec: shift image array bits to left
-VImage VImage::shiftleft( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_shiftleft_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_shiftleft: shift image n bits to left
-VImage VImage::shiftleft( int c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_shiftleft" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_shiftright_vec: shift image array bits to right
-VImage VImage::shiftright( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_shiftright_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_shiftright: shift integer image n bits to right
-VImage VImage::shiftright( int c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_shiftright" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_blend: use cond image to blend between images in1 and in2
-VImage VImage::blend( VImage in1, VImage in2 ) throw( VError )
-{
-	VImage cond = *this;
-	VImage out;
-
-	Vargv _vec( "im_blend" );
-
-	_vec.data(0) = cond.image();
-	_vec.data(1) = in1.image();
-	_vec.data(2) = in2.image();
-	_vec.data(3) = out.image();
-	_vec.call();
-	out._ref->addref( cond._ref );
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_equal: two images equal in value
-VImage VImage::equal( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_equal" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_equal_vec: image equals doublevec
-VImage VImage::equal( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_equal_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_equalconst: image equals const
-VImage VImage::equal( double c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_equalconst" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_ifthenelse: use cond image to choose pels from image in1 or in2
-VImage VImage::ifthenelse( VImage in1, VImage in2 ) throw( VError )
-{
-	VImage cond = *this;
-	VImage out;
-
-	Vargv _vec( "im_ifthenelse" );
-
-	_vec.data(0) = cond.image();
-	_vec.data(1) = in1.image();
-	_vec.data(2) = in2.image();
-	_vec.data(3) = out.image();
-	_vec.call();
-	out._ref->addref( cond._ref );
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_less: in1 less than in2 in value
-VImage VImage::less( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_less" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_less_vec: in less than doublevec
-VImage VImage::less( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_less_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_lessconst: in less than const
-VImage VImage::less( double c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_lessconst" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_lesseq: in1 less than or equal to in2 in value
-VImage VImage::lesseq( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_lesseq" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_lesseq_vec: in less than or equal to doublevec
-VImage VImage::lesseq( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_lesseq_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_lesseqconst: in less than or equal to const
-VImage VImage::lesseq( double c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_lesseqconst" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_more: in1 more than in2 in value
-VImage VImage::more( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_more" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_more_vec: in more than doublevec
-VImage VImage::more( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_more_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_moreconst: in more than const
-VImage VImage::more( double c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_moreconst" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_moreeq: in1 more than or equal to in2 in value
-VImage VImage::moreeq( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_moreeq" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_moreeq_vec: in more than or equal to doublevec
-VImage VImage::moreeq( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_moreeq_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_moreeqconst: in more than or equal to const
-VImage VImage::moreeq( double c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_moreeqconst" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_notequal: two images not equal in value
-VImage VImage::notequal( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_notequal" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( in1._ref );
-	out._ref->addref( in2._ref );
-
-	return( out );
-}
-
-// im_notequal_vec: image does not equal doublevec
-VImage VImage::notequal( std::vector<double> vec ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_notequal_vec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_doublevec_object*) _vec.data(2))->n = vec.size();
-	((im_doublevec_object*) _vec.data(2))->vec = new double[vec.size()];
-	for( unsigned int i = 0; i < vec.size(); i++ )
-		((im_doublevec_object*) _vec.data(2))->vec[i] = vec[i];
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_notequalconst: image does not equal const
-VImage VImage::notequal( double c ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_notequalconst" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = c;
-	_vec.call();
-	out._ref->addref( in1._ref );
-
-	return( out );
-}
-
-// im_quadratic: transform via quadratic
-VImage VImage::quadratic( VImage coeff ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_quadratic" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = coeff.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-	out._ref->addref( coeff._ref );
-
-	return( out );
-}
-
-
-// bodies for package format
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_csv2vips: read a file in csv format
-VImage VImage::csv2vips( char* filename ) throw( VError )
-{
-	VImage im;
-
-	Vargv _vec( "im_csv2vips" );
-
-	_vec.data(0) = (im_object) filename;
-	_vec.data(1) = im.image();
-	_vec.call();
-
-	return( im );
-}
-
-// im_fits2vips: convert from fits
-VImage VImage::fits2vips( char* in ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_fits2vips" );
-
-	_vec.data(0) = (im_object) in;
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_jpeg2vips: convert from jpeg
-VImage VImage::jpeg2vips( char* in ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_jpeg2vips" );
-
-	_vec.data(0) = (im_object) in;
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_magick2vips: load file with libMagick
-VImage VImage::magick2vips( char* in ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_magick2vips" );
-
-	_vec.data(0) = (im_object) in;
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_png2vips: convert PNG file to VIPS image
-VImage VImage::png2vips( char* in ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_png2vips" );
-
-	_vec.data(0) = (im_object) in;
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_exr2vips: convert an OpenEXR file to VIPS
-VImage VImage::exr2vips( char* in ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_exr2vips" );
-
-	_vec.data(0) = (im_object) in;
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_ppm2vips: read a file in pbm/pgm/ppm format
-VImage VImage::ppm2vips( char* filename ) throw( VError )
-{
-	VImage im;
-
-	Vargv _vec( "im_ppm2vips" );
-
-	_vec.data(0) = (im_object) filename;
-	_vec.data(1) = im.image();
-	_vec.call();
-
-	return( im );
-}
-
-// im_analyze2vips: read a file in analyze format
-VImage VImage::analyze2vips( char* filename ) throw( VError )
-{
-	VImage im;
-
-	Vargv _vec( "im_analyze2vips" );
-
-	_vec.data(0) = (im_object) filename;
-	_vec.data(1) = im.image();
-	_vec.call();
-
-	return( im );
-}
-
-// im_tiff2vips: convert TIFF file to VIPS image
-VImage VImage::tiff2vips( char* in ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_tiff2vips" );
-
-	_vec.data(0) = (im_object) in;
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_vips2csv: write an image in csv format
-void VImage::vips2csv( char* filename ) throw( VError )
-{
-	VImage in = *this;
-	Vargv _vec( "im_vips2csv" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = (im_object) filename;
-	_vec.call();
-}
-
-// im_vips2dz: save as deepzoom
-void VImage::vips2dz( char* out ) throw( VError )
-{
-	VImage in = *this;
-	Vargv _vec( "im_vips2dz" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = (im_object) out;
-	_vec.call();
-}
-
-// im_vips2jpeg: convert to jpeg
-void VImage::vips2jpeg( char* out ) throw( VError )
-{
-	VImage in = *this;
-	Vargv _vec( "im_vips2jpeg" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = (im_object) out;
-	_vec.call();
-}
-
-// im_vips2mimejpeg: convert to jpeg as mime type on stdout
-void VImage::vips2mimejpeg( int qfac ) throw( VError )
-{
-	VImage in = *this;
-	Vargv _vec( "im_vips2mimejpeg" );
-
-	_vec.data(0) = in.image();
-	*((int*) _vec.data(1)) = qfac;
-	_vec.call();
-}
-
-// im_vips2png: convert VIPS image to PNG file
-void VImage::vips2png( char* out ) throw( VError )
-{
-	VImage in = *this;
-	Vargv _vec( "im_vips2png" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = (im_object) out;
-	_vec.call();
-}
-
-// im_vips2ppm: write a file in pbm/pgm/ppm format
-void VImage::vips2ppm( char* filename ) throw( VError )
-{
-	VImage im = *this;
-	Vargv _vec( "im_vips2ppm" );
-
-	_vec.data(0) = im.image();
-	_vec.data(1) = (im_object) filename;
-	_vec.call();
-}
-
-// im_vips2tiff: convert VIPS image to TIFF file
-void VImage::vips2tiff( char* out ) throw( VError )
-{
-	VImage in = *this;
-	Vargv _vec( "im_vips2tiff" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = (im_object) out;
-	_vec.call();
-}
-
-
-// bodies for package freq_filt
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_create_fmask: create frequency domain filter mask
-VImage VImage::create_fmask( int width, int height, int type, double p1, double p2, double p3, double p4, double p5 ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_create_fmask" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = width;
-	*((int*) _vec.data(2)) = height;
-	*((int*) _vec.data(3)) = type;
-	*((double*) _vec.data(4)) = p1;
-	*((double*) _vec.data(5)) = p2;
-	*((double*) _vec.data(6)) = p3;
-	*((double*) _vec.data(7)) = p4;
-	*((double*) _vec.data(8)) = p5;
-	_vec.call();
-
-	return( out );
-}
-
-// im_disp_ps: make displayable power spectrum
-VImage VImage::disp_ps() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_disp_ps" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_flt_image_freq: frequency domain filter image
-VImage VImage::flt_image_freq( int type, double p1, double p2, double p3, double p4, double p5 ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_flt_image_freq" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = type;
-	*((double*) _vec.data(3)) = p1;
-	*((double*) _vec.data(4)) = p2;
-	*((double*) _vec.data(5)) = p3;
-	*((double*) _vec.data(6)) = p4;
-	*((double*) _vec.data(7)) = p5;
-	_vec.call();
-
-	return( out );
-}
-
-// im_fractsurf: generate a fractal surface of given dimension
-VImage VImage::fractsurf( int size, double dimension ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_fractsurf" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = size;
-	*((double*) _vec.data(2)) = dimension;
-	_vec.call();
-
-	return( out );
-}
-
-// im_freqflt: frequency-domain filter of in with mask
-VImage VImage::freqflt( VImage mask ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_freqflt" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = mask.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_fwfft: forward fast-fourier transform
-VImage VImage::fwfft() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_fwfft" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_rotquad: rotate image quadrants to move origin to centre
-VImage VImage::rotquad() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_rotquad" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_invfft: inverse fast-fourier transform
-VImage VImage::invfft() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_invfft" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_phasecor_fft: non-normalised correlation of gradient of in2 within in1
-VImage VImage::phasecor_fft( VImage in2 ) throw( VError )
-{
-	VImage in1 = *this;
-	VImage out;
-
-	Vargv _vec( "im_phasecor_fft" );
-
-	_vec.data(0) = in1.image();
-	_vec.data(1) = in2.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_invfftr: real part of inverse fast-fourier transform
-VImage VImage::invfftr() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_invfftr" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-
-// bodies for package histograms_lut
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_gammacorrect: gamma-correct image
-VImage VImage::gammacorrect( double exponent ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_gammacorrect" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = exponent;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_heq: histogram-equalise image
-VImage VImage::heq( int band_number ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_heq" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = band_number;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_hist: find and graph histogram of image
-VImage VImage::hist( int band_number ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_hist" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = band_number;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_histcum: turn histogram to cumulative histogram
-VImage VImage::histcum() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_histcum" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_histeq: form histogram equalistion LUT
-VImage VImage::histeq() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_histeq" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_hist_indexed: make a histogram with an index image
-VImage VImage::hist_indexed( VImage value ) throw( VError )
-{
-	VImage index = *this;
-	VImage out;
-
-	Vargv _vec( "im_hist_indexed" );
-
-	_vec.data(0) = index.image();
-	_vec.data(1) = value.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-	out._ref->addref( index._ref );
-	out._ref->addref( value._ref );
-
-	return( out );
-}
-
-// im_histgr: find histogram of image
-VImage VImage::histgr( int band_number ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_histgr" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = band_number;
-	_vec.call();
-
-	return( out );
-}
-
-// im_histnD: find 1D, 2D or 3D histogram of image
-VImage VImage::histnD( int bins ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_histnD" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = bins;
-	_vec.call();
-
-	return( out );
-}
-
-// im_histnorm: form normalised histogram
-VImage VImage::histnorm() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_histnorm" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_histplot: plot graph of histogram
-VImage VImage::histplot() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_histplot" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_histspec: find histogram which will make pdf of in match ref
-VImage VImage::histspec( VImage ref ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_histspec" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = ref.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_hsp: match stats of in to stats of ref
-VImage VImage::hsp( VImage ref ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_hsp" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = ref.image();
-	_vec.data(2) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_identity: generate identity histogram
-VImage VImage::identity( int nbands ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_identity" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = nbands;
-	_vec.call();
-
-	return( out );
-}
-
-// im_identity_ushort: generate ushort identity histogram
-VImage VImage::identity_ushort( int nbands, int size ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_identity_ushort" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = nbands;
-	*((int*) _vec.data(2)) = size;
-	_vec.call();
-
-	return( out );
-}
-
-// im_ismonotonic: test LUT for monotonicity
-int VImage::ismonotonic() throw( VError )
-{
-	VImage lut = *this;
-	int mono;
-
-	Vargv _vec( "im_ismonotonic" );
-
-	_vec.data(0) = lut.image();
-	_vec.call();
-	mono = *((int*)_vec.data(1));
-
-	return( mono );
-}
-
-// im_lhisteq: local histogram equalisation
-VImage VImage::lhisteq( int width, int height ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_lhisteq" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = width;
-	*((int*) _vec.data(3)) = height;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_mpercent: find threshold above which there are percent values
-int VImage::mpercent( double percent ) throw( VError )
-{
-	VImage in = *this;
-	int thresh;
-
-	Vargv _vec( "im_mpercent" );
-
-	_vec.data(0) = in.image();
-	*((double*) _vec.data(1)) = percent;
-	_vec.call();
-	thresh = *((int*)_vec.data(2));
-
-	return( thresh );
-}
-
-// im_invertlut: generate correction table from set of measures
-VImage VImage::invertlut( VDMask measures, int lut_size ) throw( VError )
-{
-	VImage lut;
-
-	Vargv _vec( "im_invertlut" );
-
-	((im_mask_object*) _vec.data(0))->mask = measures.mask().dptr;
-	_vec.data(1) = lut.image();
-	*((int*) _vec.data(2)) = lut_size;
-	_vec.call();
-
-	return( lut );
-}
-
-// im_buildlut: generate LUT table from set of x/y positions
-VImage VImage::buildlut( VDMask xyes ) throw( VError )
-{
-	VImage lut;
-
-	Vargv _vec( "im_buildlut" );
-
-	((im_mask_object*) _vec.data(0))->mask = xyes.mask().dptr;
-	_vec.data(1) = lut.image();
-	_vec.call();
-
-	return( lut );
-}
-
-// im_maplut: map image through LUT
-VImage VImage::maplut( VImage lut ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_maplut" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = lut.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-	out._ref->addref( lut._ref );
-
-	return( out );
-}
-
-// im_project: find horizontal and vertical projections of an image
-VImage VImage::project( VImage& vout ) throw( VError )
-{
-	VImage in = *this;
-	VImage hout;
-
-	Vargv _vec( "im_project" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = hout.image();
-	_vec.data(2) = vout.image();
-	_vec.call();
-
-	return( hout );
-}
-
-// im_stdif: statistical differencing
-VImage VImage::stdif( double a, double m0, double b, double s0, int xw, int yw ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_stdif" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = a;
-	*((double*) _vec.data(3)) = m0;
-	*((double*) _vec.data(4)) = b;
-	*((double*) _vec.data(5)) = s0;
-	*((int*) _vec.data(6)) = xw;
-	*((int*) _vec.data(7)) = yw;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_tone_analyse: analyse in and create LUT for tone adjustment
-VImage VImage::tone_analyse( double Ps, double Pm, double Ph, double S, double M, double H ) throw( VError )
-{
-	VImage in = *this;
-	VImage hist;
-
-	Vargv _vec( "im_tone_analyse" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = hist.image();
-	*((double*) _vec.data(2)) = Ps;
-	*((double*) _vec.data(3)) = Pm;
-	*((double*) _vec.data(4)) = Ph;
-	*((double*) _vec.data(5)) = S;
-	*((double*) _vec.data(6)) = M;
-	*((double*) _vec.data(7)) = H;
-	_vec.call();
-
-	return( hist );
-}
-
-// im_tone_build: create LUT for tone adjustment of LabS images
-VImage VImage::tone_build( double Lb, double Lw, double Ps, double Pm, double Ph, double S, double M, double H ) throw( VError )
-{
-	VImage hist;
-
-	Vargv _vec( "im_tone_build" );
-
-	_vec.data(0) = hist.image();
-	*((double*) _vec.data(1)) = Lb;
-	*((double*) _vec.data(2)) = Lw;
-	*((double*) _vec.data(3)) = Ps;
-	*((double*) _vec.data(4)) = Pm;
-	*((double*) _vec.data(5)) = Ph;
-	*((double*) _vec.data(6)) = S;
-	*((double*) _vec.data(7)) = M;
-	*((double*) _vec.data(8)) = H;
-	_vec.call();
-
-	return( hist );
-}
-
-// im_tone_build_range: create LUT for tone adjustment
-VImage VImage::tone_build_range( int in_max, int out_max, double Lb, double Lw, double Ps, double Pm, double Ph, double S, double M, double H ) throw( VError )
-{
-	VImage hist;
-
-	Vargv _vec( "im_tone_build_range" );
-
-	_vec.data(0) = hist.image();
-	*((int*) _vec.data(1)) = in_max;
-	*((int*) _vec.data(2)) = out_max;
-	*((double*) _vec.data(3)) = Lb;
-	*((double*) _vec.data(4)) = Lw;
-	*((double*) _vec.data(5)) = Ps;
-	*((double*) _vec.data(6)) = Pm;
-	*((double*) _vec.data(7)) = Ph;
-	*((double*) _vec.data(8)) = S;
-	*((double*) _vec.data(9)) = M;
-	*((double*) _vec.data(10)) = H;
-	_vec.call();
-
-	return( hist );
-}
-
-// im_tone_map: map L channel of LabS or LabQ image through LUT
-VImage VImage::tone_map( VImage lut ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_tone_map" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = lut.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-	out._ref->addref( lut._ref );
-
-	return( out );
-}
-
-
-// bodies for package inplace
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_draw_circle: draw circle on image
-void VImage::draw_circle( int cx, int cy, int radius, int fill, std::vector<double> ink ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_circle" );
-
-	_vec.data(0) = image.image();
-	*((int*) _vec.data(1)) = cx;
-	*((int*) _vec.data(2)) = cy;
-	*((int*) _vec.data(3)) = radius;
-	*((int*) _vec.data(4)) = fill;
-	((im_doublevec_object*) _vec.data(5))->n = ink.size();
-	((im_doublevec_object*) _vec.data(5))->vec = new double[ink.size()];
-	for( unsigned int i = 0; i < ink.size(); i++ )
-		((im_doublevec_object*) _vec.data(5))->vec[i] = ink[i];
-	_vec.call();
-}
-
-// im_draw_rect: draw rect on image
-void VImage::draw_rect( int left, int top, int width, int height, int fill, std::vector<double> ink ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_rect" );
-
-	_vec.data(0) = image.image();
-	*((int*) _vec.data(1)) = left;
-	*((int*) _vec.data(2)) = top;
-	*((int*) _vec.data(3)) = width;
-	*((int*) _vec.data(4)) = height;
-	*((int*) _vec.data(5)) = fill;
-	((im_doublevec_object*) _vec.data(6))->n = ink.size();
-	((im_doublevec_object*) _vec.data(6))->vec = new double[ink.size()];
-	for( unsigned int i = 0; i < ink.size(); i++ )
-		((im_doublevec_object*) _vec.data(6))->vec[i] = ink[i];
-	_vec.call();
-}
-
-// im_draw_line: draw line on image
-void VImage::draw_line( int x1, int y1, int x2, int y2, std::vector<double> ink ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_line" );
-
-	_vec.data(0) = image.image();
-	*((int*) _vec.data(1)) = x1;
-	*((int*) _vec.data(2)) = y1;
-	*((int*) _vec.data(3)) = x2;
-	*((int*) _vec.data(4)) = y2;
-	((im_doublevec_object*) _vec.data(5))->n = ink.size();
-	((im_doublevec_object*) _vec.data(5))->vec = new double[ink.size()];
-	for( unsigned int i = 0; i < ink.size(); i++ )
-		((im_doublevec_object*) _vec.data(5))->vec[i] = ink[i];
-	_vec.call();
-}
-
-// im_draw_point: draw point on image
-void VImage::draw_point( int x, int y, std::vector<double> ink ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_point" );
-
-	_vec.data(0) = image.image();
-	*((int*) _vec.data(1)) = x;
-	*((int*) _vec.data(2)) = y;
-	((im_doublevec_object*) _vec.data(3))->n = ink.size();
-	((im_doublevec_object*) _vec.data(3))->vec = new double[ink.size()];
-	for( unsigned int i = 0; i < ink.size(); i++ )
-		((im_doublevec_object*) _vec.data(3))->vec[i] = ink[i];
-	_vec.call();
-}
-
-// im_draw_smudge: smudge part of an image
-void VImage::draw_smudge( int left, int top, int width, int height ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_smudge" );
-
-	_vec.data(0) = image.image();
-	*((int*) _vec.data(1)) = left;
-	*((int*) _vec.data(2)) = top;
-	*((int*) _vec.data(3)) = width;
-	*((int*) _vec.data(4)) = height;
-	_vec.call();
-}
-
-// im_draw_flood: flood with ink from x, y while pixel != ink
-void VImage::draw_flood( int x, int y, std::vector<double> ink ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_flood" );
-
-	_vec.data(0) = image.image();
-	*((int*) _vec.data(1)) = x;
-	*((int*) _vec.data(2)) = y;
-	((im_doublevec_object*) _vec.data(3))->n = ink.size();
-	((im_doublevec_object*) _vec.data(3))->vec = new double[ink.size()];
-	for( unsigned int i = 0; i < ink.size(); i++ )
-		((im_doublevec_object*) _vec.data(3))->vec[i] = ink[i];
-	_vec.call();
-}
-
-// im_draw_flood_blob: flood with ink from x, y while pixel == start
-void VImage::draw_flood_blob( int x, int y, std::vector<double> ink ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_flood_blob" );
-
-	_vec.data(0) = image.image();
-	*((int*) _vec.data(1)) = x;
-	*((int*) _vec.data(2)) = y;
-	((im_doublevec_object*) _vec.data(3))->n = ink.size();
-	((im_doublevec_object*) _vec.data(3))->vec = new double[ink.size()];
-	for( unsigned int i = 0; i < ink.size(); i++ )
-		((im_doublevec_object*) _vec.data(3))->vec[i] = ink[i];
-	_vec.call();
-}
-
-// im_draw_flood_other: flood image with serial from x, y while pixel == start
-void VImage::draw_flood_other( VImage test, int x, int y, int serial ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_flood_other" );
-
-	_vec.data(0) = image.image();
-	_vec.data(1) = test.image();
-	*((int*) _vec.data(2)) = x;
-	*((int*) _vec.data(3)) = y;
-	*((int*) _vec.data(4)) = serial;
-	_vec.call();
-}
-
-// im_draw_image: draw image sub inside image main at position (x,y)
-void VImage::draw_image( VImage sub, int x, int y ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_image" );
-
-	_vec.data(0) = image.image();
-	_vec.data(1) = sub.image();
-	*((int*) _vec.data(2)) = x;
-	*((int*) _vec.data(3)) = y;
-	_vec.call();
-}
-
-// im_draw_mask: draw mask sub inside image main at position (x,y)
-void VImage::draw_mask( VImage mask, int x, int y, std::vector<double> ink ) throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_draw_mask" );
-
-	_vec.data(0) = image.image();
-	_vec.data(1) = mask.image();
-	*((int*) _vec.data(2)) = x;
-	*((int*) _vec.data(3)) = y;
-	((im_doublevec_object*) _vec.data(4))->n = ink.size();
-	((im_doublevec_object*) _vec.data(4))->vec = new double[ink.size()];
-	for( unsigned int i = 0; i < ink.size(); i++ )
-		((im_doublevec_object*) _vec.data(4))->vec[i] = ink[i];
-	_vec.call();
-}
-
-// im_lineset: draw line between points (x1,y1) and (x2,y2)
-VImage VImage::line( VImage mask, VImage ink, std::vector<int> x1, std::vector<int> y1, std::vector<int> x2, std::vector<int> y2 ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_lineset" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = mask.image();
-	_vec.data(3) = ink.image();
-	((im_intvec_object*) _vec.data(4))->n = x1.size();
-	((im_intvec_object*) _vec.data(4))->vec = new int[x1.size()];
-	for( unsigned int i = 0; i < x1.size(); i++ )
-		((im_intvec_object*) _vec.data(4))->vec[i] = x1[i];
-	((im_intvec_object*) _vec.data(5))->n = y1.size();
-	((im_intvec_object*) _vec.data(5))->vec = new int[y1.size()];
-	for( unsigned int i = 0; i < y1.size(); i++ )
-		((im_intvec_object*) _vec.data(5))->vec[i] = y1[i];
-	((im_intvec_object*) _vec.data(6))->n = x2.size();
-	((im_intvec_object*) _vec.data(6))->vec = new int[x2.size()];
-	for( unsigned int i = 0; i < x2.size(); i++ )
-		((im_intvec_object*) _vec.data(6))->vec[i] = x2[i];
-	((im_intvec_object*) _vec.data(7))->n = y2.size();
-	((im_intvec_object*) _vec.data(7))->vec = new int[y2.size()];
-	for( unsigned int i = 0; i < y2.size(); i++ )
-		((im_intvec_object*) _vec.data(7))->vec[i] = y2[i];
-	_vec.call();
-
-	return( out );
-}
-
-
-// bodies for package iofuncs
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_binfile: open a headerless binary file
-VImage VImage::binfile( char* filename, int width, int height, int bands, int offset ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_binfile" );
-
-	_vec.data(0) = (im_object) filename;
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = width;
-	*((int*) _vec.data(3)) = height;
-	*((int*) _vec.data(4)) = bands;
-	*((int*) _vec.data(5)) = offset;
-	_vec.call();
-
-	return( out );
-}
-
-// im_cache: cache results of an operation
-VImage VImage::cache( int tile_width, int tile_height, int max_tiles ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_cache" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = tile_width;
-	*((int*) _vec.data(3)) = tile_height;
-	*((int*) _vec.data(4)) = max_tiles;
-	_vec.call();
-
-	return( out );
-}
-
-// im_getext: return the image metadata XML as a string
-char* VImage::getext() throw( VError )
-{
-	VImage image = *this;
-	char* history;
-
-	Vargv _vec( "im_getext" );
-
-	_vec.data(0) = image.image();
-	_vec.call();
-	history = (char*) _vec.data(1);
-
-	return( history );
-}
-
-// im_header_get_typeof: return field type
-int VImage::header_get_typeof( char* field ) throw( VError )
-{
-	VImage image = *this;
-	int gtype;
-
-	Vargv _vec( "im_header_get_typeof" );
-
-	_vec.data(0) = (im_object) field;
-	_vec.data(1) = image.image();
-	_vec.call();
-	gtype = *((int*)_vec.data(2));
-
-	return( gtype );
-}
-
-// im_header_int: extract int fields from header
-int VImage::header_int( char* field ) throw( VError )
-{
-	VImage image = *this;
-	int value;
-
-	Vargv _vec( "im_header_int" );
-
-	_vec.data(0) = (im_object) field;
-	_vec.data(1) = image.image();
-	_vec.call();
-	value = *((int*)_vec.data(2));
-
-	return( value );
-}
-
-// im_header_double: extract double fields from header
-double VImage::header_double( char* field ) throw( VError )
-{
-	VImage image = *this;
-	double value;
-
-	Vargv _vec( "im_header_double" );
-
-	_vec.data(0) = (im_object) field;
-	_vec.data(1) = image.image();
-	_vec.call();
-	value = *((double*)_vec.data(2));
-
-	return( value );
-}
-
-// im_header_string: extract fields from headers as strings
-char* VImage::header_string( char* field ) throw( VError )
-{
-	VImage image = *this;
-	char* value;
-
-	Vargv _vec( "im_header_string" );
-
-	_vec.data(0) = (im_object) field;
-	_vec.data(1) = image.image();
-	_vec.call();
-	value = (char*) _vec.data(2);
-
-	return( value );
-}
-
-// im_history_get: return the image history as a string
-char* VImage::history_get() throw( VError )
-{
-	VImage image = *this;
-	char* history;
-
-	Vargv _vec( "im_history_get" );
-
-	_vec.data(0) = image.image();
-	_vec.call();
-	history = (char*) _vec.data(1);
-
-	return( history );
-}
-
-// im_printdesc: print an image header to stdout
-void VImage::printdesc() throw( VError )
-{
-	VImage image = *this;
-	Vargv _vec( "im_printdesc" );
-
-	_vec.data(0) = image.image();
-	_vec.call();
-}
-
-
-// bodies for package mask
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-
-// bodies for package morphology
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_cntlines: count horizontal or vertical lines
-double VImage::cntlines( int direction ) throw( VError )
-{
-	VImage in = *this;
-	double nlines;
-
-	Vargv _vec( "im_cntlines" );
-
-	_vec.data(0) = in.image();
-	*((int*) _vec.data(2)) = direction;
-	_vec.call();
-	nlines = *((double*)_vec.data(1));
-
-	return( nlines );
-}
-
-// im_dilate: dilate image with mask, adding a black border
-VImage VImage::dilate( VIMask mask ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_dilate" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = mask.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_rank: rank filter nth element of xsize/ysize window
-VImage VImage::rank( int xsize, int ysize, int n ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_rank" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = xsize;
-	*((int*) _vec.data(3)) = ysize;
-	*((int*) _vec.data(4)) = n;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_rank_image: point-wise pixel rank
-VImage VImage::rank_image( std::vector<VImage> in, int index ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_rank_image" );
-
-	((im_imagevec_object*) _vec.data(0))->n = in.size();
-	((im_imagevec_object*) _vec.data(0))->vec = new IMAGE *[in.size()];
-	for( unsigned int i = 0; i < in.size(); i++ )
-		((im_imagevec_object*) _vec.data(0))->vec[i] = in[i].image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = index;
-	_vec.call();
-	for( unsigned int i = 0; i < in.size(); i++ )
-		out._ref->addref( in[i]._ref );
-
-	return( out );
-}
-
-// im_maxvalue: point-wise maximum value
-VImage VImage::maxvalue( std::vector<VImage> in ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_maxvalue" );
-
-	((im_imagevec_object*) _vec.data(0))->n = in.size();
-	((im_imagevec_object*) _vec.data(0))->vec = new IMAGE *[in.size()];
-	for( unsigned int i = 0; i < in.size(); i++ )
-		((im_imagevec_object*) _vec.data(0))->vec[i] = in[i].image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	for( unsigned int i = 0; i < in.size(); i++ )
-		out._ref->addref( in[i]._ref );
-
-	return( out );
-}
-
-// im_label_regions: number continuous regions in an image
-VImage VImage::label_regions( int& segments ) throw( VError )
-{
-	VImage test = *this;
-	VImage mask;
-
-	Vargv _vec( "im_label_regions" );
-
-	_vec.data(0) = test.image();
-	_vec.data(1) = mask.image();
-	_vec.call();
-	segments = *((int*)_vec.data(2));
-
-	return( mask );
-}
-
-// im_zerox: find +ve or -ve zero crossings in image
-VImage VImage::zerox( int flag ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_zerox" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = flag;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_erode: erode image with mask, adding a black border
-VImage VImage::erode( VIMask mask ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_erode" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	((im_mask_object*) _vec.data(2))->mask = mask.mask().iptr;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_profile: find first horizontal/vertical edge
-VImage VImage::profile( int direction ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_profile" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = direction;
-	_vec.call();
-
-	return( out );
-}
-
-
-// bodies for package mosaicing
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_align_bands: align the bands of an image
-VImage VImage::align_bands() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_align_bands" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-
-	return( out );
-}
-
-// im_correl: search area around sec for match for area around ref
-double VImage::correl( VImage sec, int xref, int yref, int xsec, int ysec, int hwindowsize, int hsearchsize, int& x, int& y ) throw( VError )
-{
-	VImage ref = *this;
-	double correlation;
-
-	Vargv _vec( "im_correl" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	*((int*) _vec.data(2)) = xref;
-	*((int*) _vec.data(3)) = yref;
-	*((int*) _vec.data(4)) = xsec;
-	*((int*) _vec.data(5)) = ysec;
-	*((int*) _vec.data(6)) = hwindowsize;
-	*((int*) _vec.data(7)) = hsearchsize;
-	_vec.call();
-	correlation = *((double*)_vec.data(8));
-	x = *((int*)_vec.data(9));
-	y = *((int*)_vec.data(10));
-
-	return( correlation );
-}
-
-// im__find_lroverlap: search for left-right overlap of ref and sec
-int VImage::_find_lroverlap( VImage sec, int bandno, int xr, int yr, int xs, int ys, int halfcorrelation, int halfarea, int& dy0, double& scale1, double& angle1, double& dx1, double& dy1 ) throw( VError )
-{
-	VImage ref = *this;
-	int dx0;
-
-	Vargv _vec( "im__find_lroverlap" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	*((int*) _vec.data(2)) = bandno;
-	*((int*) _vec.data(3)) = xr;
-	*((int*) _vec.data(4)) = yr;
-	*((int*) _vec.data(5)) = xs;
-	*((int*) _vec.data(6)) = ys;
-	*((int*) _vec.data(7)) = halfcorrelation;
-	*((int*) _vec.data(8)) = halfarea;
-	_vec.call();
-	dx0 = *((int*)_vec.data(9));
-	dy0 = *((int*)_vec.data(10));
-	scale1 = *((double*)_vec.data(11));
-	angle1 = *((double*)_vec.data(12));
-	dx1 = *((double*)_vec.data(13));
-	dy1 = *((double*)_vec.data(14));
-
-	return( dx0 );
-}
-
-// im__find_tboverlap: search for top-bottom overlap of ref and sec
-int VImage::_find_tboverlap( VImage sec, int bandno, int xr, int yr, int xs, int ys, int halfcorrelation, int halfarea, int& dy0, double& scale1, double& angle1, double& dx1, double& dy1 ) throw( VError )
-{
-	VImage ref = *this;
-	int dx0;
-
-	Vargv _vec( "im__find_tboverlap" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	*((int*) _vec.data(2)) = bandno;
-	*((int*) _vec.data(3)) = xr;
-	*((int*) _vec.data(4)) = yr;
-	*((int*) _vec.data(5)) = xs;
-	*((int*) _vec.data(6)) = ys;
-	*((int*) _vec.data(7)) = halfcorrelation;
-	*((int*) _vec.data(8)) = halfarea;
-	_vec.call();
-	dx0 = *((int*)_vec.data(9));
-	dy0 = *((int*)_vec.data(10));
-	scale1 = *((double*)_vec.data(11));
-	angle1 = *((double*)_vec.data(12));
-	dx1 = *((double*)_vec.data(13));
-	dy1 = *((double*)_vec.data(14));
-
-	return( dx0 );
-}
-
-// im_global_balance: automatically rebuild mosaic with balancing
-VImage VImage::global_balance( double gamma ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_global_balance" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = gamma;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_global_balancef: automatically rebuild mosaic with balancing, float output
-VImage VImage::global_balancef( double gamma ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_global_balancef" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = gamma;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_lrmerge: left-right merge of in1 and in2
-VImage VImage::lrmerge( VImage sec, int dx, int dy, int mwidth ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_lrmerge" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = dx;
-	*((int*) _vec.data(4)) = dy;
-	*((int*) _vec.data(5)) = mwidth;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-// im_lrmerge1: first-order left-right merge of ref and sec
-VImage VImage::lrmerge1( VImage sec, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int mwidth ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_lrmerge1" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = xr1;
-	*((int*) _vec.data(4)) = yr1;
-	*((int*) _vec.data(5)) = xs1;
-	*((int*) _vec.data(6)) = ys1;
-	*((int*) _vec.data(7)) = xr2;
-	*((int*) _vec.data(8)) = yr2;
-	*((int*) _vec.data(9)) = xs2;
-	*((int*) _vec.data(10)) = ys2;
-	*((int*) _vec.data(11)) = mwidth;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-// im_lrmosaic: left-right mosaic of ref and sec
-VImage VImage::lrmosaic( VImage sec, int bandno, int xr, int yr, int xs, int ys, int halfcorrelation, int halfarea, int balancetype, int mwidth ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_lrmosaic" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = bandno;
-	*((int*) _vec.data(4)) = xr;
-	*((int*) _vec.data(5)) = yr;
-	*((int*) _vec.data(6)) = xs;
-	*((int*) _vec.data(7)) = ys;
-	*((int*) _vec.data(8)) = halfcorrelation;
-	*((int*) _vec.data(9)) = halfarea;
-	*((int*) _vec.data(10)) = balancetype;
-	*((int*) _vec.data(11)) = mwidth;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-// im_lrmosaic1: first-order left-right mosaic of ref and sec
-VImage VImage::lrmosaic1( VImage sec, int bandno, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int halfcorrelation, int halfarea, int balancetype, int mwidth ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_lrmosaic1" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = bandno;
-	*((int*) _vec.data(4)) = xr1;
-	*((int*) _vec.data(5)) = yr1;
-	*((int*) _vec.data(6)) = xs1;
-	*((int*) _vec.data(7)) = ys1;
-	*((int*) _vec.data(8)) = xr2;
-	*((int*) _vec.data(9)) = yr2;
-	*((int*) _vec.data(10)) = xs2;
-	*((int*) _vec.data(11)) = ys2;
-	*((int*) _vec.data(12)) = halfcorrelation;
-	*((int*) _vec.data(13)) = halfarea;
-	*((int*) _vec.data(14)) = balancetype;
-	*((int*) _vec.data(15)) = mwidth;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-// im_match_linear: resample ref so that tie-points match
-VImage VImage::match_linear( VImage sec, int xref1, int yref1, int xsec1, int ysec1, int xref2, int yref2, int xsec2, int ysec2 ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_match_linear" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = xref1;
-	*((int*) _vec.data(4)) = yref1;
-	*((int*) _vec.data(5)) = xsec1;
-	*((int*) _vec.data(6)) = ysec1;
-	*((int*) _vec.data(7)) = xref2;
-	*((int*) _vec.data(8)) = yref2;
-	*((int*) _vec.data(9)) = xsec2;
-	*((int*) _vec.data(10)) = ysec2;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-// im_match_linear_search: search sec, then resample so that tie-points match
-VImage VImage::match_linear_search( VImage sec, int xref1, int yref1, int xsec1, int ysec1, int xref2, int yref2, int xsec2, int ysec2, int hwindowsize, int hsearchsize ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_match_linear_search" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = xref1;
-	*((int*) _vec.data(4)) = yref1;
-	*((int*) _vec.data(5)) = xsec1;
-	*((int*) _vec.data(6)) = ysec1;
-	*((int*) _vec.data(7)) = xref2;
-	*((int*) _vec.data(8)) = yref2;
-	*((int*) _vec.data(9)) = xsec2;
-	*((int*) _vec.data(10)) = ysec2;
-	*((int*) _vec.data(11)) = hwindowsize;
-	*((int*) _vec.data(12)) = hsearchsize;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-// im_maxpos_subpel: subpixel position of maximum of (phase correlation) image
-double VImage::maxpos_subpel( double& y ) throw( VError )
-{
-	VImage im = *this;
-	double x;
-
-	Vargv _vec( "im_maxpos_subpel" );
-
-	_vec.data(0) = im.image();
-	_vec.call();
-	x = *((double*)_vec.data(1));
-	y = *((double*)_vec.data(2));
-
-	return( x );
-}
-
-// im_remosaic: automatically rebuild mosaic with new files
-VImage VImage::remosaic( char* old_str, char* new_str ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_remosaic" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.data(2) = (im_object) old_str;
-	_vec.data(3) = (im_object) new_str;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_tbmerge: top-bottom merge of in1 and in2
-VImage VImage::tbmerge( VImage sec, int dx, int dy, int mwidth ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_tbmerge" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = dx;
-	*((int*) _vec.data(4)) = dy;
-	*((int*) _vec.data(5)) = mwidth;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-// im_tbmerge1: first-order top-bottom merge of in1 and in2
-VImage VImage::tbmerge1( VImage sec, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int mwidth ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_tbmerge1" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = xr1;
-	*((int*) _vec.data(4)) = yr1;
-	*((int*) _vec.data(5)) = xs1;
-	*((int*) _vec.data(6)) = ys1;
-	*((int*) _vec.data(7)) = xr2;
-	*((int*) _vec.data(8)) = yr2;
-	*((int*) _vec.data(9)) = xs2;
-	*((int*) _vec.data(10)) = ys2;
-	*((int*) _vec.data(11)) = mwidth;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-// im_tbmosaic: top-bottom mosaic of in1 and in2
-VImage VImage::tbmosaic( VImage sec, int bandno, int xr, int yr, int xs, int ys, int halfcorrelation, int halfarea, int balancetype, int mwidth ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_tbmosaic" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = bandno;
-	*((int*) _vec.data(4)) = xr;
-	*((int*) _vec.data(5)) = yr;
-	*((int*) _vec.data(6)) = xs;
-	*((int*) _vec.data(7)) = ys;
-	*((int*) _vec.data(8)) = halfcorrelation;
-	*((int*) _vec.data(9)) = halfarea;
-	*((int*) _vec.data(10)) = balancetype;
-	*((int*) _vec.data(11)) = mwidth;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-// im_tbmosaic1: first-order top-bottom mosaic of ref and sec
-VImage VImage::tbmosaic1( VImage sec, int bandno, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int halfcorrelation, int halfarea, int balancetype, int mwidth ) throw( VError )
-{
-	VImage ref = *this;
-	VImage out;
-
-	Vargv _vec( "im_tbmosaic1" );
-
-	_vec.data(0) = ref.image();
-	_vec.data(1) = sec.image();
-	_vec.data(2) = out.image();
-	*((int*) _vec.data(3)) = bandno;
-	*((int*) _vec.data(4)) = xr1;
-	*((int*) _vec.data(5)) = yr1;
-	*((int*) _vec.data(6)) = xs1;
-	*((int*) _vec.data(7)) = ys1;
-	*((int*) _vec.data(8)) = xr2;
-	*((int*) _vec.data(9)) = yr2;
-	*((int*) _vec.data(10)) = xs2;
-	*((int*) _vec.data(11)) = ys2;
-	*((int*) _vec.data(12)) = halfcorrelation;
-	*((int*) _vec.data(13)) = halfarea;
-	*((int*) _vec.data(14)) = balancetype;
-	*((int*) _vec.data(15)) = mwidth;
-	_vec.call();
-	out._ref->addref( ref._ref );
-	out._ref->addref( sec._ref );
-
-	return( out );
-}
-
-
-// bodies for package other
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_benchmark: do something complicated for testing
-VImage VImage::benchmark() throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_benchmark" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_benchmark2: do something complicated for testing
-double VImage::benchmark2() throw( VError )
-{
-	VImage in = *this;
-	double value;
-
-	Vargv _vec( "im_benchmark2" );
-
-	_vec.data(0) = in.image();
-	_vec.call();
-	value = *((double*)_vec.data(1));
-
-	return( value );
-}
-
-// im_benchmarkn: do something complicated for testing
-VImage VImage::benchmarkn( int n ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_benchmarkn" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = n;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_eye: generate IM_BANDFMT_UCHAR [0,255] frequency/amplitude image
-VImage VImage::eye( int xsize, int ysize, double factor ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_eye" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = xsize;
-	*((int*) _vec.data(2)) = ysize;
-	*((double*) _vec.data(3)) = factor;
-	_vec.call();
-
-	return( out );
-}
-
-// im_grey: generate IM_BANDFMT_UCHAR [0,255] grey scale image
-VImage VImage::grey( int xsize, int ysize ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_grey" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = xsize;
-	*((int*) _vec.data(2)) = ysize;
-	_vec.call();
-
-	return( out );
-}
-
-// im_feye: generate IM_BANDFMT_FLOAT [-1,1] frequency/amplitude image
-VImage VImage::feye( int xsize, int ysize, double factor ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_feye" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = xsize;
-	*((int*) _vec.data(2)) = ysize;
-	*((double*) _vec.data(3)) = factor;
-	_vec.call();
-
-	return( out );
-}
-
-// im_fgrey: generate IM_BANDFMT_FLOAT [0,1] grey scale image
-VImage VImage::fgrey( int xsize, int ysize ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_fgrey" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = xsize;
-	*((int*) _vec.data(2)) = ysize;
-	_vec.call();
-
-	return( out );
-}
-
-// im_fzone: generate IM_BANDFMT_FLOAT [-1,1] zone plate image
-VImage VImage::fzone( int size ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_fzone" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = size;
-	_vec.call();
-
-	return( out );
-}
-
-// im_make_xy: generate image with pixel value equal to coordinate
-VImage VImage::make_xy( int xsize, int ysize ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_make_xy" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = xsize;
-	*((int*) _vec.data(2)) = ysize;
-	_vec.call();
-
-	return( out );
-}
-
-// im_sines: generate 2D sine image
-VImage VImage::sines( int xsize, int ysize, double horfreq, double verfreq ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_sines" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = xsize;
-	*((int*) _vec.data(2)) = ysize;
-	*((double*) _vec.data(3)) = horfreq;
-	*((double*) _vec.data(4)) = verfreq;
-	_vec.call();
-
-	return( out );
-}
-
-// im_zone: generate IM_BANDFMT_UCHAR [0,255] zone plate image
-VImage VImage::zone( int size ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_zone" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = size;
-	_vec.call();
-
-	return( out );
-}
-
-
-// bodies for package resample
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_rightshift_size: decrease size by a power-of-two factor
-VImage VImage::rightshift_size( int xshift, int yshift, int band_fmt ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_rightshift_size" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((int*) _vec.data(2)) = xshift;
-	*((int*) _vec.data(3)) = yshift;
-	*((int*) _vec.data(4)) = band_fmt;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_shrink: shrink image by xfac, yfac times
-VImage VImage::shrink( double xfac, double yfac ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_shrink" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = xfac;
-	*((double*) _vec.data(3)) = yfac;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_stretch3: stretch 3%, sub-pixel displace by xdisp/ydisp
-VImage VImage::stretch3( double xdisp, double ydisp ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_stretch3" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	*((double*) _vec.data(2)) = xdisp;
-	*((double*) _vec.data(3)) = ydisp;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_affinei: affine transform
-VImage VImage::affinei( char* interpolate, double a, double b, double c, double d, double dx, double dy, int x, int y, int w, int h ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_affinei" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	if( vips__input_interpolate_init( &_vec.data(2), interpolate ) )
-		verror();
-	*((double*) _vec.data(3)) = a;
-	*((double*) _vec.data(4)) = b;
-	*((double*) _vec.data(5)) = c;
-	*((double*) _vec.data(6)) = d;
-	*((double*) _vec.data(7)) = dx;
-	*((double*) _vec.data(8)) = dy;
-	*((int*) _vec.data(9)) = x;
-	*((int*) _vec.data(10)) = y;
-	*((int*) _vec.data(11)) = w;
-	*((int*) _vec.data(12)) = h;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-// im_affinei_all: affine transform of whole image
-VImage VImage::affinei_all( char* interpolate, double a, double b, double c, double d, double dx, double dy ) throw( VError )
-{
-	VImage in = *this;
-	VImage out;
-
-	Vargv _vec( "im_affinei_all" );
-
-	_vec.data(0) = in.image();
-	_vec.data(1) = out.image();
-	if( vips__input_interpolate_init( &_vec.data(2), interpolate ) )
-		verror();
-	*((double*) _vec.data(3)) = a;
-	*((double*) _vec.data(4)) = b;
-	*((double*) _vec.data(5)) = c;
-	*((double*) _vec.data(6)) = d;
-	*((double*) _vec.data(7)) = dx;
-	*((double*) _vec.data(8)) = dy;
-	_vec.call();
-	out._ref->addref( in._ref );
-
-	return( out );
-}
-
-
-// bodies for package video
-// this file automatically generated from
-// VIPS library 7.34.0-Tue Jun 11 11:18:24 BST 2013
-// im_video_test: test video grabber
-VImage VImage::video_test( int brightness, int error ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_video_test" );
-
-	_vec.data(0) = out.image();
-	*((int*) _vec.data(1)) = brightness;
-	*((int*) _vec.data(2)) = error;
-	_vec.call();
-
-	return( out );
-}
-
-// im_video_v4l1: grab a video frame with v4l1
-VImage VImage::video_v4l1( char* device, int channel, int brightness, int colour, int contrast, int hue, int ngrabs ) throw( VError )
-{
-	VImage out;
-
-	Vargv _vec( "im_video_v4l1" );
-
-	_vec.data(0) = out.image();
-	_vec.data(1) = (im_object) device;
-	*((int*) _vec.data(2)) = channel;
-	*((int*) _vec.data(3)) = brightness;
-	*((int*) _vec.data(4)) = colour;
-	*((int*) _vec.data(5)) = contrast;
-	*((int*) _vec.data(6)) = hue;
-	*((int*) _vec.data(7)) = ngrabs;
-	_vec.call();
-
-	return( out );
-}
-
-
diff -u --recursive --new-file vips-7.38.5-vanilla/libvipsCC/VMask.cc vips-7.38.5/libvipsCC/VMask.cc
--- vips-7.38.5-vanilla/libvipsCC/VMask.cc	2014-07-17 23:48:36.237794473 -0400
+++ vips-7.38.5/libvipsCC/VMask.cc	1969-12-31 19:00:00.000000000 -0500
@@ -1,662 +0,0 @@
-// Object part of VMask class
-
-/*
-
-    Copyright (C) 1991-2001 The National Gallery
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-#include <vips/intl.h>
-
-#include <cstdlib>
-#include <cmath>
-
-#include <vips/vips.h>
-
-#include <vips/vipscpp.h>
-
-#ifdef WITH_DMALLOC
-#include <dmalloc.h>
-#endif /*WITH_DMALLOC*/
-
-VIPS_NAMESPACE_START
-
-/* Functions for VMask - refcounting layer over VPMask.
- */
-
-VMask::~VMask()
-{
-	ref->nrefs--;
-	if( !ref->nrefs )
-		delete ref;
-}
-
-VMask &VMask::operator=( const VMask &a )
-{ 
-	// Loosing ref to LHS
-	ref->nrefs--;
-
-	if( ref->nrefs > 0 )
-		// Need fresh refblock
-		ref = new refblock;
-	else 
-		// Recycle old refblock
-		delete ref->pmask;
-
-	// LHS now points to RHS
-	ref = a.ref; 
-	ref->nrefs++; 
-	
-	return( *this ); 
-}
-
-// Make sure this is a private copy of pmask --- dup if nrefs != 1
-void VMask::make_private()
-{
-	if( ref->nrefs > 1 ) {
-		// Make fresh refblock
-		refblock *ref2 = new refblock;
-
-		// And copy the mask
-		ref2->pmask = ref->pmask->dup();
-		ref->nrefs--;
-		ref = ref2;
-	}
-}
-
-void VMask::ostream_print( std::ostream &file ) const
-{
-	file << *(ref->pmask);
-}
-
-// Embed INTMASK in VIMask
-void VIMask::embed( INTMASK *i ) throw( VError )
-{
-	if( ref->pmask )
-		verror( "embed: VIMask not empty" );
-	ref->pmask = new _private_detail::VPIMask( i );
-}
-
-// Type conversions: implicit INTMASK to DOUBLEMASK 
-VIMask::operator VDMask()
-{
-	VDMask out( xsize(), ysize() );
-
-	out.mask().dptr->scale = scale();
-	out.mask().dptr->offset = offset();
-
-	for( int i = 0; i < size(); i++ )
-		out[i] = (*this)[i];
-
-	return( out );
-}
-
-
-// Forward ref of VImage class
-class VImage;
-
-// Type conversions: implicit DOUBLEMASK to INTMASK
-VDMask::operator VIMask()
-{
-	VIMask out( xsize(), ysize() );
-
-	out.mask().iptr->scale = int( scale() );
-	out.mask().iptr->offset = int( offset() );
-
-	for( int i = 0; i < size(); i++ )
-		out[i] = (int) rint( (*this)[i] );
-
-	return( out );
-}
-
-// Type conversions: implicit DOUBLEMASK to VImage
-VDMask::operator VImage() throw( VError )
-{
-	VImage out;
-
-	if( im_mask2vips( mask().dptr, out.image() ) )
-		verror();
-
-	return( out );
-}
-
-// ... and INTMASK to VImage
-VIMask::operator VImage() { return( VImage( VDMask( *this ) ) ); }
-
-// Embed DOUBLEMASK in VDMask
-void VDMask::embed( DOUBLEMASK *i ) throw( VError )
-{
-	if( ref->pmask )
-		verror( "embed: VDMask not empty" );
-	ref->pmask = new _private_detail::VPDMask( i );
-}
-
-/* Functions for P*Mask - layer over im_*_*mask() functions.
- */
-
-// Create empty imask
-_private_detail::VPIMask::VPIMask( int xsize, int ysize ) throw( VError )
-{
-	if( !(data.iptr = im_create_imask( "VPIMask::VPIMask", xsize, ysize )) )
-		verror();
-	type = _private_detail::VPMask::INT;
-}
-
-// Init from vector
-_private_detail::VPIMask::VPIMask( int xsize, int ysize, 
-	int scale, int offset, std::vector<int> coeff )
-	throw( VError )
-{
-	int i;
-
-	if( !(data.iptr = im_create_imask( "VPIMask::VPIMask", xsize, ysize )) )
-		verror();
-	type = _private_detail::VPMask::INT;
-
-	data.iptr->scale = scale;
-	data.iptr->offset = offset;
-	for( i = 0; i < xsize * ysize; i++ )
-		data.iptr->coeff[i] = coeff[i];
-}
-
-// Create from filename
-_private_detail::VPIMask::VPIMask( const char *name ) throw( VError )
-{
-	if( !(data.iptr = im_read_imask( (char *) name )) )
-		verror();
-	type = _private_detail::VPMask::INT;
-}
-
-// Create from existing INTMASK
-_private_detail::VPIMask::VPIMask( INTMASK *imask )
-{
-	data.iptr = imask;
-	type = _private_detail::VPMask::INT;
-}
-
-// Create empty
-_private_detail::VPIMask::VPIMask()
-{
-	data.iptr = 0;
-	type = _private_detail::VPMask::UNASSIGNED;
-}
-
-_private_detail::VPIMask::~VPIMask()
-{
-	if( data.iptr ) {
-		im_free_imask( data.iptr );
-		data.iptr = 0;
-		type = _private_detail::VPMask::UNASSIGNED;
-	}
-}
-
-// Duplicate -- we are a VPIMask, return a new VPIMask which is a copy of us.
-// Return as a VPMask tho'.
-_private_detail::VPMask *_private_detail::VPIMask::dup() const throw( VError )
-{
-	_private_detail::VPIMask *out = new _private_detail::VPIMask();
-
-	INTMASK *msk;
-	if( !(msk = im_dup_imask( data.iptr, "VPIMask::dup" )) ) {
-		delete out;
-		verror();
-	}
-	out->embed( msk );
-
-	return( out );
-}
-
-// Insert INTMASK pointer
-void _private_detail::VPIMask::embed( INTMASK *msk ) throw( VError )
-{
-	if( type != _private_detail::VPMask::UNASSIGNED )
-		verror( "VPIMask::embed: VPIMask not empty" );
-
-	data.iptr = msk;
-	type = _private_detail::VPMask::INT;
-}
-
-int _private_detail::VPIMask::xsize() const throw( VError )
-{
-	if( !data.iptr ) 
-		verror( "xsize: mask not set" );
-
-	return( data.iptr->xsize );
-}
-
-int _private_detail::VPIMask::ysize() const throw( VError )
-{
-	if( !data.iptr ) 
-		verror( "ysize: mask not set" );
-
-	return( data.iptr->ysize );
-}
-
-int _private_detail::VPIMask::scale() const throw( VError )
-{
-	if( !data.iptr ) 
-		verror( "scale: mask not set" );
-
-	return( data.iptr->scale );
-}
-
-int _private_detail::VPIMask::offset() const throw( VError )
-{
-	if( !data.iptr ) 
-		verror( "offset: mask not set" );
-
-	return( data.iptr->offset );
-}
-
-const char *_private_detail::VPIMask::filename() const throw( VError )
-{
-	if( !data.iptr ) 
-		verror( "filename: mask not set" );
-
-	return( data.iptr->filename );
-}
-
-void _private_detail::VPIMask::ostream_print( std::ostream &file ) const 
-	throw( VError )
-{
-	if( !data.iptr )
-		verror( "internal error #7447234" );
-	
-	int i, j;
-	int *p = data.iptr->coeff;
-
-	file << this->xsize() << "\t" << this->ysize() << "\t";
-	file << this->scale() << "\t" << this->offset() << "\n";
-
-	for( i = 0; i < this->ysize(); i++ ) {
-		for( j = 0; j < this->xsize(); j++ )
-			file << *p++ << "\t";
-
-		file << "\n";
-	}
-}
-
-// Extract start of int array
-int *_private_detail::VPIMask::array() const 
-{ 
-	return( data.iptr->coeff ); 
-}
-
-// Create empty dmask
-_private_detail::VPDMask::VPDMask( int xsize, int ysize ) throw( VError )
-{
-	if( !(data.dptr = im_create_dmask( "VPDMask::VPDMask", xsize, ysize )) )
-		verror();
-	type = _private_detail::VPMask::DOUBLE;
-}
-
-// Create from vector
-_private_detail::VPDMask::VPDMask( int xsize, int ysize, 
-	double scale, double offset, std::vector<double> coeff ) throw( VError )
-{
-	int i;
-
-	if( !(data.dptr = im_create_dmask( "VPDMask::VPDMask", xsize, ysize )) )
-		verror();
-	type = _private_detail::VPMask::DOUBLE;
-
-	data.dptr->scale = scale;
-	data.dptr->offset = offset;
-	for( i = 0; i < xsize * ysize; i++ )
-		data.dptr->coeff[i] = coeff[i];
-}
-
-// Create from filename
-_private_detail::VPDMask::VPDMask( const char *name ) throw( VError )
-{
-	if( !(data.dptr = im_read_dmask( (char *) name )) )
-		verror();
-	type = _private_detail::VPMask::DOUBLE;
-}
-
-// Create empty
-_private_detail::VPDMask::VPDMask()
-{
-	data.dptr = 0;
-	type = _private_detail::VPMask::UNASSIGNED;
-}
-
-// Create from existing DOUBLEMASK
-_private_detail::VPDMask::VPDMask( DOUBLEMASK *dmask )
-{
-	data.dptr = dmask;
-	type = _private_detail::VPMask::DOUBLE;
-}
-
-_private_detail::VPDMask::~VPDMask()
-{
-	if( data.dptr ) {
-		im_free_dmask( data.dptr );
-		data.dptr = 0;
-		type = _private_detail::VPMask::UNASSIGNED;
-	}
-}
-
-// Duplicate -- we are a VPIMask, return a new VPIMask which is a copy of us.
-// Return as a VPMask tho'.
-_private_detail::VPMask *_private_detail::VPDMask::dup() const throw( VError )
-{
-	_private_detail::VPDMask *out = new _private_detail::VPDMask();
-
-	DOUBLEMASK *msk;
-	if( !(msk = im_dup_dmask( data.dptr, "VPDMask::dup" )) ) {
-		delete out;
-		verror();
-	}
-	out->embed( msk );
-
-	return( out );
-}
-
-// Insert DOUBLEMASK pointer
-void _private_detail::VPDMask::embed( DOUBLEMASK *msk ) throw( VError )
-{
-	if( type != _private_detail::VPMask::UNASSIGNED )
-		verror( "VPDMask::embed: VPDMask not empty" );
-
-	data.dptr = msk;
-	type = _private_detail::VPMask::DOUBLE;
-}
-
-int _private_detail::VPDMask::xsize() const throw( VError )
-{
-	if( !data.dptr ) 
-		verror( "xsize: mask not set" );
-
-	return( data.dptr->xsize );
-}
-
-int _private_detail::VPDMask::ysize() const throw( VError )
-{
-	if( !data.dptr ) 
-		verror( "ysize: mask not set" );
-
-	return( data.dptr->ysize );
-}
-
-double _private_detail::VPDMask::scale() const throw( VError )
-{
-	if( !data.dptr ) 
-		verror( "scale: mask not set" );
-
-	return( data.dptr->scale );
-}
-
-double _private_detail::VPDMask::offset() const throw( VError )
-{
-	if( !data.dptr ) 
-		verror( "offset: mask not set" );
-
-	return( data.dptr->offset );
-}
-
-const char *_private_detail::VPDMask::filename() const throw( VError )
-{
-	if( !data.dptr ) 
-		verror( "filename: mask not set" );
-
-	return( data.dptr->filename );
-}
-
-void _private_detail::VPDMask::ostream_print( std::ostream &file ) const 
-	throw( VError )
-{
-	if( !data.dptr )
-		verror( "internal error #7447234" );
-	
-	int i, j;
-	double *p = data.dptr->coeff;
-
-	file << this->xsize() << "\t" << this->ysize() << "\t";
-	file << this->scale() << "\t" << this->offset() << "\n";
-
-	for( i = 0; i < this->ysize(); i++ ) {
-		for( j = 0; j < this->xsize(); j++ )
-			file << *p++ << "\t";
-
-		file << "\n";
-	}
-}
-
-// Extract data pointer
-double *_private_detail::VPDMask::array() const 
-{ 
-	return( data.dptr->coeff ); 
-}
-
-// Build functions
-VIMask VIMask::gauss( double sig, double minamp ) throw( VError )
-{
-	VIMask out;
-	INTMASK *msk;
-
-	if( !(msk = im_gauss_imask( "VIMask::gauss", sig, minamp )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VIMask VIMask::gauss_sep( double sig, double minamp ) throw( VError )
-{
-	VIMask out;
-	INTMASK *msk;
-
-	if( !(msk = im_gauss_imask_sep( "VIMask::gauss", sig, minamp )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VDMask VDMask::gauss( double sig, double minamp ) throw( VError )
-{
-	VDMask out;
-	DOUBLEMASK *msk;
-
-	if( !(msk = im_gauss_dmask( "VDMask::gauss", sig, minamp )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VIMask VIMask::log( double sig, double minamp ) throw( VError )
-{
-	VIMask out;
-	INTMASK *msk;
-
-	if( !(msk = im_log_imask( "VIMask::log", sig, minamp )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VDMask VDMask::log( double sig, double minamp ) throw( VError )
-{
-	VDMask out;
-	DOUBLEMASK *msk;
-
-	if( !(msk = im_log_dmask( "VDMask::log", sig, minamp )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-// Manipulation functions
-VIMask VIMask::rotate45() throw( VError )
-{
-	VIMask out;
-	INTMASK *msk;
-
-	if( !(msk = im_rotate_imask45( mask().iptr, "VIMask::rotate45" )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VIMask VIMask::rotate90() throw( VError )
-{
-	VIMask out;
-	INTMASK *msk;
-
-	if( !(msk = im_rotate_imask90( mask().iptr, "VIMask::rotate90" )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VDMask VDMask::rotate45() throw( VError )
-{
-	VDMask out;
-	DOUBLEMASK *msk;
-
-	if( !(msk = im_rotate_dmask45( mask().dptr, "VDMask::rotate45" )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VDMask VDMask::rotate90() throw( VError )
-{
-	VDMask out;
-	DOUBLEMASK *msk;
-
-	if( !(msk = im_rotate_dmask90( mask().dptr, "VDMask::rotate90" )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VDMask VDMask::trn() throw( VError )
-{
-	VDMask out;
-	DOUBLEMASK *msk;
-
-	if( !(msk = im_mattrn( mask().dptr, "VDMask::trn" )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VDMask VDMask::inv() throw( VError )
-{
-	VDMask out;
-	DOUBLEMASK *msk;
-
-	if( !(msk = im_matinv( mask().dptr, "VDMask::inv" )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VDMask VDMask::mul( VDMask m ) throw( VError )
-{
-	VDMask out;
-	DOUBLEMASK *msk;
-
-	if( !(msk = im_matmul( mask().dptr, m.mask().dptr, "VDMask::mul" )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VDMask VDMask::cat( VDMask m ) throw( VError )
-{
-	VDMask out;
-	DOUBLEMASK *msk;
-
-	if( !(msk = im_matcat( mask().dptr, m.mask().dptr, "VDMask::cat" )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-VIMask VDMask::scalei() throw( VError )
-{
-	VIMask out;
-	INTMASK *msk;
-
-	if( !(msk = im_scale_dmask( mask().dptr, "VDMask::scalei" )) )
-		verror();
-	out.embed( msk );
-
-	return( out );
-}
-
-// Arithmetic on a VIMask ... just cast and use VDMask
-VDMask VIMask::trn() throw( VError ) 
-	{ return( ((VDMask)*this).trn() ); }
-VDMask VIMask::inv() throw( VError ) 
-	{ return( ((VDMask)*this).inv() ); }
-VDMask VIMask::cat( VDMask a ) throw( VError ) 
-	{ return( ((VDMask)*this).cat( a ) ); }
-VDMask VIMask::mul( VDMask a ) throw( VError ) 
-	{ return( ((VDMask)*this).mul( a ) ); }
-
-// Overload [] to get linear array subscript.
-// Our caller may write to the result, so make sure we have a private
-// copy.
-// Involves function call, slow anyway, so do range checking
-int &VIMask::operator[]( int x ) throw( VError )
-{ 
-	if( ref->nrefs != 1 )
-		make_private();
-
-	if( x > size() )
-		verror( "VIMask::operator[]: subscript out of range" );
-
-	return( ((_private_detail::VPIMask *)ref->pmask)->array()[x] ); 
-}
-
-double &VDMask::operator[]( int x ) throw( VError )
-{ 
-	if( ref->nrefs != 1 )
-		make_private();
-
-	if( x > size() )
-		verror( "VDMask::operator[]: subscript out of range" );
-
-	return( ((_private_detail::VPDMask *)ref->pmask)->array()[x] ); 
-}
-
-VIPS_NAMESPACE_END
diff -u --recursive --new-file vips-7.38.5-vanilla/Makefile.am vips-7.38.5/Makefile.am
--- vips-7.38.5-vanilla/Makefile.am	2014-07-17 23:48:36.206794473 -0400
+++ vips-7.38.5/Makefile.am	2014-07-17 23:49:32.827792979 -0400
@@ -1,23 +1,9 @@
 
-# turn off libvipsCC if C++ is disabled
-if ENABLE_CXX
-C_COMPILE_DIR = libvipsCC
-C_DIST_DIR =
-C_PKGCONFIG = vipsCC.pc
-
-# turn on Python if we can (requires C++)
-if HAVE_PYTHON
-P_COMPILE_DIR = swig
-P_DIST_DIR =
-endif
-
-else
 C_COMPILE_DIR =
-C_DIST_DIR = libvipsCC 
+C_DIST_DIR = 
 C_PKGCONFIG =
 P_COMPILE_DIR =
 P_DIST_DIR = swig
-endif
 
 SUBDIRS = \
 	libvips \
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/Makefile.am vips-7.38.5/swig/Makefile.am
--- vips-7.38.5-vanilla/swig/Makefile.am	2014-07-17 23:48:36.206794473 -0400
+++ vips-7.38.5/swig/Makefile.am	2014-07-17 23:49:32.827792979 -0400
@@ -1,5 +1,2 @@
-SUBDIRS = \
-	vipsCC 
-
 EXTRA_DIST = \
 	test   
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/__init__.py vips-7.38.5/swig/vipsCC/__init__.py
--- vips-7.38.5-vanilla/swig/vipsCC/__init__.py	2014-07-17 23:48:36.208794473 -0400
+++ vips-7.38.5/swig/vipsCC/__init__.py	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-__all__=["VImage","VMask","VError","VDisplay"]
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/Makefile.am vips-7.38.5/swig/vipsCC/Makefile.am
--- vips-7.38.5-vanilla/swig/vipsCC/Makefile.am	2014-07-17 23:48:36.208794473 -0400
+++ vips-7.38.5/swig/vipsCC/Makefile.am	1969-12-31 19:00:00.000000000 -0500
@@ -1,58 +0,0 @@
-# Let make substitute the value of PYTHON_INCLUDES rather than auto*
-# this makes it easier to support multiple python installs
-AM_CPPFLAGS = \
-	-I${top_srcdir}/libvips/include \
-	-I${top_srcdir}/libvipsCC/include \
-	@VIPS_CFLAGS@ \
-	@VIPS_INCLUDES@ \
-	$(PYTHON_INCLUDES)
-
-# we install to a directory inside the python area, since we are a module
-vipsccdir = $(pyexecdir)/vipsCC
-
-vipscc_PYTHON = VImage.py VDisplay.py VError.py VMask.py __init__.py
-
-# I tried making a suffix rule for this (and defining SUFFIXES) but I couldn't
-# get it to work, how annoying 
-# FIXME at some point
-#
-# need an expanded VImage.h ... SWIG's preprocessor b0rks on includes inside
-# class definitions
-vimagemodule.cxx: VImage.i
-	cpp -DSWIG -E $(top_srcdir)/libvipsCC/include/vips/VImage.h > VImage.h
-	swig -python -c++ -interface $(@:.cxx=) -I$(top_srcdir)/libvipsCC/include -o $@ $<
-
-vdisplaymodule.cxx: VDisplay.i
-	swig -python -c++ -interface $(@:.cxx=) -I$(top_srcdir)/libvipsCC/include -o $@ $<
-verrormodule.cxx: VError.i
-	swig -python -c++ -interface $(@:.cxx=) -I$(top_srcdir)/libvipsCC/include -o $@ $<
-vmaskmodule.cxx: VMask.i
-	swig -python -c++ -interface $(@:.cxx=) -I$(top_srcdir)/libvipsCC/include -o $@ $<
-
-vipscc_LTLIBRARIES = vimagemodule.la vdisplaymodule.la verrormodule.la vmaskmodule.la
-
-# maybe there's a clever way to avoid repeating the link stuff 4 times
-# vimagemodule uses the C API as well, so it needs libvips too
-vimagemodule_la_LDFLAGS = -module -avoid-version 
-vimagemodule_la_LIBADD = ../../libvipsCC/libvipsCC.la ../../libvips/libvips.la $(VIPS_LIBS)
-nodist_vimagemodule_la_SOURCES = vimagemodule.cxx 
-
-vdisplaymodule_la_LDFLAGS = -module -avoid-version 
-vdisplaymodule_la_LIBADD = ../../libvipsCC/libvipsCC.la $(VIPS_LIBS)
-nodist_vdisplaymodule_la_SOURCES = vdisplaymodule.cxx 
-
-verrormodule_la_LDFLAGS = -module -avoid-version 
-verrormodule_la_LIBADD = ../../libvipsCC/libvipsCC.la $(VIPS_LIBS)
-nodist_verrormodule_la_SOURCES = verrormodule.cxx 
-
-vmaskmodule_la_LDFLAGS = -module -avoid-version 
-vmaskmodule_la_LIBADD = ../../libvipsCC/libvipsCC.la $(VIPS_LIBS)
-nodist_vmaskmodule_la_SOURCES = vmaskmodule.cxx 
-
-CLEANFILES = VImage.h 
-
-EXTRA_DIST = \
-	VImage.i VDisplay.i VError.i VMask.i __init__.py \
-	vimagemodule.cxx \
-	verrormodule.cxx vdisplaymodule.cxx vmaskmodule.cxx \
-	VImage.py VDisplay.py VError.py VMask.py
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/Makefile.in vips-7.38.5/swig/vipsCC/Makefile.in
--- vips-7.38.5-vanilla/swig/vipsCC/Makefile.in	2014-07-17 23:48:36.208794473 -0400
+++ vips-7.38.5/swig/vipsCC/Makefile.in	1969-12-31 19:00:00.000000000 -0500
@@ -1,895 +0,0 @@
-# Makefile.in generated by automake 1.13.3 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994-2013 Free Software Foundation, Inc.
-
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-VPATH = @srcdir@
-am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
-am__make_running_with_option = \
-  case $${target_option-} in \
-      ?) ;; \
-      *) echo "am__make_running_with_option: internal error: invalid" \
-              "target option '$${target_option-}' specified" >&2; \
-         exit 1;; \
-  esac; \
-  has_opt=no; \
-  sane_makeflags=$$MAKEFLAGS; \
-  if $(am__is_gnu_make); then \
-    sane_makeflags=$$MFLAGS; \
-  else \
-    case $$MAKEFLAGS in \
-      *\\[\ \	]*) \
-        bs=\\; \
-        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
-          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
-    esac; \
-  fi; \
-  skip_next=no; \
-  strip_trailopt () \
-  { \
-    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
-  }; \
-  for flg in $$sane_makeflags; do \
-    test $$skip_next = yes && { skip_next=no; continue; }; \
-    case $$flg in \
-      *=*|--*) continue;; \
-        -*I) strip_trailopt 'I'; skip_next=yes;; \
-      -*I?*) strip_trailopt 'I';; \
-        -*O) strip_trailopt 'O'; skip_next=yes;; \
-      -*O?*) strip_trailopt 'O';; \
-        -*l) strip_trailopt 'l'; skip_next=yes;; \
-      -*l?*) strip_trailopt 'l';; \
-      -[dEDm]) skip_next=yes;; \
-      -[JT]) skip_next=yes;; \
-    esac; \
-    case $$flg in \
-      *$$target_option*) has_opt=yes; break;; \
-    esac; \
-  done; \
-  test $$has_opt = yes
-am__make_dryrun = (target_option=n; $(am__make_running_with_option))
-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-subdir = swig/vipsCC
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/depcomp $(vipscc_PYTHON) \
-	$(top_srcdir)/py-compile
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/gtk-doc.m4 \
-	$(top_srcdir)/m4/introspection.m4 $(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__uninstall_files_from_dir = { \
-  test -z "$$files" \
-    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
-    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
-         $(am__cd) "$$dir" && rm -f $$files; }; \
-  }
-am__installdirs = "$(DESTDIR)$(vipsccdir)" "$(DESTDIR)$(vipsccdir)"
-LTLIBRARIES = $(vipscc_LTLIBRARIES)
-am__DEPENDENCIES_1 =
-vdisplaymodule_la_DEPENDENCIES = ../../libvipsCC/libvipsCC.la \
-	$(am__DEPENDENCIES_1)
-nodist_vdisplaymodule_la_OBJECTS = vdisplaymodule.lo
-vdisplaymodule_la_OBJECTS = $(nodist_vdisplaymodule_la_OBJECTS)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-am__v_lt_1 = 
-vdisplaymodule_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
-	$(AM_CXXFLAGS) $(CXXFLAGS) $(vdisplaymodule_la_LDFLAGS) \
-	$(LDFLAGS) -o $@
-verrormodule_la_DEPENDENCIES = ../../libvipsCC/libvipsCC.la \
-	$(am__DEPENDENCIES_1)
-nodist_verrormodule_la_OBJECTS = verrormodule.lo
-verrormodule_la_OBJECTS = $(nodist_verrormodule_la_OBJECTS)
-verrormodule_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
-	$(AM_CXXFLAGS) $(CXXFLAGS) $(verrormodule_la_LDFLAGS) \
-	$(LDFLAGS) -o $@
-vimagemodule_la_DEPENDENCIES = ../../libvipsCC/libvipsCC.la \
-	../../libvips/libvips.la $(am__DEPENDENCIES_1)
-nodist_vimagemodule_la_OBJECTS = vimagemodule.lo
-vimagemodule_la_OBJECTS = $(nodist_vimagemodule_la_OBJECTS)
-vimagemodule_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
-	$(AM_CXXFLAGS) $(CXXFLAGS) $(vimagemodule_la_LDFLAGS) \
-	$(LDFLAGS) -o $@
-vmaskmodule_la_DEPENDENCIES = ../../libvipsCC/libvipsCC.la \
-	$(am__DEPENDENCIES_1)
-nodist_vmaskmodule_la_OBJECTS = vmaskmodule.lo
-vmaskmodule_la_OBJECTS = $(nodist_vmaskmodule_la_OBJECTS)
-vmaskmodule_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
-	$(AM_CXXFLAGS) $(CXXFLAGS) $(vmaskmodule_la_LDFLAGS) \
-	$(LDFLAGS) -o $@
-AM_V_P = $(am__v_P_@AM_V@)
-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
-am__v_P_0 = false
-am__v_P_1 = :
-AM_V_GEN = $(am__v_GEN_@AM_V@)
-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
-am__v_GEN_0 = @echo "  GEN     " $@;
-am__v_GEN_1 = 
-AM_V_at = $(am__v_at_@AM_V@)
-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
-am__v_at_0 = @
-am__v_at_1 = 
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-am__mv = mv -f
-CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
-LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CXXFLAGS) $(CXXFLAGS)
-AM_V_CXX = $(am__v_CXX_@AM_V@)
-am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
-am__v_CXX_0 = @echo "  CXX     " $@;
-am__v_CXX_1 = 
-CXXLD = $(CXX)
-CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
-am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
-am__v_CXXLD_0 = @echo "  CXXLD   " $@;
-am__v_CXXLD_1 = 
-SOURCES = $(nodist_vdisplaymodule_la_SOURCES) \
-	$(nodist_verrormodule_la_SOURCES) \
-	$(nodist_vimagemodule_la_SOURCES) \
-	$(nodist_vmaskmodule_la_SOURCES)
-DIST_SOURCES =
-am__can_run_installinfo = \
-  case $$AM_UPDATE_INFO_DIR in \
-    n|no|NO) false;; \
-    *) (install-info --version) >/dev/null 2>&1;; \
-  esac
-am__py_compile = PYTHON=$(PYTHON) $(SHELL) $(py_compile)
-am__pep3147_tweak = \
-  sed -e 's|\.py$$||' -e 's|[^/]*$$|__pycache__/&.*.py|'
-py_compile = $(top_srcdir)/py-compile
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
-# Read a list of newline-separated strings from the standard input,
-# and print each of them once, without duplicates.  Input order is
-# *not* preserved.
-am__uniquify_input = $(AWK) '\
-  BEGIN { nonempty = 0; } \
-  { items[$$0] = 1; nonempty = 1; } \
-  END { if (nonempty) { for (i in items) print i; }; } \
-'
-# Make sure the list of sources is unique.  This is necessary because,
-# e.g., the same source file might be shared among _SOURCES variables
-# for different programs/libraries.
-am__define_uniq_tagged_files = \
-  list='$(am__tagged_files)'; \
-  unique=`for i in $$list; do \
-    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-  done | $(am__uniquify_input)`
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
-AR = @AR@
-AS = @AS@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CATALOGS = @CATALOGS@
-CATOBJEXT = @CATOBJEXT@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFITSIO_CFLAGS = @CFITSIO_CFLAGS@
-CFITSIO_LIBS = @CFITSIO_LIBS@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DATADIRNAME = @DATADIRNAME@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DLLTOOL = @DLLTOOL@
-DLLWRAP = @DLLWRAP@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-EXIF_CFLAGS = @EXIF_CFLAGS@
-EXIF_LIBS = @EXIF_LIBS@
-FFTW_CFLAGS = @FFTW_CFLAGS@
-FFTW_LIBS = @FFTW_LIBS@
-FGREP = @FGREP@
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-GMOFILES = @GMOFILES@
-GMSGFMT = @GMSGFMT@
-GREP = @GREP@
-GTHREAD_CFLAGS = @GTHREAD_CFLAGS@
-GTHREAD_LIBS = @GTHREAD_LIBS@
-GTKDOC_CHECK = @GTKDOC_CHECK@
-GTKDOC_DEPS_CFLAGS = @GTKDOC_DEPS_CFLAGS@
-GTKDOC_DEPS_LIBS = @GTKDOC_DEPS_LIBS@
-GTKDOC_MKPDF = @GTKDOC_MKPDF@
-GTKDOC_REBASE = @GTKDOC_REBASE@
-HTML_DIR = @HTML_DIR@
-IMAGE_MAGICK_CFLAGS = @IMAGE_MAGICK_CFLAGS@
-IMAGE_MAGICK_LIBS = @IMAGE_MAGICK_LIBS@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-INSTOBJEXT = @INSTOBJEXT@
-INTLLIBS = @INTLLIBS@
-INTROSPECTION_CFLAGS = @INTROSPECTION_CFLAGS@
-INTROSPECTION_COMPILER = @INTROSPECTION_COMPILER@
-INTROSPECTION_GENERATE = @INTROSPECTION_GENERATE@
-INTROSPECTION_GIRDIR = @INTROSPECTION_GIRDIR@
-INTROSPECTION_LIBS = @INTROSPECTION_LIBS@
-INTROSPECTION_MAKEFILE = @INTROSPECTION_MAKEFILE@
-INTROSPECTION_SCANNER = @INTROSPECTION_SCANNER@
-INTROSPECTION_TYPELIBDIR = @INTROSPECTION_TYPELIBDIR@
-JPEG_INCLUDES = @JPEG_INCLUDES@
-JPEG_LIBS = @JPEG_LIBS@
-LCMS_CFLAGS = @LCMS_CFLAGS@
-LCMS_LIBS = @LCMS_LIBS@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBRARY_AGE = @LIBRARY_AGE@
-LIBRARY_CURRENT = @LIBRARY_CURRENT@
-LIBRARY_REVISION = @LIBRARY_REVISION@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIBWEBP_CFLAGS = @LIBWEBP_CFLAGS@
-LIBWEBP_LIBS = @LIBWEBP_LIBS@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAGICK_CFLAGS = @MAGICK_CFLAGS@
-MAGICK_LIBS = @MAGICK_LIBS@
-MAGICK_WAND_CFLAGS = @MAGICK_WAND_CFLAGS@
-MAGICK_WAND_LIBS = @MAGICK_WAND_LIBS@
-MAKEINFO = @MAKEINFO@
-MANIFEST_TOOL = @MANIFEST_TOOL@
-MATIO_CFLAGS = @MATIO_CFLAGS@
-MATIO_LIBS = @MATIO_LIBS@
-MKDIR_P = @MKDIR_P@
-MKINSTALLDIRS = @MKINSTALLDIRS@
-MONOTONIC_CFLAGS = @MONOTONIC_CFLAGS@
-MONOTONIC_LIBS = @MONOTONIC_LIBS@
-MSGFMT = @MSGFMT@
-MSGFMT_OPTS = @MSGFMT_OPTS@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OPENEXR_CFLAGS = @OPENEXR_CFLAGS@
-OPENEXR_LIBS = @OPENEXR_LIBS@
-OPENSLIDE_CFLAGS = @OPENSLIDE_CFLAGS@
-OPENSLIDE_LIBS = @OPENSLIDE_LIBS@
-ORC_CFLAGS = @ORC_CFLAGS@
-ORC_LIBS = @ORC_LIBS@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGES_USED = @PACKAGES_USED@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PANGOFT2_CFLAGS = @PANGOFT2_CFLAGS@
-PANGOFT2_LIBS = @PANGOFT2_LIBS@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
-PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
-PNG_CFLAGS = @PNG_CFLAGS@
-PNG_INCLUDES = @PNG_INCLUDES@
-PNG_LIBS = @PNG_LIBS@
-POFILES = @POFILES@
-POSUB = @POSUB@
-PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
-PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
-PYTHON = @PYTHON@
-PYTHON_EXEC_PREFIX = @PYTHON_EXEC_PREFIX@
-PYTHON_INCLUDES = @PYTHON_INCLUDES@
-PYTHON_PLATFORM = @PYTHON_PLATFORM@
-PYTHON_PREFIX = @PYTHON_PREFIX@
-PYTHON_VERSION = @PYTHON_VERSION@
-RANLIB = @RANLIB@
-REQUIRED_CFLAGS = @REQUIRED_CFLAGS@
-REQUIRED_LIBS = @REQUIRED_LIBS@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-THREADS_CFLAGS = @THREADS_CFLAGS@
-THREADS_LIBS = @THREADS_LIBS@
-TIFF_CFLAGS = @TIFF_CFLAGS@
-TIFF_INCLUDES = @TIFF_INCLUDES@
-TIFF_LIBS = @TIFF_LIBS@
-TYPE_INIT_CFLAGS = @TYPE_INIT_CFLAGS@
-TYPE_INIT_LIBS = @TYPE_INIT_LIBS@
-USE_NLS = @USE_NLS@
-VERSION = @VERSION@
-VIPS_CFLAGS = @VIPS_CFLAGS@
-VIPS_CXX_LIBS = @VIPS_CXX_LIBS@
-VIPS_EXEEXT = @VIPS_EXEEXT@
-VIPS_INCLUDES = @VIPS_INCLUDES@
-VIPS_LIBDIR = @VIPS_LIBDIR@
-VIPS_LIBS = @VIPS_LIBS@
-VIPS_MAJOR_VERSION = @VIPS_MAJOR_VERSION@
-VIPS_MICRO_VERSION = @VIPS_MICRO_VERSION@
-VIPS_MINOR_VERSION = @VIPS_MINOR_VERSION@
-VIPS_VERSION = @VIPS_VERSION@
-VIPS_VERSION_STRING = @VIPS_VERSION_STRING@
-XGETTEXT = @XGETTEXT@
-XMKMF = @XMKMF@
-X_CFLAGS = @X_CFLAGS@
-X_EXTRA_LIBS = @X_EXTRA_LIBS@
-X_LIBS = @X_LIBS@
-X_PRE_LIBS = @X_PRE_LIBS@
-ZIP_INCLUDES = @ZIP_INCLUDES@
-ZIP_LIBS = @ZIP_LIBS@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-pkgpyexecdir = @pkgpyexecdir@
-pkgpythondir = @pkgpythondir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-pyexecdir = @pyexecdir@
-pythondir = @pythondir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-vips_introspection_sources = @vips_introspection_sources@
-
-# Let make substitute the value of PYTHON_INCLUDES rather than auto*
-# this makes it easier to support multiple python installs
-AM_CPPFLAGS = \
-	-I${top_srcdir}/libvips/include \
-	-I${top_srcdir}/libvipsCC/include \
-	@VIPS_CFLAGS@ \
-	@VIPS_INCLUDES@ \
-	$(PYTHON_INCLUDES)
-
-
-# we install to a directory inside the python area, since we are a module
-vipsccdir = $(pyexecdir)/vipsCC
-vipscc_PYTHON = VImage.py VDisplay.py VError.py VMask.py __init__.py
-vipscc_LTLIBRARIES = vimagemodule.la vdisplaymodule.la verrormodule.la vmaskmodule.la
-
-# maybe there's a clever way to avoid repeating the link stuff 4 times
-# vimagemodule uses the C API as well, so it needs libvips too
-vimagemodule_la_LDFLAGS = -module -avoid-version 
-vimagemodule_la_LIBADD = ../../libvipsCC/libvipsCC.la ../../libvips/libvips.la $(VIPS_LIBS)
-nodist_vimagemodule_la_SOURCES = vimagemodule.cxx 
-vdisplaymodule_la_LDFLAGS = -module -avoid-version 
-vdisplaymodule_la_LIBADD = ../../libvipsCC/libvipsCC.la $(VIPS_LIBS)
-nodist_vdisplaymodule_la_SOURCES = vdisplaymodule.cxx 
-verrormodule_la_LDFLAGS = -module -avoid-version 
-verrormodule_la_LIBADD = ../../libvipsCC/libvipsCC.la $(VIPS_LIBS)
-nodist_verrormodule_la_SOURCES = verrormodule.cxx 
-vmaskmodule_la_LDFLAGS = -module -avoid-version 
-vmaskmodule_la_LIBADD = ../../libvipsCC/libvipsCC.la $(VIPS_LIBS)
-nodist_vmaskmodule_la_SOURCES = vmaskmodule.cxx 
-CLEANFILES = VImage.h 
-EXTRA_DIST = \
-	VImage.i VDisplay.i VError.i VMask.i __init__.py \
-	vimagemodule.cxx \
-	verrormodule.cxx vdisplaymodule.cxx vmaskmodule.cxx \
-	VImage.py VDisplay.py VError.py VMask.py
-
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .cxx .lo .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
-	        && { if test -f $@; then exit 0; else break; fi; }; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign swig/vipsCC/Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign swig/vipsCC/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(am__aclocal_m4_deps):
-
-install-vipsccLTLIBRARIES: $(vipscc_LTLIBRARIES)
-	@$(NORMAL_INSTALL)
-	@list='$(vipscc_LTLIBRARIES)'; test -n "$(vipsccdir)" || list=; \
-	list2=; for p in $$list; do \
-	  if test -f $$p; then \
-	    list2="$$list2 $$p"; \
-	  else :; fi; \
-	done; \
-	test -z "$$list2" || { \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(vipsccdir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(vipsccdir)" || exit 1; \
-	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(vipsccdir)'"; \
-	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(vipsccdir)"; \
-	}
-
-uninstall-vipsccLTLIBRARIES:
-	@$(NORMAL_UNINSTALL)
-	@list='$(vipscc_LTLIBRARIES)'; test -n "$(vipsccdir)" || list=; \
-	for p in $$list; do \
-	  $(am__strip_dir) \
-	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(vipsccdir)/$$f'"; \
-	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(vipsccdir)/$$f"; \
-	done
-
-clean-vipsccLTLIBRARIES:
-	-test -z "$(vipscc_LTLIBRARIES)" || rm -f $(vipscc_LTLIBRARIES)
-	@list='$(vipscc_LTLIBRARIES)'; \
-	locs=`for p in $$list; do echo $$p; done | \
-	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
-	      sort -u`; \
-	test -z "$$locs" || { \
-	  echo rm -f $${locs}; \
-	  rm -f $${locs}; \
-	}
-
-vdisplaymodule.la: $(vdisplaymodule_la_OBJECTS) $(vdisplaymodule_la_DEPENDENCIES) $(EXTRA_vdisplaymodule_la_DEPENDENCIES) 
-	$(AM_V_CXXLD)$(vdisplaymodule_la_LINK) -rpath $(vipsccdir) $(vdisplaymodule_la_OBJECTS) $(vdisplaymodule_la_LIBADD) $(LIBS)
-
-verrormodule.la: $(verrormodule_la_OBJECTS) $(verrormodule_la_DEPENDENCIES) $(EXTRA_verrormodule_la_DEPENDENCIES) 
-	$(AM_V_CXXLD)$(verrormodule_la_LINK) -rpath $(vipsccdir) $(verrormodule_la_OBJECTS) $(verrormodule_la_LIBADD) $(LIBS)
-
-vimagemodule.la: $(vimagemodule_la_OBJECTS) $(vimagemodule_la_DEPENDENCIES) $(EXTRA_vimagemodule_la_DEPENDENCIES) 
-	$(AM_V_CXXLD)$(vimagemodule_la_LINK) -rpath $(vipsccdir) $(vimagemodule_la_OBJECTS) $(vimagemodule_la_LIBADD) $(LIBS)
-
-vmaskmodule.la: $(vmaskmodule_la_OBJECTS) $(vmaskmodule_la_DEPENDENCIES) $(EXTRA_vmaskmodule_la_DEPENDENCIES) 
-	$(AM_V_CXXLD)$(vmaskmodule_la_LINK) -rpath $(vipsccdir) $(vmaskmodule_la_OBJECTS) $(vmaskmodule_la_LIBADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vdisplaymodule.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/verrormodule.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vimagemodule.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vmaskmodule.Plo@am__quote@
-
-.cxx.o:
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<
-
-.cxx.obj:
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
-
-.cxx.lo:
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-install-vipsccPYTHON: $(vipscc_PYTHON)
-	@$(NORMAL_INSTALL)
-	@list='$(vipscc_PYTHON)'; dlist=; list2=; test -n "$(vipsccdir)" || list=; \
-	if test -n "$$list"; then \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(vipsccdir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(vipsccdir)" || exit 1; \
-	fi; \
-	for p in $$list; do \
-	  if test -f "$$p"; then b=; else b="$(srcdir)/"; fi; \
-	  if test -f $$b$$p; then \
-	    $(am__strip_dir) \
-	    dlist="$$dlist $$f"; \
-	    list2="$$list2 $$b$$p"; \
-	  else :; fi; \
-	done; \
-	for file in $$list2; do echo $$file; done | $(am__base_list) | \
-	while read files; do \
-	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(vipsccdir)'"; \
-	  $(INSTALL_DATA) $$files "$(DESTDIR)$(vipsccdir)" || exit $$?; \
-	done || exit $$?; \
-	if test -n "$$dlist"; then \
-	  $(am__py_compile) --destdir "$(DESTDIR)" \
-	                    --basedir "$(vipsccdir)" $$dlist; \
-	else :; fi
-
-uninstall-vipsccPYTHON:
-	@$(NORMAL_UNINSTALL)
-	@list='$(vipscc_PYTHON)'; test -n "$(vipsccdir)" || list=; \
-	py_files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$py_files" || exit 0; \
-	dir='$(DESTDIR)$(vipsccdir)'; \
-	pyc_files=`echo "$$py_files" | sed 's|$$|c|'`; \
-	pyo_files=`echo "$$py_files" | sed 's|$$|o|'`; \
-	py_files_pep3147=`echo "$$py_files" | $(am__pep3147_tweak)`; \
-	echo "$$py_files_pep3147";\
-	pyc_files_pep3147=`echo "$$py_files_pep3147" | sed 's|$$|c|'`; \
-	pyo_files_pep3147=`echo "$$py_files_pep3147" | sed 's|$$|o|'`; \
-	st=0; \
-	for files in \
-	  "$$py_files" \
-	  "$$pyc_files" \
-	  "$$pyo_files" \
-	  "$$pyc_files_pep3147" \
-	  "$$pyo_files_pep3147" \
-	; do \
-	  $(am__uninstall_files_from_dir) || st=$$?; \
-	done; \
-	exit $$st
-
-ID: $(am__tagged_files)
-	$(am__define_uniq_tagged_files); mkid -fID $$unique
-tags: tags-am
-TAGS: tags
-
-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	set x; \
-	here=`pwd`; \
-	$(am__define_uniq_tagged_files); \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: ctags-am
-
-CTAGS: ctags
-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
-	$(am__define_uniq_tagged_files); \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-cscopelist: cscopelist-am
-
-cscopelist-am: $(am__tagged_files)
-	list='$(am__tagged_files)'; \
-	case "$(srcdir)" in \
-	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
-	  *) sdir=$(subdir)/$(srcdir) ;; \
-	esac; \
-	for i in $$list; do \
-	  if test -f "$$i"; then \
-	    echo "$(subdir)/$$i"; \
-	  else \
-	    echo "$$sdir/$$i"; \
-	  fi; \
-	done >> $(top_builddir)/cscope.files
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d "$(distdir)/$$file"; then \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
-	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
-	    fi; \
-	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
-	  else \
-	    test -f "$(distdir)/$$file" \
-	    || cp -p $$d/$$file "$(distdir)/$$file" \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(LTLIBRARIES)
-installdirs:
-	for dir in "$(DESTDIR)$(vipsccdir)" "$(DESTDIR)$(vipsccdir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	if test -z '$(STRIP)'; then \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	      install; \
-	else \
-	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
-	fi
-mostlyclean-generic:
-
-clean-generic:
-	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool clean-vipsccLTLIBRARIES \
-	mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am: install-vipsccLTLIBRARIES install-vipsccPYTHON
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am:
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-vipsccLTLIBRARIES uninstall-vipsccPYTHON
-
-.MAKE: install-am install-strip
-
-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-vipsccLTLIBRARIES cscopelist-am ctags \
-	ctags-am distclean distclean-compile distclean-generic \
-	distclean-libtool distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip \
-	install-vipsccLTLIBRARIES install-vipsccPYTHON installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags tags-am uninstall uninstall-am \
-	uninstall-vipsccLTLIBRARIES uninstall-vipsccPYTHON
-
-
-# I tried making a suffix rule for this (and defining SUFFIXES) but I couldn't
-# get it to work, how annoying 
-# FIXME at some point
-#
-# need an expanded VImage.h ... SWIG's preprocessor b0rks on includes inside
-# class definitions
-vimagemodule.cxx: VImage.i
-	cpp -DSWIG -E $(top_srcdir)/libvipsCC/include/vips/VImage.h > VImage.h
-	swig -python -c++ -interface $(@:.cxx=) -I$(top_srcdir)/libvipsCC/include -o $@ $<
-
-vdisplaymodule.cxx: VDisplay.i
-	swig -python -c++ -interface $(@:.cxx=) -I$(top_srcdir)/libvipsCC/include -o $@ $<
-verrormodule.cxx: VError.i
-	swig -python -c++ -interface $(@:.cxx=) -I$(top_srcdir)/libvipsCC/include -o $@ $<
-vmaskmodule.cxx: VMask.i
-	swig -python -c++ -interface $(@:.cxx=) -I$(top_srcdir)/libvipsCC/include -o $@ $<
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/VDisplay.i vips-7.38.5/swig/vipsCC/VDisplay.i
--- vips-7.38.5-vanilla/swig/vipsCC/VDisplay.i	2014-07-17 23:48:36.208794473 -0400
+++ vips-7.38.5/swig/vipsCC/VDisplay.i	1969-12-31 19:00:00.000000000 -0500
@@ -1,15 +0,0 @@
-/* SWIG interface file for VDisplay.
- */
-
-%module VDisplay
-%{
-#include <vips/vipscpp.h>
-%}
-
-%import "VError.i"
-
-/* Need to override assignment to get refcounting working.
- */
-%rename(__assign__) *::operator=;
-
-%include vips/VDisplay.h
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/vdisplaymodule.cxx vips-7.38.5/swig/vipsCC/vdisplaymodule.cxx
--- vips-7.38.5-vanilla/swig/vipsCC/vdisplaymodule.cxx	2014-07-17 23:48:36.211794473 -0400
+++ vips-7.38.5/swig/vipsCC/vdisplaymodule.cxx	1969-12-31 19:00:00.000000000 -0500
@@ -1,4117 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 2.0.10
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-#define SWIGPYTHON
-#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
-
-
-#ifdef __cplusplus
-/* SwigValueWrapper is described in swig.swg */
-template<typename T> class SwigValueWrapper {
-  struct SwigMovePointer {
-    T *ptr;
-    SwigMovePointer(T *p) : ptr(p) { }
-    ~SwigMovePointer() { delete ptr; }
-    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
-  } pointer;
-  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
-  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
-public:
-  SwigValueWrapper() : pointer(0) { }
-  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
-  operator T&() const { return *pointer.ptr; }
-  T *operator&() { return pointer.ptr; }
-};
-
-template <typename T> T SwigValueInit() {
-  return T();
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- *  This section contains generic SWIG labels for method/variable
- *  declarations/attributes, and other compiler dependent labels.
- * ----------------------------------------------------------------------------- */
-
-/* template workaround for compilers that cannot correctly implement the C++ standard */
-#ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# elif defined(__HP_aCC)
-/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
-/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# else
-#  define SWIGTEMPLATEDISAMBIGUATOR
-# endif
-#endif
-
-/* inline attribute */
-#ifndef SWIGINLINE
-# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
-#   define SWIGINLINE inline
-# else
-#   define SWIGINLINE
-# endif
-#endif
-
-/* attribute recognised by some compilers to avoid 'unused' warnings */
-#ifndef SWIGUNUSED
-# if defined(__GNUC__)
-#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
-#     define SWIGUNUSED __attribute__ ((__unused__)) 
-#   else
-#     define SWIGUNUSED
-#   endif
-# elif defined(__ICC)
-#   define SWIGUNUSED __attribute__ ((__unused__)) 
-# else
-#   define SWIGUNUSED 
-# endif
-#endif
-
-#ifndef SWIG_MSC_UNSUPPRESS_4505
-# if defined(_MSC_VER)
-#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
-# endif 
-#endif
-
-#ifndef SWIGUNUSEDPARM
-# ifdef __cplusplus
-#   define SWIGUNUSEDPARM(p)
-# else
-#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
-# endif
-#endif
-
-/* internal SWIG method */
-#ifndef SWIGINTERN
-# define SWIGINTERN static SWIGUNUSED
-#endif
-
-/* internal inline SWIG method */
-#ifndef SWIGINTERNINLINE
-# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/* exporting methods */
-#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
-#  ifndef GCC_HASCLASSVISIBILITY
-#    define GCC_HASCLASSVISIBILITY
-#  endif
-#endif
-
-#ifndef SWIGEXPORT
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   if defined(STATIC_LINKED)
-#     define SWIGEXPORT
-#   else
-#     define SWIGEXPORT __declspec(dllexport)
-#   endif
-# else
-#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
-#     define SWIGEXPORT __attribute__ ((visibility("default")))
-#   else
-#     define SWIGEXPORT
-#   endif
-# endif
-#endif
-
-/* calling conventions for Windows */
-#ifndef SWIGSTDCALL
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   define SWIGSTDCALL __stdcall
-# else
-#   define SWIGSTDCALL
-# endif 
-#endif
-
-/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
-#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
-# define _CRT_SECURE_NO_DEPRECATE
-#endif
-
-/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
-#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
-# define _SCL_SECURE_NO_DEPRECATE
-#endif
-
-
-
-/* Python.h has to appear first */
-#include <Python.h>
-
-/* -----------------------------------------------------------------------------
- * swigrun.swg
- *
- * This file contains generic C API SWIG runtime support for pointer
- * type checking.
- * ----------------------------------------------------------------------------- */
-
-/* This should only be incremented when either the layout of swig_type_info changes,
-   or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION "4"
-
-/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
-#ifdef SWIG_TYPE_TABLE
-# define SWIG_QUOTE_STRING(x) #x
-# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
-# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
-#else
-# define SWIG_TYPE_TABLE_NAME
-#endif
-
-/*
-  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
-  creating a static or dynamic library from the SWIG runtime code.
-  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
-  
-  But only do this if strictly necessary, ie, if you have problems
-  with your compiler or suchlike.
-*/
-
-#ifndef SWIGRUNTIME
-# define SWIGRUNTIME SWIGINTERN
-#endif
-
-#ifndef SWIGRUNTIMEINLINE
-# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
-#endif
-
-/*  Generic buffer size */
-#ifndef SWIG_BUFFER_SIZE
-# define SWIG_BUFFER_SIZE 1024
-#endif
-
-/* Flags for pointer conversions */
-#define SWIG_POINTER_DISOWN        0x1
-#define SWIG_CAST_NEW_MEMORY       0x2
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_OWN           0x1
-
-
-/* 
-   Flags/methods for returning states.
-   
-   The SWIG conversion methods, as ConvertPtr, return an integer 
-   that tells if the conversion was successful or not. And if not,
-   an error code can be returned (see swigerrors.swg for the codes).
-   
-   Use the following macros/flags to set or process the returning
-   states.
-   
-   In old versions of SWIG, code such as the following was usually written:
-
-     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
-       // success code
-     } else {
-       //fail code
-     }
-
-   Now you can be more explicit:
-
-    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-    } else {
-      // fail code
-    }
-
-   which is the same really, but now you can also do
-
-    Type *ptr;
-    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-      if (SWIG_IsNewObj(res) {
-        ...
-	delete *ptr;
-      } else {
-        ...
-      }
-    } else {
-      // fail code
-    }
-    
-   I.e., now SWIG_ConvertPtr can return new objects and you can
-   identify the case and take care of the deallocation. Of course that
-   also requires SWIG_ConvertPtr to return new result values, such as
-
-      int SWIG_ConvertPtr(obj, ptr,...) {         
-        if (<obj is ok>) {			       
-          if (<need new object>) {		       
-            *ptr = <ptr to new allocated object>; 
-            return SWIG_NEWOBJ;		       
-          } else {				       
-            *ptr = <ptr to old object>;	       
-            return SWIG_OLDOBJ;		       
-          } 				       
-        } else {				       
-          return SWIG_BADOBJ;		       
-        }					       
-      }
-
-   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
-   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
-   SWIG errors code.
-
-   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
-
-       int food(double)
-       int fooi(int);
-
-   and you call
- 
-      food(1)   // cast rank '1'  (1 -> 1.0)
-      fooi(1)   // cast rank '0'
-
-   just use the SWIG_AddCast()/SWIG_CheckState()
-*/
-
-#define SWIG_OK                    (0) 
-#define SWIG_ERROR                 (-1)
-#define SWIG_IsOK(r)               (r >= 0)
-#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
-
-/* The CastRankLimit says how many bits are used for the cast rank */
-#define SWIG_CASTRANKLIMIT         (1 << 8)
-/* The NewMask denotes the object was created (using new/malloc) */
-#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
-/* The TmpMask is for in/out typemaps that use temporal objects */
-#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
-/* Simple returning values */
-#define SWIG_BADOBJ                (SWIG_ERROR)
-#define SWIG_OLDOBJ                (SWIG_OK)
-#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
-#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
-#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
-#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
-#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
-#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
-#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
-#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
-
-/* Cast-Rank Mode */
-#if defined(SWIG_CASTRANK_MODE)
-#  ifndef SWIG_TypeRank
-#    define SWIG_TypeRank             unsigned long
-#  endif
-#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
-#    define SWIG_MAXCASTRANK          (2)
-#  endif
-#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
-#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
-SWIGINTERNINLINE int SWIG_AddCast(int r) { 
-  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
-}
-SWIGINTERNINLINE int SWIG_CheckState(int r) { 
-  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
-}
-#else /* no cast-rank mode */
-#  define SWIG_AddCast(r) (r)
-#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
-#endif
-
-
-#include <string.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef void *(*swig_converter_func)(void *, int *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-/* Structure to store information on one type */
-typedef struct swig_type_info {
-  const char             *name;			/* mangled name of this type */
-  const char             *str;			/* human readable name of this type */
-  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
-  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
-  void                   *clientdata;		/* language specific type data */
-  int                    owndata;		/* flag if the structure owns the clientdata */
-} swig_type_info;
-
-/* Structure to store a type and conversion function used for casting */
-typedef struct swig_cast_info {
-  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
-  swig_converter_func     converter;		/* function to cast the void pointers */
-  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
-  struct swig_cast_info  *prev;			/* pointer to the previous cast */
-} swig_cast_info;
-
-/* Structure used to store module information
- * Each module generates one structure like this, and the runtime collects
- * all of these structures and stores them in a circularly linked list.*/
-typedef struct swig_module_info {
-  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
-  size_t                 size;		        /* Number of types in this module */
-  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
-  swig_type_info         **type_initial;	/* Array of initially generated type structures */
-  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
-  void                    *clientdata;		/* Language specific module data */
-} swig_module_info;
-
-/* 
-  Compare two type names skipping the space characters, therefore
-  "char*" == "char *" and "Class<int>" == "Class<int >", etc.
-
-  Return 0 when the two name types are equivalent, as in
-  strncmp, but skipping ' '.
-*/
-SWIGRUNTIME int
-SWIG_TypeNameComp(const char *f1, const char *l1,
-		  const char *f2, const char *l2) {
-  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
-    while ((*f1 == ' ') && (f1 != l1)) ++f1;
-    while ((*f2 == ' ') && (f2 != l2)) ++f2;
-    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
-  }
-  return (int)((l1 - f1) - (l2 - f2));
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
-*/
-SWIGRUNTIME int
-SWIG_TypeCmp(const char *nb, const char *tb) {
-  int equiv = 1;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (equiv != 0 && *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if not equal, 1 if equal
-*/
-SWIGRUNTIME int
-SWIG_TypeEquiv(const char *nb, const char *tb) {
-  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
-}
-
-/*
-  Check the typename
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheck(const char *c, swig_type_info *ty) {
-  if (ty) {
-    swig_cast_info *iter = ty->cast;
-    while (iter) {
-      if (strcmp(iter->type->name, c) == 0) {
-        if (iter == ty->cast)
-          return iter;
-        /* Move iter to the top of the linked list */
-        iter->prev->next = iter->next;
-        if (iter->next)
-          iter->next->prev = iter->prev;
-        iter->next = ty->cast;
-        iter->prev = 0;
-        if (ty->cast) ty->cast->prev = iter;
-        ty->cast = iter;
-        return iter;
-      }
-      iter = iter->next;
-    }
-  }
-  return 0;
-}
-
-/* 
-  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
-  if (ty) {
-    swig_cast_info *iter = ty->cast;
-    while (iter) {
-      if (iter->type == from) {
-        if (iter == ty->cast)
-          return iter;
-        /* Move iter to the top of the linked list */
-        iter->prev->next = iter->next;
-        if (iter->next)
-          iter->next->prev = iter->prev;
-        iter->next = ty->cast;
-        iter->prev = 0;
-        if (ty->cast) ty->cast->prev = iter;
-        ty->cast = iter;
-        return iter;
-      }
-      iter = iter->next;
-    }
-  }
-  return 0;
-}
-
-/*
-  Cast a pointer up an inheritance hierarchy
-*/
-SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
-  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
-}
-
-/* 
-   Dynamic pointer casting. Down an inheritance hierarchy
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty->dcast) return ty;
-  while (ty && (ty->dcast)) {
-    ty = (*ty->dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/*
-  Return the name associated with this type
-*/
-SWIGRUNTIMEINLINE const char *
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty->name;
-}
-
-/*
-  Return the pretty name associated with this type,
-  that is an unmangled type name in a form presentable to the user.
-*/
-SWIGRUNTIME const char *
-SWIG_TypePrettyName(const swig_type_info *type) {
-  /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
-  if (!type) return NULL;
-  if (type->str != NULL) {
-    const char *last_name = type->str;
-    const char *s;
-    for (s = type->str; *s; s++)
-      if (*s == '|') last_name = s+1;
-    return last_name;
-  }
-  else
-    return type->name;
-}
-
-/* 
-   Set the clientdata field for a type
-*/
-SWIGRUNTIME void
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  swig_cast_info *cast = ti->cast;
-  /* if (ti->clientdata == clientdata) return; */
-  ti->clientdata = clientdata;
-  
-  while (cast) {
-    if (!cast->converter) {
-      swig_type_info *tc = cast->type;
-      if (!tc->clientdata) {
-	SWIG_TypeClientData(tc, clientdata);
-      }
-    }    
-    cast = cast->next;
-  }
-}
-SWIGRUNTIME void
-SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
-  SWIG_TypeClientData(ti, clientdata);
-  ti->owndata = 1;
-}
-  
-/*
-  Search for a swig_type_info structure only by mangled name
-  Search is a O(log #types)
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_MangledTypeQueryModule(swig_module_info *start, 
-                            swig_module_info *end, 
-		            const char *name) {
-  swig_module_info *iter = start;
-  do {
-    if (iter->size) {
-      register size_t l = 0;
-      register size_t r = iter->size - 1;
-      do {
-	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
-	register size_t i = (l + r) >> 1; 
-	const char *iname = iter->types[i]->name;
-	if (iname) {
-	  register int compare = strcmp(name, iname);
-	  if (compare == 0) {	    
-	    return iter->types[i];
-	  } else if (compare < 0) {
-	    if (i) {
-	      r = i - 1;
-	    } else {
-	      break;
-	    }
-	  } else if (compare > 0) {
-	    l = i + 1;
-	  }
-	} else {
-	  break; /* should never happen */
-	}
-      } while (l <= r);
-    }
-    iter = iter->next;
-  } while (iter != end);
-  return 0;
-}
-
-/*
-  Search for a swig_type_info structure for either a mangled name or a human readable name.
-  It first searches the mangled names of the types, which is a O(log #types)
-  If a type is not found it then searches the human readable names, which is O(#types).
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeQueryModule(swig_module_info *start, 
-                     swig_module_info *end, 
-		     const char *name) {
-  /* STEP 1: Search the name field using binary search */
-  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
-  if (ret) {
-    return ret;
-  } else {
-    /* STEP 2: If the type hasn't been found, do a complete search
-       of the str field (the human readable name) */
-    swig_module_info *iter = start;
-    do {
-      register size_t i = 0;
-      for (; i < iter->size; ++i) {
-	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
-	  return iter->types[i];
-      }
-      iter = iter->next;
-    } while (iter != end);
-  }
-  
-  /* neither found a match */
-  return 0;
-}
-
-/* 
-   Pack binary data into a string
-*/
-SWIGRUNTIME char *
-SWIG_PackData(char *c, void *ptr, size_t sz) {
-  static const char hex[17] = "0123456789abcdef";
-  register const unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu =  u + sz;
-  for (; u != eu; ++u) {
-    register unsigned char uu = *u;
-    *(c++) = hex[(uu & 0xf0) >> 4];
-    *(c++) = hex[uu & 0xf];
-  }
-  return c;
-}
-
-/* 
-   Unpack binary data from a string
-*/
-SWIGRUNTIME const char *
-SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
-  register unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu = u + sz;
-  for (; u != eu; ++u) {
-    register char d = *(c++);
-    register unsigned char uu;
-    if ((d >= '0') && (d <= '9'))
-      uu = ((d - '0') << 4);
-    else if ((d >= 'a') && (d <= 'f'))
-      uu = ((d - ('a'-10)) << 4);
-    else 
-      return (char *) 0;
-    d = *(c++);
-    if ((d >= '0') && (d <= '9'))
-      uu |= (d - '0');
-    else if ((d >= 'a') && (d <= 'f'))
-      uu |= (d - ('a'-10));
-    else 
-      return (char *) 0;
-    *u = uu;
-  }
-  return c;
-}
-
-/* 
-   Pack 'void *' into a string buffer.
-*/
-SWIGRUNTIME char *
-SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
-  char *r = buff;
-  if ((2*sizeof(void *) + 2) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,&ptr,sizeof(void *));
-  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
-  strcpy(r,name);
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      *ptr = (void *) 0;
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sizeof(void *));
-}
-
-SWIGRUNTIME char *
-SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
-  char *r = buff;
-  size_t lname = (name ? strlen(name) : 0);
-  if ((2*sz + 2 + lname) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  if (lname) {
-    strncpy(r,name,lname+1);
-  } else {
-    *r = 0;
-  }
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      memset(ptr,0,sz);
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sz);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-/*  Errors in SWIG */
-#define  SWIG_UnknownError    	   -1 
-#define  SWIG_IOError        	   -2 
-#define  SWIG_RuntimeError   	   -3 
-#define  SWIG_IndexError     	   -4 
-#define  SWIG_TypeError      	   -5 
-#define  SWIG_DivisionByZero 	   -6 
-#define  SWIG_OverflowError  	   -7 
-#define  SWIG_SyntaxError    	   -8 
-#define  SWIG_ValueError     	   -9 
-#define  SWIG_SystemError    	   -10
-#define  SWIG_AttributeError 	   -11
-#define  SWIG_MemoryError    	   -12 
-#define  SWIG_NullReferenceError   -13
-
-
-
-/* Compatibility macros for Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-
-#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
-#define PyInt_Check(x) PyLong_Check(x)
-#define PyInt_AsLong(x) PyLong_AsLong(x)
-#define PyInt_FromLong(x) PyLong_FromLong(x)
-#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
-#define PyString_Check(name) PyBytes_Check(name)
-#define PyString_FromString(x) PyUnicode_FromString(x)
-#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
-#define PyString_AsString(str) PyBytes_AsString(str)
-#define PyString_Size(str) PyBytes_Size(str)	
-#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
-#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
-#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
-
-#endif
-
-#ifndef Py_TYPE
-#  define Py_TYPE(op) ((op)->ob_type)
-#endif
-
-/* SWIG APIs for compatibility of both Python 2 & 3 */
-
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
-#else
-#  define SWIG_Python_str_FromFormat PyString_FromFormat
-#endif
-
-
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
-SWIGINTERN char*
-SWIG_Python_str_AsChar(PyObject *str)
-{
-#if PY_VERSION_HEX >= 0x03000000
-  char *cstr;
-  char *newstr;
-  Py_ssize_t len;
-  str = PyUnicode_AsUTF8String(str);
-  PyBytes_AsStringAndSize(str, &cstr, &len);
-  newstr = (char *) malloc(len+1);
-  memcpy(newstr, cstr, len+1);
-  Py_XDECREF(str);
-  return newstr;
-#else
-  return PyString_AsString(str);
-#endif
-}
-
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#else
-#  define SWIG_Python_str_DelForPy3(x) 
-#endif
-
-
-SWIGINTERN PyObject*
-SWIG_Python_str_FromChar(const char *c)
-{
-#if PY_VERSION_HEX >= 0x03000000
-  return PyUnicode_FromString(c); 
-#else
-  return PyString_FromString(c);
-#endif
-}
-
-/* Add PyOS_snprintf for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
-#  define PyOS_snprintf _snprintf
-# else
-#  define PyOS_snprintf snprintf
-# endif
-#endif
-
-/* A crude PyString_FromFormat implementation for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-
-#ifndef SWIG_PYBUFFER_SIZE
-# define SWIG_PYBUFFER_SIZE 1024
-#endif
-
-static PyObject *
-PyString_FromFormat(const char *fmt, ...) {
-  va_list ap;
-  char buf[SWIG_PYBUFFER_SIZE * 2];
-  int res;
-  va_start(ap, fmt);
-  res = vsnprintf(buf, sizeof(buf), fmt, ap);
-  va_end(ap);
-  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
-}
-#endif
-
-/* Add PyObject_Del for old Pythons */
-#if PY_VERSION_HEX < 0x01060000
-# define PyObject_Del(op) PyMem_DEL((op))
-#endif
-#ifndef PyObject_DEL
-# define PyObject_DEL PyObject_Del
-#endif
-
-/* A crude PyExc_StopIteration exception for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-# ifndef PyExc_StopIteration
-#  define PyExc_StopIteration PyExc_RuntimeError
-# endif
-# ifndef PyObject_GenericGetAttr
-#  define PyObject_GenericGetAttr 0
-# endif
-#endif
-
-/* Py_NotImplemented is defined in 2.1 and up. */
-#if PY_VERSION_HEX < 0x02010000
-# ifndef Py_NotImplemented
-#  define Py_NotImplemented PyExc_RuntimeError
-# endif
-#endif
-
-/* A crude PyString_AsStringAndSize implementation for old Pythons */
-#if PY_VERSION_HEX < 0x02010000
-# ifndef PyString_AsStringAndSize
-#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
-# endif
-#endif
-
-/* PySequence_Size for old Pythons */
-#if PY_VERSION_HEX < 0x02000000
-# ifndef PySequence_Size
-#  define PySequence_Size PySequence_Length
-# endif
-#endif
-
-/* PyBool_FromLong for old Pythons */
-#if PY_VERSION_HEX < 0x02030000
-static
-PyObject *PyBool_FromLong(long ok)
-{
-  PyObject *result = ok ? Py_True : Py_False;
-  Py_INCREF(result);
-  return result;
-}
-#endif
-
-/* Py_ssize_t for old Pythons */
-/* This code is as recommended by: */
-/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
-#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
-typedef int Py_ssize_t;
-# define PY_SSIZE_T_MAX INT_MAX
-# define PY_SSIZE_T_MIN INT_MIN
-typedef inquiry lenfunc;
-typedef intargfunc ssizeargfunc;
-typedef intintargfunc ssizessizeargfunc;
-typedef intobjargproc ssizeobjargproc;
-typedef intintobjargproc ssizessizeobjargproc;
-typedef getreadbufferproc readbufferproc;
-typedef getwritebufferproc writebufferproc;
-typedef getsegcountproc segcountproc;
-typedef getcharbufferproc charbufferproc;
-static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
-{
-  long result = 0;
-  PyObject *i = PyNumber_Int(x);
-  if (i) {
-    result = PyInt_AsLong(i);
-    Py_DECREF(i);
-  }
-  return result;
-}
-#endif
-
-#if PY_VERSION_HEX < 0x02050000
-#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
-#endif
-
-#if PY_VERSION_HEX < 0x02040000
-#define Py_VISIT(op)				\
-  do { 						\
-    if (op) {					\
-      int vret = visit((op), arg);		\
-      if (vret)					\
-        return vret;				\
-    }						\
-  } while (0)
-#endif
-
-#if PY_VERSION_HEX < 0x02030000
-typedef struct {
-  PyTypeObject type;
-  PyNumberMethods as_number;
-  PyMappingMethods as_mapping;
-  PySequenceMethods as_sequence;
-  PyBufferProcs as_buffer;
-  PyObject *name, *slots;
-} PyHeapTypeObject;
-#endif
-
-#if PY_VERSION_HEX < 0x02030000
-typedef destructor freefunc;
-#endif
-
-#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
-     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
-     (PY_MAJOR_VERSION > 3))
-# define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
-#endif
-
-#if PY_VERSION_HEX < 0x03020000
-#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
-#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
-#endif
-
-/* -----------------------------------------------------------------------------
- * error manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIME PyObject*
-SWIG_Python_ErrorType(int code) {
-  PyObject* type = 0;
-  switch(code) {
-  case SWIG_MemoryError:
-    type = PyExc_MemoryError;
-    break;
-  case SWIG_IOError:
-    type = PyExc_IOError;
-    break;
-  case SWIG_RuntimeError:
-    type = PyExc_RuntimeError;
-    break;
-  case SWIG_IndexError:
-    type = PyExc_IndexError;
-    break;
-  case SWIG_TypeError:
-    type = PyExc_TypeError;
-    break;
-  case SWIG_DivisionByZero:
-    type = PyExc_ZeroDivisionError;
-    break;
-  case SWIG_OverflowError:
-    type = PyExc_OverflowError;
-    break;
-  case SWIG_SyntaxError:
-    type = PyExc_SyntaxError;
-    break;
-  case SWIG_ValueError:
-    type = PyExc_ValueError;
-    break;
-  case SWIG_SystemError:
-    type = PyExc_SystemError;
-    break;
-  case SWIG_AttributeError:
-    type = PyExc_AttributeError;
-    break;
-  default:
-    type = PyExc_RuntimeError;
-  }
-  return type;
-}
-
-
-SWIGRUNTIME void
-SWIG_Python_AddErrorMsg(const char* mesg)
-{
-  PyObject *type = 0;
-  PyObject *value = 0;
-  PyObject *traceback = 0;
-
-  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
-  if (value) {
-    char *tmp;
-    PyObject *old_str = PyObject_Str(value);
-    PyErr_Clear();
-    Py_XINCREF(type);
-
-    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
-    SWIG_Python_str_DelForPy3(tmp);
-    Py_DECREF(old_str);
-    Py_DECREF(value);
-  } else {
-    PyErr_SetString(PyExc_RuntimeError, mesg);
-  }
-}
-
-#if defined(SWIG_PYTHON_NO_THREADS)
-#  if defined(SWIG_PYTHON_THREADS)
-#    undef SWIG_PYTHON_THREADS
-#  endif
-#endif
-#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
-#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
-#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
-#      define SWIG_PYTHON_USE_GIL
-#    endif
-#  endif
-#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
-#    endif
-#    ifdef __cplusplus /* C++ code */
-       class SWIG_Python_Thread_Block {
-         bool status;
-         PyGILState_STATE state;
-       public:
-         void end() { if (status) { PyGILState_Release(state); status = false;} }
-         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
-         ~SWIG_Python_Thread_Block() { end(); }
-       };
-       class SWIG_Python_Thread_Allow {
-         bool status;
-         PyThreadState *save;
-       public:
-         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
-         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
-         ~SWIG_Python_Thread_Allow() { end(); }
-       };
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
-#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
-#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
-#    else /* C code */
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
-#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
-#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
-#    endif
-#  else /* Old thread way, not implemented, user must provide it */
-#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
-#      define SWIG_PYTHON_INITIALIZE_THREADS
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
-#      define SWIG_PYTHON_THREAD_END_BLOCK
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
-#      define SWIG_PYTHON_THREAD_END_ALLOW
-#    endif
-#  endif
-#else /* No thread support */
-#  define SWIG_PYTHON_INITIALIZE_THREADS
-#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
-#  define SWIG_PYTHON_THREAD_END_BLOCK
-#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
-#  define SWIG_PYTHON_THREAD_END_ALLOW
-#endif
-
-/* -----------------------------------------------------------------------------
- * Python API portion that goes into the runtime
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* -----------------------------------------------------------------------------
- * Constant declarations
- * ----------------------------------------------------------------------------- */
-
-/* Constant Types */
-#define SWIG_PY_POINTER 4
-#define SWIG_PY_BINARY  5
-
-/* Constant information structure */
-typedef struct swig_const_info {
-  int type;
-  char *name;
-  long lvalue;
-  double dvalue;
-  void   *pvalue;
-  swig_type_info **ptype;
-} swig_const_info;
-
-
-/* -----------------------------------------------------------------------------
- * Wrapper of PyInstanceMethod_New() used in Python 3
- * It is exported to the generated module, used for -fastproxy
- * ----------------------------------------------------------------------------- */
-#if PY_VERSION_HEX >= 0x03000000
-SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
-{
-  return PyInstanceMethod_New(func);
-}
-#else
-SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
-{
-  return NULL;
-}
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/* -----------------------------------------------------------------------------
- * pyrun.swg
- *
- * This file contains the runtime support for Python modules
- * and includes code for managing global variables and pointer
- * type checking.
- *
- * ----------------------------------------------------------------------------- */
-
-/* Common SWIG API */
-
-/* for raw pointers */
-#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
-#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
-#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
-
-#ifdef SWIGPYTHON_BUILTIN
-#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
-#else
-#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
-#endif
-
-#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
-
-#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
-#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
-#define swig_owntype                                    int
-
-/* for raw packed data */
-#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
-#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
-
-/* for class or struct pointers */
-#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
-#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
-
-/* for C or C++ function pointers */
-#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
-#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)
-
-/* for C++ member pointers, ie, member methods */
-#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
-#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
-
-
-/* Runtime API */
-
-#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
-#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
-#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)
-
-#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
-#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
-#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
-#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
-#define SWIG_fail                        		goto fail					   
-
-
-/* Runtime API implementation */
-
-/* Error manipulation */
-
-SWIGINTERN void 
-SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
-  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
-  PyErr_SetObject(errtype, obj);
-  Py_DECREF(obj);
-  SWIG_PYTHON_THREAD_END_BLOCK;
-}
-
-SWIGINTERN void 
-SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
-  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
-  PyErr_SetString(errtype, msg);
-  SWIG_PYTHON_THREAD_END_BLOCK;
-}
-
-#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)
-
-/* Set a constant value */
-
-#if defined(SWIGPYTHON_BUILTIN)
-
-SWIGINTERN void
-SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
-  PyObject *s = PyString_InternFromString(key);
-  PyList_Append(seq, s);
-  Py_DECREF(s);
-}
-
-SWIGINTERN void
-SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
-#if PY_VERSION_HEX < 0x02030000
-  PyDict_SetItemString(d, (char *)name, obj);
-#else
-  PyDict_SetItemString(d, name, obj);
-#endif
-  Py_DECREF(obj);
-  if (public_interface)
-    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
-}
-
-#else
-
-SWIGINTERN void
-SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
-#if PY_VERSION_HEX < 0x02030000
-  PyDict_SetItemString(d, (char *)name, obj);
-#else
-  PyDict_SetItemString(d, name, obj);
-#endif
-  Py_DECREF(obj);                            
-}
-
-#endif
-
-/* Append a value to the result obj */
-
-SWIGINTERN PyObject*
-SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
-#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
-  if (!result) {
-    result = obj;
-  } else if (result == Py_None) {
-    Py_DECREF(result);
-    result = obj;
-  } else {
-    if (!PyList_Check(result)) {
-      PyObject *o2 = result;
-      result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
-    }
-    PyList_Append(result,obj);
-    Py_DECREF(obj);
-  }
-  return result;
-#else
-  PyObject*   o2;
-  PyObject*   o3;
-  if (!result) {
-    result = obj;
-  } else if (result == Py_None) {
-    Py_DECREF(result);
-    result = obj;
-  } else {
-    if (!PyTuple_Check(result)) {
-      o2 = result;
-      result = PyTuple_New(1);
-      PyTuple_SET_ITEM(result, 0, o2);
-    }
-    o3 = PyTuple_New(1);
-    PyTuple_SET_ITEM(o3, 0, obj);
-    o2 = result;
-    result = PySequence_Concat(o2, o3);
-    Py_DECREF(o2);
-    Py_DECREF(o3);
-  }
-  return result;
-#endif
-}
-
-/* Unpack the argument tuple */
-
-SWIGINTERN int
-SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
-{
-  if (!args) {
-    if (!min && !max) {
-      return 1;
-    } else {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
-		   name, (min == max ? "" : "at least "), (int)min);
-      return 0;
-    }
-  }  
-  if (!PyTuple_Check(args)) {
-    if (min <= 1 && max >= 1) {
-      register int i;
-      objs[0] = args;
-      for (i = 1; i < max; ++i) {
-	objs[i] = 0;
-      }
-      return 2;
-    }
-    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
-    return 0;
-  } else {
-    register Py_ssize_t l = PyTuple_GET_SIZE(args);
-    if (l < min) {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at least "), (int)min, (int)l);
-      return 0;
-    } else if (l > max) {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at most "), (int)max, (int)l);
-      return 0;
-    } else {
-      register int i;
-      for (i = 0; i < l; ++i) {
-	objs[i] = PyTuple_GET_ITEM(args, i);
-      }
-      for (; l < max; ++l) {
-	objs[l] = 0;
-      }
-      return i + 1;
-    }    
-  }
-}
-
-/* A functor is a function object with one single object argument */
-#if PY_VERSION_HEX >= 0x02020000
-#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
-#else
-#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
-#endif
-
-/*
-  Helper for static pointer initialization for both C and C++ code, for example
-  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
-*/
-#ifdef __cplusplus
-#define SWIG_STATIC_POINTER(var)  var
-#else
-#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
-#endif
-
-/* -----------------------------------------------------------------------------
- * Pointer declarations
- * ----------------------------------------------------------------------------- */
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
-#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
-
-#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)
-
-#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
-#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*  How to access Py_None */
-#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#  ifndef SWIG_PYTHON_NO_BUILD_NONE
-#    ifndef SWIG_PYTHON_BUILD_NONE
-#      define SWIG_PYTHON_BUILD_NONE
-#    endif
-#  endif
-#endif
-
-#ifdef SWIG_PYTHON_BUILD_NONE
-#  ifdef Py_None
-#   undef Py_None
-#   define Py_None SWIG_Py_None()
-#  endif
-SWIGRUNTIMEINLINE PyObject * 
-_SWIG_Py_None(void)
-{
-  PyObject *none = Py_BuildValue((char*)"");
-  Py_DECREF(none);
-  return none;
-}
-SWIGRUNTIME PyObject * 
-SWIG_Py_None(void)
-{
-  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
-  return none;
-}
-#endif
-
-/* The python void return value */
-
-SWIGRUNTIMEINLINE PyObject * 
-SWIG_Py_Void(void)
-{
-  PyObject *none = Py_None;
-  Py_INCREF(none);
-  return none;
-}
-
-/* SwigPyClientData */
-
-typedef struct {
-  PyObject *klass;
-  PyObject *newraw;
-  PyObject *newargs;
-  PyObject *destroy;
-  int delargs;
-  int implicitconv;
-  PyTypeObject *pytype;
-} SwigPyClientData;
-
-SWIGRUNTIMEINLINE int 
-SWIG_Python_CheckImplicit(swig_type_info *ty)
-{
-  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
-  return data ? data->implicitconv : 0;
-}
-
-SWIGRUNTIMEINLINE PyObject *
-SWIG_Python_ExceptionType(swig_type_info *desc) {
-  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
-  PyObject *klass = data ? data->klass : 0;
-  return (klass ? klass : PyExc_RuntimeError);
-}
-
-
-SWIGRUNTIME SwigPyClientData * 
-SwigPyClientData_New(PyObject* obj)
-{
-  if (!obj) {
-    return 0;
-  } else {
-    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
-    /* the klass element */
-    data->klass = obj;
-    Py_INCREF(data->klass);
-    /* the newraw method and newargs arguments used to create a new raw instance */
-    if (PyClass_Check(obj)) {
-      data->newraw = 0;
-      data->newargs = obj;
-      Py_INCREF(obj);
-    } else {
-#if (PY_VERSION_HEX < 0x02020000)
-      data->newraw = 0;
-#else
-      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
-#endif
-      if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
-      } else {
-	data->newargs = obj;
-      }
-      Py_INCREF(data->newargs);
-    }
-    /* the destroy method, aka as the C++ delete method */
-    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      data->destroy = 0;
-    }
-    if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-#ifdef METH_O
-      data->delargs = !(flags & (METH_O));
-#else
-      data->delargs = 0;
-#endif
-    } else {
-      data->delargs = 0;
-    }
-    data->implicitconv = 0;
-    data->pytype = 0;
-    return data;
-  }
-}
-
-SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
-  Py_XDECREF(data->newraw);
-  Py_XDECREF(data->newargs);
-  Py_XDECREF(data->destroy);
-}
-
-/* =============== SwigPyObject =====================*/
-
-typedef struct {
-  PyObject_HEAD
-  void *ptr;
-  swig_type_info *ty;
-  int own;
-  PyObject *next;
-#ifdef SWIGPYTHON_BUILTIN
-  PyObject *dict;
-#endif
-} SwigPyObject;
-
-SWIGRUNTIME PyObject *
-SwigPyObject_long(SwigPyObject *v)
-{
-  return PyLong_FromVoidPtr(v->ptr);
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_format(const char* fmt, SwigPyObject *v)
-{
-  PyObject *res = NULL;
-  PyObject *args = PyTuple_New(1);
-  if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
-      if (ofmt) {
-#if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
-#else
-	res = PyString_Format(ofmt,args);
-#endif
-	Py_DECREF(ofmt);
-      }
-      Py_DECREF(args);
-    }
-  }
-  return res;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_oct(SwigPyObject *v)
-{
-  return SwigPyObject_format("%o",v);
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_hex(SwigPyObject *v)
-{
-  return SwigPyObject_format("%x",v);
-}
-
-SWIGRUNTIME PyObject *
-#ifdef METH_NOARGS
-SwigPyObject_repr(SwigPyObject *v)
-#else
-SwigPyObject_repr(SwigPyObject *v, PyObject *args)
-#endif
-{
-  const char *name = SWIG_TypePrettyName(v->ty);
-  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
-# ifdef METH_NOARGS
-    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
-# else
-    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
-# endif
-# if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
-# else
-    PyString_ConcatAndDel(&repr,nrep);
-# endif
-  }
-  return repr;  
-}
-
-SWIGRUNTIME int
-SwigPyObject_print(SwigPyObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))
-{
-  char *str;
-#ifdef METH_NOARGS
-  PyObject *repr = SwigPyObject_repr(v);
-#else
-  PyObject *repr = SwigPyObject_repr(v, NULL);
-#endif
-  if (repr) {
-    str = SWIG_Python_str_AsChar(repr); 
-    fputs(str, fp);
-    SWIG_Python_str_DelForPy3(str);
-    Py_DECREF(repr);
-    return 0; 
-  } else {
-    return 1; 
-  }
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_str(SwigPyObject *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  return SWIG_PackVoidPtr(result, v->ptr, v->ty->name, sizeof(result)) ?
-    SWIG_Python_str_FromChar(result) : 0;
-}
-
-SWIGRUNTIME int
-SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
-{
-  void *i = v->ptr;
-  void *j = w->ptr;
-  return (i < j) ? -1 : ((i > j) ? 1 : 0);
-}
-
-/* Added for Python 3.x, would it also be useful for Python 2.x? */
-SWIGRUNTIME PyObject*
-SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
-{
-  PyObject* res;
-  if( op != Py_EQ && op != Py_NE ) {
-    Py_INCREF(Py_NotImplemented);
-    return Py_NotImplemented;
-  }
-  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
-  return res;  
-}
-
-
-SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);
-
-#ifdef SWIGPYTHON_BUILTIN
-static swig_type_info *SwigPyObject_stype = 0;
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_type(void) {
-    SwigPyClientData *cd;
-    assert(SwigPyObject_stype);
-    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
-    assert(cd);
-    assert(cd->pytype);
-    return cd->pytype;
-}
-#else
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_type(void) {
-  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
-  return type;
-}
-#endif
-
-SWIGRUNTIMEINLINE int
-SwigPyObject_Check(PyObject *op) {
-#ifdef SWIGPYTHON_BUILTIN
-  PyTypeObject *target_tp = SwigPyObject_type();
-  if (PyType_IsSubtype(op->ob_type, target_tp))
-    return 1;
-  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
-#else
-  return (Py_TYPE(op) == SwigPyObject_type())
-    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
-#endif
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
-
-SWIGRUNTIME void
-SwigPyObject_dealloc(PyObject *v)
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-  PyObject *next = sobj->next;
-  if (sobj->own == SWIG_POINTER_OWN) {
-    swig_type_info *ty = sobj->ty;
-    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
-    PyObject *destroy = data ? data->destroy : 0;
-    if (destroy) {
-      /* destroy is always a VARARGS method */
-      PyObject *res;
-      if (data->delargs) {
-	/* we need to create a temporary object to carry the destroy operation */
-	PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-	res = SWIG_Python_CallFunctor(destroy, tmp);
-	Py_DECREF(tmp);
-      } else {
-	PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
-	PyObject *mself = PyCFunction_GET_SELF(destroy);
-	res = ((*meth)(mself, v));
-      }
-      Py_XDECREF(res);
-    } 
-#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
-    else {
-      const char *name = SWIG_TypePrettyName(ty);
-      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
-    }
-#endif
-  } 
-  Py_XDECREF(next);
-  PyObject_DEL(v);
-}
-
-SWIGRUNTIME PyObject* 
-SwigPyObject_append(PyObject* v, PyObject* next)
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-#ifndef METH_O
-  PyObject *tmp = 0;
-  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
-  next = tmp;
-#endif
-  if (!SwigPyObject_Check(next)) {
-    return NULL;
-  }
-  sobj->next = next;
-  Py_INCREF(next);
-  return SWIG_Py_Void();
-}
-
-SWIGRUNTIME PyObject* 
-#ifdef METH_NOARGS
-SwigPyObject_next(PyObject* v)
-#else
-SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-  if (sobj->next) {    
-    Py_INCREF(sobj->next);
-    return sobj->next;
-  } else {
-    return SWIG_Py_Void();
-  }
-}
-
-SWIGINTERN PyObject*
-#ifdef METH_NOARGS
-SwigPyObject_disown(PyObject *v)
-#else
-SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *)v;
-  sobj->own = 0;
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject*
-#ifdef METH_NOARGS
-SwigPyObject_acquire(PyObject *v)
-#else
-SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *)v;
-  sobj->own = SWIG_POINTER_OWN;
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject*
-SwigPyObject_own(PyObject *v, PyObject *args)
-{
-  PyObject *val = 0;
-#if (PY_VERSION_HEX < 0x02020000)
-  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
-#elif (PY_VERSION_HEX < 0x02050000)
-  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
-#else
-  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
-#endif
-    {
-      return NULL;
-    } 
-  else
-    {
-      SwigPyObject *sobj = (SwigPyObject *)v;
-      PyObject *obj = PyBool_FromLong(sobj->own);
-      if (val) {
-#ifdef METH_NOARGS
-	if (PyObject_IsTrue(val)) {
-	  SwigPyObject_acquire(v);
-	} else {
-	  SwigPyObject_disown(v);
-	}
-#else
-	if (PyObject_IsTrue(val)) {
-	  SwigPyObject_acquire(v,args);
-	} else {
-	  SwigPyObject_disown(v,args);
-	}
-#endif
-      } 
-      return obj;
-    }
-}
-
-#ifdef METH_O
-static PyMethodDef
-swigobject_methods[] = {
-  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
-  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
-  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
-  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
-  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
-  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
-  {0, 0, 0, 0}  
-};
-#else
-static PyMethodDef
-swigobject_methods[] = {
-  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
-  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"aquires ownership of the pointer"},
-  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
-  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
-  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
-  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
-  {0, 0, 0, 0}  
-};
-#endif
-
-#if PY_VERSION_HEX < 0x02020000
-SWIGINTERN PyObject *
-SwigPyObject_getattr(SwigPyObject *sobj,char *name)
-{
-  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
-}
-#endif
-
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_TypeOnce(void) {
-  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";
-
-  static PyNumberMethods SwigPyObject_as_number = {
-    (binaryfunc)0, /*nb_add*/
-    (binaryfunc)0, /*nb_subtract*/
-    (binaryfunc)0, /*nb_multiply*/
-    /* nb_divide removed in Python 3 */
-#if PY_VERSION_HEX < 0x03000000
-    (binaryfunc)0, /*nb_divide*/
-#endif
-    (binaryfunc)0, /*nb_remainder*/
-    (binaryfunc)0, /*nb_divmod*/
-    (ternaryfunc)0,/*nb_power*/
-    (unaryfunc)0,  /*nb_negative*/
-    (unaryfunc)0,  /*nb_positive*/
-    (unaryfunc)0,  /*nb_absolute*/
-    (inquiry)0,    /*nb_nonzero*/
-    0,		   /*nb_invert*/
-    0,		   /*nb_lshift*/
-    0,		   /*nb_rshift*/
-    0,		   /*nb_and*/
-    0,		   /*nb_xor*/
-    0,		   /*nb_or*/
-#if PY_VERSION_HEX < 0x03000000
-    0,   /*nb_coerce*/
-#endif
-    (unaryfunc)SwigPyObject_long, /*nb_int*/
-#if PY_VERSION_HEX < 0x03000000
-    (unaryfunc)SwigPyObject_long, /*nb_long*/
-#else
-    0, /*nb_reserved*/
-#endif
-    (unaryfunc)0,                 /*nb_float*/
-#if PY_VERSION_HEX < 0x03000000
-    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
-    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
-#endif
-#if PY_VERSION_HEX >= 0x03000000 /* 3.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
-#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
-#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
-#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
-    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
-#endif
-  };
-
-  static PyTypeObject swigpyobject_type;
-  static int type_init = 0;
-  if (!type_init) {
-    const PyTypeObject tmp = {
-      /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-      PyVarObject_HEAD_INIT(NULL, 0)
-#else
-      PyObject_HEAD_INIT(NULL)
-      0,                                    /* ob_size */
-#endif
-      (char *)"SwigPyObject",               /* tp_name */
-      sizeof(SwigPyObject),                 /* tp_basicsize */
-      0,                                    /* tp_itemsize */
-      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      (printfunc)SwigPyObject_print,        /* tp_print */
-#if PY_VERSION_HEX < 0x02020000
-      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
-#else
-      (getattrfunc)0,                       /* tp_getattr */
-#endif
-      (setattrfunc)0,                       /* tp_setattr */
-#if PY_VERSION_HEX >= 0x03000000
-    0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
-#else
-      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
-#endif
-      (reprfunc)SwigPyObject_repr,          /* tp_repr */
-      &SwigPyObject_as_number,              /* tp_as_number */
-      0,                                    /* tp_as_sequence */
-      0,                                    /* tp_as_mapping */
-      (hashfunc)0,                          /* tp_hash */
-      (ternaryfunc)0,                       /* tp_call */
-      (reprfunc)SwigPyObject_str,           /* tp_str */
-      PyObject_GenericGetAttr,              /* tp_getattro */
-      0,                                    /* tp_setattro */
-      0,                                    /* tp_as_buffer */
-      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
-      swigobject_doc,                       /* tp_doc */
-      0,                                    /* tp_traverse */
-      0,                                    /* tp_clear */
-      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
-      0,                                    /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-      0,                                    /* tp_iter */
-      0,                                    /* tp_iternext */
-      swigobject_methods,                   /* tp_methods */
-      0,                                    /* tp_members */
-      0,                                    /* tp_getset */
-      0,                                    /* tp_base */
-      0,                                    /* tp_dict */
-      0,                                    /* tp_descr_get */
-      0,                                    /* tp_descr_set */
-      0,                                    /* tp_dictoffset */
-      0,                                    /* tp_init */
-      0,                                    /* tp_alloc */
-      0,                                    /* tp_new */
-      0,                                    /* tp_free */
-      0,                                    /* tp_is_gc */
-      0,                                    /* tp_bases */
-      0,                                    /* tp_mro */
-      0,                                    /* tp_cache */
-      0,                                    /* tp_subclasses */
-      0,                                    /* tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-      0,                                    /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-      0,                                    /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-      0,0,0,0                               /* tp_alloc -> tp_next */
-#endif
-    };
-    swigpyobject_type = tmp;
-    type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-    swigpyobject_type.ob_type = &PyType_Type;
-#else
-    if (PyType_Ready(&swigpyobject_type) < 0)
-      return NULL;
-#endif
-  }
-  return &swigpyobject_type;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
-{
-  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
-  if (sobj) {
-    sobj->ptr  = ptr;
-    sobj->ty   = ty;
-    sobj->own  = own;
-    sobj->next = 0;
-  }
-  return (PyObject *)sobj;
-}
-
-/* -----------------------------------------------------------------------------
- * Implements a simple Swig Packed type, and use it instead of string
- * ----------------------------------------------------------------------------- */
-
-typedef struct {
-  PyObject_HEAD
-  void *pack;
-  swig_type_info *ty;
-  size_t size;
-} SwigPyPacked;
-
-SWIGRUNTIME int
-SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
-{
-  char result[SWIG_BUFFER_SIZE];
-  fputs("<Swig Packed ", fp); 
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    fputs("at ", fp); 
-    fputs(result, fp); 
-  }
-  fputs(v->ty->name,fp); 
-  fputs(">", fp);
-  return 0; 
-}
-  
-SWIGRUNTIME PyObject *
-SwigPyPacked_repr(SwigPyPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
-  } else {
-    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
-  }  
-}
-
-SWIGRUNTIME PyObject *
-SwigPyPacked_str(SwigPyPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
-    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
-  } else {
-    return SWIG_Python_str_FromChar(v->ty->name);
-  }  
-}
-
-SWIGRUNTIME int
-SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
-{
-  size_t i = v->size;
-  size_t j = w->size;
-  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
-  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
-}
-
-SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);
-
-SWIGRUNTIME PyTypeObject*
-SwigPyPacked_type(void) {
-  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
-  return type;
-}
-
-SWIGRUNTIMEINLINE int
-SwigPyPacked_Check(PyObject *op) {
-  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
-    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
-}
-
-SWIGRUNTIME void
-SwigPyPacked_dealloc(PyObject *v)
-{
-  if (SwigPyPacked_Check(v)) {
-    SwigPyPacked *sobj = (SwigPyPacked *) v;
-    free(sobj->pack);
-  }
-  PyObject_DEL(v);
-}
-
-SWIGRUNTIME PyTypeObject*
-SwigPyPacked_TypeOnce(void) {
-  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
-  static PyTypeObject swigpypacked_type;
-  static int type_init = 0;
-  if (!type_init) {
-    const PyTypeObject tmp = {
-      /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX>=0x03000000
-      PyVarObject_HEAD_INIT(NULL, 0)
-#else
-      PyObject_HEAD_INIT(NULL)
-      0,                                    /* ob_size */
-#endif
-      (char *)"SwigPyPacked",               /* tp_name */
-      sizeof(SwigPyPacked),                 /* tp_basicsize */
-      0,                                    /* tp_itemsize */
-      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      (printfunc)SwigPyPacked_print,        /* tp_print */
-      (getattrfunc)0,                       /* tp_getattr */
-      (setattrfunc)0,                       /* tp_setattr */
-#if PY_VERSION_HEX>=0x03000000
-      0, /* tp_reserved in 3.0.1 */
-#else
-      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
-#endif
-      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
-      0,                                    /* tp_as_number */
-      0,                                    /* tp_as_sequence */
-      0,                                    /* tp_as_mapping */
-      (hashfunc)0,                          /* tp_hash */
-      (ternaryfunc)0,                       /* tp_call */
-      (reprfunc)SwigPyPacked_str,           /* tp_str */
-      PyObject_GenericGetAttr,              /* tp_getattro */
-      0,                                    /* tp_setattro */
-      0,                                    /* tp_as_buffer */
-      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
-      swigpacked_doc,                       /* tp_doc */
-      0,                                    /* tp_traverse */
-      0,                                    /* tp_clear */
-      0,                                    /* tp_richcompare */
-      0,                                    /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-      0,                                    /* tp_iter */
-      0,                                    /* tp_iternext */
-      0,                                    /* tp_methods */
-      0,                                    /* tp_members */
-      0,                                    /* tp_getset */
-      0,                                    /* tp_base */
-      0,                                    /* tp_dict */
-      0,                                    /* tp_descr_get */
-      0,                                    /* tp_descr_set */
-      0,                                    /* tp_dictoffset */
-      0,                                    /* tp_init */
-      0,                                    /* tp_alloc */
-      0,                                    /* tp_new */
-      0,                                    /* tp_free */
-      0,                                    /* tp_is_gc */
-      0,                                    /* tp_bases */
-      0,                                    /* tp_mro */
-      0,                                    /* tp_cache */
-      0,                                    /* tp_subclasses */
-      0,                                    /* tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-      0,                                    /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-      0,                                    /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-      0,0,0,0                               /* tp_alloc -> tp_next */
-#endif
-    };
-    swigpypacked_type = tmp;
-    type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-    swigpypacked_type.ob_type = &PyType_Type;
-#else
-    if (PyType_Ready(&swigpypacked_type) < 0)
-      return NULL;
-#endif
-  }
-  return &swigpypacked_type;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
-{
-  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
-  if (sobj) {
-    void *pack = malloc(size);
-    if (pack) {
-      memcpy(pack, ptr, size);
-      sobj->pack = pack;
-      sobj->ty   = ty;
-      sobj->size = size;
-    } else {
-      PyObject_DEL((PyObject *) sobj);
-      sobj = 0;
-    }
-  }
-  return (PyObject *) sobj;
-}
-
-SWIGRUNTIME swig_type_info *
-SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
-{
-  if (SwigPyPacked_Check(obj)) {
-    SwigPyPacked *sobj = (SwigPyPacked *)obj;
-    if (sobj->size != size) return 0;
-    memcpy(ptr, sobj->pack, size);
-    return sobj->ty;
-  } else {
-    return 0;
-  }
-}
-
-/* -----------------------------------------------------------------------------
- * pointers/data manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIMEINLINE PyObject *
-_SWIG_This(void)
-{
-    return SWIG_Python_str_FromChar("this");
-}
-
-static PyObject *swig_this = NULL;
-
-SWIGRUNTIME PyObject *
-SWIG_This(void)
-{
-  if (swig_this == NULL)
-    swig_this = _SWIG_This();
-  return swig_this;
-}
-
-/* #define SWIG_PYTHON_SLOW_GETSET_THIS */
-
-/* TODO: I don't know how to implement the fast getset in Python 3 right now */
-#if PY_VERSION_HEX>=0x03000000
-#define SWIG_PYTHON_SLOW_GETSET_THIS 
-#endif
-
-SWIGRUNTIME SwigPyObject *
-SWIG_Python_GetSwigThis(PyObject *pyobj) 
-{
-  PyObject *obj;
-
-  if (SwigPyObject_Check(pyobj))
-    return (SwigPyObject *) pyobj;
-
-#ifdef SWIGPYTHON_BUILTIN
-  (void)obj;
-# ifdef PyWeakref_CheckProxy
-  if (PyWeakref_CheckProxy(pyobj)) {
-    pyobj = PyWeakref_GET_OBJECT(pyobj);
-    if (pyobj && SwigPyObject_Check(pyobj))
-      return (SwigPyObject*) pyobj;
-  }
-# endif
-  return NULL;
-#else
-
-  obj = 0;
-
-#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
-  if (PyInstance_Check(pyobj)) {
-    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
-  } else {
-    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
-    if (dictptr != NULL) {
-      PyObject *dict = *dictptr;
-      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
-    } else {
-#ifdef PyWeakref_CheckProxy
-      if (PyWeakref_CheckProxy(pyobj)) {
-	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
-	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
-      }
-#endif
-      obj = PyObject_GetAttr(pyobj,SWIG_This());
-      if (obj) {
-	Py_DECREF(obj);
-      } else {
-	if (PyErr_Occurred()) PyErr_Clear();
-	return 0;
-      }
-    }
-  }
-#else
-  obj = PyObject_GetAttr(pyobj,SWIG_This());
-  if (obj) {
-    Py_DECREF(obj);
-  } else {
-    if (PyErr_Occurred()) PyErr_Clear();
-    return 0;
-  }
-#endif
-  if (obj && !SwigPyObject_Check(obj)) {
-    /* a PyObject is called 'this', try to get the 'real this'
-       SwigPyObject from it */ 
-    return SWIG_Python_GetSwigThis(obj);
-  }
-  return (SwigPyObject *)obj;
-#endif
-}
-
-/* Acquire a pointer value */
-
-SWIGRUNTIME int
-SWIG_Python_AcquirePtr(PyObject *obj, int own) {
-  if (own == SWIG_POINTER_OWN) {
-    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
-    if (sobj) {
-      int oldown = sobj->own;
-      sobj->own = own;
-      return oldown;
-    }
-  }
-  return 0;
-}
-
-/* Convert a pointer value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
-  int res;
-  SwigPyObject *sobj;
-
-  if (!obj)
-    return SWIG_ERROR;
-  if (obj == Py_None) {
-    if (ptr)
-      *ptr = 0;
-    return SWIG_OK;
-  }
-
-  res = SWIG_ERROR;
-
-  sobj = SWIG_Python_GetSwigThis(obj);
-  if (own)
-    *own = 0;
-  while (sobj) {
-    void *vptr = sobj->ptr;
-    if (ty) {
-      swig_type_info *to = sobj->ty;
-      if (to == ty) {
-        /* no type cast needed */
-        if (ptr) *ptr = vptr;
-        break;
-      } else {
-        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
-        if (!tc) {
-          sobj = (SwigPyObject *)sobj->next;
-        } else {
-          if (ptr) {
-            int newmemory = 0;
-            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
-            if (newmemory == SWIG_CAST_NEW_MEMORY) {
-              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
-              if (own)
-                *own = *own | SWIG_CAST_NEW_MEMORY;
-            }
-          }
-          break;
-        }
-      }
-    } else {
-      if (ptr) *ptr = vptr;
-      break;
-    }
-  }
-  if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
-    }
-    res = SWIG_OK;
-  } else {
-    if (flags & SWIG_POINTER_IMPLICIT_CONV) {
-      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
-      if (data && !data->implicitconv) {
-        PyObject *klass = data->klass;
-        if (klass) {
-          PyObject *impconv;
-          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
-          impconv = SWIG_Python_CallFunctor(klass, obj);
-          data->implicitconv = 0;
-          if (PyErr_Occurred()) {
-            PyErr_Clear();
-            impconv = 0;
-          }
-          if (impconv) {
-            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
-            if (iobj) {
-              void *vptr;
-              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
-              if (SWIG_IsOK(res)) {
-                if (ptr) {
-                  *ptr = vptr;
-                  /* transfer the ownership to 'ptr' */
-                  iobj->own = 0;
-                  res = SWIG_AddCast(res);
-                  res = SWIG_AddNewMask(res);
-                } else {
-                  res = SWIG_AddCast(res);		    
-                }
-              }
-            }
-            Py_DECREF(impconv);
-          }
-        }
-      }
-    }
-  }
-  return res;
-}
-
-/* Convert a function ptr value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
-  if (!PyCFunction_Check(obj)) {
-    return SWIG_ConvertPtr(obj, ptr, ty, 0);
-  } else {
-    void *vptr = 0;
-    
-    /* here we get the method pointer for callbacks */
-    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
-    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
-    if (desc)
-      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
-    if (!desc) 
-      return SWIG_ERROR;
-    if (ty) {
-      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
-      if (tc) {
-        int newmemory = 0;
-        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
-        assert(!newmemory); /* newmemory handling not yet implemented */
-      } else {
-        return SWIG_ERROR;
-      }
-    } else {
-      *ptr = vptr;
-    }
-    return SWIG_OK;
-  }
-}
-
-/* Convert a packed value value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
-  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
-  if (!to) return SWIG_ERROR;
-  if (ty) {
-    if (to != ty) {
-      /* check type cast? */
-      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
-      if (!tc) return SWIG_ERROR;
-    }
-  }
-  return SWIG_OK;
-}  
-
-/* -----------------------------------------------------------------------------
- * Create a new pointer object
- * ----------------------------------------------------------------------------- */
-
-/*
-  Create a new instance object, without calling __init__, and set the
-  'this' attribute.
-*/
-
-SWIGRUNTIME PyObject* 
-SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
-{
-#if (PY_VERSION_HEX >= 0x02020000)
-  PyObject *inst = 0;
-  PyObject *newraw = data->newraw;
-  if (newraw) {
-    inst = PyObject_Call(newraw, data->newargs, NULL);
-    if (inst) {
-#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
-      PyObject **dictptr = _PyObject_GetDictPtr(inst);
-      if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
-      }
-#else
-      PyObject *key = SWIG_This();
-      PyObject_SetAttr(inst, key, swig_this);
-#endif
-    }
-  } else {
-#if PY_VERSION_HEX >= 0x03000000
-    inst = PyBaseObject_Type.tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
-    if (inst) {
-      PyObject_SetAttr(inst, SWIG_This(), swig_this);
-      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
-    }
-#else
-    PyObject *dict = PyDict_New();
-    if (dict) {
-      PyDict_SetItem(dict, SWIG_This(), swig_this);
-      inst = PyInstance_NewRaw(data->newargs, dict);
-      Py_DECREF(dict);
-    }
-#endif
-  }
-  return inst;
-#else
-#if (PY_VERSION_HEX >= 0x02010000)
-  PyObject *inst = 0;
-  PyObject *dict = PyDict_New();
-  if (dict) {
-    PyDict_SetItem(dict, SWIG_This(), swig_this);
-    inst = PyInstance_NewRaw(data->newargs, dict);
-    Py_DECREF(dict);
-  }
-  return (PyObject *) inst;
-#else
-  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
-  if (inst == NULL) {
-    return NULL;
-  }
-  inst->in_class = (PyClassObject *)data->newargs;
-  Py_INCREF(inst->in_class);
-  inst->in_dict = PyDict_New();
-  if (inst->in_dict == NULL) {
-    Py_DECREF(inst);
-    return NULL;
-  }
-#ifdef Py_TPFLAGS_HAVE_WEAKREFS
-  inst->in_weakreflist = NULL;
-#endif
-#ifdef Py_TPFLAGS_GC
-  PyObject_GC_Init(inst);
-#endif
-  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
-  return (PyObject *) inst;
-#endif
-#endif
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
-{
- PyObject *dict;
-#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
- PyObject **dictptr = _PyObject_GetDictPtr(inst);
- if (dictptr != NULL) {
-   dict = *dictptr;
-   if (dict == NULL) {
-     dict = PyDict_New();
-     *dictptr = dict;
-   }
-   PyDict_SetItem(dict, SWIG_This(), swig_this);
-   return;
- }
-#endif
- dict = PyObject_GetAttrString(inst, (char*)"__dict__");
- PyDict_SetItem(dict, SWIG_This(), swig_this);
- Py_DECREF(dict);
-} 
-
-
-SWIGINTERN PyObject *
-SWIG_Python_InitShadowInstance(PyObject *args) {
-  PyObject *obj[2];
-  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
-    return NULL;
-  } else {
-    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
-    if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
-    } else {
-      SWIG_Python_SetSwigThis(obj[0], obj[1]);
-    }
-    return SWIG_Py_Void();
-  }
-}
-
-/* Create a new pointer object */
-
-SWIGRUNTIME PyObject *
-SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
-  SwigPyClientData *clientdata;
-  PyObject * robj;
-  int own;
-
-  if (!ptr)
-    return SWIG_Py_Void();
-
-  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
-  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
-  if (clientdata && clientdata->pytype) {
-    SwigPyObject *newobj;
-    if (flags & SWIG_BUILTIN_TP_INIT) {
-      newobj = (SwigPyObject*) self;
-      if (newobj->ptr) {
-        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
-        while (newobj->next)
-	  newobj = (SwigPyObject *) newobj->next;
-        newobj->next = next_self;
-        newobj = (SwigPyObject *)next_self;
-      }
-    } else {
-      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
-    }
-    if (newobj) {
-      newobj->ptr = ptr;
-      newobj->ty = type;
-      newobj->own = own;
-      newobj->next = 0;
-#ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
-#endif
-      return (PyObject*) newobj;
-    }
-    return SWIG_Py_Void();
-  }
-
-  assert(!(flags & SWIG_BUILTIN_TP_INIT));
-
-  robj = SwigPyObject_New(ptr, type, own);
-  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
-    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
-    Py_DECREF(robj);
-    robj = inst;
-  }
-  return robj;
-}
-
-/* Create a new packed object */
-
-SWIGRUNTIMEINLINE PyObject *
-SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
-  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
-}
-
-/* -----------------------------------------------------------------------------*
- *  Get type list 
- * -----------------------------------------------------------------------------*/
-
-#ifdef SWIG_LINK_RUNTIME
-void *SWIG_ReturnGlobalTypeList(void *);
-#endif
-
-SWIGRUNTIME swig_module_info *
-SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
-  static void *type_pointer = (void *)0;
-  /* first check if module already created */
-  if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
-    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
-#else
-# ifdef SWIGPY_USE_CAPSULE
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-# else
-    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
-				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
-# endif
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
-  }
-  return (swig_module_info *) type_pointer;
-}
-
-#if PY_MAJOR_VERSION < 2
-/* PyModule_AddObject function was introduced in Python 2.0.  The following function
-   is copied out of Python/modsupport.c in python version 2.3.4 */
-SWIGINTERN int
-PyModule_AddObject(PyObject *m, char *name, PyObject *o)
-{
-  PyObject *dict;
-  if (!PyModule_Check(m)) {
-    PyErr_SetString(PyExc_TypeError,
-		    "PyModule_AddObject() needs module as first arg");
-    return SWIG_ERROR;
-  }
-  if (!o) {
-    PyErr_SetString(PyExc_TypeError,
-		    "PyModule_AddObject() needs non-NULL value");
-    return SWIG_ERROR;
-  }
-  
-  dict = PyModule_GetDict(m);
-  if (dict == NULL) {
-    /* Internal error -- modules must have a dict! */
-    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
-		 PyModule_GetName(m));
-    return SWIG_ERROR;
-  }
-  if (PyDict_SetItemString(dict, name, o))
-    return SWIG_ERROR;
-  Py_DECREF(o);
-  return SWIG_OK;
-}
-#endif
-
-SWIGRUNTIME void
-#ifdef SWIGPY_USE_CAPSULE
-SWIG_Python_DestroyModule(PyObject *obj)
-#else
-SWIG_Python_DestroyModule(void *vptr)
-#endif
-{
-#ifdef SWIGPY_USE_CAPSULE
-  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
-#else
-  swig_module_info *swig_module = (swig_module_info *) vptr;
-#endif
-  swig_type_info **types = swig_module->types;
-  size_t i;
-  for (i =0; i < swig_module->size; ++i) {
-    swig_type_info *ty = types[i];
-    if (ty->owndata) {
-      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
-      if (data) SwigPyClientData_Del(data);
-    }
-  }
-  Py_DECREF(SWIG_This());
-  swig_this = NULL;
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetModule(swig_module_info *swig_module) {
-#if PY_VERSION_HEX >= 0x03000000
- /* Add a dummy module object into sys.modules */
-  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
-#else
-  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
-  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
-#endif
-#ifdef SWIGPY_USE_CAPSULE
-  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
-  if (pointer && module) {
-    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
-  } else {
-    Py_XDECREF(pointer);
-  }
-#else
-  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
-  if (pointer && module) {
-    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
-  } else {
-    Py_XDECREF(pointer);
-  }
-#endif
-}
-
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
-SWIGRUNTIME swig_type_info *
-SWIG_Python_TypeQuery(const char *type)
-{
-  PyObject *cache = SWIG_Python_TypeCache();
-  PyObject *key = SWIG_Python_str_FromChar(type); 
-  PyObject *obj = PyDict_GetItem(cache, key);
-  swig_type_info *descriptor;
-  if (obj) {
-#ifdef SWIGPY_USE_CAPSULE
-    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
-#else
-    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
-#endif
-  } else {
-    swig_module_info *swig_module = SWIG_GetModule(0);
-    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
-    if (descriptor) {
-#ifdef SWIGPY_USE_CAPSULE
-      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-#else
-      obj = PyCObject_FromVoidPtr(descriptor, NULL);
-#endif
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
-    }
-  }
-  Py_DECREF(key);
-  return descriptor;
-}
-
-/* 
-   For backward compatibility only
-*/
-#define SWIG_POINTER_EXCEPTION  0
-#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
-#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
-
-SWIGRUNTIME int
-SWIG_Python_AddErrMesg(const char* mesg, int infront)
-{  
-  if (PyErr_Occurred()) {
-    PyObject *type = 0;
-    PyObject *value = 0;
-    PyObject *traceback = 0;
-    PyErr_Fetch(&type, &value, &traceback);
-    if (value) {
-      char *tmp;
-      PyObject *old_str = PyObject_Str(value);
-      Py_XINCREF(type);
-      PyErr_Clear();
-      if (infront) {
-	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
-      } else {
-	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
-      }
-      SWIG_Python_str_DelForPy3(tmp);
-      Py_DECREF(old_str);
-    }
-    return 1;
-  } else {
-    return 0;
-  }
-}
-  
-SWIGRUNTIME int
-SWIG_Python_ArgFail(int argnum)
-{
-  if (PyErr_Occurred()) {
-    /* add information about failing argument */
-    char mesg[256];
-    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
-    return SWIG_Python_AddErrMesg(mesg, 1);
-  } else {
-    return 0;
-  }
-}
-
-SWIGRUNTIMEINLINE const char *
-SwigPyObject_GetDesc(PyObject *self)
-{
-  SwigPyObject *v = (SwigPyObject *)self;
-  swig_type_info *ty = v ? v->ty : 0;
-  return ty ? ty->str : "";
-}
-
-SWIGRUNTIME void
-SWIG_Python_TypeError(const char *type, PyObject *obj)
-{
-  if (type) {
-#if defined(SWIG_COBJECT_TYPES)
-    if (obj && SwigPyObject_Check(obj)) {
-      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
-      if (otype) {
-	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
-		     type, otype);
-	return;
-      }
-    } else 
-#endif      
-    {
-      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
-      if (otype) {
-	PyObject *str = PyObject_Str(obj);
-	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
-	if (cstr) {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
-		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
-	} else {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
-		       type, otype);
-	}
-	Py_XDECREF(str);
-	return;
-      }
-    }   
-    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
-  } else {
-    PyErr_Format(PyExc_TypeError, "unexpected type is received");
-  }
-}
-
-
-/* Convert a pointer value, signal an exception on a type mismatch */
-SWIGRUNTIME void *
-SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
-  void *result;
-  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
-    PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
-  }
-  return result;
-}
-
-#ifdef SWIGPYTHON_BUILTIN
-SWIGRUNTIME int
-SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
-  PyTypeObject *tp = obj->ob_type;
-  PyObject *descr;
-  PyObject *encoded_name;
-  descrsetfunc f;
-  int res;
-
-# ifdef Py_USING_UNICODE
-  if (PyString_Check(name)) {
-    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
-    if (!name)
-      return -1;
-  } else if (!PyUnicode_Check(name))
-# else
-  if (!PyString_Check(name))
-# endif
-  {
-    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
-    return -1;
-  } else {
-    Py_INCREF(name);
-  }
-
-  if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
-      goto done;
-  }
-
-  res = -1;
-  descr = _PyType_Lookup(tp, name);
-  f = NULL;
-  if (descr != NULL)
-    f = descr->ob_type->tp_descr_set;
-  if (!f) {
-    if (PyString_Check(name)) {
-      encoded_name = name;
-      Py_INCREF(name);
-    } else {
-      encoded_name = PyUnicode_AsUTF8String(name);
-    }
-    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
-    Py_DECREF(encoded_name);
-  } else {
-    res = f(descr, obj, value);
-  }
-  
-  done:
-  Py_DECREF(name);
-  return res;
-}
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-
-#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
-
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define SWIGTYPE_p_char swig_types[0]
-#define SWIGTYPE_p_im_col_tab_disp swig_types[1]
-#define SWIGTYPE_p_matrix swig_types[2]
-#define SWIGTYPE_p_vips__VDisplay swig_types[3]
-#define SWIGTYPE_p_vips__VError swig_types[4]
-#define SWIGTYPE_p_void swig_types[5]
-static swig_type_info *swig_types[7];
-static swig_module_info swig_module = {swig_types, 6, 0, 0, 0, 0};
-#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
-#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
-
-/* -------- TYPES TABLE (END) -------- */
-
-#if (PY_VERSION_HEX <= 0x02000000)
-# if !defined(SWIG_PYTHON_CLASSIC)
-#  error "This python version requires swig to be run with the '-classic' option"
-# endif
-#endif
-
-/*-----------------------------------------------
-              @(target):= vdisplaymodule.so
-  ------------------------------------------------*/
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_init    PyInit_vdisplaymodule
-
-#else
-#  define SWIG_init    initvdisplaymodule
-
-#endif
-#define SWIG_name    "vdisplaymodule"
-
-#define SWIGVERSION 0x020010 
-#define SWIG_VERSION SWIGVERSION
-
-
-#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
-#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
-
-
-#include <stdexcept>
-
-
-namespace swig {
-  class SwigPtr_PyObject {
-  protected:
-    PyObject *_obj;
-
-  public:
-    SwigPtr_PyObject() :_obj(0)
-    {
-    }
-
-    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
-    {
-      Py_XINCREF(_obj);      
-    }
-    
-    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
-    {
-      if (initial_ref) {
-        Py_XINCREF(_obj);
-      }
-    }
-    
-    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
-    {
-      Py_XINCREF(item._obj);
-      Py_XDECREF(_obj);
-      _obj = item._obj;
-      return *this;      
-    }
-    
-    ~SwigPtr_PyObject() 
-    {
-      Py_XDECREF(_obj);
-    }
-    
-    operator PyObject *() const
-    {
-      return _obj;
-    }
-
-    PyObject *operator->() const
-    {
-      return _obj;
-    }
-  };
-}
-
-
-namespace swig {
-  struct SwigVar_PyObject : SwigPtr_PyObject {
-    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
-    
-    SwigVar_PyObject & operator = (PyObject* obj)
-    {
-      Py_XDECREF(_obj);
-      _obj = obj;
-      return *this;      
-    }
-  };
-}
-
-
-#include <vips/vipscpp.h>
-
-
-SWIGINTERNINLINE PyObject*
-  SWIG_From_int  (int value)
-{
-  return PyInt_FromLong((long) value);
-}
-
-
-SWIGINTERN swig_type_info*
-SWIG_pchar_descriptor(void)
-{
-  static int init = 0;
-  static swig_type_info* info = 0;
-  if (!init) {
-    info = SWIG_TypeQuery("_p_char");
-    init = 1;
-  }
-  return info;
-}
-
-
-SWIGINTERN int
-SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
-{
-#if PY_VERSION_HEX>=0x03000000
-  if (PyUnicode_Check(obj))
-#else  
-  if (PyString_Check(obj))
-#endif
-  {
-    char *cstr; Py_ssize_t len;
-#if PY_VERSION_HEX>=0x03000000
-    if (!alloc && cptr) {
-        /* We can't allow converting without allocation, since the internal
-           representation of string in Python 3 is UCS-2/UCS-4 but we require
-           a UTF-8 representation.
-           TODO(bhy) More detailed explanation */
-        return SWIG_RuntimeError;
-    }
-    obj = PyUnicode_AsUTF8String(obj);
-    PyBytes_AsStringAndSize(obj, &cstr, &len);
-    if(alloc) *alloc = SWIG_NEWOBJ;
-#else
-    PyString_AsStringAndSize(obj, &cstr, &len);
-#endif
-    if (cptr) {
-      if (alloc) {
-	/* 
-	   In python the user should not be able to modify the inner
-	   string representation. To warranty that, if you define
-	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
-	   buffer is always returned.
-
-	   The default behavior is just to return the pointer value,
-	   so, be careful.
-	*/ 
-#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
-	if (*alloc != SWIG_OLDOBJ) 
-#else
-	if (*alloc == SWIG_NEWOBJ) 
-#endif
-	  {
-	    *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
-	    *alloc = SWIG_NEWOBJ;
-	  }
-	else {
-	  *cptr = cstr;
-	  *alloc = SWIG_OLDOBJ;
-	}
-      } else {
-        #if PY_VERSION_HEX>=0x03000000
-        assert(0); /* Should never reach here in Python 3 */
-        #endif
-	*cptr = SWIG_Python_str_AsChar(obj);
-      }
-    }
-    if (psize) *psize = len + 1;
-#if PY_VERSION_HEX>=0x03000000
-    Py_XDECREF(obj);
-#endif
-    return SWIG_OK;
-  } else {
-    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
-    if (pchar_descriptor) {
-      void* vptr = 0;
-      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
-	if (cptr) *cptr = (char *) vptr;
-	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
-	if (alloc) *alloc = SWIG_OLDOBJ;
-	return SWIG_OK;
-      }
-    }
-  }
-  return SWIG_TypeError;
-}
-
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-SWIGINTERN PyObject *_wrap_new_VDisplay__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDisplay *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_VDisplay",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VDisplay" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = (vips::VDisplay *)new vips::VDisplay((char const *)arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VDisplay, SWIG_POINTER_NEW |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VDisplay__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDisplay *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)":new_VDisplay")) SWIG_fail;
-  result = (vips::VDisplay *)new vips::VDisplay();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VDisplay, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VDisplay__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDisplay *arg1 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDisplay *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_VDisplay",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_vips__VDisplay,  0  | 0);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VDisplay" "', argument " "1"" of type '" "vips::VDisplay const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VDisplay" "', argument " "1"" of type '" "vips::VDisplay const &""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDisplay * >(argp1);
-  result = (vips::VDisplay *)new vips::VDisplay((vips::VDisplay const &)*arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VDisplay, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VDisplay(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[2];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_new_VDisplay__SWIG_1(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_vips__VDisplay, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VDisplay__SWIG_2(self, args);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VDisplay__SWIG_0(self, args);
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_VDisplay'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VDisplay::VDisplay(char const *)\n"
-    "    vips::VDisplay::VDisplay()\n"
-    "    vips::VDisplay::VDisplay(vips::VDisplay const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDisplay___assign__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDisplay *arg1 = (vips::VDisplay *) 0 ;
-  vips::VDisplay *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VDisplay *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VDisplay___assign__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDisplay, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDisplay___assign__" "', argument " "1"" of type '" "vips::VDisplay *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDisplay * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDisplay,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VDisplay___assign__" "', argument " "2"" of type '" "vips::VDisplay const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VDisplay___assign__" "', argument " "2"" of type '" "vips::VDisplay const &""'"); 
-  }
-  arg2 = reinterpret_cast< vips::VDisplay * >(argp2);
-  result = (vips::VDisplay *) &(arg1)->operator =((vips::VDisplay const &)*arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VDisplay, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_VDisplay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDisplay *arg1 = (vips::VDisplay *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_VDisplay",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDisplay, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VDisplay" "', argument " "1"" of type '" "vips::VDisplay *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDisplay * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDisplay_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDisplay *arg1 = (vips::VDisplay *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  void *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VDisplay_disp",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDisplay, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDisplay_disp" "', argument " "1"" of type '" "vips::VDisplay const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDisplay * >(argp1);
-  result = (void *)((vips::VDisplay const *)arg1)->disp();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDisplay_luts(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDisplay *arg1 = (vips::VDisplay *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  im_col_tab_disp *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VDisplay_luts",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDisplay, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDisplay_luts" "', argument " "1"" of type '" "vips::VDisplay const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDisplay * >(argp1);
-  try {
-    result = (im_col_tab_disp *)((vips::VDisplay const *)arg1)->luts();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_im_col_tab_disp, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *VDisplay_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_vips__VDisplay, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-static PyMethodDef SwigMethods[] = {
-	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { (char *)"new_VDisplay", _wrap_new_VDisplay, METH_VARARGS, NULL},
-	 { (char *)"VDisplay___assign__", _wrap_VDisplay___assign__, METH_VARARGS, NULL},
-	 { (char *)"delete_VDisplay", _wrap_delete_VDisplay, METH_VARARGS, NULL},
-	 { (char *)"VDisplay_disp", _wrap_VDisplay_disp, METH_VARARGS, NULL},
-	 { (char *)"VDisplay_luts", _wrap_VDisplay_luts, METH_VARARGS, NULL},
-	 { (char *)"VDisplay_swigregister", VDisplay_swigregister, METH_VARARGS, NULL},
-	 { NULL, NULL, 0, NULL }
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_im_col_tab_disp = {"_p_im_col_tab_disp", "im_col_tab_disp *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_matrix = {"_p_matrix", "matrix *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VDisplay = {"_p_vips__VDisplay", "vips::VDisplay *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VError = {"_p_vips__VError", "vips::VError *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};
-
-static swig_type_info *swig_type_initial[] = {
-  &_swigt__p_char,
-  &_swigt__p_im_col_tab_disp,
-  &_swigt__p_matrix,
-  &_swigt__p_vips__VDisplay,
-  &_swigt__p_vips__VError,
-  &_swigt__p_void,
-};
-
-static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_im_col_tab_disp[] = {  {&_swigt__p_im_col_tab_disp, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_matrix[] = {  {&_swigt__p_matrix, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VDisplay[] = {  {&_swigt__p_vips__VDisplay, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VError[] = {  {&_swigt__p_vips__VError, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};
-
-static swig_cast_info *swig_cast_initial[] = {
-  _swigc__p_char,
-  _swigc__p_im_col_tab_disp,
-  _swigc__p_matrix,
-  _swigc__p_vips__VDisplay,
-  _swigc__p_vips__VError,
-  _swigc__p_void,
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-static swig_const_info swig_const_table[] = {
-{0, 0, 0, 0.0, 0, 0}};
-
-#ifdef __cplusplus
-}
-#endif
-/* -----------------------------------------------------------------------------
- * Type initialization:
- * This problem is tough by the requirement that no dynamic 
- * memory is used. Also, since swig_type_info structures store pointers to 
- * swig_cast_info structures and swig_cast_info structures store pointers back
- * to swig_type_info structures, we need some lookup code at initialization. 
- * The idea is that swig generates all the structures that are needed. 
- * The runtime then collects these partially filled structures. 
- * The SWIG_InitializeModule function takes these initial arrays out of 
- * swig_module, and does all the lookup, filling in the swig_module.types
- * array with the correct data and linking the correct swig_cast_info
- * structures together.
- *
- * The generated swig_type_info structures are assigned staticly to an initial 
- * array. We just loop through that array, and handle each type individually.
- * First we lookup if this type has been already loaded, and if so, use the
- * loaded structure instead of the generated one. Then we have to fill in the
- * cast linked list. The cast data is initially stored in something like a
- * two-dimensional array. Each row corresponds to a type (there are the same
- * number of rows as there are in the swig_type_initial array). Each entry in
- * a column is one of the swig_cast_info structures for that type.
- * The cast_initial array is actually an array of arrays, because each row has
- * a variable number of columns. So to actually build the cast linked list,
- * we find the array of casts associated with the type, and loop through it 
- * adding the casts to the list. The one last trick we need to do is making
- * sure the type pointer in the swig_cast_info struct is correct.
- *
- * First off, we lookup the cast->type name to see if it is already loaded. 
- * There are three cases to handle:
- *  1) If the cast->type has already been loaded AND the type we are adding
- *     casting info to has not been loaded (it is in this module), THEN we
- *     replace the cast->type pointer with the type pointer that has already
- *     been loaded.
- *  2) If BOTH types (the one we are adding casting info to, and the 
- *     cast->type) are loaded, THEN the cast info has already been loaded by
- *     the previous module so we just ignore it.
- *  3) Finally, if cast->type has not already been loaded, then we add that
- *     swig_cast_info to the linked list (because the cast->type) pointer will
- *     be correct.
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#if 0
-} /* c-mode */
-#endif
-#endif
-
-#if 0
-#define SWIGRUNTIME_DEBUG
-#endif
-
-
-SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
-  size_t i;
-  swig_module_info *module_head, *iter;
-  int found, init;
-  
-  /* check to see if the circular list has been setup, if not, set it up */
-  if (swig_module.next==0) {
-    /* Initialize the swig_module */
-    swig_module.type_initial = swig_type_initial;
-    swig_module.cast_initial = swig_cast_initial;
-    swig_module.next = &swig_module;
-    init = 1;
-  } else {
-    init = 0;
-  }
-  
-  /* Try and load any already created modules */
-  module_head = SWIG_GetModule(clientdata);
-  if (!module_head) {
-    /* This is the first module loaded for this interpreter */
-    /* so set the swig module into the interpreter */
-    SWIG_SetModule(clientdata, &swig_module);
-    module_head = &swig_module;
-  } else {
-    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
-    found=0;
-    iter=module_head;
-    do {
-      if (iter==&swig_module) {
-        found=1;
-        break;
-      }
-      iter=iter->next;
-    } while (iter!= module_head);
-    
-    /* if the is found in the list, then all is done and we may leave */
-    if (found) return;
-    /* otherwise we must add out module into the list */
-    swig_module.next = module_head->next;
-    module_head->next = &swig_module;
-  }
-  
-  /* When multiple interpeters are used, a module could have already been initialized in
-       a different interpreter, but not yet have a pointer in this interpreter.
-       In this case, we do not want to continue adding types... everything should be
-       set up already */
-  if (init == 0) return;
-  
-  /* Now work on filling in swig_module.types */
-#ifdef SWIGRUNTIME_DEBUG
-  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
-#endif
-  for (i = 0; i < swig_module.size; ++i) {
-    swig_type_info *type = 0;
-    swig_type_info *ret;
-    swig_cast_info *cast;
-    
-#ifdef SWIGRUNTIME_DEBUG
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-#endif
-    
-    /* if there is another module already loaded */
-    if (swig_module.next != &swig_module) {
-      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
-    }
-    if (type) {
-      /* Overwrite clientdata field */
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: found type %s\n", type->name);
-#endif
-      if (swig_module.type_initial[i]->clientdata) {
-        type->clientdata = swig_module.type_initial[i]->clientdata;
-#ifdef SWIGRUNTIME_DEBUG
-        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
-#endif
-      }
-    } else {
-      type = swig_module.type_initial[i];
-    }
-    
-    /* Insert casting types */
-    cast = swig_module.cast_initial[i];
-    while (cast->type) {
-      /* Don't need to add information already in the list */
-      ret = 0;
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
-#endif
-      if (swig_module.next != &swig_module) {
-        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
-#ifdef SWIGRUNTIME_DEBUG
-        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
-#endif
-      }
-      if (ret) {
-        if (type == swig_module.type_initial[i]) {
-#ifdef SWIGRUNTIME_DEBUG
-          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
-#endif
-          cast->type = ret;
-          ret = 0;
-        } else {
-          /* Check for casting already in the list */
-          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
-#ifdef SWIGRUNTIME_DEBUG
-          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
-#endif
-          if (!ocast) ret = 0;
-        }
-      }
-      
-      if (!ret) {
-#ifdef SWIGRUNTIME_DEBUG
-        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
-#endif
-        if (type->cast) {
-          type->cast->prev = cast;
-          cast->next = type->cast;
-        }
-        type->cast = cast;
-      }
-      cast++;
-    }
-    /* Set entry in modules->types array equal to the type */
-    swig_module.types[i] = type;
-  }
-  swig_module.types[i] = 0;
-  
-#ifdef SWIGRUNTIME_DEBUG
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-  for (i = 0; i < swig_module.size; ++i) {
-    int j = 0;
-    swig_cast_info *cast = swig_module.cast_initial[i];
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-    while (cast->type) {
-      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
-      cast++;
-      ++j;
-    }
-    printf("---- Total casts: %d\n",j);
-  }
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-#endif
-}
-
-/* This function will propagate the clientdata field of type to
-* any new swig_type_info structures that have been added into the list
-* of equivalent types.  It is like calling
-* SWIG_TypeClientData(type, clientdata) a second time.
-*/
-SWIGRUNTIME void
-SWIG_PropagateClientData(void) {
-  size_t i;
-  swig_cast_info *equiv;
-  static int init_run = 0;
-  
-  if (init_run) return;
-  init_run = 1;
-  
-  for (i = 0; i < swig_module.size; i++) {
-    if (swig_module.types[i]->clientdata) {
-      equiv = swig_module.types[i]->cast;
-      while (equiv) {
-        if (!equiv->converter) {
-          if (equiv->type && !equiv->type->clientdata)
-          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
-        }
-        equiv = equiv->next;
-      }
-    }
-  }
-}
-
-#ifdef __cplusplus
-#if 0
-{
-  /* c-mode */
-#endif
-}
-#endif
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-  
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
-    char *tmp;
-    PyObject *str = swig_varlink_str(v);
-    fprintf(fp,"Swig global variables ");
-    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
-    SWIG_Python_str_DelForPy3(tmp);
-    Py_DECREF(str);
-    return 0;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-        /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        (char *)"swigvarlink",              /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        (printfunc) swig_varlink_print,     /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-        0,                                  /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-        0,                                  /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-        0,0,0,0                             /* tp_alloc -> tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-      varlink_type.ob_type = &PyType_Type;
-#else
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-#endif
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        strncpy(gv->name,name,size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *_SWIG_globals = 0; 
-    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
-    return _SWIG_globals;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * constants/methods manipulation
-   * ----------------------------------------------------------------------------- */
-  
-  /* Install Constants */
-  SWIGINTERN void
-  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
-    PyObject *obj = 0;
-    size_t i;
-    for (i = 0; constants[i].type; ++i) {
-      switch(constants[i].type) {
-      case SWIG_PY_POINTER:
-        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
-        break;
-      case SWIG_PY_BINARY:
-        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
-        break;
-      default:
-        obj = 0;
-        break;
-      }
-      if (obj) {
-        PyDict_SetItemString(d, constants[i].name, obj);
-        Py_DECREF(obj);
-      }
-    }
-  }
-  
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
-  
-  SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
-    size_t i;
-    for (i = 0; methods[i].ml_name; ++i) {
-      const char *c = methods[i].ml_doc;
-      if (c && (c = strstr(c, "swig_ptr: "))) {
-        int j;
-        swig_const_info *ci = 0;
-        const char *name = c + 10;
-        for (j = 0; const_table[j].type; ++j) {
-          if (strncmp(const_table[j].name, name, 
-              strlen(const_table[j].name)) == 0) {
-            ci = &(const_table[j]);
-            break;
-          }
-        }
-        if (ci) {
-          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
-          if (ptr) {
-            size_t shift = (ci->ptype) - types;
-            swig_type_info *ty = types_initial[shift];
-            size_t ldoc = (c - methods[i].ml_doc);
-            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
-            char *ndoc = (char*)malloc(ldoc + lptr + 10);
-            if (ndoc) {
-              char *buff = ndoc;
-              strncpy(buff, methods[i].ml_doc, ldoc);
-              buff += ldoc;
-              strncpy(buff, "swig_ptr: ", 10);
-              buff += 10;
-              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
-              methods[i].ml_doc = ndoc;
-            }
-          }
-        }
-      }
-    }
-  } 
-  
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------*
- *  Partial Init method
- * -----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern "C"
-#endif
-
-SWIGEXPORT 
-#if PY_VERSION_HEX >= 0x03000000
-PyObject*
-#else
-void
-#endif
-SWIG_init(void) {
-  PyObject *m, *d, *md;
-#if PY_VERSION_HEX >= 0x03000000
-  static struct PyModuleDef SWIG_module = {
-# if PY_VERSION_HEX >= 0x03020000
-    PyModuleDef_HEAD_INIT,
-# else
-    {
-      PyObject_HEAD_INIT(NULL)
-      NULL, /* m_init */
-      0,    /* m_index */
-      NULL, /* m_copy */
-    },
-# endif
-    (char *) SWIG_name,
-    NULL,
-    -1,
-    SwigMethods,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-  };
-#endif
-  
-#if defined(SWIGPYTHON_BUILTIN)
-  static SwigPyClientData SwigPyObject_clientdata = {
-    0, 0, 0, 0, 0, 0, 0
-  };
-  static PyGetSetDef this_getset_def = {
-    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
-  };
-  static SwigPyGetSet thisown_getset_closure = {
-    (PyCFunction) SwigPyObject_own,
-    (PyCFunction) SwigPyObject_own
-  };
-  static PyGetSetDef thisown_getset_def = {
-    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
-  };
-  PyObject *metatype_args;
-  PyTypeObject *builtin_pytype;
-  int builtin_base_count;
-  swig_type_info *builtin_basetype;
-  PyObject *tuple;
-  PyGetSetDescrObject *static_getset;
-  PyTypeObject *metatype;
-  SwigPyClientData *cd;
-  PyObject *public_interface, *public_symbol;
-  PyObject *this_descr;
-  PyObject *thisown_descr;
-  int i;
-  
-  (void)builtin_pytype;
-  (void)builtin_base_count;
-  (void)builtin_basetype;
-  (void)tuple;
-  (void)static_getset;
-  
-  /* metatype is used to implement static member variables. */
-  metatype_args = Py_BuildValue("(s(O){})", "SwigPyObjectType", &PyType_Type);
-  assert(metatype_args);
-  metatype = (PyTypeObject *) PyType_Type.tp_call((PyObject *) &PyType_Type, metatype_args, NULL);
-  assert(metatype);
-  Py_DECREF(metatype_args);
-  metatype->tp_setattro = (setattrofunc) &SwigPyObjectType_setattro;
-  assert(PyType_Ready(metatype) >= 0);
-#endif
-  
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
-  
-#if PY_VERSION_HEX >= 0x03000000
-  m = PyModule_Create(&SWIG_module);
-#else
-  m = Py_InitModule((char *) SWIG_name, SwigMethods);
-#endif
-  md = d = PyModule_GetDict(m);
-  (void)md;
-  
-  SWIG_InitializeModule(0);
-  
-#ifdef SWIGPYTHON_BUILTIN
-  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
-  assert(SwigPyObject_stype);
-  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
-  if (!cd) {
-    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
-    SwigPyObject_clientdata.pytype = SwigPyObject_TypeOnce();
-  } else if (SwigPyObject_TypeOnce()->tp_basicsize != cd->pytype->tp_basicsize) {
-    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
-# if PY_VERSION_HEX >= 0x03000000
-    return NULL;
-# else
-    return;
-# endif
-  }
-  
-  /* All objects have a 'this' attribute */
-  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
-  (void)this_descr;
-  
-  /* All objects have a 'thisown' attribute */
-  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
-  (void)thisown_descr;
-  
-  public_interface = PyList_New(0);
-  public_symbol = 0;
-  (void)public_symbol;
-  
-  PyDict_SetItemString(md, "__all__", public_interface);
-  Py_DECREF(public_interface);
-  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
-  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
-  for (i = 0; swig_const_table[i].name != 0; ++i)
-  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
-#endif
-  
-  SWIG_InstallConstants(d,swig_const_table);
-  
-  SWIG_Python_SetConstant(d, "VDisplay_BARCO",SWIG_From_int(static_cast< int >(vips::VDisplay::BARCO)));
-  SWIG_Python_SetConstant(d, "VDisplay_DUMB",SWIG_From_int(static_cast< int >(vips::VDisplay::DUMB)));
-#if PY_VERSION_HEX >= 0x03000000
-  return m;
-#else
-  return;
-#endif
-}
-
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/VDisplay.py vips-7.38.5/swig/vipsCC/VDisplay.py
--- vips-7.38.5-vanilla/swig/vipsCC/VDisplay.py	2014-07-17 23:48:36.211794473 -0400
+++ vips-7.38.5/swig/vipsCC/VDisplay.py	1969-12-31 19:00:00.000000000 -0500
@@ -1,93 +0,0 @@
-# This file was automatically generated by SWIG (http://www.swig.org).
-# Version 2.0.10
-#
-# Do not make changes to this file unless you know what you are doing--modify
-# the SWIG interface file instead.
-
-
-
-from sys import version_info
-if version_info >= (2,6,0):
-    def swig_import_helper():
-        from os.path import dirname
-        import imp
-        fp = None
-        try:
-            fp, pathname, description = imp.find_module('vdisplaymodule', [dirname(__file__)])
-        except ImportError:
-            import vdisplaymodule
-            return vdisplaymodule
-        if fp is not None:
-            try:
-                _mod = imp.load_module('vdisplaymodule', fp, pathname, description)
-            finally:
-                fp.close()
-            return _mod
-    vdisplaymodule = swig_import_helper()
-    del swig_import_helper
-else:
-    import vdisplaymodule
-del version_info
-try:
-    _swig_property = property
-except NameError:
-    pass # Python < 2.2 doesn't have 'property'.
-def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
-    if (name == "thisown"): return self.this.own(value)
-    if (name == "this"):
-        if type(value).__name__ == 'SwigPyObject':
-            self.__dict__[name] = value
-            return
-    method = class_type.__swig_setmethods__.get(name,None)
-    if method: return method(self,value)
-    if (not static):
-        self.__dict__[name] = value
-    else:
-        raise AttributeError("You cannot add attributes to %s" % self)
-
-def _swig_setattr(self,class_type,name,value):
-    return _swig_setattr_nondynamic(self,class_type,name,value,0)
-
-def _swig_getattr(self,class_type,name):
-    if (name == "thisown"): return self.this.own()
-    method = class_type.__swig_getmethods__.get(name,None)
-    if method: return method(self)
-    raise AttributeError(name)
-
-def _swig_repr(self):
-    try: strthis = "proxy of " + self.this.__repr__()
-    except: strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-try:
-    _object = object
-    _newclass = 1
-except AttributeError:
-    class _object : pass
-    _newclass = 0
-
-
-import VError
-class VDisplay(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, VDisplay, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, VDisplay, name)
-    __repr__ = _swig_repr
-    BARCO = vdisplaymodule.VDisplay_BARCO
-    DUMB = vdisplaymodule.VDisplay_DUMB
-    def __init__(self, *args): 
-        this = vdisplaymodule.new_VDisplay(*args)
-        try: self.this.append(this)
-        except: self.this = this
-    def __assign__(self, *args): return vdisplaymodule.VDisplay___assign__(self, *args)
-    __swig_destroy__ = vdisplaymodule.delete_VDisplay
-    __del__ = lambda self : None;
-    def disp(self): return vdisplaymodule.VDisplay_disp(self)
-    def luts(self): return vdisplaymodule.VDisplay_luts(self)
-VDisplay_swigregister = vdisplaymodule.VDisplay_swigregister
-VDisplay_swigregister(VDisplay)
-
-# This file is compatible with both classic and new-style classes.
-
-
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/VError.i vips-7.38.5/swig/vipsCC/VError.i
--- vips-7.38.5-vanilla/swig/vipsCC/VError.i	2014-07-17 23:48:36.209794473 -0400
+++ vips-7.38.5/swig/vipsCC/VError.i	1969-12-31 19:00:00.000000000 -0500
@@ -1,19 +0,0 @@
-/* SWIG interface file for VError.
- */
-
-%module VError
-%{
-#include <vips/vipscpp.h>
-%}
-
-%include "std_except.i"
-%include "std_string.i"
-
-%include vips/VError.h
-
-%extend vips::VError {
-        const char *__str__ () {
-                return $self->what ();
-        }
-}
-
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/verrormodule.cxx vips-7.38.5/swig/vipsCC/verrormodule.cxx
--- vips-7.38.5-vanilla/swig/vipsCC/verrormodule.cxx	2014-07-17 23:48:36.211794473 -0400
+++ vips-7.38.5/swig/vipsCC/verrormodule.cxx	1969-12-31 19:00:00.000000000 -0500
@@ -1,4593 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 2.0.10
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-#define SWIGPYTHON
-#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
-
-
-#ifdef __cplusplus
-/* SwigValueWrapper is described in swig.swg */
-template<typename T> class SwigValueWrapper {
-  struct SwigMovePointer {
-    T *ptr;
-    SwigMovePointer(T *p) : ptr(p) { }
-    ~SwigMovePointer() { delete ptr; }
-    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
-  } pointer;
-  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
-  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
-public:
-  SwigValueWrapper() : pointer(0) { }
-  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
-  operator T&() const { return *pointer.ptr; }
-  T *operator&() { return pointer.ptr; }
-};
-
-template <typename T> T SwigValueInit() {
-  return T();
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- *  This section contains generic SWIG labels for method/variable
- *  declarations/attributes, and other compiler dependent labels.
- * ----------------------------------------------------------------------------- */
-
-/* template workaround for compilers that cannot correctly implement the C++ standard */
-#ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# elif defined(__HP_aCC)
-/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
-/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# else
-#  define SWIGTEMPLATEDISAMBIGUATOR
-# endif
-#endif
-
-/* inline attribute */
-#ifndef SWIGINLINE
-# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
-#   define SWIGINLINE inline
-# else
-#   define SWIGINLINE
-# endif
-#endif
-
-/* attribute recognised by some compilers to avoid 'unused' warnings */
-#ifndef SWIGUNUSED
-# if defined(__GNUC__)
-#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
-#     define SWIGUNUSED __attribute__ ((__unused__)) 
-#   else
-#     define SWIGUNUSED
-#   endif
-# elif defined(__ICC)
-#   define SWIGUNUSED __attribute__ ((__unused__)) 
-# else
-#   define SWIGUNUSED 
-# endif
-#endif
-
-#ifndef SWIG_MSC_UNSUPPRESS_4505
-# if defined(_MSC_VER)
-#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
-# endif 
-#endif
-
-#ifndef SWIGUNUSEDPARM
-# ifdef __cplusplus
-#   define SWIGUNUSEDPARM(p)
-# else
-#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
-# endif
-#endif
-
-/* internal SWIG method */
-#ifndef SWIGINTERN
-# define SWIGINTERN static SWIGUNUSED
-#endif
-
-/* internal inline SWIG method */
-#ifndef SWIGINTERNINLINE
-# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/* exporting methods */
-#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
-#  ifndef GCC_HASCLASSVISIBILITY
-#    define GCC_HASCLASSVISIBILITY
-#  endif
-#endif
-
-#ifndef SWIGEXPORT
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   if defined(STATIC_LINKED)
-#     define SWIGEXPORT
-#   else
-#     define SWIGEXPORT __declspec(dllexport)
-#   endif
-# else
-#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
-#     define SWIGEXPORT __attribute__ ((visibility("default")))
-#   else
-#     define SWIGEXPORT
-#   endif
-# endif
-#endif
-
-/* calling conventions for Windows */
-#ifndef SWIGSTDCALL
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   define SWIGSTDCALL __stdcall
-# else
-#   define SWIGSTDCALL
-# endif 
-#endif
-
-/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
-#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
-# define _CRT_SECURE_NO_DEPRECATE
-#endif
-
-/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
-#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
-# define _SCL_SECURE_NO_DEPRECATE
-#endif
-
-
-
-/* Python.h has to appear first */
-#include <Python.h>
-
-/* -----------------------------------------------------------------------------
- * swigrun.swg
- *
- * This file contains generic C API SWIG runtime support for pointer
- * type checking.
- * ----------------------------------------------------------------------------- */
-
-/* This should only be incremented when either the layout of swig_type_info changes,
-   or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION "4"
-
-/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
-#ifdef SWIG_TYPE_TABLE
-# define SWIG_QUOTE_STRING(x) #x
-# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
-# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
-#else
-# define SWIG_TYPE_TABLE_NAME
-#endif
-
-/*
-  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
-  creating a static or dynamic library from the SWIG runtime code.
-  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
-  
-  But only do this if strictly necessary, ie, if you have problems
-  with your compiler or suchlike.
-*/
-
-#ifndef SWIGRUNTIME
-# define SWIGRUNTIME SWIGINTERN
-#endif
-
-#ifndef SWIGRUNTIMEINLINE
-# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
-#endif
-
-/*  Generic buffer size */
-#ifndef SWIG_BUFFER_SIZE
-# define SWIG_BUFFER_SIZE 1024
-#endif
-
-/* Flags for pointer conversions */
-#define SWIG_POINTER_DISOWN        0x1
-#define SWIG_CAST_NEW_MEMORY       0x2
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_OWN           0x1
-
-
-/* 
-   Flags/methods for returning states.
-   
-   The SWIG conversion methods, as ConvertPtr, return an integer 
-   that tells if the conversion was successful or not. And if not,
-   an error code can be returned (see swigerrors.swg for the codes).
-   
-   Use the following macros/flags to set or process the returning
-   states.
-   
-   In old versions of SWIG, code such as the following was usually written:
-
-     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
-       // success code
-     } else {
-       //fail code
-     }
-
-   Now you can be more explicit:
-
-    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-    } else {
-      // fail code
-    }
-
-   which is the same really, but now you can also do
-
-    Type *ptr;
-    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-      if (SWIG_IsNewObj(res) {
-        ...
-	delete *ptr;
-      } else {
-        ...
-      }
-    } else {
-      // fail code
-    }
-    
-   I.e., now SWIG_ConvertPtr can return new objects and you can
-   identify the case and take care of the deallocation. Of course that
-   also requires SWIG_ConvertPtr to return new result values, such as
-
-      int SWIG_ConvertPtr(obj, ptr,...) {         
-        if (<obj is ok>) {			       
-          if (<need new object>) {		       
-            *ptr = <ptr to new allocated object>; 
-            return SWIG_NEWOBJ;		       
-          } else {				       
-            *ptr = <ptr to old object>;	       
-            return SWIG_OLDOBJ;		       
-          } 				       
-        } else {				       
-          return SWIG_BADOBJ;		       
-        }					       
-      }
-
-   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
-   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
-   SWIG errors code.
-
-   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
-
-       int food(double)
-       int fooi(int);
-
-   and you call
- 
-      food(1)   // cast rank '1'  (1 -> 1.0)
-      fooi(1)   // cast rank '0'
-
-   just use the SWIG_AddCast()/SWIG_CheckState()
-*/
-
-#define SWIG_OK                    (0) 
-#define SWIG_ERROR                 (-1)
-#define SWIG_IsOK(r)               (r >= 0)
-#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
-
-/* The CastRankLimit says how many bits are used for the cast rank */
-#define SWIG_CASTRANKLIMIT         (1 << 8)
-/* The NewMask denotes the object was created (using new/malloc) */
-#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
-/* The TmpMask is for in/out typemaps that use temporal objects */
-#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
-/* Simple returning values */
-#define SWIG_BADOBJ                (SWIG_ERROR)
-#define SWIG_OLDOBJ                (SWIG_OK)
-#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
-#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
-#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
-#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
-#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
-#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
-#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
-#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
-
-/* Cast-Rank Mode */
-#if defined(SWIG_CASTRANK_MODE)
-#  ifndef SWIG_TypeRank
-#    define SWIG_TypeRank             unsigned long
-#  endif
-#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
-#    define SWIG_MAXCASTRANK          (2)
-#  endif
-#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
-#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
-SWIGINTERNINLINE int SWIG_AddCast(int r) { 
-  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
-}
-SWIGINTERNINLINE int SWIG_CheckState(int r) { 
-  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
-}
-#else /* no cast-rank mode */
-#  define SWIG_AddCast(r) (r)
-#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
-#endif
-
-
-#include <string.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef void *(*swig_converter_func)(void *, int *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-/* Structure to store information on one type */
-typedef struct swig_type_info {
-  const char             *name;			/* mangled name of this type */
-  const char             *str;			/* human readable name of this type */
-  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
-  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
-  void                   *clientdata;		/* language specific type data */
-  int                    owndata;		/* flag if the structure owns the clientdata */
-} swig_type_info;
-
-/* Structure to store a type and conversion function used for casting */
-typedef struct swig_cast_info {
-  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
-  swig_converter_func     converter;		/* function to cast the void pointers */
-  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
-  struct swig_cast_info  *prev;			/* pointer to the previous cast */
-} swig_cast_info;
-
-/* Structure used to store module information
- * Each module generates one structure like this, and the runtime collects
- * all of these structures and stores them in a circularly linked list.*/
-typedef struct swig_module_info {
-  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
-  size_t                 size;		        /* Number of types in this module */
-  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
-  swig_type_info         **type_initial;	/* Array of initially generated type structures */
-  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
-  void                    *clientdata;		/* Language specific module data */
-} swig_module_info;
-
-/* 
-  Compare two type names skipping the space characters, therefore
-  "char*" == "char *" and "Class<int>" == "Class<int >", etc.
-
-  Return 0 when the two name types are equivalent, as in
-  strncmp, but skipping ' '.
-*/
-SWIGRUNTIME int
-SWIG_TypeNameComp(const char *f1, const char *l1,
-		  const char *f2, const char *l2) {
-  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
-    while ((*f1 == ' ') && (f1 != l1)) ++f1;
-    while ((*f2 == ' ') && (f2 != l2)) ++f2;
-    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
-  }
-  return (int)((l1 - f1) - (l2 - f2));
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
-*/
-SWIGRUNTIME int
-SWIG_TypeCmp(const char *nb, const char *tb) {
-  int equiv = 1;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (equiv != 0 && *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if not equal, 1 if equal
-*/
-SWIGRUNTIME int
-SWIG_TypeEquiv(const char *nb, const char *tb) {
-  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
-}
-
-/*
-  Check the typename
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheck(const char *c, swig_type_info *ty) {
-  if (ty) {
-    swig_cast_info *iter = ty->cast;
-    while (iter) {
-      if (strcmp(iter->type->name, c) == 0) {
-        if (iter == ty->cast)
-          return iter;
-        /* Move iter to the top of the linked list */
-        iter->prev->next = iter->next;
-        if (iter->next)
-          iter->next->prev = iter->prev;
-        iter->next = ty->cast;
-        iter->prev = 0;
-        if (ty->cast) ty->cast->prev = iter;
-        ty->cast = iter;
-        return iter;
-      }
-      iter = iter->next;
-    }
-  }
-  return 0;
-}
-
-/* 
-  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
-  if (ty) {
-    swig_cast_info *iter = ty->cast;
-    while (iter) {
-      if (iter->type == from) {
-        if (iter == ty->cast)
-          return iter;
-        /* Move iter to the top of the linked list */
-        iter->prev->next = iter->next;
-        if (iter->next)
-          iter->next->prev = iter->prev;
-        iter->next = ty->cast;
-        iter->prev = 0;
-        if (ty->cast) ty->cast->prev = iter;
-        ty->cast = iter;
-        return iter;
-      }
-      iter = iter->next;
-    }
-  }
-  return 0;
-}
-
-/*
-  Cast a pointer up an inheritance hierarchy
-*/
-SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
-  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
-}
-
-/* 
-   Dynamic pointer casting. Down an inheritance hierarchy
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty->dcast) return ty;
-  while (ty && (ty->dcast)) {
-    ty = (*ty->dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/*
-  Return the name associated with this type
-*/
-SWIGRUNTIMEINLINE const char *
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty->name;
-}
-
-/*
-  Return the pretty name associated with this type,
-  that is an unmangled type name in a form presentable to the user.
-*/
-SWIGRUNTIME const char *
-SWIG_TypePrettyName(const swig_type_info *type) {
-  /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
-  if (!type) return NULL;
-  if (type->str != NULL) {
-    const char *last_name = type->str;
-    const char *s;
-    for (s = type->str; *s; s++)
-      if (*s == '|') last_name = s+1;
-    return last_name;
-  }
-  else
-    return type->name;
-}
-
-/* 
-   Set the clientdata field for a type
-*/
-SWIGRUNTIME void
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  swig_cast_info *cast = ti->cast;
-  /* if (ti->clientdata == clientdata) return; */
-  ti->clientdata = clientdata;
-  
-  while (cast) {
-    if (!cast->converter) {
-      swig_type_info *tc = cast->type;
-      if (!tc->clientdata) {
-	SWIG_TypeClientData(tc, clientdata);
-      }
-    }    
-    cast = cast->next;
-  }
-}
-SWIGRUNTIME void
-SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
-  SWIG_TypeClientData(ti, clientdata);
-  ti->owndata = 1;
-}
-  
-/*
-  Search for a swig_type_info structure only by mangled name
-  Search is a O(log #types)
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_MangledTypeQueryModule(swig_module_info *start, 
-                            swig_module_info *end, 
-		            const char *name) {
-  swig_module_info *iter = start;
-  do {
-    if (iter->size) {
-      register size_t l = 0;
-      register size_t r = iter->size - 1;
-      do {
-	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
-	register size_t i = (l + r) >> 1; 
-	const char *iname = iter->types[i]->name;
-	if (iname) {
-	  register int compare = strcmp(name, iname);
-	  if (compare == 0) {	    
-	    return iter->types[i];
-	  } else if (compare < 0) {
-	    if (i) {
-	      r = i - 1;
-	    } else {
-	      break;
-	    }
-	  } else if (compare > 0) {
-	    l = i + 1;
-	  }
-	} else {
-	  break; /* should never happen */
-	}
-      } while (l <= r);
-    }
-    iter = iter->next;
-  } while (iter != end);
-  return 0;
-}
-
-/*
-  Search for a swig_type_info structure for either a mangled name or a human readable name.
-  It first searches the mangled names of the types, which is a O(log #types)
-  If a type is not found it then searches the human readable names, which is O(#types).
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeQueryModule(swig_module_info *start, 
-                     swig_module_info *end, 
-		     const char *name) {
-  /* STEP 1: Search the name field using binary search */
-  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
-  if (ret) {
-    return ret;
-  } else {
-    /* STEP 2: If the type hasn't been found, do a complete search
-       of the str field (the human readable name) */
-    swig_module_info *iter = start;
-    do {
-      register size_t i = 0;
-      for (; i < iter->size; ++i) {
-	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
-	  return iter->types[i];
-      }
-      iter = iter->next;
-    } while (iter != end);
-  }
-  
-  /* neither found a match */
-  return 0;
-}
-
-/* 
-   Pack binary data into a string
-*/
-SWIGRUNTIME char *
-SWIG_PackData(char *c, void *ptr, size_t sz) {
-  static const char hex[17] = "0123456789abcdef";
-  register const unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu =  u + sz;
-  for (; u != eu; ++u) {
-    register unsigned char uu = *u;
-    *(c++) = hex[(uu & 0xf0) >> 4];
-    *(c++) = hex[uu & 0xf];
-  }
-  return c;
-}
-
-/* 
-   Unpack binary data from a string
-*/
-SWIGRUNTIME const char *
-SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
-  register unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu = u + sz;
-  for (; u != eu; ++u) {
-    register char d = *(c++);
-    register unsigned char uu;
-    if ((d >= '0') && (d <= '9'))
-      uu = ((d - '0') << 4);
-    else if ((d >= 'a') && (d <= 'f'))
-      uu = ((d - ('a'-10)) << 4);
-    else 
-      return (char *) 0;
-    d = *(c++);
-    if ((d >= '0') && (d <= '9'))
-      uu |= (d - '0');
-    else if ((d >= 'a') && (d <= 'f'))
-      uu |= (d - ('a'-10));
-    else 
-      return (char *) 0;
-    *u = uu;
-  }
-  return c;
-}
-
-/* 
-   Pack 'void *' into a string buffer.
-*/
-SWIGRUNTIME char *
-SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
-  char *r = buff;
-  if ((2*sizeof(void *) + 2) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,&ptr,sizeof(void *));
-  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
-  strcpy(r,name);
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      *ptr = (void *) 0;
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sizeof(void *));
-}
-
-SWIGRUNTIME char *
-SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
-  char *r = buff;
-  size_t lname = (name ? strlen(name) : 0);
-  if ((2*sz + 2 + lname) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  if (lname) {
-    strncpy(r,name,lname+1);
-  } else {
-    *r = 0;
-  }
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      memset(ptr,0,sz);
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sz);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-/*  Errors in SWIG */
-#define  SWIG_UnknownError    	   -1 
-#define  SWIG_IOError        	   -2 
-#define  SWIG_RuntimeError   	   -3 
-#define  SWIG_IndexError     	   -4 
-#define  SWIG_TypeError      	   -5 
-#define  SWIG_DivisionByZero 	   -6 
-#define  SWIG_OverflowError  	   -7 
-#define  SWIG_SyntaxError    	   -8 
-#define  SWIG_ValueError     	   -9 
-#define  SWIG_SystemError    	   -10
-#define  SWIG_AttributeError 	   -11
-#define  SWIG_MemoryError    	   -12 
-#define  SWIG_NullReferenceError   -13
-
-
-
-/* Compatibility macros for Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-
-#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
-#define PyInt_Check(x) PyLong_Check(x)
-#define PyInt_AsLong(x) PyLong_AsLong(x)
-#define PyInt_FromLong(x) PyLong_FromLong(x)
-#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
-#define PyString_Check(name) PyBytes_Check(name)
-#define PyString_FromString(x) PyUnicode_FromString(x)
-#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
-#define PyString_AsString(str) PyBytes_AsString(str)
-#define PyString_Size(str) PyBytes_Size(str)	
-#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
-#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
-#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
-
-#endif
-
-#ifndef Py_TYPE
-#  define Py_TYPE(op) ((op)->ob_type)
-#endif
-
-/* SWIG APIs for compatibility of both Python 2 & 3 */
-
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
-#else
-#  define SWIG_Python_str_FromFormat PyString_FromFormat
-#endif
-
-
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
-SWIGINTERN char*
-SWIG_Python_str_AsChar(PyObject *str)
-{
-#if PY_VERSION_HEX >= 0x03000000
-  char *cstr;
-  char *newstr;
-  Py_ssize_t len;
-  str = PyUnicode_AsUTF8String(str);
-  PyBytes_AsStringAndSize(str, &cstr, &len);
-  newstr = (char *) malloc(len+1);
-  memcpy(newstr, cstr, len+1);
-  Py_XDECREF(str);
-  return newstr;
-#else
-  return PyString_AsString(str);
-#endif
-}
-
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#else
-#  define SWIG_Python_str_DelForPy3(x) 
-#endif
-
-
-SWIGINTERN PyObject*
-SWIG_Python_str_FromChar(const char *c)
-{
-#if PY_VERSION_HEX >= 0x03000000
-  return PyUnicode_FromString(c); 
-#else
-  return PyString_FromString(c);
-#endif
-}
-
-/* Add PyOS_snprintf for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
-#  define PyOS_snprintf _snprintf
-# else
-#  define PyOS_snprintf snprintf
-# endif
-#endif
-
-/* A crude PyString_FromFormat implementation for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-
-#ifndef SWIG_PYBUFFER_SIZE
-# define SWIG_PYBUFFER_SIZE 1024
-#endif
-
-static PyObject *
-PyString_FromFormat(const char *fmt, ...) {
-  va_list ap;
-  char buf[SWIG_PYBUFFER_SIZE * 2];
-  int res;
-  va_start(ap, fmt);
-  res = vsnprintf(buf, sizeof(buf), fmt, ap);
-  va_end(ap);
-  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
-}
-#endif
-
-/* Add PyObject_Del for old Pythons */
-#if PY_VERSION_HEX < 0x01060000
-# define PyObject_Del(op) PyMem_DEL((op))
-#endif
-#ifndef PyObject_DEL
-# define PyObject_DEL PyObject_Del
-#endif
-
-/* A crude PyExc_StopIteration exception for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-# ifndef PyExc_StopIteration
-#  define PyExc_StopIteration PyExc_RuntimeError
-# endif
-# ifndef PyObject_GenericGetAttr
-#  define PyObject_GenericGetAttr 0
-# endif
-#endif
-
-/* Py_NotImplemented is defined in 2.1 and up. */
-#if PY_VERSION_HEX < 0x02010000
-# ifndef Py_NotImplemented
-#  define Py_NotImplemented PyExc_RuntimeError
-# endif
-#endif
-
-/* A crude PyString_AsStringAndSize implementation for old Pythons */
-#if PY_VERSION_HEX < 0x02010000
-# ifndef PyString_AsStringAndSize
-#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
-# endif
-#endif
-
-/* PySequence_Size for old Pythons */
-#if PY_VERSION_HEX < 0x02000000
-# ifndef PySequence_Size
-#  define PySequence_Size PySequence_Length
-# endif
-#endif
-
-/* PyBool_FromLong for old Pythons */
-#if PY_VERSION_HEX < 0x02030000
-static
-PyObject *PyBool_FromLong(long ok)
-{
-  PyObject *result = ok ? Py_True : Py_False;
-  Py_INCREF(result);
-  return result;
-}
-#endif
-
-/* Py_ssize_t for old Pythons */
-/* This code is as recommended by: */
-/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
-#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
-typedef int Py_ssize_t;
-# define PY_SSIZE_T_MAX INT_MAX
-# define PY_SSIZE_T_MIN INT_MIN
-typedef inquiry lenfunc;
-typedef intargfunc ssizeargfunc;
-typedef intintargfunc ssizessizeargfunc;
-typedef intobjargproc ssizeobjargproc;
-typedef intintobjargproc ssizessizeobjargproc;
-typedef getreadbufferproc readbufferproc;
-typedef getwritebufferproc writebufferproc;
-typedef getsegcountproc segcountproc;
-typedef getcharbufferproc charbufferproc;
-static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
-{
-  long result = 0;
-  PyObject *i = PyNumber_Int(x);
-  if (i) {
-    result = PyInt_AsLong(i);
-    Py_DECREF(i);
-  }
-  return result;
-}
-#endif
-
-#if PY_VERSION_HEX < 0x02050000
-#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
-#endif
-
-#if PY_VERSION_HEX < 0x02040000
-#define Py_VISIT(op)				\
-  do { 						\
-    if (op) {					\
-      int vret = visit((op), arg);		\
-      if (vret)					\
-        return vret;				\
-    }						\
-  } while (0)
-#endif
-
-#if PY_VERSION_HEX < 0x02030000
-typedef struct {
-  PyTypeObject type;
-  PyNumberMethods as_number;
-  PyMappingMethods as_mapping;
-  PySequenceMethods as_sequence;
-  PyBufferProcs as_buffer;
-  PyObject *name, *slots;
-} PyHeapTypeObject;
-#endif
-
-#if PY_VERSION_HEX < 0x02030000
-typedef destructor freefunc;
-#endif
-
-#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
-     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
-     (PY_MAJOR_VERSION > 3))
-# define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
-#endif
-
-#if PY_VERSION_HEX < 0x03020000
-#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
-#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
-#endif
-
-/* -----------------------------------------------------------------------------
- * error manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIME PyObject*
-SWIG_Python_ErrorType(int code) {
-  PyObject* type = 0;
-  switch(code) {
-  case SWIG_MemoryError:
-    type = PyExc_MemoryError;
-    break;
-  case SWIG_IOError:
-    type = PyExc_IOError;
-    break;
-  case SWIG_RuntimeError:
-    type = PyExc_RuntimeError;
-    break;
-  case SWIG_IndexError:
-    type = PyExc_IndexError;
-    break;
-  case SWIG_TypeError:
-    type = PyExc_TypeError;
-    break;
-  case SWIG_DivisionByZero:
-    type = PyExc_ZeroDivisionError;
-    break;
-  case SWIG_OverflowError:
-    type = PyExc_OverflowError;
-    break;
-  case SWIG_SyntaxError:
-    type = PyExc_SyntaxError;
-    break;
-  case SWIG_ValueError:
-    type = PyExc_ValueError;
-    break;
-  case SWIG_SystemError:
-    type = PyExc_SystemError;
-    break;
-  case SWIG_AttributeError:
-    type = PyExc_AttributeError;
-    break;
-  default:
-    type = PyExc_RuntimeError;
-  }
-  return type;
-}
-
-
-SWIGRUNTIME void
-SWIG_Python_AddErrorMsg(const char* mesg)
-{
-  PyObject *type = 0;
-  PyObject *value = 0;
-  PyObject *traceback = 0;
-
-  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
-  if (value) {
-    char *tmp;
-    PyObject *old_str = PyObject_Str(value);
-    PyErr_Clear();
-    Py_XINCREF(type);
-
-    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
-    SWIG_Python_str_DelForPy3(tmp);
-    Py_DECREF(old_str);
-    Py_DECREF(value);
-  } else {
-    PyErr_SetString(PyExc_RuntimeError, mesg);
-  }
-}
-
-#if defined(SWIG_PYTHON_NO_THREADS)
-#  if defined(SWIG_PYTHON_THREADS)
-#    undef SWIG_PYTHON_THREADS
-#  endif
-#endif
-#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
-#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
-#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
-#      define SWIG_PYTHON_USE_GIL
-#    endif
-#  endif
-#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
-#    endif
-#    ifdef __cplusplus /* C++ code */
-       class SWIG_Python_Thread_Block {
-         bool status;
-         PyGILState_STATE state;
-       public:
-         void end() { if (status) { PyGILState_Release(state); status = false;} }
-         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
-         ~SWIG_Python_Thread_Block() { end(); }
-       };
-       class SWIG_Python_Thread_Allow {
-         bool status;
-         PyThreadState *save;
-       public:
-         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
-         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
-         ~SWIG_Python_Thread_Allow() { end(); }
-       };
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
-#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
-#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
-#    else /* C code */
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
-#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
-#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
-#    endif
-#  else /* Old thread way, not implemented, user must provide it */
-#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
-#      define SWIG_PYTHON_INITIALIZE_THREADS
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
-#      define SWIG_PYTHON_THREAD_END_BLOCK
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
-#      define SWIG_PYTHON_THREAD_END_ALLOW
-#    endif
-#  endif
-#else /* No thread support */
-#  define SWIG_PYTHON_INITIALIZE_THREADS
-#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
-#  define SWIG_PYTHON_THREAD_END_BLOCK
-#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
-#  define SWIG_PYTHON_THREAD_END_ALLOW
-#endif
-
-/* -----------------------------------------------------------------------------
- * Python API portion that goes into the runtime
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* -----------------------------------------------------------------------------
- * Constant declarations
- * ----------------------------------------------------------------------------- */
-
-/* Constant Types */
-#define SWIG_PY_POINTER 4
-#define SWIG_PY_BINARY  5
-
-/* Constant information structure */
-typedef struct swig_const_info {
-  int type;
-  char *name;
-  long lvalue;
-  double dvalue;
-  void   *pvalue;
-  swig_type_info **ptype;
-} swig_const_info;
-
-
-/* -----------------------------------------------------------------------------
- * Wrapper of PyInstanceMethod_New() used in Python 3
- * It is exported to the generated module, used for -fastproxy
- * ----------------------------------------------------------------------------- */
-#if PY_VERSION_HEX >= 0x03000000
-SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
-{
-  return PyInstanceMethod_New(func);
-}
-#else
-SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
-{
-  return NULL;
-}
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/* -----------------------------------------------------------------------------
- * pyrun.swg
- *
- * This file contains the runtime support for Python modules
- * and includes code for managing global variables and pointer
- * type checking.
- *
- * ----------------------------------------------------------------------------- */
-
-/* Common SWIG API */
-
-/* for raw pointers */
-#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
-#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
-#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
-
-#ifdef SWIGPYTHON_BUILTIN
-#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
-#else
-#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
-#endif
-
-#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
-
-#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
-#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
-#define swig_owntype                                    int
-
-/* for raw packed data */
-#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
-#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
-
-/* for class or struct pointers */
-#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
-#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
-
-/* for C or C++ function pointers */
-#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
-#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)
-
-/* for C++ member pointers, ie, member methods */
-#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
-#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
-
-
-/* Runtime API */
-
-#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
-#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
-#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)
-
-#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
-#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
-#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
-#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
-#define SWIG_fail                        		goto fail					   
-
-
-/* Runtime API implementation */
-
-/* Error manipulation */
-
-SWIGINTERN void 
-SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
-  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
-  PyErr_SetObject(errtype, obj);
-  Py_DECREF(obj);
-  SWIG_PYTHON_THREAD_END_BLOCK;
-}
-
-SWIGINTERN void 
-SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
-  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
-  PyErr_SetString(errtype, msg);
-  SWIG_PYTHON_THREAD_END_BLOCK;
-}
-
-#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)
-
-/* Set a constant value */
-
-#if defined(SWIGPYTHON_BUILTIN)
-
-SWIGINTERN void
-SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
-  PyObject *s = PyString_InternFromString(key);
-  PyList_Append(seq, s);
-  Py_DECREF(s);
-}
-
-SWIGINTERN void
-SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
-#if PY_VERSION_HEX < 0x02030000
-  PyDict_SetItemString(d, (char *)name, obj);
-#else
-  PyDict_SetItemString(d, name, obj);
-#endif
-  Py_DECREF(obj);
-  if (public_interface)
-    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
-}
-
-#else
-
-SWIGINTERN void
-SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
-#if PY_VERSION_HEX < 0x02030000
-  PyDict_SetItemString(d, (char *)name, obj);
-#else
-  PyDict_SetItemString(d, name, obj);
-#endif
-  Py_DECREF(obj);                            
-}
-
-#endif
-
-/* Append a value to the result obj */
-
-SWIGINTERN PyObject*
-SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
-#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
-  if (!result) {
-    result = obj;
-  } else if (result == Py_None) {
-    Py_DECREF(result);
-    result = obj;
-  } else {
-    if (!PyList_Check(result)) {
-      PyObject *o2 = result;
-      result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
-    }
-    PyList_Append(result,obj);
-    Py_DECREF(obj);
-  }
-  return result;
-#else
-  PyObject*   o2;
-  PyObject*   o3;
-  if (!result) {
-    result = obj;
-  } else if (result == Py_None) {
-    Py_DECREF(result);
-    result = obj;
-  } else {
-    if (!PyTuple_Check(result)) {
-      o2 = result;
-      result = PyTuple_New(1);
-      PyTuple_SET_ITEM(result, 0, o2);
-    }
-    o3 = PyTuple_New(1);
-    PyTuple_SET_ITEM(o3, 0, obj);
-    o2 = result;
-    result = PySequence_Concat(o2, o3);
-    Py_DECREF(o2);
-    Py_DECREF(o3);
-  }
-  return result;
-#endif
-}
-
-/* Unpack the argument tuple */
-
-SWIGINTERN int
-SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
-{
-  if (!args) {
-    if (!min && !max) {
-      return 1;
-    } else {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
-		   name, (min == max ? "" : "at least "), (int)min);
-      return 0;
-    }
-  }  
-  if (!PyTuple_Check(args)) {
-    if (min <= 1 && max >= 1) {
-      register int i;
-      objs[0] = args;
-      for (i = 1; i < max; ++i) {
-	objs[i] = 0;
-      }
-      return 2;
-    }
-    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
-    return 0;
-  } else {
-    register Py_ssize_t l = PyTuple_GET_SIZE(args);
-    if (l < min) {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at least "), (int)min, (int)l);
-      return 0;
-    } else if (l > max) {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at most "), (int)max, (int)l);
-      return 0;
-    } else {
-      register int i;
-      for (i = 0; i < l; ++i) {
-	objs[i] = PyTuple_GET_ITEM(args, i);
-      }
-      for (; l < max; ++l) {
-	objs[l] = 0;
-      }
-      return i + 1;
-    }    
-  }
-}
-
-/* A functor is a function object with one single object argument */
-#if PY_VERSION_HEX >= 0x02020000
-#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
-#else
-#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
-#endif
-
-/*
-  Helper for static pointer initialization for both C and C++ code, for example
-  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
-*/
-#ifdef __cplusplus
-#define SWIG_STATIC_POINTER(var)  var
-#else
-#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
-#endif
-
-/* -----------------------------------------------------------------------------
- * Pointer declarations
- * ----------------------------------------------------------------------------- */
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
-#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
-
-#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)
-
-#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
-#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*  How to access Py_None */
-#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#  ifndef SWIG_PYTHON_NO_BUILD_NONE
-#    ifndef SWIG_PYTHON_BUILD_NONE
-#      define SWIG_PYTHON_BUILD_NONE
-#    endif
-#  endif
-#endif
-
-#ifdef SWIG_PYTHON_BUILD_NONE
-#  ifdef Py_None
-#   undef Py_None
-#   define Py_None SWIG_Py_None()
-#  endif
-SWIGRUNTIMEINLINE PyObject * 
-_SWIG_Py_None(void)
-{
-  PyObject *none = Py_BuildValue((char*)"");
-  Py_DECREF(none);
-  return none;
-}
-SWIGRUNTIME PyObject * 
-SWIG_Py_None(void)
-{
-  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
-  return none;
-}
-#endif
-
-/* The python void return value */
-
-SWIGRUNTIMEINLINE PyObject * 
-SWIG_Py_Void(void)
-{
-  PyObject *none = Py_None;
-  Py_INCREF(none);
-  return none;
-}
-
-/* SwigPyClientData */
-
-typedef struct {
-  PyObject *klass;
-  PyObject *newraw;
-  PyObject *newargs;
-  PyObject *destroy;
-  int delargs;
-  int implicitconv;
-  PyTypeObject *pytype;
-} SwigPyClientData;
-
-SWIGRUNTIMEINLINE int 
-SWIG_Python_CheckImplicit(swig_type_info *ty)
-{
-  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
-  return data ? data->implicitconv : 0;
-}
-
-SWIGRUNTIMEINLINE PyObject *
-SWIG_Python_ExceptionType(swig_type_info *desc) {
-  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
-  PyObject *klass = data ? data->klass : 0;
-  return (klass ? klass : PyExc_RuntimeError);
-}
-
-
-SWIGRUNTIME SwigPyClientData * 
-SwigPyClientData_New(PyObject* obj)
-{
-  if (!obj) {
-    return 0;
-  } else {
-    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
-    /* the klass element */
-    data->klass = obj;
-    Py_INCREF(data->klass);
-    /* the newraw method and newargs arguments used to create a new raw instance */
-    if (PyClass_Check(obj)) {
-      data->newraw = 0;
-      data->newargs = obj;
-      Py_INCREF(obj);
-    } else {
-#if (PY_VERSION_HEX < 0x02020000)
-      data->newraw = 0;
-#else
-      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
-#endif
-      if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
-      } else {
-	data->newargs = obj;
-      }
-      Py_INCREF(data->newargs);
-    }
-    /* the destroy method, aka as the C++ delete method */
-    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      data->destroy = 0;
-    }
-    if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-#ifdef METH_O
-      data->delargs = !(flags & (METH_O));
-#else
-      data->delargs = 0;
-#endif
-    } else {
-      data->delargs = 0;
-    }
-    data->implicitconv = 0;
-    data->pytype = 0;
-    return data;
-  }
-}
-
-SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
-  Py_XDECREF(data->newraw);
-  Py_XDECREF(data->newargs);
-  Py_XDECREF(data->destroy);
-}
-
-/* =============== SwigPyObject =====================*/
-
-typedef struct {
-  PyObject_HEAD
-  void *ptr;
-  swig_type_info *ty;
-  int own;
-  PyObject *next;
-#ifdef SWIGPYTHON_BUILTIN
-  PyObject *dict;
-#endif
-} SwigPyObject;
-
-SWIGRUNTIME PyObject *
-SwigPyObject_long(SwigPyObject *v)
-{
-  return PyLong_FromVoidPtr(v->ptr);
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_format(const char* fmt, SwigPyObject *v)
-{
-  PyObject *res = NULL;
-  PyObject *args = PyTuple_New(1);
-  if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
-      if (ofmt) {
-#if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
-#else
-	res = PyString_Format(ofmt,args);
-#endif
-	Py_DECREF(ofmt);
-      }
-      Py_DECREF(args);
-    }
-  }
-  return res;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_oct(SwigPyObject *v)
-{
-  return SwigPyObject_format("%o",v);
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_hex(SwigPyObject *v)
-{
-  return SwigPyObject_format("%x",v);
-}
-
-SWIGRUNTIME PyObject *
-#ifdef METH_NOARGS
-SwigPyObject_repr(SwigPyObject *v)
-#else
-SwigPyObject_repr(SwigPyObject *v, PyObject *args)
-#endif
-{
-  const char *name = SWIG_TypePrettyName(v->ty);
-  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
-# ifdef METH_NOARGS
-    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
-# else
-    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
-# endif
-# if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
-# else
-    PyString_ConcatAndDel(&repr,nrep);
-# endif
-  }
-  return repr;  
-}
-
-SWIGRUNTIME int
-SwigPyObject_print(SwigPyObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))
-{
-  char *str;
-#ifdef METH_NOARGS
-  PyObject *repr = SwigPyObject_repr(v);
-#else
-  PyObject *repr = SwigPyObject_repr(v, NULL);
-#endif
-  if (repr) {
-    str = SWIG_Python_str_AsChar(repr); 
-    fputs(str, fp);
-    SWIG_Python_str_DelForPy3(str);
-    Py_DECREF(repr);
-    return 0; 
-  } else {
-    return 1; 
-  }
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_str(SwigPyObject *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  return SWIG_PackVoidPtr(result, v->ptr, v->ty->name, sizeof(result)) ?
-    SWIG_Python_str_FromChar(result) : 0;
-}
-
-SWIGRUNTIME int
-SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
-{
-  void *i = v->ptr;
-  void *j = w->ptr;
-  return (i < j) ? -1 : ((i > j) ? 1 : 0);
-}
-
-/* Added for Python 3.x, would it also be useful for Python 2.x? */
-SWIGRUNTIME PyObject*
-SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
-{
-  PyObject* res;
-  if( op != Py_EQ && op != Py_NE ) {
-    Py_INCREF(Py_NotImplemented);
-    return Py_NotImplemented;
-  }
-  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
-  return res;  
-}
-
-
-SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);
-
-#ifdef SWIGPYTHON_BUILTIN
-static swig_type_info *SwigPyObject_stype = 0;
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_type(void) {
-    SwigPyClientData *cd;
-    assert(SwigPyObject_stype);
-    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
-    assert(cd);
-    assert(cd->pytype);
-    return cd->pytype;
-}
-#else
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_type(void) {
-  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
-  return type;
-}
-#endif
-
-SWIGRUNTIMEINLINE int
-SwigPyObject_Check(PyObject *op) {
-#ifdef SWIGPYTHON_BUILTIN
-  PyTypeObject *target_tp = SwigPyObject_type();
-  if (PyType_IsSubtype(op->ob_type, target_tp))
-    return 1;
-  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
-#else
-  return (Py_TYPE(op) == SwigPyObject_type())
-    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
-#endif
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
-
-SWIGRUNTIME void
-SwigPyObject_dealloc(PyObject *v)
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-  PyObject *next = sobj->next;
-  if (sobj->own == SWIG_POINTER_OWN) {
-    swig_type_info *ty = sobj->ty;
-    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
-    PyObject *destroy = data ? data->destroy : 0;
-    if (destroy) {
-      /* destroy is always a VARARGS method */
-      PyObject *res;
-      if (data->delargs) {
-	/* we need to create a temporary object to carry the destroy operation */
-	PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-	res = SWIG_Python_CallFunctor(destroy, tmp);
-	Py_DECREF(tmp);
-      } else {
-	PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
-	PyObject *mself = PyCFunction_GET_SELF(destroy);
-	res = ((*meth)(mself, v));
-      }
-      Py_XDECREF(res);
-    } 
-#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
-    else {
-      const char *name = SWIG_TypePrettyName(ty);
-      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
-    }
-#endif
-  } 
-  Py_XDECREF(next);
-  PyObject_DEL(v);
-}
-
-SWIGRUNTIME PyObject* 
-SwigPyObject_append(PyObject* v, PyObject* next)
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-#ifndef METH_O
-  PyObject *tmp = 0;
-  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
-  next = tmp;
-#endif
-  if (!SwigPyObject_Check(next)) {
-    return NULL;
-  }
-  sobj->next = next;
-  Py_INCREF(next);
-  return SWIG_Py_Void();
-}
-
-SWIGRUNTIME PyObject* 
-#ifdef METH_NOARGS
-SwigPyObject_next(PyObject* v)
-#else
-SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-  if (sobj->next) {    
-    Py_INCREF(sobj->next);
-    return sobj->next;
-  } else {
-    return SWIG_Py_Void();
-  }
-}
-
-SWIGINTERN PyObject*
-#ifdef METH_NOARGS
-SwigPyObject_disown(PyObject *v)
-#else
-SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *)v;
-  sobj->own = 0;
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject*
-#ifdef METH_NOARGS
-SwigPyObject_acquire(PyObject *v)
-#else
-SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *)v;
-  sobj->own = SWIG_POINTER_OWN;
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject*
-SwigPyObject_own(PyObject *v, PyObject *args)
-{
-  PyObject *val = 0;
-#if (PY_VERSION_HEX < 0x02020000)
-  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
-#elif (PY_VERSION_HEX < 0x02050000)
-  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
-#else
-  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
-#endif
-    {
-      return NULL;
-    } 
-  else
-    {
-      SwigPyObject *sobj = (SwigPyObject *)v;
-      PyObject *obj = PyBool_FromLong(sobj->own);
-      if (val) {
-#ifdef METH_NOARGS
-	if (PyObject_IsTrue(val)) {
-	  SwigPyObject_acquire(v);
-	} else {
-	  SwigPyObject_disown(v);
-	}
-#else
-	if (PyObject_IsTrue(val)) {
-	  SwigPyObject_acquire(v,args);
-	} else {
-	  SwigPyObject_disown(v,args);
-	}
-#endif
-      } 
-      return obj;
-    }
-}
-
-#ifdef METH_O
-static PyMethodDef
-swigobject_methods[] = {
-  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
-  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
-  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
-  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
-  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
-  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
-  {0, 0, 0, 0}  
-};
-#else
-static PyMethodDef
-swigobject_methods[] = {
-  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
-  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"aquires ownership of the pointer"},
-  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
-  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
-  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
-  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
-  {0, 0, 0, 0}  
-};
-#endif
-
-#if PY_VERSION_HEX < 0x02020000
-SWIGINTERN PyObject *
-SwigPyObject_getattr(SwigPyObject *sobj,char *name)
-{
-  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
-}
-#endif
-
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_TypeOnce(void) {
-  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";
-
-  static PyNumberMethods SwigPyObject_as_number = {
-    (binaryfunc)0, /*nb_add*/
-    (binaryfunc)0, /*nb_subtract*/
-    (binaryfunc)0, /*nb_multiply*/
-    /* nb_divide removed in Python 3 */
-#if PY_VERSION_HEX < 0x03000000
-    (binaryfunc)0, /*nb_divide*/
-#endif
-    (binaryfunc)0, /*nb_remainder*/
-    (binaryfunc)0, /*nb_divmod*/
-    (ternaryfunc)0,/*nb_power*/
-    (unaryfunc)0,  /*nb_negative*/
-    (unaryfunc)0,  /*nb_positive*/
-    (unaryfunc)0,  /*nb_absolute*/
-    (inquiry)0,    /*nb_nonzero*/
-    0,		   /*nb_invert*/
-    0,		   /*nb_lshift*/
-    0,		   /*nb_rshift*/
-    0,		   /*nb_and*/
-    0,		   /*nb_xor*/
-    0,		   /*nb_or*/
-#if PY_VERSION_HEX < 0x03000000
-    0,   /*nb_coerce*/
-#endif
-    (unaryfunc)SwigPyObject_long, /*nb_int*/
-#if PY_VERSION_HEX < 0x03000000
-    (unaryfunc)SwigPyObject_long, /*nb_long*/
-#else
-    0, /*nb_reserved*/
-#endif
-    (unaryfunc)0,                 /*nb_float*/
-#if PY_VERSION_HEX < 0x03000000
-    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
-    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
-#endif
-#if PY_VERSION_HEX >= 0x03000000 /* 3.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
-#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
-#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
-#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
-    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
-#endif
-  };
-
-  static PyTypeObject swigpyobject_type;
-  static int type_init = 0;
-  if (!type_init) {
-    const PyTypeObject tmp = {
-      /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-      PyVarObject_HEAD_INIT(NULL, 0)
-#else
-      PyObject_HEAD_INIT(NULL)
-      0,                                    /* ob_size */
-#endif
-      (char *)"SwigPyObject",               /* tp_name */
-      sizeof(SwigPyObject),                 /* tp_basicsize */
-      0,                                    /* tp_itemsize */
-      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      (printfunc)SwigPyObject_print,        /* tp_print */
-#if PY_VERSION_HEX < 0x02020000
-      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
-#else
-      (getattrfunc)0,                       /* tp_getattr */
-#endif
-      (setattrfunc)0,                       /* tp_setattr */
-#if PY_VERSION_HEX >= 0x03000000
-    0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
-#else
-      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
-#endif
-      (reprfunc)SwigPyObject_repr,          /* tp_repr */
-      &SwigPyObject_as_number,              /* tp_as_number */
-      0,                                    /* tp_as_sequence */
-      0,                                    /* tp_as_mapping */
-      (hashfunc)0,                          /* tp_hash */
-      (ternaryfunc)0,                       /* tp_call */
-      (reprfunc)SwigPyObject_str,           /* tp_str */
-      PyObject_GenericGetAttr,              /* tp_getattro */
-      0,                                    /* tp_setattro */
-      0,                                    /* tp_as_buffer */
-      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
-      swigobject_doc,                       /* tp_doc */
-      0,                                    /* tp_traverse */
-      0,                                    /* tp_clear */
-      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
-      0,                                    /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-      0,                                    /* tp_iter */
-      0,                                    /* tp_iternext */
-      swigobject_methods,                   /* tp_methods */
-      0,                                    /* tp_members */
-      0,                                    /* tp_getset */
-      0,                                    /* tp_base */
-      0,                                    /* tp_dict */
-      0,                                    /* tp_descr_get */
-      0,                                    /* tp_descr_set */
-      0,                                    /* tp_dictoffset */
-      0,                                    /* tp_init */
-      0,                                    /* tp_alloc */
-      0,                                    /* tp_new */
-      0,                                    /* tp_free */
-      0,                                    /* tp_is_gc */
-      0,                                    /* tp_bases */
-      0,                                    /* tp_mro */
-      0,                                    /* tp_cache */
-      0,                                    /* tp_subclasses */
-      0,                                    /* tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-      0,                                    /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-      0,                                    /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-      0,0,0,0                               /* tp_alloc -> tp_next */
-#endif
-    };
-    swigpyobject_type = tmp;
-    type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-    swigpyobject_type.ob_type = &PyType_Type;
-#else
-    if (PyType_Ready(&swigpyobject_type) < 0)
-      return NULL;
-#endif
-  }
-  return &swigpyobject_type;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
-{
-  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
-  if (sobj) {
-    sobj->ptr  = ptr;
-    sobj->ty   = ty;
-    sobj->own  = own;
-    sobj->next = 0;
-  }
-  return (PyObject *)sobj;
-}
-
-/* -----------------------------------------------------------------------------
- * Implements a simple Swig Packed type, and use it instead of string
- * ----------------------------------------------------------------------------- */
-
-typedef struct {
-  PyObject_HEAD
-  void *pack;
-  swig_type_info *ty;
-  size_t size;
-} SwigPyPacked;
-
-SWIGRUNTIME int
-SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
-{
-  char result[SWIG_BUFFER_SIZE];
-  fputs("<Swig Packed ", fp); 
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    fputs("at ", fp); 
-    fputs(result, fp); 
-  }
-  fputs(v->ty->name,fp); 
-  fputs(">", fp);
-  return 0; 
-}
-  
-SWIGRUNTIME PyObject *
-SwigPyPacked_repr(SwigPyPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
-  } else {
-    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
-  }  
-}
-
-SWIGRUNTIME PyObject *
-SwigPyPacked_str(SwigPyPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
-    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
-  } else {
-    return SWIG_Python_str_FromChar(v->ty->name);
-  }  
-}
-
-SWIGRUNTIME int
-SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
-{
-  size_t i = v->size;
-  size_t j = w->size;
-  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
-  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
-}
-
-SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);
-
-SWIGRUNTIME PyTypeObject*
-SwigPyPacked_type(void) {
-  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
-  return type;
-}
-
-SWIGRUNTIMEINLINE int
-SwigPyPacked_Check(PyObject *op) {
-  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
-    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
-}
-
-SWIGRUNTIME void
-SwigPyPacked_dealloc(PyObject *v)
-{
-  if (SwigPyPacked_Check(v)) {
-    SwigPyPacked *sobj = (SwigPyPacked *) v;
-    free(sobj->pack);
-  }
-  PyObject_DEL(v);
-}
-
-SWIGRUNTIME PyTypeObject*
-SwigPyPacked_TypeOnce(void) {
-  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
-  static PyTypeObject swigpypacked_type;
-  static int type_init = 0;
-  if (!type_init) {
-    const PyTypeObject tmp = {
-      /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX>=0x03000000
-      PyVarObject_HEAD_INIT(NULL, 0)
-#else
-      PyObject_HEAD_INIT(NULL)
-      0,                                    /* ob_size */
-#endif
-      (char *)"SwigPyPacked",               /* tp_name */
-      sizeof(SwigPyPacked),                 /* tp_basicsize */
-      0,                                    /* tp_itemsize */
-      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      (printfunc)SwigPyPacked_print,        /* tp_print */
-      (getattrfunc)0,                       /* tp_getattr */
-      (setattrfunc)0,                       /* tp_setattr */
-#if PY_VERSION_HEX>=0x03000000
-      0, /* tp_reserved in 3.0.1 */
-#else
-      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
-#endif
-      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
-      0,                                    /* tp_as_number */
-      0,                                    /* tp_as_sequence */
-      0,                                    /* tp_as_mapping */
-      (hashfunc)0,                          /* tp_hash */
-      (ternaryfunc)0,                       /* tp_call */
-      (reprfunc)SwigPyPacked_str,           /* tp_str */
-      PyObject_GenericGetAttr,              /* tp_getattro */
-      0,                                    /* tp_setattro */
-      0,                                    /* tp_as_buffer */
-      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
-      swigpacked_doc,                       /* tp_doc */
-      0,                                    /* tp_traverse */
-      0,                                    /* tp_clear */
-      0,                                    /* tp_richcompare */
-      0,                                    /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-      0,                                    /* tp_iter */
-      0,                                    /* tp_iternext */
-      0,                                    /* tp_methods */
-      0,                                    /* tp_members */
-      0,                                    /* tp_getset */
-      0,                                    /* tp_base */
-      0,                                    /* tp_dict */
-      0,                                    /* tp_descr_get */
-      0,                                    /* tp_descr_set */
-      0,                                    /* tp_dictoffset */
-      0,                                    /* tp_init */
-      0,                                    /* tp_alloc */
-      0,                                    /* tp_new */
-      0,                                    /* tp_free */
-      0,                                    /* tp_is_gc */
-      0,                                    /* tp_bases */
-      0,                                    /* tp_mro */
-      0,                                    /* tp_cache */
-      0,                                    /* tp_subclasses */
-      0,                                    /* tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-      0,                                    /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-      0,                                    /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-      0,0,0,0                               /* tp_alloc -> tp_next */
-#endif
-    };
-    swigpypacked_type = tmp;
-    type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-    swigpypacked_type.ob_type = &PyType_Type;
-#else
-    if (PyType_Ready(&swigpypacked_type) < 0)
-      return NULL;
-#endif
-  }
-  return &swigpypacked_type;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
-{
-  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
-  if (sobj) {
-    void *pack = malloc(size);
-    if (pack) {
-      memcpy(pack, ptr, size);
-      sobj->pack = pack;
-      sobj->ty   = ty;
-      sobj->size = size;
-    } else {
-      PyObject_DEL((PyObject *) sobj);
-      sobj = 0;
-    }
-  }
-  return (PyObject *) sobj;
-}
-
-SWIGRUNTIME swig_type_info *
-SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
-{
-  if (SwigPyPacked_Check(obj)) {
-    SwigPyPacked *sobj = (SwigPyPacked *)obj;
-    if (sobj->size != size) return 0;
-    memcpy(ptr, sobj->pack, size);
-    return sobj->ty;
-  } else {
-    return 0;
-  }
-}
-
-/* -----------------------------------------------------------------------------
- * pointers/data manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIMEINLINE PyObject *
-_SWIG_This(void)
-{
-    return SWIG_Python_str_FromChar("this");
-}
-
-static PyObject *swig_this = NULL;
-
-SWIGRUNTIME PyObject *
-SWIG_This(void)
-{
-  if (swig_this == NULL)
-    swig_this = _SWIG_This();
-  return swig_this;
-}
-
-/* #define SWIG_PYTHON_SLOW_GETSET_THIS */
-
-/* TODO: I don't know how to implement the fast getset in Python 3 right now */
-#if PY_VERSION_HEX>=0x03000000
-#define SWIG_PYTHON_SLOW_GETSET_THIS 
-#endif
-
-SWIGRUNTIME SwigPyObject *
-SWIG_Python_GetSwigThis(PyObject *pyobj) 
-{
-  PyObject *obj;
-
-  if (SwigPyObject_Check(pyobj))
-    return (SwigPyObject *) pyobj;
-
-#ifdef SWIGPYTHON_BUILTIN
-  (void)obj;
-# ifdef PyWeakref_CheckProxy
-  if (PyWeakref_CheckProxy(pyobj)) {
-    pyobj = PyWeakref_GET_OBJECT(pyobj);
-    if (pyobj && SwigPyObject_Check(pyobj))
-      return (SwigPyObject*) pyobj;
-  }
-# endif
-  return NULL;
-#else
-
-  obj = 0;
-
-#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
-  if (PyInstance_Check(pyobj)) {
-    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
-  } else {
-    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
-    if (dictptr != NULL) {
-      PyObject *dict = *dictptr;
-      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
-    } else {
-#ifdef PyWeakref_CheckProxy
-      if (PyWeakref_CheckProxy(pyobj)) {
-	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
-	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
-      }
-#endif
-      obj = PyObject_GetAttr(pyobj,SWIG_This());
-      if (obj) {
-	Py_DECREF(obj);
-      } else {
-	if (PyErr_Occurred()) PyErr_Clear();
-	return 0;
-      }
-    }
-  }
-#else
-  obj = PyObject_GetAttr(pyobj,SWIG_This());
-  if (obj) {
-    Py_DECREF(obj);
-  } else {
-    if (PyErr_Occurred()) PyErr_Clear();
-    return 0;
-  }
-#endif
-  if (obj && !SwigPyObject_Check(obj)) {
-    /* a PyObject is called 'this', try to get the 'real this'
-       SwigPyObject from it */ 
-    return SWIG_Python_GetSwigThis(obj);
-  }
-  return (SwigPyObject *)obj;
-#endif
-}
-
-/* Acquire a pointer value */
-
-SWIGRUNTIME int
-SWIG_Python_AcquirePtr(PyObject *obj, int own) {
-  if (own == SWIG_POINTER_OWN) {
-    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
-    if (sobj) {
-      int oldown = sobj->own;
-      sobj->own = own;
-      return oldown;
-    }
-  }
-  return 0;
-}
-
-/* Convert a pointer value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
-  int res;
-  SwigPyObject *sobj;
-
-  if (!obj)
-    return SWIG_ERROR;
-  if (obj == Py_None) {
-    if (ptr)
-      *ptr = 0;
-    return SWIG_OK;
-  }
-
-  res = SWIG_ERROR;
-
-  sobj = SWIG_Python_GetSwigThis(obj);
-  if (own)
-    *own = 0;
-  while (sobj) {
-    void *vptr = sobj->ptr;
-    if (ty) {
-      swig_type_info *to = sobj->ty;
-      if (to == ty) {
-        /* no type cast needed */
-        if (ptr) *ptr = vptr;
-        break;
-      } else {
-        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
-        if (!tc) {
-          sobj = (SwigPyObject *)sobj->next;
-        } else {
-          if (ptr) {
-            int newmemory = 0;
-            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
-            if (newmemory == SWIG_CAST_NEW_MEMORY) {
-              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
-              if (own)
-                *own = *own | SWIG_CAST_NEW_MEMORY;
-            }
-          }
-          break;
-        }
-      }
-    } else {
-      if (ptr) *ptr = vptr;
-      break;
-    }
-  }
-  if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
-    }
-    res = SWIG_OK;
-  } else {
-    if (flags & SWIG_POINTER_IMPLICIT_CONV) {
-      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
-      if (data && !data->implicitconv) {
-        PyObject *klass = data->klass;
-        if (klass) {
-          PyObject *impconv;
-          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
-          impconv = SWIG_Python_CallFunctor(klass, obj);
-          data->implicitconv = 0;
-          if (PyErr_Occurred()) {
-            PyErr_Clear();
-            impconv = 0;
-          }
-          if (impconv) {
-            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
-            if (iobj) {
-              void *vptr;
-              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
-              if (SWIG_IsOK(res)) {
-                if (ptr) {
-                  *ptr = vptr;
-                  /* transfer the ownership to 'ptr' */
-                  iobj->own = 0;
-                  res = SWIG_AddCast(res);
-                  res = SWIG_AddNewMask(res);
-                } else {
-                  res = SWIG_AddCast(res);		    
-                }
-              }
-            }
-            Py_DECREF(impconv);
-          }
-        }
-      }
-    }
-  }
-  return res;
-}
-
-/* Convert a function ptr value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
-  if (!PyCFunction_Check(obj)) {
-    return SWIG_ConvertPtr(obj, ptr, ty, 0);
-  } else {
-    void *vptr = 0;
-    
-    /* here we get the method pointer for callbacks */
-    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
-    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
-    if (desc)
-      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
-    if (!desc) 
-      return SWIG_ERROR;
-    if (ty) {
-      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
-      if (tc) {
-        int newmemory = 0;
-        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
-        assert(!newmemory); /* newmemory handling not yet implemented */
-      } else {
-        return SWIG_ERROR;
-      }
-    } else {
-      *ptr = vptr;
-    }
-    return SWIG_OK;
-  }
-}
-
-/* Convert a packed value value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
-  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
-  if (!to) return SWIG_ERROR;
-  if (ty) {
-    if (to != ty) {
-      /* check type cast? */
-      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
-      if (!tc) return SWIG_ERROR;
-    }
-  }
-  return SWIG_OK;
-}  
-
-/* -----------------------------------------------------------------------------
- * Create a new pointer object
- * ----------------------------------------------------------------------------- */
-
-/*
-  Create a new instance object, without calling __init__, and set the
-  'this' attribute.
-*/
-
-SWIGRUNTIME PyObject* 
-SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
-{
-#if (PY_VERSION_HEX >= 0x02020000)
-  PyObject *inst = 0;
-  PyObject *newraw = data->newraw;
-  if (newraw) {
-    inst = PyObject_Call(newraw, data->newargs, NULL);
-    if (inst) {
-#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
-      PyObject **dictptr = _PyObject_GetDictPtr(inst);
-      if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
-      }
-#else
-      PyObject *key = SWIG_This();
-      PyObject_SetAttr(inst, key, swig_this);
-#endif
-    }
-  } else {
-#if PY_VERSION_HEX >= 0x03000000
-    inst = PyBaseObject_Type.tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
-    if (inst) {
-      PyObject_SetAttr(inst, SWIG_This(), swig_this);
-      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
-    }
-#else
-    PyObject *dict = PyDict_New();
-    if (dict) {
-      PyDict_SetItem(dict, SWIG_This(), swig_this);
-      inst = PyInstance_NewRaw(data->newargs, dict);
-      Py_DECREF(dict);
-    }
-#endif
-  }
-  return inst;
-#else
-#if (PY_VERSION_HEX >= 0x02010000)
-  PyObject *inst = 0;
-  PyObject *dict = PyDict_New();
-  if (dict) {
-    PyDict_SetItem(dict, SWIG_This(), swig_this);
-    inst = PyInstance_NewRaw(data->newargs, dict);
-    Py_DECREF(dict);
-  }
-  return (PyObject *) inst;
-#else
-  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
-  if (inst == NULL) {
-    return NULL;
-  }
-  inst->in_class = (PyClassObject *)data->newargs;
-  Py_INCREF(inst->in_class);
-  inst->in_dict = PyDict_New();
-  if (inst->in_dict == NULL) {
-    Py_DECREF(inst);
-    return NULL;
-  }
-#ifdef Py_TPFLAGS_HAVE_WEAKREFS
-  inst->in_weakreflist = NULL;
-#endif
-#ifdef Py_TPFLAGS_GC
-  PyObject_GC_Init(inst);
-#endif
-  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
-  return (PyObject *) inst;
-#endif
-#endif
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
-{
- PyObject *dict;
-#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
- PyObject **dictptr = _PyObject_GetDictPtr(inst);
- if (dictptr != NULL) {
-   dict = *dictptr;
-   if (dict == NULL) {
-     dict = PyDict_New();
-     *dictptr = dict;
-   }
-   PyDict_SetItem(dict, SWIG_This(), swig_this);
-   return;
- }
-#endif
- dict = PyObject_GetAttrString(inst, (char*)"__dict__");
- PyDict_SetItem(dict, SWIG_This(), swig_this);
- Py_DECREF(dict);
-} 
-
-
-SWIGINTERN PyObject *
-SWIG_Python_InitShadowInstance(PyObject *args) {
-  PyObject *obj[2];
-  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
-    return NULL;
-  } else {
-    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
-    if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
-    } else {
-      SWIG_Python_SetSwigThis(obj[0], obj[1]);
-    }
-    return SWIG_Py_Void();
-  }
-}
-
-/* Create a new pointer object */
-
-SWIGRUNTIME PyObject *
-SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
-  SwigPyClientData *clientdata;
-  PyObject * robj;
-  int own;
-
-  if (!ptr)
-    return SWIG_Py_Void();
-
-  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
-  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
-  if (clientdata && clientdata->pytype) {
-    SwigPyObject *newobj;
-    if (flags & SWIG_BUILTIN_TP_INIT) {
-      newobj = (SwigPyObject*) self;
-      if (newobj->ptr) {
-        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
-        while (newobj->next)
-	  newobj = (SwigPyObject *) newobj->next;
-        newobj->next = next_self;
-        newobj = (SwigPyObject *)next_self;
-      }
-    } else {
-      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
-    }
-    if (newobj) {
-      newobj->ptr = ptr;
-      newobj->ty = type;
-      newobj->own = own;
-      newobj->next = 0;
-#ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
-#endif
-      return (PyObject*) newobj;
-    }
-    return SWIG_Py_Void();
-  }
-
-  assert(!(flags & SWIG_BUILTIN_TP_INIT));
-
-  robj = SwigPyObject_New(ptr, type, own);
-  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
-    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
-    Py_DECREF(robj);
-    robj = inst;
-  }
-  return robj;
-}
-
-/* Create a new packed object */
-
-SWIGRUNTIMEINLINE PyObject *
-SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
-  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
-}
-
-/* -----------------------------------------------------------------------------*
- *  Get type list 
- * -----------------------------------------------------------------------------*/
-
-#ifdef SWIG_LINK_RUNTIME
-void *SWIG_ReturnGlobalTypeList(void *);
-#endif
-
-SWIGRUNTIME swig_module_info *
-SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
-  static void *type_pointer = (void *)0;
-  /* first check if module already created */
-  if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
-    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
-#else
-# ifdef SWIGPY_USE_CAPSULE
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-# else
-    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
-				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
-# endif
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
-  }
-  return (swig_module_info *) type_pointer;
-}
-
-#if PY_MAJOR_VERSION < 2
-/* PyModule_AddObject function was introduced in Python 2.0.  The following function
-   is copied out of Python/modsupport.c in python version 2.3.4 */
-SWIGINTERN int
-PyModule_AddObject(PyObject *m, char *name, PyObject *o)
-{
-  PyObject *dict;
-  if (!PyModule_Check(m)) {
-    PyErr_SetString(PyExc_TypeError,
-		    "PyModule_AddObject() needs module as first arg");
-    return SWIG_ERROR;
-  }
-  if (!o) {
-    PyErr_SetString(PyExc_TypeError,
-		    "PyModule_AddObject() needs non-NULL value");
-    return SWIG_ERROR;
-  }
-  
-  dict = PyModule_GetDict(m);
-  if (dict == NULL) {
-    /* Internal error -- modules must have a dict! */
-    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
-		 PyModule_GetName(m));
-    return SWIG_ERROR;
-  }
-  if (PyDict_SetItemString(dict, name, o))
-    return SWIG_ERROR;
-  Py_DECREF(o);
-  return SWIG_OK;
-}
-#endif
-
-SWIGRUNTIME void
-#ifdef SWIGPY_USE_CAPSULE
-SWIG_Python_DestroyModule(PyObject *obj)
-#else
-SWIG_Python_DestroyModule(void *vptr)
-#endif
-{
-#ifdef SWIGPY_USE_CAPSULE
-  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
-#else
-  swig_module_info *swig_module = (swig_module_info *) vptr;
-#endif
-  swig_type_info **types = swig_module->types;
-  size_t i;
-  for (i =0; i < swig_module->size; ++i) {
-    swig_type_info *ty = types[i];
-    if (ty->owndata) {
-      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
-      if (data) SwigPyClientData_Del(data);
-    }
-  }
-  Py_DECREF(SWIG_This());
-  swig_this = NULL;
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetModule(swig_module_info *swig_module) {
-#if PY_VERSION_HEX >= 0x03000000
- /* Add a dummy module object into sys.modules */
-  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
-#else
-  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
-  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
-#endif
-#ifdef SWIGPY_USE_CAPSULE
-  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
-  if (pointer && module) {
-    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
-  } else {
-    Py_XDECREF(pointer);
-  }
-#else
-  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
-  if (pointer && module) {
-    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
-  } else {
-    Py_XDECREF(pointer);
-  }
-#endif
-}
-
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
-SWIGRUNTIME swig_type_info *
-SWIG_Python_TypeQuery(const char *type)
-{
-  PyObject *cache = SWIG_Python_TypeCache();
-  PyObject *key = SWIG_Python_str_FromChar(type); 
-  PyObject *obj = PyDict_GetItem(cache, key);
-  swig_type_info *descriptor;
-  if (obj) {
-#ifdef SWIGPY_USE_CAPSULE
-    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
-#else
-    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
-#endif
-  } else {
-    swig_module_info *swig_module = SWIG_GetModule(0);
-    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
-    if (descriptor) {
-#ifdef SWIGPY_USE_CAPSULE
-      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-#else
-      obj = PyCObject_FromVoidPtr(descriptor, NULL);
-#endif
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
-    }
-  }
-  Py_DECREF(key);
-  return descriptor;
-}
-
-/* 
-   For backward compatibility only
-*/
-#define SWIG_POINTER_EXCEPTION  0
-#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
-#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
-
-SWIGRUNTIME int
-SWIG_Python_AddErrMesg(const char* mesg, int infront)
-{  
-  if (PyErr_Occurred()) {
-    PyObject *type = 0;
-    PyObject *value = 0;
-    PyObject *traceback = 0;
-    PyErr_Fetch(&type, &value, &traceback);
-    if (value) {
-      char *tmp;
-      PyObject *old_str = PyObject_Str(value);
-      Py_XINCREF(type);
-      PyErr_Clear();
-      if (infront) {
-	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
-      } else {
-	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
-      }
-      SWIG_Python_str_DelForPy3(tmp);
-      Py_DECREF(old_str);
-    }
-    return 1;
-  } else {
-    return 0;
-  }
-}
-  
-SWIGRUNTIME int
-SWIG_Python_ArgFail(int argnum)
-{
-  if (PyErr_Occurred()) {
-    /* add information about failing argument */
-    char mesg[256];
-    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
-    return SWIG_Python_AddErrMesg(mesg, 1);
-  } else {
-    return 0;
-  }
-}
-
-SWIGRUNTIMEINLINE const char *
-SwigPyObject_GetDesc(PyObject *self)
-{
-  SwigPyObject *v = (SwigPyObject *)self;
-  swig_type_info *ty = v ? v->ty : 0;
-  return ty ? ty->str : "";
-}
-
-SWIGRUNTIME void
-SWIG_Python_TypeError(const char *type, PyObject *obj)
-{
-  if (type) {
-#if defined(SWIG_COBJECT_TYPES)
-    if (obj && SwigPyObject_Check(obj)) {
-      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
-      if (otype) {
-	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
-		     type, otype);
-	return;
-      }
-    } else 
-#endif      
-    {
-      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
-      if (otype) {
-	PyObject *str = PyObject_Str(obj);
-	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
-	if (cstr) {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
-		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
-	} else {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
-		       type, otype);
-	}
-	Py_XDECREF(str);
-	return;
-      }
-    }   
-    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
-  } else {
-    PyErr_Format(PyExc_TypeError, "unexpected type is received");
-  }
-}
-
-
-/* Convert a pointer value, signal an exception on a type mismatch */
-SWIGRUNTIME void *
-SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
-  void *result;
-  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
-    PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
-  }
-  return result;
-}
-
-#ifdef SWIGPYTHON_BUILTIN
-SWIGRUNTIME int
-SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
-  PyTypeObject *tp = obj->ob_type;
-  PyObject *descr;
-  PyObject *encoded_name;
-  descrsetfunc f;
-  int res;
-
-# ifdef Py_USING_UNICODE
-  if (PyString_Check(name)) {
-    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
-    if (!name)
-      return -1;
-  } else if (!PyUnicode_Check(name))
-# else
-  if (!PyString_Check(name))
-# endif
-  {
-    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
-    return -1;
-  } else {
-    Py_INCREF(name);
-  }
-
-  if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
-      goto done;
-  }
-
-  res = -1;
-  descr = _PyType_Lookup(tp, name);
-  f = NULL;
-  if (descr != NULL)
-    f = descr->ob_type->tp_descr_set;
-  if (!f) {
-    if (PyString_Check(name)) {
-      encoded_name = name;
-      Py_INCREF(name);
-    } else {
-      encoded_name = PyUnicode_AsUTF8String(name);
-    }
-    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
-    Py_DECREF(encoded_name);
-  } else {
-    res = f(descr, obj, value);
-  }
-  
-  done:
-  Py_DECREF(name);
-  return res;
-}
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-
-#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
-
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define SWIGTYPE_p_char swig_types[0]
-#define SWIGTYPE_p_std__exception swig_types[1]
-#define SWIGTYPE_p_std__ostream swig_types[2]
-#define SWIGTYPE_p_vips__VError swig_types[3]
-static swig_type_info *swig_types[5];
-static swig_module_info swig_module = {swig_types, 4, 0, 0, 0, 0};
-#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
-#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
-
-/* -------- TYPES TABLE (END) -------- */
-
-#if (PY_VERSION_HEX <= 0x02000000)
-# if !defined(SWIG_PYTHON_CLASSIC)
-#  error "This python version requires swig to be run with the '-classic' option"
-# endif
-#endif
-
-/*-----------------------------------------------
-              @(target):= verrormodule.so
-  ------------------------------------------------*/
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_init    PyInit_verrormodule
-
-#else
-#  define SWIG_init    initverrormodule
-
-#endif
-#define SWIG_name    "verrormodule"
-
-#define SWIGVERSION 0x020010 
-#define SWIG_VERSION SWIGVERSION
-
-
-#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
-#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
-
-
-#include <stdexcept>
-
-
-namespace swig {
-  class SwigPtr_PyObject {
-  protected:
-    PyObject *_obj;
-
-  public:
-    SwigPtr_PyObject() :_obj(0)
-    {
-    }
-
-    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
-    {
-      Py_XINCREF(_obj);      
-    }
-    
-    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
-    {
-      if (initial_ref) {
-        Py_XINCREF(_obj);
-      }
-    }
-    
-    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
-    {
-      Py_XINCREF(item._obj);
-      Py_XDECREF(_obj);
-      _obj = item._obj;
-      return *this;      
-    }
-    
-    ~SwigPtr_PyObject() 
-    {
-      Py_XDECREF(_obj);
-    }
-    
-    operator PyObject *() const
-    {
-      return _obj;
-    }
-
-    PyObject *operator->() const
-    {
-      return _obj;
-    }
-  };
-}
-
-
-namespace swig {
-  struct SwigVar_PyObject : SwigPtr_PyObject {
-    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
-    
-    SwigVar_PyObject & operator = (PyObject* obj)
-    {
-      Py_XDECREF(_obj);
-      _obj = obj;
-      return *this;      
-    }
-  };
-}
-
-
-#include <vips/vipscpp.h>
-
-
-#include <stdexcept>
-
-
-#include <string>
-
-
-SWIGINTERN swig_type_info*
-SWIG_pchar_descriptor(void)
-{
-  static int init = 0;
-  static swig_type_info* info = 0;
-  if (!init) {
-    info = SWIG_TypeQuery("_p_char");
-    init = 1;
-  }
-  return info;
-}
-
-
-SWIGINTERN int
-SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
-{
-#if PY_VERSION_HEX>=0x03000000
-  if (PyUnicode_Check(obj))
-#else  
-  if (PyString_Check(obj))
-#endif
-  {
-    char *cstr; Py_ssize_t len;
-#if PY_VERSION_HEX>=0x03000000
-    if (!alloc && cptr) {
-        /* We can't allow converting without allocation, since the internal
-           representation of string in Python 3 is UCS-2/UCS-4 but we require
-           a UTF-8 representation.
-           TODO(bhy) More detailed explanation */
-        return SWIG_RuntimeError;
-    }
-    obj = PyUnicode_AsUTF8String(obj);
-    PyBytes_AsStringAndSize(obj, &cstr, &len);
-    if(alloc) *alloc = SWIG_NEWOBJ;
-#else
-    PyString_AsStringAndSize(obj, &cstr, &len);
-#endif
-    if (cptr) {
-      if (alloc) {
-	/* 
-	   In python the user should not be able to modify the inner
-	   string representation. To warranty that, if you define
-	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
-	   buffer is always returned.
-
-	   The default behavior is just to return the pointer value,
-	   so, be careful.
-	*/ 
-#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
-	if (*alloc != SWIG_OLDOBJ) 
-#else
-	if (*alloc == SWIG_NEWOBJ) 
-#endif
-	  {
-	    *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
-	    *alloc = SWIG_NEWOBJ;
-	  }
-	else {
-	  *cptr = cstr;
-	  *alloc = SWIG_OLDOBJ;
-	}
-      } else {
-        #if PY_VERSION_HEX>=0x03000000
-        assert(0); /* Should never reach here in Python 3 */
-        #endif
-	*cptr = SWIG_Python_str_AsChar(obj);
-      }
-    }
-    if (psize) *psize = len + 1;
-#if PY_VERSION_HEX>=0x03000000
-    Py_XDECREF(obj);
-#endif
-    return SWIG_OK;
-  } else {
-    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
-    if (pchar_descriptor) {
-      void* vptr = 0;
-      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
-	if (cptr) *cptr = (char *) vptr;
-	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
-	if (alloc) *alloc = SWIG_OLDOBJ;
-	return SWIG_OK;
-      }
-    }
-  }
-  return SWIG_TypeError;
-}
-
-
-SWIGINTERN int
-SWIG_AsPtr_std_string (PyObject * obj, std::string **val) 
-{
-  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
-  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
-    if (buf) {
-      if (val) *val = new std::string(buf, size - 1);
-      if (alloc == SWIG_NEWOBJ) delete[] buf;
-      return SWIG_NEWOBJ;
-    } else {
-      if (val) *val = 0;
-      return SWIG_OLDOBJ;
-    }
-  } else {
-    static int init = 0;
-    static swig_type_info* descriptor = 0;
-    if (!init) {
-      descriptor = SWIG_TypeQuery("std::string" " *");
-      init = 1;
-    }
-    if (descriptor) {
-      std::string *vptr;
-      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
-      if (SWIG_IsOK(res) && val) *val = vptr;
-      return res;
-    }
-  }
-  return SWIG_ERROR;
-}
-
-
-
-
-
-#include <limits.h>
-#if !defined(SWIG_NO_LLONG_MAX)
-# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
-#   define LLONG_MAX __LONG_LONG_MAX__
-#   define LLONG_MIN (-LLONG_MAX - 1LL)
-#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
-# endif
-#endif
-
-
-SWIGINTERN int
-SWIG_AsVal_double (PyObject *obj, double *val)
-{
-  int res = SWIG_TypeError;
-  if (PyFloat_Check(obj)) {
-    if (val) *val = PyFloat_AsDouble(obj);
-    return SWIG_OK;
-  } else if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AsLong(obj);
-    return SWIG_OK;
-  } else if (PyLong_Check(obj)) {
-    double v = PyLong_AsDouble(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_OK;
-    } else {
-      PyErr_Clear();
-    }
-  }
-#ifdef SWIG_PYTHON_CAST_MODE
-  {
-    int dispatch = 0;
-    double d = PyFloat_AsDouble(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = d;
-      return SWIG_AddCast(SWIG_OK);
-    } else {
-      PyErr_Clear();
-    }
-    if (!dispatch) {
-      long v = PyLong_AsLong(obj);
-      if (!PyErr_Occurred()) {
-	if (val) *val = v;
-	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
-      } else {
-	PyErr_Clear();
-      }
-    }
-  }
-#endif
-  return res;
-}
-
-
-#include <float.h>
-
-
-#include <math.h>
-
-
-SWIGINTERNINLINE int
-SWIG_CanCastAsInteger(double *d, double min, double max) {
-  double x = *d;
-  if ((min <= x && x <= max)) {
-   double fx = floor(x);
-   double cx = ceil(x);
-   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
-   if ((errno == EDOM) || (errno == ERANGE)) {
-     errno = 0;
-   } else {
-     double summ, reps, diff;
-     if (rd < x) {
-       diff = x - rd;
-     } else if (rd > x) {
-       diff = rd - x;
-     } else {
-       return 1;
-     }
-     summ = rd + x;
-     reps = diff/summ;
-     if (reps < 8*DBL_EPSILON) {
-       *d = rd;
-       return 1;
-     }
-   }
-  }
-  return 0;
-}
-
-
-SWIGINTERN int
-SWIG_AsVal_long (PyObject *obj, long* val)
-{
-  if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AsLong(obj);
-    return SWIG_OK;
-  } else if (PyLong_Check(obj)) {
-    long v = PyLong_AsLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_OK;
-    } else {
-      PyErr_Clear();
-    }
-  }
-#ifdef SWIG_PYTHON_CAST_MODE
-  {
-    int dispatch = 0;
-    long v = PyInt_AsLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_AddCast(SWIG_OK);
-    } else {
-      PyErr_Clear();
-    }
-    if (!dispatch) {
-      double d;
-      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
-      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
-	if (val) *val = (long)(d);
-	return res;
-      }
-    }
-  }
-#endif
-  return SWIG_TypeError;
-}
-
-
-SWIGINTERN int
-SWIG_AsVal_int (PyObject * obj, int *val)
-{
-  long v;
-  int res = SWIG_AsVal_long (obj, &v);
-  if (SWIG_IsOK(res)) {
-    if ((v < INT_MIN || v > INT_MAX)) {
-      return SWIG_OverflowError;
-    } else {
-      if (val) *val = static_cast< int >(v);
-    }
-  }  
-  return res;
-}
-
-
-SWIGINTERNINLINE PyObject *
-SWIG_FromCharPtrAndSize(const char* carray, size_t size)
-{
-  if (carray) {
-    if (size > INT_MAX) {
-      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
-      return pchar_descriptor ? 
-	SWIG_InternalNewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
-    } else {
-#if PY_VERSION_HEX >= 0x03000000
-      return PyUnicode_FromStringAndSize(carray, static_cast< int >(size));
-#else
-      return PyString_FromStringAndSize(carray, static_cast< int >(size));
-#endif
-    }
-  } else {
-    return SWIG_Py_Void();
-  }
-}
-
-
-SWIGINTERNINLINE PyObject * 
-SWIG_FromCharPtr(const char *cptr)
-{ 
-  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
-}
-
-SWIGINTERN char const *vips_VError___str__(vips::VError *self){
-                return self->what ();
-        }
-#ifdef __cplusplus
-extern "C" {
-#endif
-SWIGINTERN PyObject *_wrap_new_VError__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::string arg1 ;
-  PyObject * obj0 = 0 ;
-  vips::VError *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_VError",&obj0)) SWIG_fail;
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(obj0, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_VError" "', argument " "1"" of type '" "std::string""'"); 
-    }
-    arg1 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  result = (vips::VError *)new vips::VError(arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VError, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VError__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VError *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)":new_VError")) SWIG_fail;
-  result = (vips::VError *)new vips::VError();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VError, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VError(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[2];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_new_VError__SWIG_1(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VError__SWIG_0(self, args);
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_VError'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VError::VError(std::string)\n"
-    "    vips::VError::VError()\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_VError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VError *arg1 = (vips::VError *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_VError",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VError, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VError" "', argument " "1"" of type '" "vips::VError *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VError * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VError_perror__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VError *arg1 = (vips::VError *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VError_perror",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VError, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VError_perror" "', argument " "1"" of type '" "vips::VError *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VError * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VError_perror" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  (arg1)->perror((char const *)arg2);
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VError_perror__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VError *arg1 = (vips::VError *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VError_perror",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VError, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VError_perror" "', argument " "1"" of type '" "vips::VError *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VError * >(argp1);
-  (arg1)->perror();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VError_perror(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VError, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_VError_perror__SWIG_1(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VError, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VError_perror__SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VError_perror'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VError::perror(char const *)\n"
-    "    vips::VError::perror()\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VError_app__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VError *arg1 = (vips::VError *) 0 ;
-  std::string arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VError *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VError_app",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VError, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VError_app" "', argument " "1"" of type '" "vips::VError *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VError * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VError_app" "', argument " "2"" of type '" "std::string""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  result = (vips::VError *) &(arg1)->app(arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VError, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VError_app__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VError *arg1 = (vips::VError *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VError *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VError_app",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VError, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VError_app" "', argument " "1"" of type '" "vips::VError *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VError * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VError_app" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  result = (vips::VError *) &(arg1)->app(arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VError, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VError_app(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VError, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VError_app__SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VError, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VError_app__SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VError_app'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VError::app(std::string)\n"
-    "    vips::VError::app(int const)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VError_what(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VError *arg1 = (vips::VError *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VError_what",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VError, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VError_what" "', argument " "1"" of type '" "vips::VError const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VError * >(argp1);
-  result = (char *)((vips::VError const *)arg1)->what();
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VError_ostream_print(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VError *arg1 = (vips::VError *) 0 ;
-  std::ostream *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VError_ostream_print",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VError, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VError_ostream_print" "', argument " "1"" of type '" "vips::VError const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VError * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__ostream,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VError_ostream_print" "', argument " "2"" of type '" "std::ostream &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VError_ostream_print" "', argument " "2"" of type '" "std::ostream &""'"); 
-  }
-  arg2 = reinterpret_cast< std::ostream * >(argp2);
-  ((vips::VError const *)arg1)->ostream_print(*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VError___str__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VError *arg1 = (vips::VError *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VError___str__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VError, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VError___str__" "', argument " "1"" of type '" "vips::VError *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VError * >(argp1);
-  result = (char *)vips_VError___str__(arg1);
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *VError_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_vips__VError, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject *_wrap___lshift__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::ostream *arg1 = 0 ;
-  vips::VError *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::ostream *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:__lshift__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__ostream,  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__lshift__" "', argument " "1"" of type '" "std::ostream &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__lshift__" "', argument " "1"" of type '" "std::ostream &""'"); 
-  }
-  arg1 = reinterpret_cast< std::ostream * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VError,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "__lshift__" "', argument " "2"" of type '" "vips::VError const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__lshift__" "', argument " "2"" of type '" "vips::VError const &""'"); 
-  }
-  arg2 = reinterpret_cast< vips::VError * >(argp2);
-  result = (std::ostream *) &vips::operator <<(*arg1,(vips::VError const &)*arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_verror__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::string arg1 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:verror",&obj0)) SWIG_fail;
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(obj0, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "verror" "', argument " "1"" of type '" "std::string""'"); 
-    }
-    arg1 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    vips::verror(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_verror__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  
-  if (!PyArg_ParseTuple(args,(char *)":verror")) SWIG_fail;
-  try {
-    vips::verror();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_verror(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[2];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_verror__SWIG_1(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_verror__SWIG_0(self, args);
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'verror'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::verror(std::string)\n"
-    "    vips::verror()\n");
-  return 0;
-}
-
-
-static PyMethodDef SwigMethods[] = {
-	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { (char *)"new_VError", _wrap_new_VError, METH_VARARGS, NULL},
-	 { (char *)"delete_VError", _wrap_delete_VError, METH_VARARGS, NULL},
-	 { (char *)"VError_perror", _wrap_VError_perror, METH_VARARGS, NULL},
-	 { (char *)"VError_app", _wrap_VError_app, METH_VARARGS, NULL},
-	 { (char *)"VError_what", _wrap_VError_what, METH_VARARGS, NULL},
-	 { (char *)"VError_ostream_print", _wrap_VError_ostream_print, METH_VARARGS, NULL},
-	 { (char *)"VError___str__", _wrap_VError___str__, METH_VARARGS, NULL},
-	 { (char *)"VError_swigregister", VError_swigregister, METH_VARARGS, NULL},
-	 { (char *)"__lshift__", _wrap___lshift__, METH_VARARGS, NULL},
-	 { (char *)"verror", _wrap_verror, METH_VARARGS, NULL},
-	 { NULL, NULL, 0, NULL }
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static void *_p_vips__VErrorTo_p_std__exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
-    return (void *)((std::exception *)  ((vips::VError *) x));
-}
-static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__exception = {"_p_std__exception", "std::exception *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VError = {"_p_vips__VError", "vips::VError *", 0, 0, (void*)0, 0};
-
-static swig_type_info *swig_type_initial[] = {
-  &_swigt__p_char,
-  &_swigt__p_std__exception,
-  &_swigt__p_std__ostream,
-  &_swigt__p_vips__VError,
-};
-
-static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__exception[] = {  {&_swigt__p_std__exception, 0, 0, 0},  {&_swigt__p_vips__VError, _p_vips__VErrorTo_p_std__exception, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VError[] = {  {&_swigt__p_vips__VError, 0, 0, 0},{0, 0, 0, 0}};
-
-static swig_cast_info *swig_cast_initial[] = {
-  _swigc__p_char,
-  _swigc__p_std__exception,
-  _swigc__p_std__ostream,
-  _swigc__p_vips__VError,
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-static swig_const_info swig_const_table[] = {
-{0, 0, 0, 0.0, 0, 0}};
-
-#ifdef __cplusplus
-}
-#endif
-/* -----------------------------------------------------------------------------
- * Type initialization:
- * This problem is tough by the requirement that no dynamic 
- * memory is used. Also, since swig_type_info structures store pointers to 
- * swig_cast_info structures and swig_cast_info structures store pointers back
- * to swig_type_info structures, we need some lookup code at initialization. 
- * The idea is that swig generates all the structures that are needed. 
- * The runtime then collects these partially filled structures. 
- * The SWIG_InitializeModule function takes these initial arrays out of 
- * swig_module, and does all the lookup, filling in the swig_module.types
- * array with the correct data and linking the correct swig_cast_info
- * structures together.
- *
- * The generated swig_type_info structures are assigned staticly to an initial 
- * array. We just loop through that array, and handle each type individually.
- * First we lookup if this type has been already loaded, and if so, use the
- * loaded structure instead of the generated one. Then we have to fill in the
- * cast linked list. The cast data is initially stored in something like a
- * two-dimensional array. Each row corresponds to a type (there are the same
- * number of rows as there are in the swig_type_initial array). Each entry in
- * a column is one of the swig_cast_info structures for that type.
- * The cast_initial array is actually an array of arrays, because each row has
- * a variable number of columns. So to actually build the cast linked list,
- * we find the array of casts associated with the type, and loop through it 
- * adding the casts to the list. The one last trick we need to do is making
- * sure the type pointer in the swig_cast_info struct is correct.
- *
- * First off, we lookup the cast->type name to see if it is already loaded. 
- * There are three cases to handle:
- *  1) If the cast->type has already been loaded AND the type we are adding
- *     casting info to has not been loaded (it is in this module), THEN we
- *     replace the cast->type pointer with the type pointer that has already
- *     been loaded.
- *  2) If BOTH types (the one we are adding casting info to, and the 
- *     cast->type) are loaded, THEN the cast info has already been loaded by
- *     the previous module so we just ignore it.
- *  3) Finally, if cast->type has not already been loaded, then we add that
- *     swig_cast_info to the linked list (because the cast->type) pointer will
- *     be correct.
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#if 0
-} /* c-mode */
-#endif
-#endif
-
-#if 0
-#define SWIGRUNTIME_DEBUG
-#endif
-
-
-SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
-  size_t i;
-  swig_module_info *module_head, *iter;
-  int found, init;
-  
-  /* check to see if the circular list has been setup, if not, set it up */
-  if (swig_module.next==0) {
-    /* Initialize the swig_module */
-    swig_module.type_initial = swig_type_initial;
-    swig_module.cast_initial = swig_cast_initial;
-    swig_module.next = &swig_module;
-    init = 1;
-  } else {
-    init = 0;
-  }
-  
-  /* Try and load any already created modules */
-  module_head = SWIG_GetModule(clientdata);
-  if (!module_head) {
-    /* This is the first module loaded for this interpreter */
-    /* so set the swig module into the interpreter */
-    SWIG_SetModule(clientdata, &swig_module);
-    module_head = &swig_module;
-  } else {
-    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
-    found=0;
-    iter=module_head;
-    do {
-      if (iter==&swig_module) {
-        found=1;
-        break;
-      }
-      iter=iter->next;
-    } while (iter!= module_head);
-    
-    /* if the is found in the list, then all is done and we may leave */
-    if (found) return;
-    /* otherwise we must add out module into the list */
-    swig_module.next = module_head->next;
-    module_head->next = &swig_module;
-  }
-  
-  /* When multiple interpeters are used, a module could have already been initialized in
-       a different interpreter, but not yet have a pointer in this interpreter.
-       In this case, we do not want to continue adding types... everything should be
-       set up already */
-  if (init == 0) return;
-  
-  /* Now work on filling in swig_module.types */
-#ifdef SWIGRUNTIME_DEBUG
-  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
-#endif
-  for (i = 0; i < swig_module.size; ++i) {
-    swig_type_info *type = 0;
-    swig_type_info *ret;
-    swig_cast_info *cast;
-    
-#ifdef SWIGRUNTIME_DEBUG
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-#endif
-    
-    /* if there is another module already loaded */
-    if (swig_module.next != &swig_module) {
-      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
-    }
-    if (type) {
-      /* Overwrite clientdata field */
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: found type %s\n", type->name);
-#endif
-      if (swig_module.type_initial[i]->clientdata) {
-        type->clientdata = swig_module.type_initial[i]->clientdata;
-#ifdef SWIGRUNTIME_DEBUG
-        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
-#endif
-      }
-    } else {
-      type = swig_module.type_initial[i];
-    }
-    
-    /* Insert casting types */
-    cast = swig_module.cast_initial[i];
-    while (cast->type) {
-      /* Don't need to add information already in the list */
-      ret = 0;
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
-#endif
-      if (swig_module.next != &swig_module) {
-        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
-#ifdef SWIGRUNTIME_DEBUG
-        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
-#endif
-      }
-      if (ret) {
-        if (type == swig_module.type_initial[i]) {
-#ifdef SWIGRUNTIME_DEBUG
-          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
-#endif
-          cast->type = ret;
-          ret = 0;
-        } else {
-          /* Check for casting already in the list */
-          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
-#ifdef SWIGRUNTIME_DEBUG
-          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
-#endif
-          if (!ocast) ret = 0;
-        }
-      }
-      
-      if (!ret) {
-#ifdef SWIGRUNTIME_DEBUG
-        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
-#endif
-        if (type->cast) {
-          type->cast->prev = cast;
-          cast->next = type->cast;
-        }
-        type->cast = cast;
-      }
-      cast++;
-    }
-    /* Set entry in modules->types array equal to the type */
-    swig_module.types[i] = type;
-  }
-  swig_module.types[i] = 0;
-  
-#ifdef SWIGRUNTIME_DEBUG
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-  for (i = 0; i < swig_module.size; ++i) {
-    int j = 0;
-    swig_cast_info *cast = swig_module.cast_initial[i];
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-    while (cast->type) {
-      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
-      cast++;
-      ++j;
-    }
-    printf("---- Total casts: %d\n",j);
-  }
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-#endif
-}
-
-/* This function will propagate the clientdata field of type to
-* any new swig_type_info structures that have been added into the list
-* of equivalent types.  It is like calling
-* SWIG_TypeClientData(type, clientdata) a second time.
-*/
-SWIGRUNTIME void
-SWIG_PropagateClientData(void) {
-  size_t i;
-  swig_cast_info *equiv;
-  static int init_run = 0;
-  
-  if (init_run) return;
-  init_run = 1;
-  
-  for (i = 0; i < swig_module.size; i++) {
-    if (swig_module.types[i]->clientdata) {
-      equiv = swig_module.types[i]->cast;
-      while (equiv) {
-        if (!equiv->converter) {
-          if (equiv->type && !equiv->type->clientdata)
-          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
-        }
-        equiv = equiv->next;
-      }
-    }
-  }
-}
-
-#ifdef __cplusplus
-#if 0
-{
-  /* c-mode */
-#endif
-}
-#endif
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-  
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
-    char *tmp;
-    PyObject *str = swig_varlink_str(v);
-    fprintf(fp,"Swig global variables ");
-    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
-    SWIG_Python_str_DelForPy3(tmp);
-    Py_DECREF(str);
-    return 0;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-        /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        (char *)"swigvarlink",              /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        (printfunc) swig_varlink_print,     /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-        0,                                  /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-        0,                                  /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-        0,0,0,0                             /* tp_alloc -> tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-      varlink_type.ob_type = &PyType_Type;
-#else
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-#endif
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        strncpy(gv->name,name,size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *_SWIG_globals = 0; 
-    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
-    return _SWIG_globals;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * constants/methods manipulation
-   * ----------------------------------------------------------------------------- */
-  
-  /* Install Constants */
-  SWIGINTERN void
-  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
-    PyObject *obj = 0;
-    size_t i;
-    for (i = 0; constants[i].type; ++i) {
-      switch(constants[i].type) {
-      case SWIG_PY_POINTER:
-        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
-        break;
-      case SWIG_PY_BINARY:
-        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
-        break;
-      default:
-        obj = 0;
-        break;
-      }
-      if (obj) {
-        PyDict_SetItemString(d, constants[i].name, obj);
-        Py_DECREF(obj);
-      }
-    }
-  }
-  
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
-  
-  SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
-    size_t i;
-    for (i = 0; methods[i].ml_name; ++i) {
-      const char *c = methods[i].ml_doc;
-      if (c && (c = strstr(c, "swig_ptr: "))) {
-        int j;
-        swig_const_info *ci = 0;
-        const char *name = c + 10;
-        for (j = 0; const_table[j].type; ++j) {
-          if (strncmp(const_table[j].name, name, 
-              strlen(const_table[j].name)) == 0) {
-            ci = &(const_table[j]);
-            break;
-          }
-        }
-        if (ci) {
-          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
-          if (ptr) {
-            size_t shift = (ci->ptype) - types;
-            swig_type_info *ty = types_initial[shift];
-            size_t ldoc = (c - methods[i].ml_doc);
-            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
-            char *ndoc = (char*)malloc(ldoc + lptr + 10);
-            if (ndoc) {
-              char *buff = ndoc;
-              strncpy(buff, methods[i].ml_doc, ldoc);
-              buff += ldoc;
-              strncpy(buff, "swig_ptr: ", 10);
-              buff += 10;
-              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
-              methods[i].ml_doc = ndoc;
-            }
-          }
-        }
-      }
-    }
-  } 
-  
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------*
- *  Partial Init method
- * -----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern "C"
-#endif
-
-SWIGEXPORT 
-#if PY_VERSION_HEX >= 0x03000000
-PyObject*
-#else
-void
-#endif
-SWIG_init(void) {
-  PyObject *m, *d, *md;
-#if PY_VERSION_HEX >= 0x03000000
-  static struct PyModuleDef SWIG_module = {
-# if PY_VERSION_HEX >= 0x03020000
-    PyModuleDef_HEAD_INIT,
-# else
-    {
-      PyObject_HEAD_INIT(NULL)
-      NULL, /* m_init */
-      0,    /* m_index */
-      NULL, /* m_copy */
-    },
-# endif
-    (char *) SWIG_name,
-    NULL,
-    -1,
-    SwigMethods,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-  };
-#endif
-  
-#if defined(SWIGPYTHON_BUILTIN)
-  static SwigPyClientData SwigPyObject_clientdata = {
-    0, 0, 0, 0, 0, 0, 0
-  };
-  static PyGetSetDef this_getset_def = {
-    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
-  };
-  static SwigPyGetSet thisown_getset_closure = {
-    (PyCFunction) SwigPyObject_own,
-    (PyCFunction) SwigPyObject_own
-  };
-  static PyGetSetDef thisown_getset_def = {
-    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
-  };
-  PyObject *metatype_args;
-  PyTypeObject *builtin_pytype;
-  int builtin_base_count;
-  swig_type_info *builtin_basetype;
-  PyObject *tuple;
-  PyGetSetDescrObject *static_getset;
-  PyTypeObject *metatype;
-  SwigPyClientData *cd;
-  PyObject *public_interface, *public_symbol;
-  PyObject *this_descr;
-  PyObject *thisown_descr;
-  int i;
-  
-  (void)builtin_pytype;
-  (void)builtin_base_count;
-  (void)builtin_basetype;
-  (void)tuple;
-  (void)static_getset;
-  
-  /* metatype is used to implement static member variables. */
-  metatype_args = Py_BuildValue("(s(O){})", "SwigPyObjectType", &PyType_Type);
-  assert(metatype_args);
-  metatype = (PyTypeObject *) PyType_Type.tp_call((PyObject *) &PyType_Type, metatype_args, NULL);
-  assert(metatype);
-  Py_DECREF(metatype_args);
-  metatype->tp_setattro = (setattrofunc) &SwigPyObjectType_setattro;
-  assert(PyType_Ready(metatype) >= 0);
-#endif
-  
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
-  
-#if PY_VERSION_HEX >= 0x03000000
-  m = PyModule_Create(&SWIG_module);
-#else
-  m = Py_InitModule((char *) SWIG_name, SwigMethods);
-#endif
-  md = d = PyModule_GetDict(m);
-  (void)md;
-  
-  SWIG_InitializeModule(0);
-  
-#ifdef SWIGPYTHON_BUILTIN
-  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
-  assert(SwigPyObject_stype);
-  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
-  if (!cd) {
-    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
-    SwigPyObject_clientdata.pytype = SwigPyObject_TypeOnce();
-  } else if (SwigPyObject_TypeOnce()->tp_basicsize != cd->pytype->tp_basicsize) {
-    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
-# if PY_VERSION_HEX >= 0x03000000
-    return NULL;
-# else
-    return;
-# endif
-  }
-  
-  /* All objects have a 'this' attribute */
-  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
-  (void)this_descr;
-  
-  /* All objects have a 'thisown' attribute */
-  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
-  (void)thisown_descr;
-  
-  public_interface = PyList_New(0);
-  public_symbol = 0;
-  (void)public_symbol;
-  
-  PyDict_SetItemString(md, "__all__", public_interface);
-  Py_DECREF(public_interface);
-  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
-  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
-  for (i = 0; swig_const_table[i].name != 0; ++i)
-  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
-#endif
-  
-  SWIG_InstallConstants(d,swig_const_table);
-  
-#if PY_VERSION_HEX >= 0x03000000
-  return m;
-#else
-  return;
-#endif
-}
-
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/VError.py vips-7.38.5/swig/vipsCC/VError.py
--- vips-7.38.5-vanilla/swig/vipsCC/VError.py	2014-07-17 23:48:36.211794473 -0400
+++ vips-7.38.5/swig/vipsCC/VError.py	1969-12-31 19:00:00.000000000 -0500
@@ -1,100 +0,0 @@
-# This file was automatically generated by SWIG (http://www.swig.org).
-# Version 2.0.10
-#
-# Do not make changes to this file unless you know what you are doing--modify
-# the SWIG interface file instead.
-
-
-
-from sys import version_info
-if version_info >= (2,6,0):
-    def swig_import_helper():
-        from os.path import dirname
-        import imp
-        fp = None
-        try:
-            fp, pathname, description = imp.find_module('verrormodule', [dirname(__file__)])
-        except ImportError:
-            import verrormodule
-            return verrormodule
-        if fp is not None:
-            try:
-                _mod = imp.load_module('verrormodule', fp, pathname, description)
-            finally:
-                fp.close()
-            return _mod
-    verrormodule = swig_import_helper()
-    del swig_import_helper
-else:
-    import verrormodule
-del version_info
-try:
-    _swig_property = property
-except NameError:
-    pass # Python < 2.2 doesn't have 'property'.
-def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
-    if (name == "thisown"): return self.this.own(value)
-    if (name == "this"):
-        if type(value).__name__ == 'SwigPyObject':
-            self.__dict__[name] = value
-            return
-    method = class_type.__swig_setmethods__.get(name,None)
-    if method: return method(self,value)
-    if (not static):
-        self.__dict__[name] = value
-    else:
-        raise AttributeError("You cannot add attributes to %s" % self)
-
-def _swig_setattr(self,class_type,name,value):
-    return _swig_setattr_nondynamic(self,class_type,name,value,0)
-
-def _swig_getattr(self,class_type,name):
-    if (name == "thisown"): return self.this.own()
-    method = class_type.__swig_getmethods__.get(name,None)
-    if method: return method(self)
-    raise AttributeError(name)
-
-def _swig_repr(self):
-    try: strthis = "proxy of " + self.this.__repr__()
-    except: strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-try:
-    _object = object
-    _newclass = 1
-except AttributeError:
-    class _object : pass
-    _newclass = 0
-
-
-class VError(Exception):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, VError, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, VError, name)
-    __repr__ = _swig_repr
-    def __init__(self, *args): 
-        this = verrormodule.new_VError(*args)
-        try: self.this.append(this)
-        except: self.this = this
-    __swig_destroy__ = verrormodule.delete_VError
-    __del__ = lambda self : None;
-    def perror(self, *args): return verrormodule.VError_perror(self, *args)
-    def app(self, *args): return verrormodule.VError_app(self, *args)
-    def what(self): return verrormodule.VError_what(self)
-    def ostream_print(self, *args): return verrormodule.VError_ostream_print(self, *args)
-    def __str__(self): return verrormodule.VError___str__(self)
-VError_swigregister = verrormodule.VError_swigregister
-VError_swigregister(VError)
-
-
-def __lshift__(*args):
-  return verrormodule.__lshift__(*args)
-__lshift__ = verrormodule.__lshift__
-
-def verror(str=""):
-  return verrormodule.verror(str)
-verror = verrormodule.verror
-# This file is compatible with both classic and new-style classes.
-
-
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/VImage.i vips-7.38.5/swig/vipsCC/VImage.i
--- vips-7.38.5-vanilla/swig/vipsCC/VImage.i	2014-07-17 23:48:36.207794473 -0400
+++ vips-7.38.5/swig/vipsCC/VImage.i	1969-12-31 19:00:00.000000000 -0500
@@ -1,380 +0,0 @@
-/* SWIG interface file for vipsCC7
- *
- * 5/9/07
- *      - use g_option_context_set_ignore_unknown_options() so we don't fail
- *        on unrecognied -args (thanks Simon)
- * 3/8/08
- *      - add .tobuffer() / .frombuffer (), .tostring (), .fromstring ()
- *        methods
- *      - add PIL_mode_from_vips () and vips_from_PIL_mode () utility
- *        functions
- * 6/11/09
- *      - arg, std::vector<vips::VImage> was missing the "vips::"
- */
-
-%module VImage
-
-%{
-#include <vips/vipscpp.h>
-
-/* We need the C API too for the args init and some of the
- * frombuffer/tobuffer stuff.
- */
-#include <vips/vips.h>
-%}
-
-/* Need to override assignment to get refcounting working.
- */
-%rename(__assign__) vips::VImage::operator=;
-
-%include "std_list.i"
-%include "std_complex.i"
-%include "std_vector.i"
-%include "std_except.i"
-%include "std_string.i"
-%include "cstring.i"
-%include "typemaps.i"
-
-%import "VError.i"
-%import "VMask.i"
-%import "VDisplay.i"
-
-namespace std {
-  %template(IntVector) vector<int>;
-  %template(DoubleVector) vector<double>;
-  %template(ImageVector) vector<vips::VImage>;
-}
-
-/* To get image data to and from VImage (eg. when interfacing with PIL) we
- * need to be able to import and export Python buffer() objects. Add new
- * methods to construct from and return pointer/length pairs, then wrap them
- * ourselves with a couple of typemaps.
- */
-
-%{
-struct VBuffer {
-  void *data;
-  size_t size;
-};
-%}
-
-%typemap (out) VBuffer {
-  $result = PyBuffer_FromMemory ($1.data, $1.size);
-}
-
-%typemap (in) VBuffer {
-  const char *buffer;
-  Py_ssize_t buffer_len;
-
-  if (PyObject_AsCharBuffer ($input, &buffer, &buffer_len) == -1) {
-    PyErr_SetString (PyExc_TypeError,"Type error. Unable to get char pointer from buffer");
-    return NULL;
-  }
-
-  $1.data = (void *) buffer;
-  $1.size = buffer_len;
-}
-
-/* Functions which return extra values though their parameters need special
- * typemaps.
- */
-
-// double maxpos_avg( double& maxpos_avg_y, double& maxpos_avg_out )
-%apply double *OUTPUT { double & maxpos_avg_y };
-%apply double *OUTPUT { double & maxpos_avg_out };
-
-// VImage system_image( char* system_image_in_format, char* system_image_out_format, char* system_image_command, char*& system_image_log ) 
-%cstring_output_allocate(char **system_image_log, g_free(*$1));
-
-// VImage segment( int& segment_segments ) 
-%apply int *OUTPUT { int & segment_segments };
-
-// VImage project( VImage& project_vout ) throw( VError );
-// nope ... not sure how to handle this one
-//%apply VImage *OUTPUT { VImage & project_vout };
-
-// VImage label_regions( int& label_regions_segments ) 
-%apply int *OUTPUT { int & label_regions_segments };
-
-// double correl( VImage correl_sec, int correl_xref, int correl_yref, int correl_xsec, int correl_ysec, int correl_hwindowsize, int correl_hsearchsize, int& correl_x, int& correl_y ) 
-%apply int *OUTPUT { int & correl_x };
-%apply int *OUTPUT { int & correl_y };
-
-// int _find_lroverlap( VImage _find_lroverlap_sec, int _find_lroverlap_bandno, int _find_lroverlap_xr, int _find_lroverlap_yr, int _find_lroverlap_xs, int _find_lroverlap_ys, int _find_lroverlap_halfcorrelation, int _find_lroverlap_halfarea, int& _find_lroverlap_dy0, double& _find_lroverlap_scale1, double& _find_lroverlap_angle1, double& _find_lroverlap_dx1, double& _find_lroverlap_dy1 ) 
-%apply int *OUTPUT { int & _find_lroverlap_dy0 };
-%apply double *OUTPUT { double & _find_lroverlap_scale1 };
-%apply double *OUTPUT { double & _find_lroverlap_angle1 };
-%apply double *OUTPUT { double & _find_lroverlap_dx1 };
-%apply double *OUTPUT { double & _find_lroverlap_dy1 };
-
-// int _find_tboverlap( VImage _find_tboverlap_sec, int _find_tboverlap_bandno, int _find_tboverlap_xr, int _find_tboverlap_yr, int _find_tboverlap_xs, int _find_tboverlap_ys, int _find_tboverlap_halfcorrelation, int _find_tboverlap_halfarea, int& _find_tboverlap_dy0, double& _find_tboverlap_scale1, double& _find_tboverlap_angle1, double& _find_tboverlap_dx1, double& _find_tboverlap_dy1 ) 
-%apply int *OUTPUT { int & _find_tboverlap_dy0 };
-%apply double *OUTPUT { double & _find_tboverlap_scale1 };
-%apply double *OUTPUT { double & _find_tboverlap_angle1 };
-%apply double *OUTPUT { double & _find_tboverlap_dx1 };
-%apply double *OUTPUT { double & _find_tboverlap_dy1 };
-
-// double maxpos_subpel( double& maxpos_subpel_y ) 
-%apply double *OUTPUT { double & maxpos_subpel_y };
-
-/* Need the expanded VImage.h in this directory, rather than the usual
- * vips/VImage.h. SWIG b0rks on #include inside class definitions.
- */
-%include VImage.h
-
-%extend vips::VImage {
-public:
-  VBuffer tobuffer () throw (VError)
-  {
-    VBuffer buffer;
-
-    buffer.data = $self->data ();
-    buffer.size = (size_t) $self->Xsize () * $self->Ysize () * 
-        IM_IMAGE_SIZEOF_PEL ($self->image ());
-
-    return buffer;
-  }
-
-  static VImage frombuffer (VBuffer buffer, int width, int height,
-    int bands, TBandFmt format) throw (VError)
-  {
-    return VImage (buffer.data, width, height, bands, format);
-  }
-
-  %cstring_output_allocate_size (char **buffer, int *buffer_len, im_free (*$1))
-
-  void tostring (char **buffer, int *buffer_len) throw (VError)
-  {
-    void *vips_memory;
-
-    /* Eval the vips image first. This may throw an exception and we want to
-     * make sure we do this before we try to malloc() space for the copy.
-     */
-    vips_memory = $self->data ();
-
-    /* We have to copy the image data to make a string that Python can
-     * manage. Use frombuffer() / tobuffer () if you want to avoid the copy
-     * and manage memory lifetime yourself.
-     */
-    *buffer_len = (size_t) $self->Xsize () * $self->Ysize () * 
-      IM_IMAGE_SIZEOF_PEL ($self->image ());
-    if (!(*buffer = (char *) im_malloc (NULL, *buffer_len))) 
-      verror ("Unable to allocate memory for image copy.");
-    memcpy (*buffer, vips_memory, *buffer_len);
-  }
-
-  static VImage fromstring (std::string buffer, int width, int height,
-    int bands, TBandFmt format) throw (VError)
-  {
-    void *vips_memory;
-    VImage result;
-
-    /* We have to copy the string, then add a callback to the VImage to free
-     * it when we free the VImage. Use frombuffer() / tobuffer () if you want 
-     * to avoid the copy and manage memory lifetime yourself.
-     */
-    if (!(vips_memory = im_malloc (NULL, buffer.length ()))) 
-      verror ("Unable to allocate memory for image copy.");
-
-    /* We have to use .c_str () since the string may not be contiguous.
-     */
-    memcpy (vips_memory, buffer.c_str (), buffer.length ());
-    result = VImage (vips_memory, width, height, bands, format);
-
-    if (im_add_close_callback (result.image (), 
-      (im_callback_fn) im_free, vips_memory, NULL))
-      verror ();
-
-    return result;
-  }
-}
-
-%pythoncode %{
-# try to guess a PIL mode string from a VIPS image
-def PIL_mode_from_vips (vim):
-  if vim.Bands () == 3 and vim.BandFmt () == VImage.FMTUCHAR:
-    return 'RGB'
-  elif vim.Bands () == 4 and vim.BandFmt () == VImage.FMTUCHAR and vim.Type () == VImage.RGB:
-    return 'RGBA'
-  elif vim.Bands () == 4 and vim.BandFmt () == VImage.FMTUCHAR and vim.Type () == VImage.CMYK:
-    return 'CMYK'
-  elif vim.Bands () == 1 and vim.BandFmt () == VImage.FMTUCHAR:
-    return 'L'
-  elif vim.Bands () == 1 and vim.BandFmt () == VImage.FMTINT:
-    return 'I'
-  elif vim.Bands () == 1 and vim.BandFmt () == VImage.FMTFLOAT:
-    return 'F'
-  elif vim.Bands () == 2 and vim.BandFmt () == VImage.FMTUCHAR:
-    return 'LA'
-  else:
-    raise ValueError ('unsupported vips -> pil image')
-
-# return vips (bands, format, type) for a PIL mode
-def vips_from_PIL_mode (mode):
-  if mode == 'RGB':
-    return (3, VImage.FMTUCHAR, VImage.RGB)
-  elif mode == 'RGBA':
-    return (4, VImage.FMTUCHAR, VImage.RGB)
-  elif mode == 'CMYK':
-    return (4, VImage.FMTUCHAR, VImage.CMYK)
-  elif mode == 'L':
-    return (1, VImage.FMTUCHAR, VImage.B_W)
-  elif mode == 'I':
-    return (1, VImage.FMTINT, VImage.B_W)
-  elif mode == 'F':
-    return (1, VImage.FMTFLOAT, VImage.B_W)
-  elif mode == 'LA':
-    return (2, VImage.FMTUCHAR, VImage.B_W)
-  else:
-    raise ValueError ('unsupported pil -> vips image')
-%}
-
-/* Helper code for vips_init().
- */
-%{
-/* Turn on to print args.
-#define DEBUG
- */
-
-/* Command-line args during parse.
- */
-typedef struct _Args {
-  /* The n strings we alloc when we get from Python.
-   */
-  int n;
-  char **str;
-
-  /* argc/argv as processed by us.
-   */
-  int argc;
-  char **argv;
-} Args;
-
-#ifdef DEBUG
-static void
-args_print (Args *args)
-{
-  int i;
-
-  printf ("args_print: argc = %d\n", args->argc);
-  // +1 so we print the trailing NULL too
-  for (i = 0; i < args->argc + 1; i++)
-    printf ("\t%2d)\t%s\n", i, args->argv[i]);
-}
-#endif /*DEBUG*/
-
-static void
-args_free (Args *args)
-{
-  int i;
-
-  for (i = 0; i < args->n; i++)
-    IM_FREE (args->str[i]);
-  args->n = 0;
-  args->argc = 0;
-  IM_FREE (args->str);
-  IM_FREE (args->argv);
-  IM_FREE (args);
-}
-
-/* Get argv/argc from python.
- */
-static Args *
-args_new (void)
-{
-  Args *args;
-  PyObject *av;
-  int i;
-  int n;
-
-  args = g_new (Args, 1);
-  args->n = 0;
-  args->str = NULL;
-  args->argc = 0;
-  args->argv = NULL;
-
-  if (!(av = PySys_GetObject ((char *) "argv"))) 
-    return (args);
-  if (!PyList_Check (av)) {
-    PyErr_Warn (PyExc_Warning, "ignoring sys.argv: "
-      "it must be a list of strings");
-    return args;
-  }
-
-  n = PyList_Size (av);
-  args->str = g_new (char *, n);
-  for (i = 0; i < n; i++)
-    args->str[i] = g_strdup (PyString_AsString (PyList_GetItem (av, i)));
-  args->n = n;
-
-  /* +1 for NULL termination.
-   */
-  args->argc = n;
-  args->argv = g_new (char *, n + 1);
-  for (i = 0; i < n; i++)
-    args->argv[i] = args->str[i];
-  args->argv[i] = NULL;
-
-  return args;
-}
-
-static void
-vips_fatal (const char *msg)
-{
-  char buf[256];
-
-  im_snprintf (buf, 256, "%s\n%s", msg, im_error_buffer());
-  im_error_clear ();
-  Py_FatalError (buf);
-}
-
-%}
-
-%init %{
-{
-  Args *args;
-        
-  args = args_new ();
-
-#ifdef DEBUG
-  printf ("on startup:\n");
-  args_print (args);
-#endif /*DEBUG*/
-        
-  if (im_init_world (args->argv[0])) {
-     args_free (args);
-     vips_fatal ("can't initialise module vips");
-  }
-
-  /* Now parse any GOptions. 
-   */
-  GError *error = NULL;
-  GOptionContext *context;
-
-  context = g_option_context_new ("- vips");
-  g_option_context_add_group (context, im_get_option_group());
-
-  g_option_context_set_ignore_unknown_options (context, TRUE);
-  if (!g_option_context_parse (context, 
-    &args->argc, &args->argv, &error)) {
-    g_option_context_free (context);
-    args_free (args);
-    im_error ("vipsmodule", "%s", error->message);
-    g_error_free (error);
-    vips_fatal ("can't initialise module vips");
-  }
-  g_option_context_free (context);
-
-#ifdef DEBUG
-  printf ("after parse:\n");
-  args_print (args);
-#endif /*DEBUG*/
-
-  // Write (possibly) modified argc/argv back again.
-  if (args->argv) 
-    PySys_SetArgv (args->argc, args->argv);
-
-  args_free (args);
-}
-%}
-
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/vimagemodule.cxx vips-7.38.5/swig/vipsCC/vimagemodule.cxx
--- vips-7.38.5-vanilla/swig/vipsCC/vimagemodule.cxx	2014-07-17 23:48:36.211794473 -0400
+++ vips-7.38.5/swig/vipsCC/vimagemodule.cxx	1969-12-31 19:00:00.000000000 -0500
@@ -1,33595 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 2.0.10
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-#define SWIGPYTHON
-#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
-
-
-#ifdef __cplusplus
-/* SwigValueWrapper is described in swig.swg */
-template<typename T> class SwigValueWrapper {
-  struct SwigMovePointer {
-    T *ptr;
-    SwigMovePointer(T *p) : ptr(p) { }
-    ~SwigMovePointer() { delete ptr; }
-    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
-  } pointer;
-  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
-  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
-public:
-  SwigValueWrapper() : pointer(0) { }
-  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
-  operator T&() const { return *pointer.ptr; }
-  T *operator&() { return pointer.ptr; }
-};
-
-template <typename T> T SwigValueInit() {
-  return T();
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- *  This section contains generic SWIG labels for method/variable
- *  declarations/attributes, and other compiler dependent labels.
- * ----------------------------------------------------------------------------- */
-
-/* template workaround for compilers that cannot correctly implement the C++ standard */
-#ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# elif defined(__HP_aCC)
-/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
-/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# else
-#  define SWIGTEMPLATEDISAMBIGUATOR
-# endif
-#endif
-
-/* inline attribute */
-#ifndef SWIGINLINE
-# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
-#   define SWIGINLINE inline
-# else
-#   define SWIGINLINE
-# endif
-#endif
-
-/* attribute recognised by some compilers to avoid 'unused' warnings */
-#ifndef SWIGUNUSED
-# if defined(__GNUC__)
-#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
-#     define SWIGUNUSED __attribute__ ((__unused__)) 
-#   else
-#     define SWIGUNUSED
-#   endif
-# elif defined(__ICC)
-#   define SWIGUNUSED __attribute__ ((__unused__)) 
-# else
-#   define SWIGUNUSED 
-# endif
-#endif
-
-#ifndef SWIG_MSC_UNSUPPRESS_4505
-# if defined(_MSC_VER)
-#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
-# endif 
-#endif
-
-#ifndef SWIGUNUSEDPARM
-# ifdef __cplusplus
-#   define SWIGUNUSEDPARM(p)
-# else
-#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
-# endif
-#endif
-
-/* internal SWIG method */
-#ifndef SWIGINTERN
-# define SWIGINTERN static SWIGUNUSED
-#endif
-
-/* internal inline SWIG method */
-#ifndef SWIGINTERNINLINE
-# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/* exporting methods */
-#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
-#  ifndef GCC_HASCLASSVISIBILITY
-#    define GCC_HASCLASSVISIBILITY
-#  endif
-#endif
-
-#ifndef SWIGEXPORT
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   if defined(STATIC_LINKED)
-#     define SWIGEXPORT
-#   else
-#     define SWIGEXPORT __declspec(dllexport)
-#   endif
-# else
-#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
-#     define SWIGEXPORT __attribute__ ((visibility("default")))
-#   else
-#     define SWIGEXPORT
-#   endif
-# endif
-#endif
-
-/* calling conventions for Windows */
-#ifndef SWIGSTDCALL
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   define SWIGSTDCALL __stdcall
-# else
-#   define SWIGSTDCALL
-# endif 
-#endif
-
-/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
-#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
-# define _CRT_SECURE_NO_DEPRECATE
-#endif
-
-/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
-#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
-# define _SCL_SECURE_NO_DEPRECATE
-#endif
-
-
-
-/* Python.h has to appear first */
-#include <Python.h>
-
-/* -----------------------------------------------------------------------------
- * swigrun.swg
- *
- * This file contains generic C API SWIG runtime support for pointer
- * type checking.
- * ----------------------------------------------------------------------------- */
-
-/* This should only be incremented when either the layout of swig_type_info changes,
-   or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION "4"
-
-/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
-#ifdef SWIG_TYPE_TABLE
-# define SWIG_QUOTE_STRING(x) #x
-# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
-# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
-#else
-# define SWIG_TYPE_TABLE_NAME
-#endif
-
-/*
-  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
-  creating a static or dynamic library from the SWIG runtime code.
-  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
-  
-  But only do this if strictly necessary, ie, if you have problems
-  with your compiler or suchlike.
-*/
-
-#ifndef SWIGRUNTIME
-# define SWIGRUNTIME SWIGINTERN
-#endif
-
-#ifndef SWIGRUNTIMEINLINE
-# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
-#endif
-
-/*  Generic buffer size */
-#ifndef SWIG_BUFFER_SIZE
-# define SWIG_BUFFER_SIZE 1024
-#endif
-
-/* Flags for pointer conversions */
-#define SWIG_POINTER_DISOWN        0x1
-#define SWIG_CAST_NEW_MEMORY       0x2
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_OWN           0x1
-
-
-/* 
-   Flags/methods for returning states.
-   
-   The SWIG conversion methods, as ConvertPtr, return an integer 
-   that tells if the conversion was successful or not. And if not,
-   an error code can be returned (see swigerrors.swg for the codes).
-   
-   Use the following macros/flags to set or process the returning
-   states.
-   
-   In old versions of SWIG, code such as the following was usually written:
-
-     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
-       // success code
-     } else {
-       //fail code
-     }
-
-   Now you can be more explicit:
-
-    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-    } else {
-      // fail code
-    }
-
-   which is the same really, but now you can also do
-
-    Type *ptr;
-    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-      if (SWIG_IsNewObj(res) {
-        ...
-	delete *ptr;
-      } else {
-        ...
-      }
-    } else {
-      // fail code
-    }
-    
-   I.e., now SWIG_ConvertPtr can return new objects and you can
-   identify the case and take care of the deallocation. Of course that
-   also requires SWIG_ConvertPtr to return new result values, such as
-
-      int SWIG_ConvertPtr(obj, ptr,...) {         
-        if (<obj is ok>) {			       
-          if (<need new object>) {		       
-            *ptr = <ptr to new allocated object>; 
-            return SWIG_NEWOBJ;		       
-          } else {				       
-            *ptr = <ptr to old object>;	       
-            return SWIG_OLDOBJ;		       
-          } 				       
-        } else {				       
-          return SWIG_BADOBJ;		       
-        }					       
-      }
-
-   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
-   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
-   SWIG errors code.
-
-   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
-
-       int food(double)
-       int fooi(int);
-
-   and you call
- 
-      food(1)   // cast rank '1'  (1 -> 1.0)
-      fooi(1)   // cast rank '0'
-
-   just use the SWIG_AddCast()/SWIG_CheckState()
-*/
-
-#define SWIG_OK                    (0) 
-#define SWIG_ERROR                 (-1)
-#define SWIG_IsOK(r)               (r >= 0)
-#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
-
-/* The CastRankLimit says how many bits are used for the cast rank */
-#define SWIG_CASTRANKLIMIT         (1 << 8)
-/* The NewMask denotes the object was created (using new/malloc) */
-#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
-/* The TmpMask is for in/out typemaps that use temporal objects */
-#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
-/* Simple returning values */
-#define SWIG_BADOBJ                (SWIG_ERROR)
-#define SWIG_OLDOBJ                (SWIG_OK)
-#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
-#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
-#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
-#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
-#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
-#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
-#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
-#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
-
-/* Cast-Rank Mode */
-#if defined(SWIG_CASTRANK_MODE)
-#  ifndef SWIG_TypeRank
-#    define SWIG_TypeRank             unsigned long
-#  endif
-#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
-#    define SWIG_MAXCASTRANK          (2)
-#  endif
-#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
-#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
-SWIGINTERNINLINE int SWIG_AddCast(int r) { 
-  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
-}
-SWIGINTERNINLINE int SWIG_CheckState(int r) { 
-  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
-}
-#else /* no cast-rank mode */
-#  define SWIG_AddCast(r) (r)
-#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
-#endif
-
-
-#include <string.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef void *(*swig_converter_func)(void *, int *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-/* Structure to store information on one type */
-typedef struct swig_type_info {
-  const char             *name;			/* mangled name of this type */
-  const char             *str;			/* human readable name of this type */
-  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
-  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
-  void                   *clientdata;		/* language specific type data */
-  int                    owndata;		/* flag if the structure owns the clientdata */
-} swig_type_info;
-
-/* Structure to store a type and conversion function used for casting */
-typedef struct swig_cast_info {
-  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
-  swig_converter_func     converter;		/* function to cast the void pointers */
-  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
-  struct swig_cast_info  *prev;			/* pointer to the previous cast */
-} swig_cast_info;
-
-/* Structure used to store module information
- * Each module generates one structure like this, and the runtime collects
- * all of these structures and stores them in a circularly linked list.*/
-typedef struct swig_module_info {
-  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
-  size_t                 size;		        /* Number of types in this module */
-  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
-  swig_type_info         **type_initial;	/* Array of initially generated type structures */
-  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
-  void                    *clientdata;		/* Language specific module data */
-} swig_module_info;
-
-/* 
-  Compare two type names skipping the space characters, therefore
-  "char*" == "char *" and "Class<int>" == "Class<int >", etc.
-
-  Return 0 when the two name types are equivalent, as in
-  strncmp, but skipping ' '.
-*/
-SWIGRUNTIME int
-SWIG_TypeNameComp(const char *f1, const char *l1,
-		  const char *f2, const char *l2) {
-  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
-    while ((*f1 == ' ') && (f1 != l1)) ++f1;
-    while ((*f2 == ' ') && (f2 != l2)) ++f2;
-    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
-  }
-  return (int)((l1 - f1) - (l2 - f2));
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
-*/
-SWIGRUNTIME int
-SWIG_TypeCmp(const char *nb, const char *tb) {
-  int equiv = 1;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (equiv != 0 && *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if not equal, 1 if equal
-*/
-SWIGRUNTIME int
-SWIG_TypeEquiv(const char *nb, const char *tb) {
-  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
-}
-
-/*
-  Check the typename
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheck(const char *c, swig_type_info *ty) {
-  if (ty) {
-    swig_cast_info *iter = ty->cast;
-    while (iter) {
-      if (strcmp(iter->type->name, c) == 0) {
-        if (iter == ty->cast)
-          return iter;
-        /* Move iter to the top of the linked list */
-        iter->prev->next = iter->next;
-        if (iter->next)
-          iter->next->prev = iter->prev;
-        iter->next = ty->cast;
-        iter->prev = 0;
-        if (ty->cast) ty->cast->prev = iter;
-        ty->cast = iter;
-        return iter;
-      }
-      iter = iter->next;
-    }
-  }
-  return 0;
-}
-
-/* 
-  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
-  if (ty) {
-    swig_cast_info *iter = ty->cast;
-    while (iter) {
-      if (iter->type == from) {
-        if (iter == ty->cast)
-          return iter;
-        /* Move iter to the top of the linked list */
-        iter->prev->next = iter->next;
-        if (iter->next)
-          iter->next->prev = iter->prev;
-        iter->next = ty->cast;
-        iter->prev = 0;
-        if (ty->cast) ty->cast->prev = iter;
-        ty->cast = iter;
-        return iter;
-      }
-      iter = iter->next;
-    }
-  }
-  return 0;
-}
-
-/*
-  Cast a pointer up an inheritance hierarchy
-*/
-SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
-  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
-}
-
-/* 
-   Dynamic pointer casting. Down an inheritance hierarchy
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty->dcast) return ty;
-  while (ty && (ty->dcast)) {
-    ty = (*ty->dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/*
-  Return the name associated with this type
-*/
-SWIGRUNTIMEINLINE const char *
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty->name;
-}
-
-/*
-  Return the pretty name associated with this type,
-  that is an unmangled type name in a form presentable to the user.
-*/
-SWIGRUNTIME const char *
-SWIG_TypePrettyName(const swig_type_info *type) {
-  /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
-  if (!type) return NULL;
-  if (type->str != NULL) {
-    const char *last_name = type->str;
-    const char *s;
-    for (s = type->str; *s; s++)
-      if (*s == '|') last_name = s+1;
-    return last_name;
-  }
-  else
-    return type->name;
-}
-
-/* 
-   Set the clientdata field for a type
-*/
-SWIGRUNTIME void
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  swig_cast_info *cast = ti->cast;
-  /* if (ti->clientdata == clientdata) return; */
-  ti->clientdata = clientdata;
-  
-  while (cast) {
-    if (!cast->converter) {
-      swig_type_info *tc = cast->type;
-      if (!tc->clientdata) {
-	SWIG_TypeClientData(tc, clientdata);
-      }
-    }    
-    cast = cast->next;
-  }
-}
-SWIGRUNTIME void
-SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
-  SWIG_TypeClientData(ti, clientdata);
-  ti->owndata = 1;
-}
-  
-/*
-  Search for a swig_type_info structure only by mangled name
-  Search is a O(log #types)
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_MangledTypeQueryModule(swig_module_info *start, 
-                            swig_module_info *end, 
-		            const char *name) {
-  swig_module_info *iter = start;
-  do {
-    if (iter->size) {
-      register size_t l = 0;
-      register size_t r = iter->size - 1;
-      do {
-	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
-	register size_t i = (l + r) >> 1; 
-	const char *iname = iter->types[i]->name;
-	if (iname) {
-	  register int compare = strcmp(name, iname);
-	  if (compare == 0) {	    
-	    return iter->types[i];
-	  } else if (compare < 0) {
-	    if (i) {
-	      r = i - 1;
-	    } else {
-	      break;
-	    }
-	  } else if (compare > 0) {
-	    l = i + 1;
-	  }
-	} else {
-	  break; /* should never happen */
-	}
-      } while (l <= r);
-    }
-    iter = iter->next;
-  } while (iter != end);
-  return 0;
-}
-
-/*
-  Search for a swig_type_info structure for either a mangled name or a human readable name.
-  It first searches the mangled names of the types, which is a O(log #types)
-  If a type is not found it then searches the human readable names, which is O(#types).
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeQueryModule(swig_module_info *start, 
-                     swig_module_info *end, 
-		     const char *name) {
-  /* STEP 1: Search the name field using binary search */
-  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
-  if (ret) {
-    return ret;
-  } else {
-    /* STEP 2: If the type hasn't been found, do a complete search
-       of the str field (the human readable name) */
-    swig_module_info *iter = start;
-    do {
-      register size_t i = 0;
-      for (; i < iter->size; ++i) {
-	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
-	  return iter->types[i];
-      }
-      iter = iter->next;
-    } while (iter != end);
-  }
-  
-  /* neither found a match */
-  return 0;
-}
-
-/* 
-   Pack binary data into a string
-*/
-SWIGRUNTIME char *
-SWIG_PackData(char *c, void *ptr, size_t sz) {
-  static const char hex[17] = "0123456789abcdef";
-  register const unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu =  u + sz;
-  for (; u != eu; ++u) {
-    register unsigned char uu = *u;
-    *(c++) = hex[(uu & 0xf0) >> 4];
-    *(c++) = hex[uu & 0xf];
-  }
-  return c;
-}
-
-/* 
-   Unpack binary data from a string
-*/
-SWIGRUNTIME const char *
-SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
-  register unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu = u + sz;
-  for (; u != eu; ++u) {
-    register char d = *(c++);
-    register unsigned char uu;
-    if ((d >= '0') && (d <= '9'))
-      uu = ((d - '0') << 4);
-    else if ((d >= 'a') && (d <= 'f'))
-      uu = ((d - ('a'-10)) << 4);
-    else 
-      return (char *) 0;
-    d = *(c++);
-    if ((d >= '0') && (d <= '9'))
-      uu |= (d - '0');
-    else if ((d >= 'a') && (d <= 'f'))
-      uu |= (d - ('a'-10));
-    else 
-      return (char *) 0;
-    *u = uu;
-  }
-  return c;
-}
-
-/* 
-   Pack 'void *' into a string buffer.
-*/
-SWIGRUNTIME char *
-SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
-  char *r = buff;
-  if ((2*sizeof(void *) + 2) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,&ptr,sizeof(void *));
-  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
-  strcpy(r,name);
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      *ptr = (void *) 0;
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sizeof(void *));
-}
-
-SWIGRUNTIME char *
-SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
-  char *r = buff;
-  size_t lname = (name ? strlen(name) : 0);
-  if ((2*sz + 2 + lname) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  if (lname) {
-    strncpy(r,name,lname+1);
-  } else {
-    *r = 0;
-  }
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      memset(ptr,0,sz);
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sz);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-/*  Errors in SWIG */
-#define  SWIG_UnknownError    	   -1 
-#define  SWIG_IOError        	   -2 
-#define  SWIG_RuntimeError   	   -3 
-#define  SWIG_IndexError     	   -4 
-#define  SWIG_TypeError      	   -5 
-#define  SWIG_DivisionByZero 	   -6 
-#define  SWIG_OverflowError  	   -7 
-#define  SWIG_SyntaxError    	   -8 
-#define  SWIG_ValueError     	   -9 
-#define  SWIG_SystemError    	   -10
-#define  SWIG_AttributeError 	   -11
-#define  SWIG_MemoryError    	   -12 
-#define  SWIG_NullReferenceError   -13
-
-
-
-/* Compatibility macros for Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-
-#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
-#define PyInt_Check(x) PyLong_Check(x)
-#define PyInt_AsLong(x) PyLong_AsLong(x)
-#define PyInt_FromLong(x) PyLong_FromLong(x)
-#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
-#define PyString_Check(name) PyBytes_Check(name)
-#define PyString_FromString(x) PyUnicode_FromString(x)
-#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
-#define PyString_AsString(str) PyBytes_AsString(str)
-#define PyString_Size(str) PyBytes_Size(str)	
-#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
-#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
-#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
-
-#endif
-
-#ifndef Py_TYPE
-#  define Py_TYPE(op) ((op)->ob_type)
-#endif
-
-/* SWIG APIs for compatibility of both Python 2 & 3 */
-
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
-#else
-#  define SWIG_Python_str_FromFormat PyString_FromFormat
-#endif
-
-
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
-SWIGINTERN char*
-SWIG_Python_str_AsChar(PyObject *str)
-{
-#if PY_VERSION_HEX >= 0x03000000
-  char *cstr;
-  char *newstr;
-  Py_ssize_t len;
-  str = PyUnicode_AsUTF8String(str);
-  PyBytes_AsStringAndSize(str, &cstr, &len);
-  newstr = (char *) malloc(len+1);
-  memcpy(newstr, cstr, len+1);
-  Py_XDECREF(str);
-  return newstr;
-#else
-  return PyString_AsString(str);
-#endif
-}
-
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#else
-#  define SWIG_Python_str_DelForPy3(x) 
-#endif
-
-
-SWIGINTERN PyObject*
-SWIG_Python_str_FromChar(const char *c)
-{
-#if PY_VERSION_HEX >= 0x03000000
-  return PyUnicode_FromString(c); 
-#else
-  return PyString_FromString(c);
-#endif
-}
-
-/* Add PyOS_snprintf for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
-#  define PyOS_snprintf _snprintf
-# else
-#  define PyOS_snprintf snprintf
-# endif
-#endif
-
-/* A crude PyString_FromFormat implementation for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-
-#ifndef SWIG_PYBUFFER_SIZE
-# define SWIG_PYBUFFER_SIZE 1024
-#endif
-
-static PyObject *
-PyString_FromFormat(const char *fmt, ...) {
-  va_list ap;
-  char buf[SWIG_PYBUFFER_SIZE * 2];
-  int res;
-  va_start(ap, fmt);
-  res = vsnprintf(buf, sizeof(buf), fmt, ap);
-  va_end(ap);
-  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
-}
-#endif
-
-/* Add PyObject_Del for old Pythons */
-#if PY_VERSION_HEX < 0x01060000
-# define PyObject_Del(op) PyMem_DEL((op))
-#endif
-#ifndef PyObject_DEL
-# define PyObject_DEL PyObject_Del
-#endif
-
-/* A crude PyExc_StopIteration exception for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-# ifndef PyExc_StopIteration
-#  define PyExc_StopIteration PyExc_RuntimeError
-# endif
-# ifndef PyObject_GenericGetAttr
-#  define PyObject_GenericGetAttr 0
-# endif
-#endif
-
-/* Py_NotImplemented is defined in 2.1 and up. */
-#if PY_VERSION_HEX < 0x02010000
-# ifndef Py_NotImplemented
-#  define Py_NotImplemented PyExc_RuntimeError
-# endif
-#endif
-
-/* A crude PyString_AsStringAndSize implementation for old Pythons */
-#if PY_VERSION_HEX < 0x02010000
-# ifndef PyString_AsStringAndSize
-#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
-# endif
-#endif
-
-/* PySequence_Size for old Pythons */
-#if PY_VERSION_HEX < 0x02000000
-# ifndef PySequence_Size
-#  define PySequence_Size PySequence_Length
-# endif
-#endif
-
-/* PyBool_FromLong for old Pythons */
-#if PY_VERSION_HEX < 0x02030000
-static
-PyObject *PyBool_FromLong(long ok)
-{
-  PyObject *result = ok ? Py_True : Py_False;
-  Py_INCREF(result);
-  return result;
-}
-#endif
-
-/* Py_ssize_t for old Pythons */
-/* This code is as recommended by: */
-/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
-#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
-typedef int Py_ssize_t;
-# define PY_SSIZE_T_MAX INT_MAX
-# define PY_SSIZE_T_MIN INT_MIN
-typedef inquiry lenfunc;
-typedef intargfunc ssizeargfunc;
-typedef intintargfunc ssizessizeargfunc;
-typedef intobjargproc ssizeobjargproc;
-typedef intintobjargproc ssizessizeobjargproc;
-typedef getreadbufferproc readbufferproc;
-typedef getwritebufferproc writebufferproc;
-typedef getsegcountproc segcountproc;
-typedef getcharbufferproc charbufferproc;
-static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
-{
-  long result = 0;
-  PyObject *i = PyNumber_Int(x);
-  if (i) {
-    result = PyInt_AsLong(i);
-    Py_DECREF(i);
-  }
-  return result;
-}
-#endif
-
-#if PY_VERSION_HEX < 0x02050000
-#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
-#endif
-
-#if PY_VERSION_HEX < 0x02040000
-#define Py_VISIT(op)				\
-  do { 						\
-    if (op) {					\
-      int vret = visit((op), arg);		\
-      if (vret)					\
-        return vret;				\
-    }						\
-  } while (0)
-#endif
-
-#if PY_VERSION_HEX < 0x02030000
-typedef struct {
-  PyTypeObject type;
-  PyNumberMethods as_number;
-  PyMappingMethods as_mapping;
-  PySequenceMethods as_sequence;
-  PyBufferProcs as_buffer;
-  PyObject *name, *slots;
-} PyHeapTypeObject;
-#endif
-
-#if PY_VERSION_HEX < 0x02030000
-typedef destructor freefunc;
-#endif
-
-#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
-     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
-     (PY_MAJOR_VERSION > 3))
-# define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
-#endif
-
-#if PY_VERSION_HEX < 0x03020000
-#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
-#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
-#endif
-
-/* -----------------------------------------------------------------------------
- * error manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIME PyObject*
-SWIG_Python_ErrorType(int code) {
-  PyObject* type = 0;
-  switch(code) {
-  case SWIG_MemoryError:
-    type = PyExc_MemoryError;
-    break;
-  case SWIG_IOError:
-    type = PyExc_IOError;
-    break;
-  case SWIG_RuntimeError:
-    type = PyExc_RuntimeError;
-    break;
-  case SWIG_IndexError:
-    type = PyExc_IndexError;
-    break;
-  case SWIG_TypeError:
-    type = PyExc_TypeError;
-    break;
-  case SWIG_DivisionByZero:
-    type = PyExc_ZeroDivisionError;
-    break;
-  case SWIG_OverflowError:
-    type = PyExc_OverflowError;
-    break;
-  case SWIG_SyntaxError:
-    type = PyExc_SyntaxError;
-    break;
-  case SWIG_ValueError:
-    type = PyExc_ValueError;
-    break;
-  case SWIG_SystemError:
-    type = PyExc_SystemError;
-    break;
-  case SWIG_AttributeError:
-    type = PyExc_AttributeError;
-    break;
-  default:
-    type = PyExc_RuntimeError;
-  }
-  return type;
-}
-
-
-SWIGRUNTIME void
-SWIG_Python_AddErrorMsg(const char* mesg)
-{
-  PyObject *type = 0;
-  PyObject *value = 0;
-  PyObject *traceback = 0;
-
-  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
-  if (value) {
-    char *tmp;
-    PyObject *old_str = PyObject_Str(value);
-    PyErr_Clear();
-    Py_XINCREF(type);
-
-    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
-    SWIG_Python_str_DelForPy3(tmp);
-    Py_DECREF(old_str);
-    Py_DECREF(value);
-  } else {
-    PyErr_SetString(PyExc_RuntimeError, mesg);
-  }
-}
-
-#if defined(SWIG_PYTHON_NO_THREADS)
-#  if defined(SWIG_PYTHON_THREADS)
-#    undef SWIG_PYTHON_THREADS
-#  endif
-#endif
-#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
-#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
-#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
-#      define SWIG_PYTHON_USE_GIL
-#    endif
-#  endif
-#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
-#    endif
-#    ifdef __cplusplus /* C++ code */
-       class SWIG_Python_Thread_Block {
-         bool status;
-         PyGILState_STATE state;
-       public:
-         void end() { if (status) { PyGILState_Release(state); status = false;} }
-         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
-         ~SWIG_Python_Thread_Block() { end(); }
-       };
-       class SWIG_Python_Thread_Allow {
-         bool status;
-         PyThreadState *save;
-       public:
-         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
-         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
-         ~SWIG_Python_Thread_Allow() { end(); }
-       };
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
-#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
-#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
-#    else /* C code */
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
-#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
-#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
-#    endif
-#  else /* Old thread way, not implemented, user must provide it */
-#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
-#      define SWIG_PYTHON_INITIALIZE_THREADS
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
-#      define SWIG_PYTHON_THREAD_END_BLOCK
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
-#      define SWIG_PYTHON_THREAD_END_ALLOW
-#    endif
-#  endif
-#else /* No thread support */
-#  define SWIG_PYTHON_INITIALIZE_THREADS
-#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
-#  define SWIG_PYTHON_THREAD_END_BLOCK
-#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
-#  define SWIG_PYTHON_THREAD_END_ALLOW
-#endif
-
-/* -----------------------------------------------------------------------------
- * Python API portion that goes into the runtime
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* -----------------------------------------------------------------------------
- * Constant declarations
- * ----------------------------------------------------------------------------- */
-
-/* Constant Types */
-#define SWIG_PY_POINTER 4
-#define SWIG_PY_BINARY  5
-
-/* Constant information structure */
-typedef struct swig_const_info {
-  int type;
-  char *name;
-  long lvalue;
-  double dvalue;
-  void   *pvalue;
-  swig_type_info **ptype;
-} swig_const_info;
-
-
-/* -----------------------------------------------------------------------------
- * Wrapper of PyInstanceMethod_New() used in Python 3
- * It is exported to the generated module, used for -fastproxy
- * ----------------------------------------------------------------------------- */
-#if PY_VERSION_HEX >= 0x03000000
-SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
-{
-  return PyInstanceMethod_New(func);
-}
-#else
-SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
-{
-  return NULL;
-}
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/* -----------------------------------------------------------------------------
- * pyrun.swg
- *
- * This file contains the runtime support for Python modules
- * and includes code for managing global variables and pointer
- * type checking.
- *
- * ----------------------------------------------------------------------------- */
-
-/* Common SWIG API */
-
-/* for raw pointers */
-#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
-#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
-#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
-
-#ifdef SWIGPYTHON_BUILTIN
-#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
-#else
-#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
-#endif
-
-#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
-
-#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
-#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
-#define swig_owntype                                    int
-
-/* for raw packed data */
-#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
-#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
-
-/* for class or struct pointers */
-#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
-#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
-
-/* for C or C++ function pointers */
-#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
-#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)
-
-/* for C++ member pointers, ie, member methods */
-#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
-#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
-
-
-/* Runtime API */
-
-#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
-#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
-#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)
-
-#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
-#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
-#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
-#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
-#define SWIG_fail                        		goto fail					   
-
-
-/* Runtime API implementation */
-
-/* Error manipulation */
-
-SWIGINTERN void 
-SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
-  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
-  PyErr_SetObject(errtype, obj);
-  Py_DECREF(obj);
-  SWIG_PYTHON_THREAD_END_BLOCK;
-}
-
-SWIGINTERN void 
-SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
-  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
-  PyErr_SetString(errtype, msg);
-  SWIG_PYTHON_THREAD_END_BLOCK;
-}
-
-#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)
-
-/* Set a constant value */
-
-#if defined(SWIGPYTHON_BUILTIN)
-
-SWIGINTERN void
-SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
-  PyObject *s = PyString_InternFromString(key);
-  PyList_Append(seq, s);
-  Py_DECREF(s);
-}
-
-SWIGINTERN void
-SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
-#if PY_VERSION_HEX < 0x02030000
-  PyDict_SetItemString(d, (char *)name, obj);
-#else
-  PyDict_SetItemString(d, name, obj);
-#endif
-  Py_DECREF(obj);
-  if (public_interface)
-    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
-}
-
-#else
-
-SWIGINTERN void
-SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
-#if PY_VERSION_HEX < 0x02030000
-  PyDict_SetItemString(d, (char *)name, obj);
-#else
-  PyDict_SetItemString(d, name, obj);
-#endif
-  Py_DECREF(obj);                            
-}
-
-#endif
-
-/* Append a value to the result obj */
-
-SWIGINTERN PyObject*
-SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
-#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
-  if (!result) {
-    result = obj;
-  } else if (result == Py_None) {
-    Py_DECREF(result);
-    result = obj;
-  } else {
-    if (!PyList_Check(result)) {
-      PyObject *o2 = result;
-      result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
-    }
-    PyList_Append(result,obj);
-    Py_DECREF(obj);
-  }
-  return result;
-#else
-  PyObject*   o2;
-  PyObject*   o3;
-  if (!result) {
-    result = obj;
-  } else if (result == Py_None) {
-    Py_DECREF(result);
-    result = obj;
-  } else {
-    if (!PyTuple_Check(result)) {
-      o2 = result;
-      result = PyTuple_New(1);
-      PyTuple_SET_ITEM(result, 0, o2);
-    }
-    o3 = PyTuple_New(1);
-    PyTuple_SET_ITEM(o3, 0, obj);
-    o2 = result;
-    result = PySequence_Concat(o2, o3);
-    Py_DECREF(o2);
-    Py_DECREF(o3);
-  }
-  return result;
-#endif
-}
-
-/* Unpack the argument tuple */
-
-SWIGINTERN int
-SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
-{
-  if (!args) {
-    if (!min && !max) {
-      return 1;
-    } else {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
-		   name, (min == max ? "" : "at least "), (int)min);
-      return 0;
-    }
-  }  
-  if (!PyTuple_Check(args)) {
-    if (min <= 1 && max >= 1) {
-      register int i;
-      objs[0] = args;
-      for (i = 1; i < max; ++i) {
-	objs[i] = 0;
-      }
-      return 2;
-    }
-    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
-    return 0;
-  } else {
-    register Py_ssize_t l = PyTuple_GET_SIZE(args);
-    if (l < min) {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at least "), (int)min, (int)l);
-      return 0;
-    } else if (l > max) {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at most "), (int)max, (int)l);
-      return 0;
-    } else {
-      register int i;
-      for (i = 0; i < l; ++i) {
-	objs[i] = PyTuple_GET_ITEM(args, i);
-      }
-      for (; l < max; ++l) {
-	objs[l] = 0;
-      }
-      return i + 1;
-    }    
-  }
-}
-
-/* A functor is a function object with one single object argument */
-#if PY_VERSION_HEX >= 0x02020000
-#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
-#else
-#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
-#endif
-
-/*
-  Helper for static pointer initialization for both C and C++ code, for example
-  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
-*/
-#ifdef __cplusplus
-#define SWIG_STATIC_POINTER(var)  var
-#else
-#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
-#endif
-
-/* -----------------------------------------------------------------------------
- * Pointer declarations
- * ----------------------------------------------------------------------------- */
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
-#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
-
-#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)
-
-#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
-#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*  How to access Py_None */
-#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#  ifndef SWIG_PYTHON_NO_BUILD_NONE
-#    ifndef SWIG_PYTHON_BUILD_NONE
-#      define SWIG_PYTHON_BUILD_NONE
-#    endif
-#  endif
-#endif
-
-#ifdef SWIG_PYTHON_BUILD_NONE
-#  ifdef Py_None
-#   undef Py_None
-#   define Py_None SWIG_Py_None()
-#  endif
-SWIGRUNTIMEINLINE PyObject * 
-_SWIG_Py_None(void)
-{
-  PyObject *none = Py_BuildValue((char*)"");
-  Py_DECREF(none);
-  return none;
-}
-SWIGRUNTIME PyObject * 
-SWIG_Py_None(void)
-{
-  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
-  return none;
-}
-#endif
-
-/* The python void return value */
-
-SWIGRUNTIMEINLINE PyObject * 
-SWIG_Py_Void(void)
-{
-  PyObject *none = Py_None;
-  Py_INCREF(none);
-  return none;
-}
-
-/* SwigPyClientData */
-
-typedef struct {
-  PyObject *klass;
-  PyObject *newraw;
-  PyObject *newargs;
-  PyObject *destroy;
-  int delargs;
-  int implicitconv;
-  PyTypeObject *pytype;
-} SwigPyClientData;
-
-SWIGRUNTIMEINLINE int 
-SWIG_Python_CheckImplicit(swig_type_info *ty)
-{
-  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
-  return data ? data->implicitconv : 0;
-}
-
-SWIGRUNTIMEINLINE PyObject *
-SWIG_Python_ExceptionType(swig_type_info *desc) {
-  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
-  PyObject *klass = data ? data->klass : 0;
-  return (klass ? klass : PyExc_RuntimeError);
-}
-
-
-SWIGRUNTIME SwigPyClientData * 
-SwigPyClientData_New(PyObject* obj)
-{
-  if (!obj) {
-    return 0;
-  } else {
-    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
-    /* the klass element */
-    data->klass = obj;
-    Py_INCREF(data->klass);
-    /* the newraw method and newargs arguments used to create a new raw instance */
-    if (PyClass_Check(obj)) {
-      data->newraw = 0;
-      data->newargs = obj;
-      Py_INCREF(obj);
-    } else {
-#if (PY_VERSION_HEX < 0x02020000)
-      data->newraw = 0;
-#else
-      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
-#endif
-      if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
-      } else {
-	data->newargs = obj;
-      }
-      Py_INCREF(data->newargs);
-    }
-    /* the destroy method, aka as the C++ delete method */
-    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      data->destroy = 0;
-    }
-    if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-#ifdef METH_O
-      data->delargs = !(flags & (METH_O));
-#else
-      data->delargs = 0;
-#endif
-    } else {
-      data->delargs = 0;
-    }
-    data->implicitconv = 0;
-    data->pytype = 0;
-    return data;
-  }
-}
-
-SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
-  Py_XDECREF(data->newraw);
-  Py_XDECREF(data->newargs);
-  Py_XDECREF(data->destroy);
-}
-
-/* =============== SwigPyObject =====================*/
-
-typedef struct {
-  PyObject_HEAD
-  void *ptr;
-  swig_type_info *ty;
-  int own;
-  PyObject *next;
-#ifdef SWIGPYTHON_BUILTIN
-  PyObject *dict;
-#endif
-} SwigPyObject;
-
-SWIGRUNTIME PyObject *
-SwigPyObject_long(SwigPyObject *v)
-{
-  return PyLong_FromVoidPtr(v->ptr);
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_format(const char* fmt, SwigPyObject *v)
-{
-  PyObject *res = NULL;
-  PyObject *args = PyTuple_New(1);
-  if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
-      if (ofmt) {
-#if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
-#else
-	res = PyString_Format(ofmt,args);
-#endif
-	Py_DECREF(ofmt);
-      }
-      Py_DECREF(args);
-    }
-  }
-  return res;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_oct(SwigPyObject *v)
-{
-  return SwigPyObject_format("%o",v);
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_hex(SwigPyObject *v)
-{
-  return SwigPyObject_format("%x",v);
-}
-
-SWIGRUNTIME PyObject *
-#ifdef METH_NOARGS
-SwigPyObject_repr(SwigPyObject *v)
-#else
-SwigPyObject_repr(SwigPyObject *v, PyObject *args)
-#endif
-{
-  const char *name = SWIG_TypePrettyName(v->ty);
-  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
-# ifdef METH_NOARGS
-    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
-# else
-    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
-# endif
-# if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
-# else
-    PyString_ConcatAndDel(&repr,nrep);
-# endif
-  }
-  return repr;  
-}
-
-SWIGRUNTIME int
-SwigPyObject_print(SwigPyObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))
-{
-  char *str;
-#ifdef METH_NOARGS
-  PyObject *repr = SwigPyObject_repr(v);
-#else
-  PyObject *repr = SwigPyObject_repr(v, NULL);
-#endif
-  if (repr) {
-    str = SWIG_Python_str_AsChar(repr); 
-    fputs(str, fp);
-    SWIG_Python_str_DelForPy3(str);
-    Py_DECREF(repr);
-    return 0; 
-  } else {
-    return 1; 
-  }
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_str(SwigPyObject *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  return SWIG_PackVoidPtr(result, v->ptr, v->ty->name, sizeof(result)) ?
-    SWIG_Python_str_FromChar(result) : 0;
-}
-
-SWIGRUNTIME int
-SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
-{
-  void *i = v->ptr;
-  void *j = w->ptr;
-  return (i < j) ? -1 : ((i > j) ? 1 : 0);
-}
-
-/* Added for Python 3.x, would it also be useful for Python 2.x? */
-SWIGRUNTIME PyObject*
-SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
-{
-  PyObject* res;
-  if( op != Py_EQ && op != Py_NE ) {
-    Py_INCREF(Py_NotImplemented);
-    return Py_NotImplemented;
-  }
-  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
-  return res;  
-}
-
-
-SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);
-
-#ifdef SWIGPYTHON_BUILTIN
-static swig_type_info *SwigPyObject_stype = 0;
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_type(void) {
-    SwigPyClientData *cd;
-    assert(SwigPyObject_stype);
-    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
-    assert(cd);
-    assert(cd->pytype);
-    return cd->pytype;
-}
-#else
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_type(void) {
-  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
-  return type;
-}
-#endif
-
-SWIGRUNTIMEINLINE int
-SwigPyObject_Check(PyObject *op) {
-#ifdef SWIGPYTHON_BUILTIN
-  PyTypeObject *target_tp = SwigPyObject_type();
-  if (PyType_IsSubtype(op->ob_type, target_tp))
-    return 1;
-  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
-#else
-  return (Py_TYPE(op) == SwigPyObject_type())
-    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
-#endif
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
-
-SWIGRUNTIME void
-SwigPyObject_dealloc(PyObject *v)
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-  PyObject *next = sobj->next;
-  if (sobj->own == SWIG_POINTER_OWN) {
-    swig_type_info *ty = sobj->ty;
-    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
-    PyObject *destroy = data ? data->destroy : 0;
-    if (destroy) {
-      /* destroy is always a VARARGS method */
-      PyObject *res;
-      if (data->delargs) {
-	/* we need to create a temporary object to carry the destroy operation */
-	PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-	res = SWIG_Python_CallFunctor(destroy, tmp);
-	Py_DECREF(tmp);
-      } else {
-	PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
-	PyObject *mself = PyCFunction_GET_SELF(destroy);
-	res = ((*meth)(mself, v));
-      }
-      Py_XDECREF(res);
-    } 
-#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
-    else {
-      const char *name = SWIG_TypePrettyName(ty);
-      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
-    }
-#endif
-  } 
-  Py_XDECREF(next);
-  PyObject_DEL(v);
-}
-
-SWIGRUNTIME PyObject* 
-SwigPyObject_append(PyObject* v, PyObject* next)
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-#ifndef METH_O
-  PyObject *tmp = 0;
-  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
-  next = tmp;
-#endif
-  if (!SwigPyObject_Check(next)) {
-    return NULL;
-  }
-  sobj->next = next;
-  Py_INCREF(next);
-  return SWIG_Py_Void();
-}
-
-SWIGRUNTIME PyObject* 
-#ifdef METH_NOARGS
-SwigPyObject_next(PyObject* v)
-#else
-SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-  if (sobj->next) {    
-    Py_INCREF(sobj->next);
-    return sobj->next;
-  } else {
-    return SWIG_Py_Void();
-  }
-}
-
-SWIGINTERN PyObject*
-#ifdef METH_NOARGS
-SwigPyObject_disown(PyObject *v)
-#else
-SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *)v;
-  sobj->own = 0;
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject*
-#ifdef METH_NOARGS
-SwigPyObject_acquire(PyObject *v)
-#else
-SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *)v;
-  sobj->own = SWIG_POINTER_OWN;
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject*
-SwigPyObject_own(PyObject *v, PyObject *args)
-{
-  PyObject *val = 0;
-#if (PY_VERSION_HEX < 0x02020000)
-  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
-#elif (PY_VERSION_HEX < 0x02050000)
-  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
-#else
-  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
-#endif
-    {
-      return NULL;
-    } 
-  else
-    {
-      SwigPyObject *sobj = (SwigPyObject *)v;
-      PyObject *obj = PyBool_FromLong(sobj->own);
-      if (val) {
-#ifdef METH_NOARGS
-	if (PyObject_IsTrue(val)) {
-	  SwigPyObject_acquire(v);
-	} else {
-	  SwigPyObject_disown(v);
-	}
-#else
-	if (PyObject_IsTrue(val)) {
-	  SwigPyObject_acquire(v,args);
-	} else {
-	  SwigPyObject_disown(v,args);
-	}
-#endif
-      } 
-      return obj;
-    }
-}
-
-#ifdef METH_O
-static PyMethodDef
-swigobject_methods[] = {
-  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
-  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
-  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
-  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
-  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
-  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
-  {0, 0, 0, 0}  
-};
-#else
-static PyMethodDef
-swigobject_methods[] = {
-  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
-  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"aquires ownership of the pointer"},
-  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
-  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
-  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
-  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
-  {0, 0, 0, 0}  
-};
-#endif
-
-#if PY_VERSION_HEX < 0x02020000
-SWIGINTERN PyObject *
-SwigPyObject_getattr(SwigPyObject *sobj,char *name)
-{
-  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
-}
-#endif
-
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_TypeOnce(void) {
-  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";
-
-  static PyNumberMethods SwigPyObject_as_number = {
-    (binaryfunc)0, /*nb_add*/
-    (binaryfunc)0, /*nb_subtract*/
-    (binaryfunc)0, /*nb_multiply*/
-    /* nb_divide removed in Python 3 */
-#if PY_VERSION_HEX < 0x03000000
-    (binaryfunc)0, /*nb_divide*/
-#endif
-    (binaryfunc)0, /*nb_remainder*/
-    (binaryfunc)0, /*nb_divmod*/
-    (ternaryfunc)0,/*nb_power*/
-    (unaryfunc)0,  /*nb_negative*/
-    (unaryfunc)0,  /*nb_positive*/
-    (unaryfunc)0,  /*nb_absolute*/
-    (inquiry)0,    /*nb_nonzero*/
-    0,		   /*nb_invert*/
-    0,		   /*nb_lshift*/
-    0,		   /*nb_rshift*/
-    0,		   /*nb_and*/
-    0,		   /*nb_xor*/
-    0,		   /*nb_or*/
-#if PY_VERSION_HEX < 0x03000000
-    0,   /*nb_coerce*/
-#endif
-    (unaryfunc)SwigPyObject_long, /*nb_int*/
-#if PY_VERSION_HEX < 0x03000000
-    (unaryfunc)SwigPyObject_long, /*nb_long*/
-#else
-    0, /*nb_reserved*/
-#endif
-    (unaryfunc)0,                 /*nb_float*/
-#if PY_VERSION_HEX < 0x03000000
-    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
-    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
-#endif
-#if PY_VERSION_HEX >= 0x03000000 /* 3.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
-#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
-#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
-#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
-    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
-#endif
-  };
-
-  static PyTypeObject swigpyobject_type;
-  static int type_init = 0;
-  if (!type_init) {
-    const PyTypeObject tmp = {
-      /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-      PyVarObject_HEAD_INIT(NULL, 0)
-#else
-      PyObject_HEAD_INIT(NULL)
-      0,                                    /* ob_size */
-#endif
-      (char *)"SwigPyObject",               /* tp_name */
-      sizeof(SwigPyObject),                 /* tp_basicsize */
-      0,                                    /* tp_itemsize */
-      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      (printfunc)SwigPyObject_print,        /* tp_print */
-#if PY_VERSION_HEX < 0x02020000
-      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
-#else
-      (getattrfunc)0,                       /* tp_getattr */
-#endif
-      (setattrfunc)0,                       /* tp_setattr */
-#if PY_VERSION_HEX >= 0x03000000
-    0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
-#else
-      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
-#endif
-      (reprfunc)SwigPyObject_repr,          /* tp_repr */
-      &SwigPyObject_as_number,              /* tp_as_number */
-      0,                                    /* tp_as_sequence */
-      0,                                    /* tp_as_mapping */
-      (hashfunc)0,                          /* tp_hash */
-      (ternaryfunc)0,                       /* tp_call */
-      (reprfunc)SwigPyObject_str,           /* tp_str */
-      PyObject_GenericGetAttr,              /* tp_getattro */
-      0,                                    /* tp_setattro */
-      0,                                    /* tp_as_buffer */
-      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
-      swigobject_doc,                       /* tp_doc */
-      0,                                    /* tp_traverse */
-      0,                                    /* tp_clear */
-      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
-      0,                                    /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-      0,                                    /* tp_iter */
-      0,                                    /* tp_iternext */
-      swigobject_methods,                   /* tp_methods */
-      0,                                    /* tp_members */
-      0,                                    /* tp_getset */
-      0,                                    /* tp_base */
-      0,                                    /* tp_dict */
-      0,                                    /* tp_descr_get */
-      0,                                    /* tp_descr_set */
-      0,                                    /* tp_dictoffset */
-      0,                                    /* tp_init */
-      0,                                    /* tp_alloc */
-      0,                                    /* tp_new */
-      0,                                    /* tp_free */
-      0,                                    /* tp_is_gc */
-      0,                                    /* tp_bases */
-      0,                                    /* tp_mro */
-      0,                                    /* tp_cache */
-      0,                                    /* tp_subclasses */
-      0,                                    /* tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-      0,                                    /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-      0,                                    /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-      0,0,0,0                               /* tp_alloc -> tp_next */
-#endif
-    };
-    swigpyobject_type = tmp;
-    type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-    swigpyobject_type.ob_type = &PyType_Type;
-#else
-    if (PyType_Ready(&swigpyobject_type) < 0)
-      return NULL;
-#endif
-  }
-  return &swigpyobject_type;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
-{
-  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
-  if (sobj) {
-    sobj->ptr  = ptr;
-    sobj->ty   = ty;
-    sobj->own  = own;
-    sobj->next = 0;
-  }
-  return (PyObject *)sobj;
-}
-
-/* -----------------------------------------------------------------------------
- * Implements a simple Swig Packed type, and use it instead of string
- * ----------------------------------------------------------------------------- */
-
-typedef struct {
-  PyObject_HEAD
-  void *pack;
-  swig_type_info *ty;
-  size_t size;
-} SwigPyPacked;
-
-SWIGRUNTIME int
-SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
-{
-  char result[SWIG_BUFFER_SIZE];
-  fputs("<Swig Packed ", fp); 
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    fputs("at ", fp); 
-    fputs(result, fp); 
-  }
-  fputs(v->ty->name,fp); 
-  fputs(">", fp);
-  return 0; 
-}
-  
-SWIGRUNTIME PyObject *
-SwigPyPacked_repr(SwigPyPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
-  } else {
-    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
-  }  
-}
-
-SWIGRUNTIME PyObject *
-SwigPyPacked_str(SwigPyPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
-    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
-  } else {
-    return SWIG_Python_str_FromChar(v->ty->name);
-  }  
-}
-
-SWIGRUNTIME int
-SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
-{
-  size_t i = v->size;
-  size_t j = w->size;
-  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
-  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
-}
-
-SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);
-
-SWIGRUNTIME PyTypeObject*
-SwigPyPacked_type(void) {
-  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
-  return type;
-}
-
-SWIGRUNTIMEINLINE int
-SwigPyPacked_Check(PyObject *op) {
-  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
-    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
-}
-
-SWIGRUNTIME void
-SwigPyPacked_dealloc(PyObject *v)
-{
-  if (SwigPyPacked_Check(v)) {
-    SwigPyPacked *sobj = (SwigPyPacked *) v;
-    free(sobj->pack);
-  }
-  PyObject_DEL(v);
-}
-
-SWIGRUNTIME PyTypeObject*
-SwigPyPacked_TypeOnce(void) {
-  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
-  static PyTypeObject swigpypacked_type;
-  static int type_init = 0;
-  if (!type_init) {
-    const PyTypeObject tmp = {
-      /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX>=0x03000000
-      PyVarObject_HEAD_INIT(NULL, 0)
-#else
-      PyObject_HEAD_INIT(NULL)
-      0,                                    /* ob_size */
-#endif
-      (char *)"SwigPyPacked",               /* tp_name */
-      sizeof(SwigPyPacked),                 /* tp_basicsize */
-      0,                                    /* tp_itemsize */
-      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      (printfunc)SwigPyPacked_print,        /* tp_print */
-      (getattrfunc)0,                       /* tp_getattr */
-      (setattrfunc)0,                       /* tp_setattr */
-#if PY_VERSION_HEX>=0x03000000
-      0, /* tp_reserved in 3.0.1 */
-#else
-      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
-#endif
-      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
-      0,                                    /* tp_as_number */
-      0,                                    /* tp_as_sequence */
-      0,                                    /* tp_as_mapping */
-      (hashfunc)0,                          /* tp_hash */
-      (ternaryfunc)0,                       /* tp_call */
-      (reprfunc)SwigPyPacked_str,           /* tp_str */
-      PyObject_GenericGetAttr,              /* tp_getattro */
-      0,                                    /* tp_setattro */
-      0,                                    /* tp_as_buffer */
-      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
-      swigpacked_doc,                       /* tp_doc */
-      0,                                    /* tp_traverse */
-      0,                                    /* tp_clear */
-      0,                                    /* tp_richcompare */
-      0,                                    /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-      0,                                    /* tp_iter */
-      0,                                    /* tp_iternext */
-      0,                                    /* tp_methods */
-      0,                                    /* tp_members */
-      0,                                    /* tp_getset */
-      0,                                    /* tp_base */
-      0,                                    /* tp_dict */
-      0,                                    /* tp_descr_get */
-      0,                                    /* tp_descr_set */
-      0,                                    /* tp_dictoffset */
-      0,                                    /* tp_init */
-      0,                                    /* tp_alloc */
-      0,                                    /* tp_new */
-      0,                                    /* tp_free */
-      0,                                    /* tp_is_gc */
-      0,                                    /* tp_bases */
-      0,                                    /* tp_mro */
-      0,                                    /* tp_cache */
-      0,                                    /* tp_subclasses */
-      0,                                    /* tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-      0,                                    /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-      0,                                    /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-      0,0,0,0                               /* tp_alloc -> tp_next */
-#endif
-    };
-    swigpypacked_type = tmp;
-    type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-    swigpypacked_type.ob_type = &PyType_Type;
-#else
-    if (PyType_Ready(&swigpypacked_type) < 0)
-      return NULL;
-#endif
-  }
-  return &swigpypacked_type;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
-{
-  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
-  if (sobj) {
-    void *pack = malloc(size);
-    if (pack) {
-      memcpy(pack, ptr, size);
-      sobj->pack = pack;
-      sobj->ty   = ty;
-      sobj->size = size;
-    } else {
-      PyObject_DEL((PyObject *) sobj);
-      sobj = 0;
-    }
-  }
-  return (PyObject *) sobj;
-}
-
-SWIGRUNTIME swig_type_info *
-SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
-{
-  if (SwigPyPacked_Check(obj)) {
-    SwigPyPacked *sobj = (SwigPyPacked *)obj;
-    if (sobj->size != size) return 0;
-    memcpy(ptr, sobj->pack, size);
-    return sobj->ty;
-  } else {
-    return 0;
-  }
-}
-
-/* -----------------------------------------------------------------------------
- * pointers/data manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIMEINLINE PyObject *
-_SWIG_This(void)
-{
-    return SWIG_Python_str_FromChar("this");
-}
-
-static PyObject *swig_this = NULL;
-
-SWIGRUNTIME PyObject *
-SWIG_This(void)
-{
-  if (swig_this == NULL)
-    swig_this = _SWIG_This();
-  return swig_this;
-}
-
-/* #define SWIG_PYTHON_SLOW_GETSET_THIS */
-
-/* TODO: I don't know how to implement the fast getset in Python 3 right now */
-#if PY_VERSION_HEX>=0x03000000
-#define SWIG_PYTHON_SLOW_GETSET_THIS 
-#endif
-
-SWIGRUNTIME SwigPyObject *
-SWIG_Python_GetSwigThis(PyObject *pyobj) 
-{
-  PyObject *obj;
-
-  if (SwigPyObject_Check(pyobj))
-    return (SwigPyObject *) pyobj;
-
-#ifdef SWIGPYTHON_BUILTIN
-  (void)obj;
-# ifdef PyWeakref_CheckProxy
-  if (PyWeakref_CheckProxy(pyobj)) {
-    pyobj = PyWeakref_GET_OBJECT(pyobj);
-    if (pyobj && SwigPyObject_Check(pyobj))
-      return (SwigPyObject*) pyobj;
-  }
-# endif
-  return NULL;
-#else
-
-  obj = 0;
-
-#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
-  if (PyInstance_Check(pyobj)) {
-    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
-  } else {
-    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
-    if (dictptr != NULL) {
-      PyObject *dict = *dictptr;
-      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
-    } else {
-#ifdef PyWeakref_CheckProxy
-      if (PyWeakref_CheckProxy(pyobj)) {
-	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
-	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
-      }
-#endif
-      obj = PyObject_GetAttr(pyobj,SWIG_This());
-      if (obj) {
-	Py_DECREF(obj);
-      } else {
-	if (PyErr_Occurred()) PyErr_Clear();
-	return 0;
-      }
-    }
-  }
-#else
-  obj = PyObject_GetAttr(pyobj,SWIG_This());
-  if (obj) {
-    Py_DECREF(obj);
-  } else {
-    if (PyErr_Occurred()) PyErr_Clear();
-    return 0;
-  }
-#endif
-  if (obj && !SwigPyObject_Check(obj)) {
-    /* a PyObject is called 'this', try to get the 'real this'
-       SwigPyObject from it */ 
-    return SWIG_Python_GetSwigThis(obj);
-  }
-  return (SwigPyObject *)obj;
-#endif
-}
-
-/* Acquire a pointer value */
-
-SWIGRUNTIME int
-SWIG_Python_AcquirePtr(PyObject *obj, int own) {
-  if (own == SWIG_POINTER_OWN) {
-    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
-    if (sobj) {
-      int oldown = sobj->own;
-      sobj->own = own;
-      return oldown;
-    }
-  }
-  return 0;
-}
-
-/* Convert a pointer value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
-  int res;
-  SwigPyObject *sobj;
-
-  if (!obj)
-    return SWIG_ERROR;
-  if (obj == Py_None) {
-    if (ptr)
-      *ptr = 0;
-    return SWIG_OK;
-  }
-
-  res = SWIG_ERROR;
-
-  sobj = SWIG_Python_GetSwigThis(obj);
-  if (own)
-    *own = 0;
-  while (sobj) {
-    void *vptr = sobj->ptr;
-    if (ty) {
-      swig_type_info *to = sobj->ty;
-      if (to == ty) {
-        /* no type cast needed */
-        if (ptr) *ptr = vptr;
-        break;
-      } else {
-        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
-        if (!tc) {
-          sobj = (SwigPyObject *)sobj->next;
-        } else {
-          if (ptr) {
-            int newmemory = 0;
-            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
-            if (newmemory == SWIG_CAST_NEW_MEMORY) {
-              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
-              if (own)
-                *own = *own | SWIG_CAST_NEW_MEMORY;
-            }
-          }
-          break;
-        }
-      }
-    } else {
-      if (ptr) *ptr = vptr;
-      break;
-    }
-  }
-  if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
-    }
-    res = SWIG_OK;
-  } else {
-    if (flags & SWIG_POINTER_IMPLICIT_CONV) {
-      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
-      if (data && !data->implicitconv) {
-        PyObject *klass = data->klass;
-        if (klass) {
-          PyObject *impconv;
-          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
-          impconv = SWIG_Python_CallFunctor(klass, obj);
-          data->implicitconv = 0;
-          if (PyErr_Occurred()) {
-            PyErr_Clear();
-            impconv = 0;
-          }
-          if (impconv) {
-            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
-            if (iobj) {
-              void *vptr;
-              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
-              if (SWIG_IsOK(res)) {
-                if (ptr) {
-                  *ptr = vptr;
-                  /* transfer the ownership to 'ptr' */
-                  iobj->own = 0;
-                  res = SWIG_AddCast(res);
-                  res = SWIG_AddNewMask(res);
-                } else {
-                  res = SWIG_AddCast(res);		    
-                }
-              }
-            }
-            Py_DECREF(impconv);
-          }
-        }
-      }
-    }
-  }
-  return res;
-}
-
-/* Convert a function ptr value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
-  if (!PyCFunction_Check(obj)) {
-    return SWIG_ConvertPtr(obj, ptr, ty, 0);
-  } else {
-    void *vptr = 0;
-    
-    /* here we get the method pointer for callbacks */
-    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
-    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
-    if (desc)
-      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
-    if (!desc) 
-      return SWIG_ERROR;
-    if (ty) {
-      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
-      if (tc) {
-        int newmemory = 0;
-        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
-        assert(!newmemory); /* newmemory handling not yet implemented */
-      } else {
-        return SWIG_ERROR;
-      }
-    } else {
-      *ptr = vptr;
-    }
-    return SWIG_OK;
-  }
-}
-
-/* Convert a packed value value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
-  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
-  if (!to) return SWIG_ERROR;
-  if (ty) {
-    if (to != ty) {
-      /* check type cast? */
-      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
-      if (!tc) return SWIG_ERROR;
-    }
-  }
-  return SWIG_OK;
-}  
-
-/* -----------------------------------------------------------------------------
- * Create a new pointer object
- * ----------------------------------------------------------------------------- */
-
-/*
-  Create a new instance object, without calling __init__, and set the
-  'this' attribute.
-*/
-
-SWIGRUNTIME PyObject* 
-SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
-{
-#if (PY_VERSION_HEX >= 0x02020000)
-  PyObject *inst = 0;
-  PyObject *newraw = data->newraw;
-  if (newraw) {
-    inst = PyObject_Call(newraw, data->newargs, NULL);
-    if (inst) {
-#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
-      PyObject **dictptr = _PyObject_GetDictPtr(inst);
-      if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
-      }
-#else
-      PyObject *key = SWIG_This();
-      PyObject_SetAttr(inst, key, swig_this);
-#endif
-    }
-  } else {
-#if PY_VERSION_HEX >= 0x03000000
-    inst = PyBaseObject_Type.tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
-    if (inst) {
-      PyObject_SetAttr(inst, SWIG_This(), swig_this);
-      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
-    }
-#else
-    PyObject *dict = PyDict_New();
-    if (dict) {
-      PyDict_SetItem(dict, SWIG_This(), swig_this);
-      inst = PyInstance_NewRaw(data->newargs, dict);
-      Py_DECREF(dict);
-    }
-#endif
-  }
-  return inst;
-#else
-#if (PY_VERSION_HEX >= 0x02010000)
-  PyObject *inst = 0;
-  PyObject *dict = PyDict_New();
-  if (dict) {
-    PyDict_SetItem(dict, SWIG_This(), swig_this);
-    inst = PyInstance_NewRaw(data->newargs, dict);
-    Py_DECREF(dict);
-  }
-  return (PyObject *) inst;
-#else
-  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
-  if (inst == NULL) {
-    return NULL;
-  }
-  inst->in_class = (PyClassObject *)data->newargs;
-  Py_INCREF(inst->in_class);
-  inst->in_dict = PyDict_New();
-  if (inst->in_dict == NULL) {
-    Py_DECREF(inst);
-    return NULL;
-  }
-#ifdef Py_TPFLAGS_HAVE_WEAKREFS
-  inst->in_weakreflist = NULL;
-#endif
-#ifdef Py_TPFLAGS_GC
-  PyObject_GC_Init(inst);
-#endif
-  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
-  return (PyObject *) inst;
-#endif
-#endif
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
-{
- PyObject *dict;
-#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
- PyObject **dictptr = _PyObject_GetDictPtr(inst);
- if (dictptr != NULL) {
-   dict = *dictptr;
-   if (dict == NULL) {
-     dict = PyDict_New();
-     *dictptr = dict;
-   }
-   PyDict_SetItem(dict, SWIG_This(), swig_this);
-   return;
- }
-#endif
- dict = PyObject_GetAttrString(inst, (char*)"__dict__");
- PyDict_SetItem(dict, SWIG_This(), swig_this);
- Py_DECREF(dict);
-} 
-
-
-SWIGINTERN PyObject *
-SWIG_Python_InitShadowInstance(PyObject *args) {
-  PyObject *obj[2];
-  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
-    return NULL;
-  } else {
-    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
-    if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
-    } else {
-      SWIG_Python_SetSwigThis(obj[0], obj[1]);
-    }
-    return SWIG_Py_Void();
-  }
-}
-
-/* Create a new pointer object */
-
-SWIGRUNTIME PyObject *
-SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
-  SwigPyClientData *clientdata;
-  PyObject * robj;
-  int own;
-
-  if (!ptr)
-    return SWIG_Py_Void();
-
-  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
-  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
-  if (clientdata && clientdata->pytype) {
-    SwigPyObject *newobj;
-    if (flags & SWIG_BUILTIN_TP_INIT) {
-      newobj = (SwigPyObject*) self;
-      if (newobj->ptr) {
-        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
-        while (newobj->next)
-	  newobj = (SwigPyObject *) newobj->next;
-        newobj->next = next_self;
-        newobj = (SwigPyObject *)next_self;
-      }
-    } else {
-      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
-    }
-    if (newobj) {
-      newobj->ptr = ptr;
-      newobj->ty = type;
-      newobj->own = own;
-      newobj->next = 0;
-#ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
-#endif
-      return (PyObject*) newobj;
-    }
-    return SWIG_Py_Void();
-  }
-
-  assert(!(flags & SWIG_BUILTIN_TP_INIT));
-
-  robj = SwigPyObject_New(ptr, type, own);
-  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
-    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
-    Py_DECREF(robj);
-    robj = inst;
-  }
-  return robj;
-}
-
-/* Create a new packed object */
-
-SWIGRUNTIMEINLINE PyObject *
-SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
-  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
-}
-
-/* -----------------------------------------------------------------------------*
- *  Get type list 
- * -----------------------------------------------------------------------------*/
-
-#ifdef SWIG_LINK_RUNTIME
-void *SWIG_ReturnGlobalTypeList(void *);
-#endif
-
-SWIGRUNTIME swig_module_info *
-SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
-  static void *type_pointer = (void *)0;
-  /* first check if module already created */
-  if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
-    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
-#else
-# ifdef SWIGPY_USE_CAPSULE
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-# else
-    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
-				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
-# endif
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
-  }
-  return (swig_module_info *) type_pointer;
-}
-
-#if PY_MAJOR_VERSION < 2
-/* PyModule_AddObject function was introduced in Python 2.0.  The following function
-   is copied out of Python/modsupport.c in python version 2.3.4 */
-SWIGINTERN int
-PyModule_AddObject(PyObject *m, char *name, PyObject *o)
-{
-  PyObject *dict;
-  if (!PyModule_Check(m)) {
-    PyErr_SetString(PyExc_TypeError,
-		    "PyModule_AddObject() needs module as first arg");
-    return SWIG_ERROR;
-  }
-  if (!o) {
-    PyErr_SetString(PyExc_TypeError,
-		    "PyModule_AddObject() needs non-NULL value");
-    return SWIG_ERROR;
-  }
-  
-  dict = PyModule_GetDict(m);
-  if (dict == NULL) {
-    /* Internal error -- modules must have a dict! */
-    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
-		 PyModule_GetName(m));
-    return SWIG_ERROR;
-  }
-  if (PyDict_SetItemString(dict, name, o))
-    return SWIG_ERROR;
-  Py_DECREF(o);
-  return SWIG_OK;
-}
-#endif
-
-SWIGRUNTIME void
-#ifdef SWIGPY_USE_CAPSULE
-SWIG_Python_DestroyModule(PyObject *obj)
-#else
-SWIG_Python_DestroyModule(void *vptr)
-#endif
-{
-#ifdef SWIGPY_USE_CAPSULE
-  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
-#else
-  swig_module_info *swig_module = (swig_module_info *) vptr;
-#endif
-  swig_type_info **types = swig_module->types;
-  size_t i;
-  for (i =0; i < swig_module->size; ++i) {
-    swig_type_info *ty = types[i];
-    if (ty->owndata) {
-      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
-      if (data) SwigPyClientData_Del(data);
-    }
-  }
-  Py_DECREF(SWIG_This());
-  swig_this = NULL;
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetModule(swig_module_info *swig_module) {
-#if PY_VERSION_HEX >= 0x03000000
- /* Add a dummy module object into sys.modules */
-  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
-#else
-  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
-  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
-#endif
-#ifdef SWIGPY_USE_CAPSULE
-  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
-  if (pointer && module) {
-    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
-  } else {
-    Py_XDECREF(pointer);
-  }
-#else
-  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
-  if (pointer && module) {
-    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
-  } else {
-    Py_XDECREF(pointer);
-  }
-#endif
-}
-
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
-SWIGRUNTIME swig_type_info *
-SWIG_Python_TypeQuery(const char *type)
-{
-  PyObject *cache = SWIG_Python_TypeCache();
-  PyObject *key = SWIG_Python_str_FromChar(type); 
-  PyObject *obj = PyDict_GetItem(cache, key);
-  swig_type_info *descriptor;
-  if (obj) {
-#ifdef SWIGPY_USE_CAPSULE
-    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
-#else
-    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
-#endif
-  } else {
-    swig_module_info *swig_module = SWIG_GetModule(0);
-    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
-    if (descriptor) {
-#ifdef SWIGPY_USE_CAPSULE
-      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-#else
-      obj = PyCObject_FromVoidPtr(descriptor, NULL);
-#endif
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
-    }
-  }
-  Py_DECREF(key);
-  return descriptor;
-}
-
-/* 
-   For backward compatibility only
-*/
-#define SWIG_POINTER_EXCEPTION  0
-#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
-#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
-
-SWIGRUNTIME int
-SWIG_Python_AddErrMesg(const char* mesg, int infront)
-{  
-  if (PyErr_Occurred()) {
-    PyObject *type = 0;
-    PyObject *value = 0;
-    PyObject *traceback = 0;
-    PyErr_Fetch(&type, &value, &traceback);
-    if (value) {
-      char *tmp;
-      PyObject *old_str = PyObject_Str(value);
-      Py_XINCREF(type);
-      PyErr_Clear();
-      if (infront) {
-	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
-      } else {
-	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
-      }
-      SWIG_Python_str_DelForPy3(tmp);
-      Py_DECREF(old_str);
-    }
-    return 1;
-  } else {
-    return 0;
-  }
-}
-  
-SWIGRUNTIME int
-SWIG_Python_ArgFail(int argnum)
-{
-  if (PyErr_Occurred()) {
-    /* add information about failing argument */
-    char mesg[256];
-    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
-    return SWIG_Python_AddErrMesg(mesg, 1);
-  } else {
-    return 0;
-  }
-}
-
-SWIGRUNTIMEINLINE const char *
-SwigPyObject_GetDesc(PyObject *self)
-{
-  SwigPyObject *v = (SwigPyObject *)self;
-  swig_type_info *ty = v ? v->ty : 0;
-  return ty ? ty->str : "";
-}
-
-SWIGRUNTIME void
-SWIG_Python_TypeError(const char *type, PyObject *obj)
-{
-  if (type) {
-#if defined(SWIG_COBJECT_TYPES)
-    if (obj && SwigPyObject_Check(obj)) {
-      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
-      if (otype) {
-	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
-		     type, otype);
-	return;
-      }
-    } else 
-#endif      
-    {
-      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
-      if (otype) {
-	PyObject *str = PyObject_Str(obj);
-	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
-	if (cstr) {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
-		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
-	} else {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
-		       type, otype);
-	}
-	Py_XDECREF(str);
-	return;
-      }
-    }   
-    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
-  } else {
-    PyErr_Format(PyExc_TypeError, "unexpected type is received");
-  }
-}
-
-
-/* Convert a pointer value, signal an exception on a type mismatch */
-SWIGRUNTIME void *
-SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
-  void *result;
-  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
-    PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
-  }
-  return result;
-}
-
-#ifdef SWIGPYTHON_BUILTIN
-SWIGRUNTIME int
-SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
-  PyTypeObject *tp = obj->ob_type;
-  PyObject *descr;
-  PyObject *encoded_name;
-  descrsetfunc f;
-  int res;
-
-# ifdef Py_USING_UNICODE
-  if (PyString_Check(name)) {
-    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
-    if (!name)
-      return -1;
-  } else if (!PyUnicode_Check(name))
-# else
-  if (!PyString_Check(name))
-# endif
-  {
-    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
-    return -1;
-  } else {
-    Py_INCREF(name);
-  }
-
-  if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
-      goto done;
-  }
-
-  res = -1;
-  descr = _PyType_Lookup(tp, name);
-  f = NULL;
-  if (descr != NULL)
-    f = descr->ob_type->tp_descr_set;
-  if (!f) {
-    if (PyString_Check(name)) {
-      encoded_name = name;
-      Py_INCREF(name);
-    } else {
-      encoded_name = PyUnicode_AsUTF8String(name);
-    }
-    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
-    Py_DECREF(encoded_name);
-  } else {
-    res = f(descr, obj, value);
-  }
-  
-  done:
-  Py_DECREF(name);
-  return res;
-}
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-
-#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
-
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
-
-  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define SWIGTYPE_p_GType swig_types[0]
-#define SWIGTYPE_p_VBuffer swig_types[1]
-#define SWIGTYPE_p__VipsImage swig_types[2]
-#define SWIGTYPE_p_allocator_type swig_types[3]
-#define SWIGTYPE_p_char swig_types[4]
-#define SWIGTYPE_p_difference_type swig_types[5]
-#define SWIGTYPE_p_double swig_types[6]
-#define SWIGTYPE_p_float swig_types[7]
-#define SWIGTYPE_p_gboolean swig_types[8]
-#define SWIGTYPE_p_int swig_types[9]
-#define SWIGTYPE_p_matrix swig_types[10]
-#define SWIGTYPE_p_p_PyObject swig_types[11]
-#define SWIGTYPE_p_p_char swig_types[12]
-#define SWIGTYPE_p_size_t swig_types[13]
-#define SWIGTYPE_p_size_type swig_types[14]
-#define SWIGTYPE_p_std__allocatorT_double_t swig_types[15]
-#define SWIGTYPE_p_std__allocatorT_int_t swig_types[16]
-#define SWIGTYPE_p_std__allocatorT_vips__VImage_t swig_types[17]
-#define SWIGTYPE_p_std__invalid_argument swig_types[18]
-#define SWIGTYPE_p_std__vectorT__Tp__Alloc_t swig_types[19]
-#define SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t swig_types[20]
-#define SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t swig_types[21]
-#define SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t swig_types[22]
-#define SWIGTYPE_p_swig__SwigPyIterator swig_types[23]
-#define SWIGTYPE_p_value_type swig_types[24]
-#define SWIGTYPE_p_vips__VDMask swig_types[25]
-#define SWIGTYPE_p_vips__VDisplay swig_types[26]
-#define SWIGTYPE_p_vips__VError swig_types[27]
-#define SWIGTYPE_p_vips__VIMask swig_types[28]
-#define SWIGTYPE_p_vips__VImage swig_types[29]
-#define SWIGTYPE_p_void swig_types[30]
-static swig_type_info *swig_types[32];
-static swig_module_info swig_module = {swig_types, 31, 0, 0, 0, 0};
-#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
-#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
-
-/* -------- TYPES TABLE (END) -------- */
-
-#if (PY_VERSION_HEX <= 0x02000000)
-# if !defined(SWIG_PYTHON_CLASSIC)
-#  error "This python version requires swig to be run with the '-classic' option"
-# endif
-#endif
-
-/*-----------------------------------------------
-              @(target):= vimagemodule.so
-  ------------------------------------------------*/
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_init    PyInit_vimagemodule
-
-#else
-#  define SWIG_init    initvimagemodule
-
-#endif
-#define SWIG_name    "vimagemodule"
-
-#define SWIGVERSION 0x020010 
-#define SWIG_VERSION SWIGVERSION
-
-
-#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
-#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
-
-
-#include <stdexcept>
-
-
-namespace swig {
-  class SwigPtr_PyObject {
-  protected:
-    PyObject *_obj;
-
-  public:
-    SwigPtr_PyObject() :_obj(0)
-    {
-    }
-
-    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
-    {
-      Py_XINCREF(_obj);      
-    }
-    
-    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
-    {
-      if (initial_ref) {
-        Py_XINCREF(_obj);
-      }
-    }
-    
-    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
-    {
-      Py_XINCREF(item._obj);
-      Py_XDECREF(_obj);
-      _obj = item._obj;
-      return *this;      
-    }
-    
-    ~SwigPtr_PyObject() 
-    {
-      Py_XDECREF(_obj);
-    }
-    
-    operator PyObject *() const
-    {
-      return _obj;
-    }
-
-    PyObject *operator->() const
-    {
-      return _obj;
-    }
-  };
-}
-
-
-namespace swig {
-  struct SwigVar_PyObject : SwigPtr_PyObject {
-    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
-    
-    SwigVar_PyObject & operator = (PyObject* obj)
-    {
-      Py_XDECREF(_obj);
-      _obj = obj;
-      return *this;      
-    }
-  };
-}
-
-
-#include <vips/vipscpp.h>
-
-/* We need the C API too for the args init and some of the
- * frombuffer/tobuffer stuff.
- */
-#include <vips/vips.h>
-
-
-#include <iostream>
-
-#if PY_VERSION_HEX >= 0x03020000
-# define SWIGPY_SLICE_ARG(obj) ((PyObject*) (obj))
-#else
-# define SWIGPY_SLICE_ARG(obj) ((PySliceObject*) (obj))
-#endif
-
-
-#include <stdexcept>
-
-
-#if defined(__GNUC__)
-#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
-#     define SWIG_STD_NOMODERN_STL
-#  endif
-#endif
-
-
-#include <string>
-#include <stdexcept>
-#include <stddef.h>
-
-
-  #include <stddef.h>
-
-
-namespace swig {
-  struct stop_iteration {
-  };
-
-  struct SwigPyIterator {
-  private:
-    SwigPtr_PyObject _seq;
-
-  protected:
-    SwigPyIterator(PyObject *seq) : _seq(seq)
-    {
-    }
-      
-  public:
-    virtual ~SwigPyIterator() {}
-
-    // Access iterator method, required by Python
-    virtual PyObject *value() const = 0;
-
-    // Forward iterator method, required by Python
-    virtual SwigPyIterator *incr(size_t n = 1) = 0;
-    
-    // Backward iterator method, very common in C++, but not required in Python
-    virtual SwigPyIterator *decr(size_t /*n*/ = 1)
-    {
-      throw stop_iteration();
-    }
-
-    // Random access iterator methods, but not required in Python
-    virtual ptrdiff_t distance(const SwigPyIterator &/*x*/) const
-    {
-      throw std::invalid_argument("operation not supported");
-    }
-
-    virtual bool equal (const SwigPyIterator &/*x*/) const
-    {
-      throw std::invalid_argument("operation not supported");
-    }
-    
-    // C++ common/needed methods
-    virtual SwigPyIterator *copy() const = 0;
-
-    PyObject *next()     
-    {
-      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
-      PyObject *obj = value();
-      incr();       
-      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads
-      return obj;     
-    }
-
-    /* Make an alias for Python 3.x */
-    PyObject *__next__()
-    {
-      return next();
-    }
-
-    PyObject *previous()
-    {
-      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
-      decr();
-      PyObject *obj = value();
-      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads       
-      return obj;
-    }
-
-    SwigPyIterator *advance(ptrdiff_t n)
-    {
-      return  (n > 0) ?  incr(n) : decr(-n);
-    }
-      
-    bool operator == (const SwigPyIterator& x)  const
-    {
-      return equal(x);
-    }
-      
-    bool operator != (const SwigPyIterator& x) const
-    {
-      return ! operator==(x);
-    }
-      
-    SwigPyIterator& operator += (ptrdiff_t n)
-    {
-      return *advance(n);
-    }
-
-    SwigPyIterator& operator -= (ptrdiff_t n)
-    {
-      return *advance(-n);
-    }
-      
-    SwigPyIterator* operator + (ptrdiff_t n) const
-    {
-      return copy()->advance(n);
-    }
-
-    SwigPyIterator* operator - (ptrdiff_t n) const
-    {
-      return copy()->advance(-n);
-    }
-      
-    ptrdiff_t operator - (const SwigPyIterator& x) const
-    {
-      return x.distance(*this);
-    }
-      
-    static swig_type_info* descriptor() {
-      static int init = 0;
-      static swig_type_info* desc = 0;
-      if (!init) {
-	desc = SWIG_TypeQuery("swig::SwigPyIterator *");
-	init = 1;
-      }	
-      return desc;
-    }    
-  };
-
-#if defined(SWIGPYTHON_BUILTIN)
-  inline PyObject* make_output_iterator_builtin (PyObject *pyself)
-  {
-    Py_INCREF(pyself);
-    return pyself;
-  }
-#endif
-}
-
-
-SWIGINTERN int
-SWIG_AsVal_double (PyObject *obj, double *val)
-{
-  int res = SWIG_TypeError;
-  if (PyFloat_Check(obj)) {
-    if (val) *val = PyFloat_AsDouble(obj);
-    return SWIG_OK;
-  } else if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AsLong(obj);
-    return SWIG_OK;
-  } else if (PyLong_Check(obj)) {
-    double v = PyLong_AsDouble(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_OK;
-    } else {
-      PyErr_Clear();
-    }
-  }
-#ifdef SWIG_PYTHON_CAST_MODE
-  {
-    int dispatch = 0;
-    double d = PyFloat_AsDouble(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = d;
-      return SWIG_AddCast(SWIG_OK);
-    } else {
-      PyErr_Clear();
-    }
-    if (!dispatch) {
-      long v = PyLong_AsLong(obj);
-      if (!PyErr_Occurred()) {
-	if (val) *val = v;
-	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
-      } else {
-	PyErr_Clear();
-      }
-    }
-  }
-#endif
-  return res;
-}
-
-
-#include <float.h>
-
-
-#include <math.h>
-
-
-SWIGINTERNINLINE int
-SWIG_CanCastAsInteger(double *d, double min, double max) {
-  double x = *d;
-  if ((min <= x && x <= max)) {
-   double fx = floor(x);
-   double cx = ceil(x);
-   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
-   if ((errno == EDOM) || (errno == ERANGE)) {
-     errno = 0;
-   } else {
-     double summ, reps, diff;
-     if (rd < x) {
-       diff = x - rd;
-     } else if (rd > x) {
-       diff = rd - x;
-     } else {
-       return 1;
-     }
-     summ = rd + x;
-     reps = diff/summ;
-     if (reps < 8*DBL_EPSILON) {
-       *d = rd;
-       return 1;
-     }
-   }
-  }
-  return 0;
-}
-
-
-SWIGINTERN int
-SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
-{
-#if PY_VERSION_HEX < 0x03000000
-  if (PyInt_Check(obj)) {
-    long v = PyInt_AsLong(obj);
-    if (v >= 0) {
-      if (val) *val = v;
-      return SWIG_OK;
-    } else {
-      return SWIG_OverflowError;
-    }
-  } else
-#endif
-  if (PyLong_Check(obj)) {
-    unsigned long v = PyLong_AsUnsignedLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_OK;
-    } else {
-      PyErr_Clear();
-#if PY_VERSION_HEX >= 0x03000000
-      {
-        long v = PyLong_AsLong(obj);
-        if (!PyErr_Occurred()) {
-          if (v < 0) {
-            return SWIG_OverflowError;
-          }
-        } else {
-          PyErr_Clear();
-        }
-      }
-#endif
-    }
-  }
-#ifdef SWIG_PYTHON_CAST_MODE
-  {
-    int dispatch = 0;
-    unsigned long v = PyLong_AsUnsignedLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_AddCast(SWIG_OK);
-    } else {
-      PyErr_Clear();
-    }
-    if (!dispatch) {
-      double d;
-      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
-      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
-	if (val) *val = (unsigned long)(d);
-	return res;
-      }
-    }
-  }
-#endif
-  return SWIG_TypeError;
-}
-
-
-SWIGINTERNINLINE int
-SWIG_AsVal_size_t (PyObject * obj, size_t *val)
-{
-  unsigned long v;
-  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
-  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
-  return res;
-}
-
-
-  #define SWIG_From_long   PyLong_FromLong 
-
-
-SWIGINTERNINLINE PyObject *
-SWIG_From_ptrdiff_t  (ptrdiff_t value)
-{    
-  return SWIG_From_long  (static_cast< long >(value));
-}
-
-
-SWIGINTERNINLINE PyObject*
-  SWIG_From_bool  (bool value)
-{
-  return PyBool_FromLong(value ? 1 : 0);
-}
-
-
-SWIGINTERN int
-SWIG_AsVal_long (PyObject *obj, long* val)
-{
-  if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AsLong(obj);
-    return SWIG_OK;
-  } else if (PyLong_Check(obj)) {
-    long v = PyLong_AsLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_OK;
-    } else {
-      PyErr_Clear();
-    }
-  }
-#ifdef SWIG_PYTHON_CAST_MODE
-  {
-    int dispatch = 0;
-    long v = PyInt_AsLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_AddCast(SWIG_OK);
-    } else {
-      PyErr_Clear();
-    }
-    if (!dispatch) {
-      double d;
-      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
-      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
-	if (val) *val = (long)(d);
-	return res;
-      }
-    }
-  }
-#endif
-  return SWIG_TypeError;
-}
-
-
-SWIGINTERNINLINE int
-SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
-{
-  long v;
-  int res = SWIG_AsVal_long (obj, val ? &v : 0);
-  if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
-  return res;
-}
-
-
-#include <stdexcept>
-
-
-#include <algorithm>
-
-
-#include <list>
-
-
-#include <complex> 
-
-
-#include <vector>
-
-
-#include <string>
-
-
-namespace swig {  
-  template <class Type>
-  struct noconst_traits {
-    typedef Type noconst_type;
-  };
-
-  template <class Type>
-  struct noconst_traits<const Type> {
-    typedef Type noconst_type;
-  };
-
-  /*
-    type categories
-  */
-  struct pointer_category { };  
-  struct value_category { };
-
-  /*
-    General traits that provides type_name and type_info
-  */
-  template <class Type> struct traits { };
-
-  template <class Type>
-  inline const char* type_name() {
-    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
-  }
-
-  template <class Type> 
-  struct traits_info {
-    static swig_type_info *type_query(std::string name) {
-      name += " *";
-      return SWIG_TypeQuery(name.c_str());
-    }    
-    static swig_type_info *type_info() {
-      static swig_type_info *info = type_query(type_name<Type>());
-      return info;
-    }
-  };
-
-  template <class Type>
-  inline swig_type_info *type_info() {
-    return traits_info<Type>::type_info();
-  }
-
-  /*
-    Partial specialization for pointers
-  */
-  template <class Type> struct traits <Type *> {
-    typedef pointer_category category;
-    static std::string make_ptr_name(const char* name) {
-      std::string ptrname = name;
-      ptrname += " *";
-      return ptrname;
-    }    
-    static const char* type_name() {
-      static std::string name = make_ptr_name(swig::type_name<Type>());
-      return name.c_str();
-    }
-  };
-
-  template <class Type, class Category> 
-  struct traits_as { };
- 
-  template <class Type, class Category> 
-  struct traits_check { };
-
-}
-
-
-namespace swig {  
-  /*
-    Traits that provides the from method
-  */
-  template <class Type> struct traits_from_ptr {
-    static PyObject *from(Type *val, int owner = 0) {
-      return SWIG_InternalNewPointerObj(val, type_info<Type>(), owner);
-    }
-  };
-
-  template <class Type> struct traits_from {
-    static PyObject *from(const Type& val) {
-      return traits_from_ptr<Type>::from(new Type(val), 1);
-    }
-  };
-
-  template <class Type> struct traits_from<Type *> {
-    static PyObject *from(Type* val) {
-      return traits_from_ptr<Type>::from(val, 0);
-    }
-  };
-
-  template <class Type> struct traits_from<const Type *> {
-    static PyObject *from(const Type* val) {
-      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
-    }
-  };
-
-
-  template <class Type>
-  inline PyObject *from(const Type& val) {
-    return traits_from<Type>::from(val);
-  }
-
-  template <class Type>
-  inline PyObject *from_ptr(Type* val, int owner) {
-    return traits_from_ptr<Type>::from(val, owner);
-  }
-
-  /*
-    Traits that provides the asval/as/check method
-  */
-  template <class Type>
-  struct traits_asptr {   
-    static int asptr(PyObject *obj, Type **val) {
-      Type *p;
-      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
-      if (SWIG_IsOK(res)) {
-	if (val) *val = p;
-      }
-      return res;
-    }
-  }; 
-
-  template <class Type>
-  inline int asptr(PyObject *obj, Type **vptr) {
-    return traits_asptr<Type>::asptr(obj, vptr);
-  }
-
-  template <class Type> 
-  struct traits_asval {
-    static int asval(PyObject *obj, Type *val) {
-      if (val) {
-	Type *p = 0;
-	int res = traits_asptr<Type>::asptr(obj, &p);
-	if (!SWIG_IsOK(res)) return res;	
-	if (p) {
-	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
-	  *(const_cast<noconst_type*>(val)) = *p;
-	  if (SWIG_IsNewObj(res)){
-	    delete p;
-	    res = SWIG_DelNewMask(res);
-	  }
-	  return res;
-	} else {
-	  return SWIG_ERROR;
-	}
-      } else {
-	return traits_asptr<Type>::asptr(obj, (Type **)(0));
-      }
-    }
-  };
-
-  template <class Type> struct traits_asval<Type*> {
-    static int asval(PyObject *obj, Type **val) {
-      if (val) {
-        typedef typename noconst_traits<Type>::noconst_type noconst_type;
-        noconst_type *p = 0;
-        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
-        if (SWIG_IsOK(res)) {
-          *(const_cast<noconst_type**>(val)) = p;
-	}
-	return res;
-      } else {
-	return traits_asptr<Type>::asptr(obj, (Type **)(0));
-      }
-    }
-  };
-  
-  template <class Type>
-  inline int asval(PyObject *obj, Type *val) {
-    return traits_asval<Type>::asval(obj, val);
-  }
-
-  template <class Type> 
-  struct traits_as<Type, value_category> {
-    static Type as(PyObject *obj, bool throw_error) {
-      Type v;
-      int res = asval(obj, &v);
-      if (!obj || !SWIG_IsOK(res)) {
-	if (!PyErr_Occurred()) {
-	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
-	}
-	if (throw_error) throw std::invalid_argument("bad type");
-      }
-      return v;
-    }
-  };
-
-  template <class Type> 
-  struct traits_as<Type, pointer_category> {
-    static Type as(PyObject *obj, bool throw_error) {
-      Type *v = 0;      
-      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
-      if (SWIG_IsOK(res) && v) {
-	if (SWIG_IsNewObj(res)) {
-	  Type r(*v);
-	  delete v;
-	  return r;
-	} else {
-	  return *v;
-	}
-      } else {
-	// Uninitialized return value, no Type() constructor required.
-	static Type *v_def = (Type*) malloc(sizeof(Type));
-	if (!PyErr_Occurred()) {
-	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
-	}
-	if (throw_error) throw std::invalid_argument("bad type");
-	memset(v_def,0,sizeof(Type));
-	return *v_def;
-      }
-    }
-  };
-
-  template <class Type> 
-  struct traits_as<Type*, pointer_category> {
-    static Type* as(PyObject *obj, bool throw_error) {
-      Type *v = 0;      
-      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
-      if (SWIG_IsOK(res)) {
-	return v;
-      } else {
-	if (!PyErr_Occurred()) {
-	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
-	}
-	if (throw_error) throw std::invalid_argument("bad type");
-	return 0;
-      }
-    }
-  };
-    
-  template <class Type>
-  inline Type as(PyObject *obj, bool te = false) {
-    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
-  }
-
-  template <class Type> 
-  struct traits_check<Type, value_category> {
-    static bool check(PyObject *obj) {
-      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
-      return SWIG_IsOK(res) ? true : false;
-    }
-  };
-
-  template <class Type> 
-  struct traits_check<Type, pointer_category> {
-    static bool check(PyObject *obj) {
-      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
-      return SWIG_IsOK(res) ? true : false;
-    }
-  };
-
-  template <class Type>
-  inline bool check(PyObject *obj) {
-    return traits_check<Type, typename traits<Type>::category>::check(obj);
-  }
-}
-
-
-#include <functional>
-
-namespace std {
-  template <>
-  struct less <PyObject *>: public binary_function<PyObject *, PyObject *, bool>
-  {
-    bool
-    operator()(PyObject * v, PyObject *w) const
-    { 
-      bool res;
-      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
-      res = PyObject_RichCompareBool(v, w, Py_LT) ? true : false;
-      /* This may fall into a case of inconsistent
-               eg. ObjA > ObjX > ObjB
-               but ObjA < ObjB
-      */
-      if( PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError) )
-      {
-        /* Objects can't be compared, this mostly occurred in Python 3.0 */
-        /* Compare their ptr directly for a workaround */
-        res = (v < w);
-        PyErr_Clear();
-      }
-      SWIG_PYTHON_THREAD_END_BLOCK;
-      return res;
-    }
-  };
-
-  template <>
-  struct less <swig::SwigPtr_PyObject>: public binary_function<swig::SwigPtr_PyObject, swig::SwigPtr_PyObject, bool>
-  {
-    bool
-    operator()(const swig::SwigPtr_PyObject& v, const swig::SwigPtr_PyObject& w) const
-    {
-      return std::less<PyObject *>()(v, w);
-    }
-  };
-
-  template <>
-  struct less <swig::SwigVar_PyObject>: public binary_function<swig::SwigVar_PyObject, swig::SwigVar_PyObject, bool>
-  {
-    bool
-    operator()(const swig::SwigVar_PyObject& v, const swig::SwigVar_PyObject& w) const
-    {
-      return std::less<PyObject *>()(v, w);
-    }
-  };
-
-}
-
-namespace swig {
-  template <> struct traits<PyObject *> {
-    typedef value_category category;
-    static const char* type_name() { return "PyObject *"; }
-  };  
-
-  template <>  struct traits_asval<PyObject * > {   
-    typedef PyObject * value_type;
-    static int asval(PyObject *obj, value_type *val) {
-      if (val) *val = obj;
-      return SWIG_OK;
-    }
-  };
-
-  template <> 
-  struct traits_check<PyObject *, value_category> {
-    static bool check(PyObject *) {
-      return true;
-    }
-  };
-
-  template <>  struct traits_from<PyObject *> {
-    typedef PyObject * value_type;
-    static PyObject *from(const value_type& val) {
-      Py_XINCREF(val);
-      return val;
-    }
-  };
-  
-}
-
-namespace swig {
-  template <class Difference>
-  inline size_t
-  check_index(Difference i, size_t size, bool insert = false) {
-    if ( i < 0 ) {
-      if ((size_t) (-i) <= size)
-	return (size_t) (i + size);
-    } else if ( (size_t) i < size ) {
-      return (size_t) i;
-    } else if (insert && ((size_t) i == size)) {
-      return size;
-    }
-    throw std::out_of_range("index out of range");
-  }
-
-  template <class Difference>
-  void
-  slice_adjust(Difference i, Difference j, Py_ssize_t step, size_t size, Difference &ii, Difference &jj, bool insert = false) {
-    if (step == 0) {
-      throw std::invalid_argument("slice step cannot be zero");
-    } else if (step > 0) {
-      // Required range: 0 <= i < size, 0 <= j < size
-      if (i < 0) {
-        ii = 0;
-      } else if (i < (Difference)size) {
-        ii = i;
-      } else if (insert && (i >= (Difference)size)) {
-        ii = (Difference)size;
-      }
-      if ( j < 0 ) {
-        jj = 0;
-      } else {
-        jj = (j < (Difference)size) ? j : (Difference)size;
-      }
-    } else {
-      // Required range: -1 <= i < size-1, -1 <= j < size-1
-      if (i < -1) {
-        ii = -1;
-      } else if (i < (Difference) size) {
-        ii = i;
-      } else if (i >= (Difference)(size-1)) {
-        ii = (Difference)(size-1);
-      }
-      if (j < -1) {
-        jj = -1;
-      } else {
-        jj = (j < (Difference)size ) ? j : (Difference)(size-1);
-      }
-    }
-  }
-
-  template <class Sequence, class Difference>
-  inline typename Sequence::iterator
-  getpos(Sequence* self, Difference i)  {
-    typename Sequence::iterator pos = self->begin();
-    std::advance(pos, check_index(i,self->size()));
-    return pos;
-  }
-
-  template <class Sequence, class Difference>
-  inline typename Sequence::const_iterator
-  cgetpos(const Sequence* self, Difference i)  {
-    typename Sequence::const_iterator pos = self->begin();
-    std::advance(pos, check_index(i,self->size()));
-    return pos;
-  }
-
-  template <class Sequence, class Difference>
-  inline Sequence*
-  getslice(const Sequence* self, Difference i, Difference j, Py_ssize_t step) {
-    typename Sequence::size_type size = self->size();
-    Difference ii = 0;
-    Difference jj = 0;
-    swig::slice_adjust(i, j, step, size, ii, jj);
-
-    if (step > 0) {
-      typename Sequence::const_iterator sb = self->begin();
-      typename Sequence::const_iterator se = self->begin();
-      std::advance(sb,ii);
-      std::advance(se,jj);
-      if (step == 1) {
-        return new Sequence(sb, se);
-      } else {
-        Sequence *sequence = new Sequence();
-        typename Sequence::const_iterator it = sb;
-        while (it!=se) {
-          sequence->push_back(*it);
-          for (Py_ssize_t c=0; c<step && it!=se; ++c)
-            it++;
-        }
-        return sequence;
-      } 
-    } else {
-      Sequence *sequence = new Sequence();
-      if (ii > jj) {
-        typename Sequence::const_reverse_iterator sb = self->rbegin();
-        typename Sequence::const_reverse_iterator se = self->rbegin();
-        std::advance(sb,size-ii-1);
-        std::advance(se,size-jj-1);
-        typename Sequence::const_reverse_iterator it = sb;
-        while (it!=se) {
-          sequence->push_back(*it);
-          for (Py_ssize_t c=0; c<-step && it!=se; ++c)
-            it++;
-        }
-      }
-      return sequence;
-    }
-  }
-
-  template <class Sequence, class Difference, class InputSeq>
-  inline void
-  setslice(Sequence* self, Difference i, Difference j, Py_ssize_t step, const InputSeq& is = InputSeq()) {
-    typename Sequence::size_type size = self->size();
-    Difference ii = 0;
-    Difference jj = 0;
-    swig::slice_adjust(i, j, step, size, ii, jj, true);
-    if (step > 0) {
-      if (jj < ii)
-        jj = ii;
-      if (step == 1) {
-        size_t ssize = jj - ii;
-        if (ssize <= is.size()) {
-          // expanding/staying the same size
-          typename Sequence::iterator sb = self->begin();
-          typename InputSeq::const_iterator isit = is.begin();
-          std::advance(sb,ii);
-          std::advance(isit, jj - ii);
-          self->insert(std::copy(is.begin(), isit, sb), isit, is.end());
-        } else {
-          // shrinking
-          typename Sequence::iterator sb = self->begin();
-          typename Sequence::iterator se = self->begin();
-          std::advance(sb,ii);
-          std::advance(se,jj);
-          self->erase(sb,se);
-          sb = self->begin();
-          std::advance(sb,ii);
-          self->insert(sb, is.begin(), is.end());
-        }
-      } else {
-        size_t replacecount = (jj - ii + step - 1) / step;
-        if (is.size() != replacecount) {
-          char msg[1024];
-          sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
-          throw std::invalid_argument(msg);
-        }
-        typename Sequence::const_iterator isit = is.begin();
-        typename Sequence::iterator it = self->begin();
-        std::advance(it,ii);
-        for (size_t rc=0; rc<replacecount; ++rc) {
-          *it++ = *isit++;
-          for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
-            it++;
-        }
-      }
-    } else {
-      if (jj > ii)
-        jj = ii;
-      size_t replacecount = (ii - jj - step - 1) / -step;
-      if (is.size() != replacecount) {
-        char msg[1024];
-        sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
-        throw std::invalid_argument(msg);
-      }
-      typename Sequence::const_iterator isit = is.begin();
-      typename Sequence::reverse_iterator it = self->rbegin();
-      std::advance(it,size-ii-1);
-      for (size_t rc=0; rc<replacecount; ++rc) {
-        *it++ = *isit++;
-        for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
-          it++;
-      }
-    }
-  }
-
-  template <class Sequence, class Difference>
-  inline void
-  delslice(Sequence* self, Difference i, Difference j, Py_ssize_t step) {
-    typename Sequence::size_type size = self->size();
-    Difference ii = 0;
-    Difference jj = 0;
-    swig::slice_adjust(i, j, step, size, ii, jj, true);
-    if (step > 0) {
-      if (jj > ii) {
-        typename Sequence::iterator sb = self->begin();
-        std::advance(sb,ii);
-        if (step == 1) {
-          typename Sequence::iterator se = self->begin();
-          std::advance(se,jj);
-          self->erase(sb,se);
-        } else {
-          typename Sequence::iterator it = sb;
-          size_t delcount = (jj - ii + step - 1) / step;
-          while (delcount) {
-            it = self->erase(it);
-            for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
-              it++;
-            delcount--;
-          }
-        }
-      }
-    } else {
-      if (ii > jj) {
-        typename Sequence::reverse_iterator sb = self->rbegin();
-        std::advance(sb,size-ii-1);
-        typename Sequence::reverse_iterator it = sb;
-        size_t delcount = (ii - jj - step - 1) / -step;
-        while (delcount) {
-          it = typename Sequence::reverse_iterator(self->erase((++it).base()));
-          for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
-            it++;
-          delcount--;
-        }
-      }
-    }
-  }
-}
-
-
-#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
-#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
-#    define SWIG_STD_NOITERATOR_TRAITS_STL
-#  endif
-#endif
-
-#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
-#include <iterator>
-#else
-namespace std {
-  template <class Iterator>
-  struct iterator_traits {
-    typedef ptrdiff_t difference_type;
-    typedef typename Iterator::value_type value_type;
-  };
-
-  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
-  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
-    typedef Distance difference_type;
-    typedef T value_type;
-  };
-
-  template <class T>
-  struct iterator_traits<T*> {
-    typedef T value_type;
-    typedef ptrdiff_t difference_type;
-  };
-
-  template<typename _InputIterator>
-  inline typename iterator_traits<_InputIterator>::difference_type
-  distance(_InputIterator __first, _InputIterator __last)
-  {
-    typename iterator_traits<_InputIterator>::difference_type __n = 0;
-    while (__first != __last) {
-      ++__first; ++__n;
-    }
-    return __n;
-  }
-}
-#endif
-
-
-namespace swig {
-  template<typename OutIterator>
-  class SwigPyIterator_T :  public SwigPyIterator
-  {
-  public:
-    typedef OutIterator out_iterator;
-    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
-    typedef SwigPyIterator_T<out_iterator> self_type;
-
-    SwigPyIterator_T(out_iterator curr, PyObject *seq)
-      : SwigPyIterator(seq), current(curr)
-    {
-    }
-
-    const out_iterator& get_current() const
-    {
-      return current;
-    }
-
-    
-    bool equal (const SwigPyIterator &iter) const
-    {
-      const self_type *iters = dynamic_cast<const self_type *>(&iter);
-      if (iters) {
-	return (current == iters->get_current());
-      } else {
-	throw std::invalid_argument("bad iterator type");
-      }
-    }
-    
-    ptrdiff_t distance(const SwigPyIterator &iter) const
-    {
-      const self_type *iters = dynamic_cast<const self_type *>(&iter);
-      if (iters) {
-	return std::distance(current, iters->get_current());
-      } else {
-	throw std::invalid_argument("bad iterator type");
-      }
-    }    
-    
-  protected:
-    out_iterator current;
-  };
-  
-  template <class ValueType>
-  struct from_oper 
-  {
-    typedef const ValueType& argument_type;
-    typedef PyObject *result_type;
-    result_type operator()(argument_type v) const
-    {
-      return swig::from(v);
-    }
-  };
-
-  template<typename OutIterator, 
-	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
-	   typename FromOper = from_oper<ValueType> >
-  class SwigPyIteratorOpen_T :  public SwigPyIterator_T<OutIterator>
-  {
-  public:
-    FromOper from;
-    typedef OutIterator out_iterator;
-    typedef ValueType value_type;
-    typedef SwigPyIterator_T<out_iterator>  base;
-    typedef SwigPyIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
-    
-    SwigPyIteratorOpen_T(out_iterator curr, PyObject *seq)
-      : SwigPyIterator_T<OutIterator>(curr, seq)
-    {
-    }
-    
-    PyObject *value() const {
-      return from(static_cast<const value_type&>(*(base::current)));
-    }
-    
-    SwigPyIterator *copy() const
-    {
-      return new self_type(*this);
-    }
-
-    SwigPyIterator *incr(size_t n = 1)
-    {
-      while (n--) {
-	++base::current;
-      }
-      return this;
-    }
-
-    SwigPyIterator *decr(size_t n = 1)
-    {
-      while (n--) {
-	--base::current;
-      }
-      return this;
-    }
-  };
-
-  template<typename OutIterator, 
-	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
-	   typename FromOper = from_oper<ValueType> >
-  class SwigPyIteratorClosed_T :  public SwigPyIterator_T<OutIterator>
-  {
-  public:
-    FromOper from;
-    typedef OutIterator out_iterator;
-    typedef ValueType value_type;
-    typedef SwigPyIterator_T<out_iterator>  base;    
-    typedef SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
-    
-    SwigPyIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
-      : SwigPyIterator_T<OutIterator>(curr, seq), begin(first), end(last)
-    {
-    }
-    
-    PyObject *value() const {
-      if (base::current == end) {
-	throw stop_iteration();
-      } else {
-	return from(static_cast<const value_type&>(*(base::current)));
-      }
-    }
-    
-    SwigPyIterator *copy() const
-    {
-      return new self_type(*this);
-    }
-
-    SwigPyIterator *incr(size_t n = 1)
-    {
-      while (n--) {
-	if (base::current == end) {
-	  throw stop_iteration();
-	} else {
-	  ++base::current;
-	}
-      }
-      return this;
-    }
-
-    SwigPyIterator *decr(size_t n = 1)
-    {
-      while (n--) {
-	if (base::current == begin) {
-	  throw stop_iteration();
-	} else {
-	  --base::current;
-	}
-      }
-      return this;
-    }
-
-  private:
-    out_iterator begin;
-    out_iterator end;
-  };
-
-  template<typename OutIter>
-  inline SwigPyIterator*
-  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
-  {
-    return new SwigPyIteratorClosed_T<OutIter>(current, begin, end, seq);
-  }
-
-  template<typename OutIter>
-  inline SwigPyIterator*
-  make_output_iterator(const OutIter& current, PyObject *seq = 0)
-  {
-    return new SwigPyIteratorOpen_T<OutIter>(current, seq);
-  }
-
-}
-
-
-namespace swig
-{
-  template <class T>
-  struct SwigPySequence_Ref
-  {
-    SwigPySequence_Ref(PyObject* seq, int index)
-      : _seq(seq), _index(index)
-    {
-    }
-    
-    operator T () const
-    {
-      swig::SwigVar_PyObject item = PySequence_GetItem(_seq, _index);
-      try {
-	return swig::as<T>(item, true);
-      } catch (std::exception& e) {
-	char msg[1024];
-	sprintf(msg, "in sequence element %d ", _index);
-	if (!PyErr_Occurred()) {
-	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
-	}
-	SWIG_Python_AddErrorMsg(msg);
-	SWIG_Python_AddErrorMsg(e.what());
-	throw;
-      }
-    }
-
-    SwigPySequence_Ref& operator=(const T& v)
-    {
-      PySequence_SetItem(_seq, _index, swig::from<T>(v));
-      return *this;
-    }
-
-  private:
-    PyObject* _seq;
-    int _index;
-  };
-
-  template <class T>
-  struct SwigPySequence_ArrowProxy
-  {
-    SwigPySequence_ArrowProxy(const T& x): m_value(x) {}
-    const T* operator->() const { return &m_value; }
-    operator const T*() const { return &m_value; }
-    T m_value;
-  };
-
-  template <class T, class Reference >
-  struct SwigPySequence_InputIterator
-  {
-    typedef SwigPySequence_InputIterator<T, Reference > self;
-
-    typedef std::random_access_iterator_tag iterator_category;
-    typedef Reference reference;
-    typedef T value_type;
-    typedef T* pointer;
-    typedef int difference_type;
-
-    SwigPySequence_InputIterator()
-    {
-    }
-
-    SwigPySequence_InputIterator(PyObject* seq, int index)
-      : _seq(seq), _index(index)
-    {
-    }
-
-    reference operator*() const
-    {
-      return reference(_seq, _index);
-    }
-
-    SwigPySequence_ArrowProxy<T>
-    operator->() const {
-      return SwigPySequence_ArrowProxy<T>(operator*());
-    }
-
-    bool operator==(const self& ri) const
-    {
-      return (_index == ri._index) && (_seq == ri._seq);
-    }
-
-    bool operator!=(const self& ri) const
-    {
-      return !(operator==(ri));
-    }
-
-    self& operator ++ ()
-    {
-      ++_index;
-      return *this;
-    }
-
-    self& operator -- ()
-    {
-      --_index;
-      return *this;
-    }
-
-    self& operator += (difference_type n)
-    {
-      _index += n;
-      return *this;
-    }
-
-    self operator +(difference_type n) const
-    {
-      return self(_seq, _index + n);
-    }
-
-    self& operator -= (difference_type n)
-    {
-      _index -= n;
-      return *this;
-    }
-
-    self operator -(difference_type n) const
-    {
-      return self(_seq, _index - n);
-    }
-
-    difference_type operator - (const self& ri) const
-    {
-      return _index - ri._index;
-    }
-
-    bool operator < (const self& ri) const
-    {
-      return _index < ri._index;
-    }
-
-    reference
-    operator[](difference_type n) const
-    {
-      return reference(_seq, _index + n);
-    }
-
-  private:
-    PyObject* _seq;
-    difference_type _index;
-  };
-
-  template <class T>
-  struct SwigPySequence_Cont
-  {
-    typedef SwigPySequence_Ref<T> reference;
-    typedef const SwigPySequence_Ref<T> const_reference;
-    typedef T value_type;
-    typedef T* pointer;
-    typedef int difference_type;
-    typedef int size_type;
-    typedef const pointer const_pointer;
-    typedef SwigPySequence_InputIterator<T, reference> iterator;
-    typedef SwigPySequence_InputIterator<T, const_reference> const_iterator;
-
-    SwigPySequence_Cont(PyObject* seq) : _seq(0)
-    {
-      if (!PySequence_Check(seq)) {
-	throw std::invalid_argument("a sequence is expected");
-      }
-      _seq = seq;
-      Py_INCREF(_seq);
-    }
-
-    ~SwigPySequence_Cont()
-    {
-      Py_XDECREF(_seq);
-    }
-
-    size_type size() const
-    {
-      return static_cast<size_type>(PySequence_Size(_seq));
-    }
-
-    bool empty() const
-    {
-      return size() == 0;
-    }
-
-    iterator begin()
-    {
-      return iterator(_seq, 0);
-    }
-
-    const_iterator begin() const
-    {
-      return const_iterator(_seq, 0);
-    }
-
-    iterator end()
-    {
-      return iterator(_seq, size());
-    }
-
-    const_iterator end() const
-    {
-      return const_iterator(_seq, size());
-    }
-
-    reference operator[](difference_type n)
-    {
-      return reference(_seq, n);
-    }
-
-    const_reference operator[](difference_type n)  const
-    {
-      return const_reference(_seq, n);
-    }
-
-    bool check(bool set_err = true) const
-    {
-      int s = size();
-      for (int i = 0; i < s; ++i) {
-	swig::SwigVar_PyObject item = PySequence_GetItem(_seq, i);
-	if (!swig::check<value_type>(item)) {
-	  if (set_err) {
-	    char msg[1024];
-	    sprintf(msg, "in sequence element %d", i);
-	    SWIG_Error(SWIG_RuntimeError, msg);
-	  }
-	  return false;
-	}
-      }
-      return true;
-    }
-
-  private:
-    PyObject* _seq;
-  };
-
-}
-
-
-#include <limits.h>
-#if !defined(SWIG_NO_LLONG_MAX)
-# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
-#   define LLONG_MAX __LONG_LONG_MAX__
-#   define LLONG_MIN (-LLONG_MAX - 1LL)
-#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
-# endif
-#endif
-
-
-SWIGINTERN int
-SWIG_AsVal_int (PyObject * obj, int *val)
-{
-  long v;
-  int res = SWIG_AsVal_long (obj, &v);
-  if (SWIG_IsOK(res)) {
-    if ((v < INT_MIN || v > INT_MAX)) {
-      return SWIG_OverflowError;
-    } else {
-      if (val) *val = static_cast< int >(v);
-    }
-  }  
-  return res;
-}
-
-
-SWIGINTERNINLINE PyObject*
-  SWIG_From_int  (int value)
-{
-  return PyInt_FromLong((long) value);
-}
-
-
-namespace swig {
-  template <> struct traits<int > {
-    typedef value_category category;
-    static const char* type_name() { return"int"; }
-  };  
-  template <>  struct traits_asval<int > {   
-    typedef int value_type;
-    static int asval(PyObject *obj, value_type *val) { 
-      return SWIG_AsVal_int (obj, val);
-    }
-  };
-  template <>  struct traits_from<int > {
-    typedef int value_type;
-    static PyObject *from(const value_type& val) {
-      return SWIG_From_int  (val);
-    }
-  };
-}
-
-
-namespace swig {
-  template <class SwigPySeq, class Seq>
-  inline void
-  assign(const SwigPySeq& swigpyseq, Seq* seq) {
-    // seq->assign(swigpyseq.begin(), swigpyseq.end()); // not used as not always implemented
-    typedef typename SwigPySeq::value_type value_type;
-    typename SwigPySeq::const_iterator it = swigpyseq.begin();
-    for (;it != swigpyseq.end(); ++it) {
-      seq->insert(seq->end(),(value_type)(*it));
-    }
-  }
-
-  template <class Seq, class T = typename Seq::value_type >
-  struct traits_asptr_stdseq {
-    typedef Seq sequence;
-    typedef T value_type;
-
-    static int asptr(PyObject *obj, sequence **seq) {
-      if (obj == Py_None || SWIG_Python_GetSwigThis(obj)) {
-	sequence *p;
-	if (::SWIG_ConvertPtr(obj,(void**)&p,
-			      swig::type_info<sequence>(),0) == SWIG_OK) {
-	  if (seq) *seq = p;
-	  return SWIG_OLDOBJ;
-	}
-      } else if (PySequence_Check(obj)) {
-	try {
-	  SwigPySequence_Cont<value_type> swigpyseq(obj);
-	  if (seq) {
-	    sequence *pseq = new sequence();
-	    assign(swigpyseq, pseq);
-	    *seq = pseq;
-	    return SWIG_NEWOBJ;
-	  } else {
-	    return swigpyseq.check() ? SWIG_OK : SWIG_ERROR;
-	  }
-	} catch (std::exception& e) {
-	  if (seq) {
-	    if (!PyErr_Occurred()) {
-	      PyErr_SetString(PyExc_TypeError, e.what());
-	    }
-	  }
-	  return SWIG_ERROR;
-	}
-      }
-      return SWIG_ERROR;
-    }
-  };
-
-  template <class Seq, class T = typename Seq::value_type >
-  struct traits_from_stdseq {
-    typedef Seq sequence;
-    typedef T value_type;
-    typedef typename Seq::size_type size_type;
-    typedef typename sequence::const_iterator const_iterator;
-
-    static PyObject *from(const sequence& seq) {
-#ifdef SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
-      swig_type_info *desc = swig::type_info<sequence>();
-      if (desc && desc->clientdata) {
-	return SWIG_NewPointerObj(new sequence(seq), desc, SWIG_POINTER_OWN);
-      }
-#endif
-      size_type size = seq.size();
-      if (size <= (size_type)INT_MAX) {
-	PyObject *obj = PyTuple_New((int)size);
-	int i = 0;
-	for (const_iterator it = seq.begin();
-	     it != seq.end(); ++it, ++i) {
-	  PyTuple_SetItem(obj,i,swig::from<value_type>(*it));
-	}
-	return obj;
-      } else {
-	PyErr_SetString(PyExc_OverflowError,"sequence size not valid in python");
-	return NULL;
-      }
-    }
-  };
-}
-
-
-  namespace swig {
-    template <class T>
-    struct traits_asptr<std::vector<T> >  {
-      static int asptr(PyObject *obj, std::vector<T> **vec) {
-	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
-      }
-    };
-    
-    template <class T>
-    struct traits_from<std::vector<T> > {
-      static PyObject *from(const std::vector<T>& vec) {
-	return traits_from_stdseq<std::vector<T> >::from(vec);
-      }
-    };
-  }
-
-
-      namespace swig {
-	template <>  struct traits<std::vector<int, std::allocator< int > > > {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return "std::vector<" "int" "," "std::allocator< int >" " >";
-	  }
-	};
-      }
-    
-SWIGINTERN swig::SwigPyIterator *std_vector_Sl_int_Sg__iterator(std::vector< int > *self,PyObject **PYTHON_SELF){
-      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
-    }
-SWIGINTERN bool std_vector_Sl_int_Sg____nonzero__(std::vector< int > const *self){
-      return !(self->empty());
-    }
-SWIGINTERN bool std_vector_Sl_int_Sg____bool__(std::vector< int > const *self){
-      return !(self->empty());
-    }
-SWIGINTERN std::vector< int >::size_type std_vector_Sl_int_Sg____len__(std::vector< int > const *self){
-      return self->size();
-    }
-
-SWIGINTERNINLINE PyObject* 
-SWIG_From_unsigned_SS_long  (unsigned long value)
-{
-  return (value > LONG_MAX) ?
-    PyLong_FromUnsignedLong(value) : PyLong_FromLong(static_cast< long >(value)); 
-}
-
-
-SWIGINTERNINLINE PyObject *
-SWIG_From_size_t  (size_t value)
-{    
-  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
-}
-
-SWIGINTERN std::vector< int >::value_type std_vector_Sl_int_Sg__pop(std::vector< int > *self){
-      if (self->size() == 0)
-	throw std::out_of_range("pop from empty container");
-      std::vector<int,std::allocator< int > >::value_type x = self->back();
-      self->pop_back();
-      return x;
-    }
-SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg____getslice__(std::vector< int > *self,std::vector< int >::difference_type i,std::vector< int >::difference_type j){
-      return swig::getslice(self, i, j, 1);
-    }
-SWIGINTERN void std_vector_Sl_int_Sg____setslice____SWIG_0(std::vector< int > *self,std::vector< int >::difference_type i,std::vector< int >::difference_type j,std::vector< int,std::allocator< int > > const &v=std::vector< int,std::allocator< int > >()){
-      swig::setslice(self, i, j, 1, v);
-    }
-SWIGINTERN void std_vector_Sl_int_Sg____delslice__(std::vector< int > *self,std::vector< int >::difference_type i,std::vector< int >::difference_type j){
-      swig::delslice(self, i, j, 1);
-    }
-SWIGINTERN void std_vector_Sl_int_Sg____delitem____SWIG_0(std::vector< int > *self,std::vector< int >::difference_type i){
-      self->erase(swig::getpos(self,i));
-    }
-SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg____getitem____SWIG_0(std::vector< int > *self,PySliceObject *slice){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return NULL;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<int,std::allocator< int > >::difference_type id = i;
-      std::vector<int,std::allocator< int > >::difference_type jd = j;
-      return swig::getslice(self, id, jd, step);
-    }
-SWIGINTERN void std_vector_Sl_int_Sg____setitem____SWIG_0(std::vector< int > *self,PySliceObject *slice,std::vector< int,std::allocator< int > > const &v){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<int,std::allocator< int > >::difference_type id = i;
-      std::vector<int,std::allocator< int > >::difference_type jd = j;
-      swig::setslice(self, id, jd, step, v);
-    }
-SWIGINTERN void std_vector_Sl_int_Sg____setitem____SWIG_1(std::vector< int > *self,PySliceObject *slice){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<int,std::allocator< int > >::difference_type id = i;
-      std::vector<int,std::allocator< int > >::difference_type jd = j;
-      swig::delslice(self, id, jd, step);
-    }
-SWIGINTERN void std_vector_Sl_int_Sg____delitem____SWIG_1(std::vector< int > *self,PySliceObject *slice){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<int,std::allocator< int > >::difference_type id = i;
-      std::vector<int,std::allocator< int > >::difference_type jd = j;
-      swig::delslice(self, id, jd, step);
-    }
-SWIGINTERN std::vector< int >::value_type const &std_vector_Sl_int_Sg____getitem____SWIG_1(std::vector< int > const *self,std::vector< int >::difference_type i){
-      return *(swig::cgetpos(self, i));
-    }
-SWIGINTERN void std_vector_Sl_int_Sg____setitem____SWIG_2(std::vector< int > *self,std::vector< int >::difference_type i,std::vector< int >::value_type const &x){
-      *(swig::getpos(self,i)) = x;
-    }
-SWIGINTERN void std_vector_Sl_int_Sg__append(std::vector< int > *self,std::vector< int >::value_type const &x){
-      self->push_back(x);
-    }
-
-  #define SWIG_From_double   PyFloat_FromDouble 
-
-
-namespace swig {
-  template <> struct traits<double > {
-    typedef value_category category;
-    static const char* type_name() { return"double"; }
-  };  
-  template <>  struct traits_asval<double > {   
-    typedef double value_type;
-    static int asval(PyObject *obj, value_type *val) { 
-      return SWIG_AsVal_double (obj, val);
-    }
-  };
-  template <>  struct traits_from<double > {
-    typedef double value_type;
-    static PyObject *from(const value_type& val) {
-      return SWIG_From_double  (val);
-    }
-  };
-}
-
-
-      namespace swig {
-	template <>  struct traits<std::vector<double, std::allocator< double > > > {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return "std::vector<" "double" "," "std::allocator< double >" " >";
-	  }
-	};
-      }
-    
-SWIGINTERN swig::SwigPyIterator *std_vector_Sl_double_Sg__iterator(std::vector< double > *self,PyObject **PYTHON_SELF){
-      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
-    }
-SWIGINTERN bool std_vector_Sl_double_Sg____nonzero__(std::vector< double > const *self){
-      return !(self->empty());
-    }
-SWIGINTERN bool std_vector_Sl_double_Sg____bool__(std::vector< double > const *self){
-      return !(self->empty());
-    }
-SWIGINTERN std::vector< double >::size_type std_vector_Sl_double_Sg____len__(std::vector< double > const *self){
-      return self->size();
-    }
-SWIGINTERN std::vector< double >::value_type std_vector_Sl_double_Sg__pop(std::vector< double > *self){
-      if (self->size() == 0)
-	throw std::out_of_range("pop from empty container");
-      std::vector<double,std::allocator< double > >::value_type x = self->back();
-      self->pop_back();
-      return x;
-    }
-SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg____getslice__(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::difference_type j){
-      return swig::getslice(self, i, j, 1);
-    }
-SWIGINTERN void std_vector_Sl_double_Sg____setslice____SWIG_0(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::difference_type j,std::vector< double,std::allocator< double > > const &v=std::vector< double,std::allocator< double > >()){
-      swig::setslice(self, i, j, 1, v);
-    }
-SWIGINTERN void std_vector_Sl_double_Sg____delslice__(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::difference_type j){
-      swig::delslice(self, i, j, 1);
-    }
-SWIGINTERN void std_vector_Sl_double_Sg____delitem____SWIG_0(std::vector< double > *self,std::vector< double >::difference_type i){
-      self->erase(swig::getpos(self,i));
-    }
-SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg____getitem____SWIG_0(std::vector< double > *self,PySliceObject *slice){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return NULL;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<double,std::allocator< double > >::difference_type id = i;
-      std::vector<double,std::allocator< double > >::difference_type jd = j;
-      return swig::getslice(self, id, jd, step);
-    }
-SWIGINTERN void std_vector_Sl_double_Sg____setitem____SWIG_0(std::vector< double > *self,PySliceObject *slice,std::vector< double,std::allocator< double > > const &v){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<double,std::allocator< double > >::difference_type id = i;
-      std::vector<double,std::allocator< double > >::difference_type jd = j;
-      swig::setslice(self, id, jd, step, v);
-    }
-SWIGINTERN void std_vector_Sl_double_Sg____setitem____SWIG_1(std::vector< double > *self,PySliceObject *slice){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<double,std::allocator< double > >::difference_type id = i;
-      std::vector<double,std::allocator< double > >::difference_type jd = j;
-      swig::delslice(self, id, jd, step);
-    }
-SWIGINTERN void std_vector_Sl_double_Sg____delitem____SWIG_1(std::vector< double > *self,PySliceObject *slice){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<double,std::allocator< double > >::difference_type id = i;
-      std::vector<double,std::allocator< double > >::difference_type jd = j;
-      swig::delslice(self, id, jd, step);
-    }
-SWIGINTERN std::vector< double >::value_type const &std_vector_Sl_double_Sg____getitem____SWIG_1(std::vector< double > const *self,std::vector< double >::difference_type i){
-      return *(swig::cgetpos(self, i));
-    }
-SWIGINTERN void std_vector_Sl_double_Sg____setitem____SWIG_2(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::value_type const &x){
-      *(swig::getpos(self,i)) = x;
-    }
-SWIGINTERN void std_vector_Sl_double_Sg__append(std::vector< double > *self,std::vector< double >::value_type const &x){
-      self->push_back(x);
-    }
-
-  namespace swig {
-    template <>  struct traits<vips::VImage > {
-      typedef pointer_category category;
-      static const char* type_name() { return"vips::VImage"; }
-    };
-  }
-
-
-      namespace swig {
-	template <>  struct traits<std::vector<vips::VImage, std::allocator< vips::VImage > > > {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return "std::vector<" "vips::VImage" "," "std::allocator< vips::VImage >" " >";
-	  }
-	};
-      }
-    
-SWIGINTERN swig::SwigPyIterator *std_vector_Sl_vips_VImage_Sg__iterator(std::vector< vips::VImage > *self,PyObject **PYTHON_SELF){
-      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
-    }
-SWIGINTERN bool std_vector_Sl_vips_VImage_Sg____nonzero__(std::vector< vips::VImage > const *self){
-      return !(self->empty());
-    }
-SWIGINTERN bool std_vector_Sl_vips_VImage_Sg____bool__(std::vector< vips::VImage > const *self){
-      return !(self->empty());
-    }
-SWIGINTERN std::vector< vips::VImage >::size_type std_vector_Sl_vips_VImage_Sg____len__(std::vector< vips::VImage > const *self){
-      return self->size();
-    }
-SWIGINTERN std::vector< vips::VImage >::value_type std_vector_Sl_vips_VImage_Sg__pop(std::vector< vips::VImage > *self){
-      if (self->size() == 0)
-	throw std::out_of_range("pop from empty container");
-      std::vector<vips::VImage,std::allocator< vips::VImage > >::value_type x = self->back();
-      self->pop_back();
-      return x;
-    }
-SWIGINTERN std::vector< vips::VImage,std::allocator< vips::VImage > > *std_vector_Sl_vips_VImage_Sg____getslice__(std::vector< vips::VImage > *self,std::vector< vips::VImage >::difference_type i,std::vector< vips::VImage >::difference_type j){
-      return swig::getslice(self, i, j, 1);
-    }
-SWIGINTERN void std_vector_Sl_vips_VImage_Sg____setslice____SWIG_0(std::vector< vips::VImage > *self,std::vector< vips::VImage >::difference_type i,std::vector< vips::VImage >::difference_type j,std::vector< vips::VImage,std::allocator< vips::VImage > > const &v=std::vector< vips::VImage,std::allocator< vips::VImage > >()){
-      swig::setslice(self, i, j, 1, v);
-    }
-SWIGINTERN void std_vector_Sl_vips_VImage_Sg____delslice__(std::vector< vips::VImage > *self,std::vector< vips::VImage >::difference_type i,std::vector< vips::VImage >::difference_type j){
-      swig::delslice(self, i, j, 1);
-    }
-SWIGINTERN void std_vector_Sl_vips_VImage_Sg____delitem____SWIG_0(std::vector< vips::VImage > *self,std::vector< vips::VImage >::difference_type i){
-      self->erase(swig::getpos(self,i));
-    }
-SWIGINTERN std::vector< vips::VImage,std::allocator< vips::VImage > > *std_vector_Sl_vips_VImage_Sg____getitem____SWIG_0(std::vector< vips::VImage > *self,PySliceObject *slice){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return NULL;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<vips::VImage,std::allocator< vips::VImage > >::difference_type id = i;
-      std::vector<vips::VImage,std::allocator< vips::VImage > >::difference_type jd = j;
-      return swig::getslice(self, id, jd, step);
-    }
-SWIGINTERN void std_vector_Sl_vips_VImage_Sg____setitem____SWIG_0(std::vector< vips::VImage > *self,PySliceObject *slice,std::vector< vips::VImage,std::allocator< vips::VImage > > const &v){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<vips::VImage,std::allocator< vips::VImage > >::difference_type id = i;
-      std::vector<vips::VImage,std::allocator< vips::VImage > >::difference_type jd = j;
-      swig::setslice(self, id, jd, step, v);
-    }
-SWIGINTERN void std_vector_Sl_vips_VImage_Sg____setitem____SWIG_1(std::vector< vips::VImage > *self,PySliceObject *slice){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<vips::VImage,std::allocator< vips::VImage > >::difference_type id = i;
-      std::vector<vips::VImage,std::allocator< vips::VImage > >::difference_type jd = j;
-      swig::delslice(self, id, jd, step);
-    }
-SWIGINTERN void std_vector_Sl_vips_VImage_Sg____delitem____SWIG_1(std::vector< vips::VImage > *self,PySliceObject *slice){
-      Py_ssize_t i, j, step;
-      if( !PySlice_Check(slice) ) {
-        SWIG_Error(SWIG_TypeError, "Slice object expected.");
-        return;
-      }
-      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
-      std::vector<vips::VImage,std::allocator< vips::VImage > >::difference_type id = i;
-      std::vector<vips::VImage,std::allocator< vips::VImage > >::difference_type jd = j;
-      swig::delslice(self, id, jd, step);
-    }
-SWIGINTERN std::vector< vips::VImage >::value_type const &std_vector_Sl_vips_VImage_Sg____getitem____SWIG_1(std::vector< vips::VImage > const *self,std::vector< vips::VImage >::difference_type i){
-      return *(swig::cgetpos(self, i));
-    }
-SWIGINTERN void std_vector_Sl_vips_VImage_Sg____setitem____SWIG_2(std::vector< vips::VImage > *self,std::vector< vips::VImage >::difference_type i,std::vector< vips::VImage >::value_type const &x){
-      *(swig::getpos(self,i)) = x;
-    }
-SWIGINTERN void std_vector_Sl_vips_VImage_Sg__append(std::vector< vips::VImage > *self,std::vector< vips::VImage >::value_type const &x){
-      self->push_back(x);
-    }
-
-struct VBuffer {
-  void *data;
-  size_t size;
-};
-
-
-SWIGINTERN swig_type_info*
-SWIG_pchar_descriptor(void)
-{
-  static int init = 0;
-  static swig_type_info* info = 0;
-  if (!init) {
-    info = SWIG_TypeQuery("_p_char");
-    init = 1;
-  }
-  return info;
-}
-
-
-SWIGINTERN int
-SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
-{
-#if PY_VERSION_HEX>=0x03000000
-  if (PyUnicode_Check(obj))
-#else  
-  if (PyString_Check(obj))
-#endif
-  {
-    char *cstr; Py_ssize_t len;
-#if PY_VERSION_HEX>=0x03000000
-    if (!alloc && cptr) {
-        /* We can't allow converting without allocation, since the internal
-           representation of string in Python 3 is UCS-2/UCS-4 but we require
-           a UTF-8 representation.
-           TODO(bhy) More detailed explanation */
-        return SWIG_RuntimeError;
-    }
-    obj = PyUnicode_AsUTF8String(obj);
-    PyBytes_AsStringAndSize(obj, &cstr, &len);
-    if(alloc) *alloc = SWIG_NEWOBJ;
-#else
-    PyString_AsStringAndSize(obj, &cstr, &len);
-#endif
-    if (cptr) {
-      if (alloc) {
-	/* 
-	   In python the user should not be able to modify the inner
-	   string representation. To warranty that, if you define
-	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
-	   buffer is always returned.
-
-	   The default behavior is just to return the pointer value,
-	   so, be careful.
-	*/ 
-#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
-	if (*alloc != SWIG_OLDOBJ) 
-#else
-	if (*alloc == SWIG_NEWOBJ) 
-#endif
-	  {
-	    *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
-	    *alloc = SWIG_NEWOBJ;
-	  }
-	else {
-	  *cptr = cstr;
-	  *alloc = SWIG_OLDOBJ;
-	}
-      } else {
-        #if PY_VERSION_HEX>=0x03000000
-        assert(0); /* Should never reach here in Python 3 */
-        #endif
-	*cptr = SWIG_Python_str_AsChar(obj);
-      }
-    }
-    if (psize) *psize = len + 1;
-#if PY_VERSION_HEX>=0x03000000
-    Py_XDECREF(obj);
-#endif
-    return SWIG_OK;
-  } else {
-    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
-    if (pchar_descriptor) {
-      void* vptr = 0;
-      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
-	if (cptr) *cptr = (char *) vptr;
-	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
-	if (alloc) *alloc = SWIG_OLDOBJ;
-	return SWIG_OK;
-      }
-    }
-  }
-  return SWIG_TypeError;
-}
-
-
-
-
-
-SWIGINTERNINLINE PyObject *
-SWIG_From_float  (float value)
-{    
-  return SWIG_From_double  (value);
-}
-
-
-SWIGINTERNINLINE PyObject *
-SWIG_From_short  (short value)
-{    
-  return SWIG_From_long  (value);
-}
-
-
-SWIGINTERNINLINE PyObject *
-SWIG_FromCharPtrAndSize(const char* carray, size_t size)
-{
-  if (carray) {
-    if (size > INT_MAX) {
-      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
-      return pchar_descriptor ? 
-	SWIG_InternalNewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
-    } else {
-#if PY_VERSION_HEX >= 0x03000000
-      return PyUnicode_FromStringAndSize(carray, static_cast< int >(size));
-#else
-      return PyString_FromStringAndSize(carray, static_cast< int >(size));
-#endif
-    }
-  } else {
-    return SWIG_Py_Void();
-  }
-}
-
-
-SWIGINTERNINLINE PyObject * 
-SWIG_FromCharPtr(const char *cptr)
-{ 
-  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
-}
-
-
-SWIGINTERN int
-SWIG_AsVal_float (PyObject * obj, float *val)
-{
-  double v;
-  int res = SWIG_AsVal_double (obj, &v);
-  if (SWIG_IsOK(res)) {
-    if ((v < -FLT_MAX || v > FLT_MAX)) {
-      return SWIG_OverflowError;
-    } else {
-      if (val) *val = static_cast< float >(v);
-    }
-  }  
-  return res;
-}
-
-
-SWIGINTERNINLINE PyObject*
-SWIG_From_std_complex_Sl_double_Sg_  (/*@SWIG:/usr/share/swig2.0/typemaps/swigmacros.swg,104,%ifcplusplus@*/
-
-const std::complex<double>&
-
-
-
-/*@SWIG@*/ c)
-{
-  return PyComplex_FromDoubles(std::real(c), std::imag(c));
-}
-
-SWIGINTERN VBuffer vips_VImage_tobuffer(vips::VImage *self){
-    VBuffer buffer;
-
-    buffer.data = self->data ();
-    buffer.size = (size_t) self->Xsize () * self->Ysize () * 
-        IM_IMAGE_SIZEOF_PEL (self->image ());
-
-    return buffer;
-  }
-SWIGINTERN vips::VImage vips_VImage_frombuffer(VBuffer buffer,int width,int height,int bands,vips::VImage::TBandFmt format){
-    return VImage (buffer.data, width, height, bands, format);
-  }
-SWIGINTERN void vips_VImage_tostring(vips::VImage *self,char **buffer,int *buffer_len){
-    void *vips_memory;
-
-    /* Eval the vips image first. This may throw an exception and we want to
-     * make sure we do this before we try to malloc() space for the copy.
-     */
-    vips_memory = self->data ();
-
-    /* We have to copy the image data to make a string that Python can
-     * manage. Use frombuffer() / tobuffer () if you want to avoid the copy
-     * and manage memory lifetime yourself.
-     */
-    *buffer_len = (size_t) self->Xsize () * self->Ysize () * 
-      IM_IMAGE_SIZEOF_PEL (self->image ());
-    if (!(*buffer = (char *) im_malloc (NULL, *buffer_len))) 
-      verror ("Unable to allocate memory for image copy.");
-    memcpy (*buffer, vips_memory, *buffer_len);
-  }
-
-SWIGINTERN int
-SWIG_AsPtr_std_string (PyObject * obj, std::string **val) 
-{
-  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
-  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
-    if (buf) {
-      if (val) *val = new std::string(buf, size - 1);
-      if (alloc == SWIG_NEWOBJ) delete[] buf;
-      return SWIG_NEWOBJ;
-    } else {
-      if (val) *val = 0;
-      return SWIG_OLDOBJ;
-    }
-  } else {
-    static int init = 0;
-    static swig_type_info* descriptor = 0;
-    if (!init) {
-      descriptor = SWIG_TypeQuery("std::string" " *");
-      init = 1;
-    }
-    if (descriptor) {
-      std::string *vptr;
-      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
-      if (SWIG_IsOK(res) && val) *val = vptr;
-      return res;
-    }
-  }
-  return SWIG_ERROR;
-}
-
-SWIGINTERN vips::VImage vips_VImage_fromstring(std::string buffer,int width,int height,int bands,vips::VImage::TBandFmt format){
-    void *vips_memory;
-    VImage result;
-
-    /* We have to copy the string, then add a callback to the VImage to free
-     * it when we free the VImage. Use frombuffer() / tobuffer () if you want 
-     * to avoid the copy and manage memory lifetime yourself.
-     */
-    if (!(vips_memory = im_malloc (NULL, buffer.length ()))) 
-      verror ("Unable to allocate memory for image copy.");
-
-    /* We have to use .c_str () since the string may not be contiguous.
-     */
-    memcpy (vips_memory, buffer.c_str (), buffer.length ());
-    result = VImage (vips_memory, width, height, bands, format);
-
-    if (im_add_close_callback (result.image (), 
-      (im_callback_fn) im_free, vips_memory, NULL))
-      verror ();
-
-    return result;
-  }
-
-/* Turn on to print args.
-#define DEBUG
- */
-
-/* Command-line args during parse.
- */
-typedef struct _Args {
-  /* The n strings we alloc when we get from Python.
-   */
-  int n;
-  char **str;
-
-  /* argc/argv as processed by us.
-   */
-  int argc;
-  char **argv;
-} Args;
-
-#ifdef DEBUG
-static void
-args_print (Args *args)
-{
-  int i;
-
-  printf ("args_print: argc = %d\n", args->argc);
-  // +1 so we print the trailing NULL too
-  for (i = 0; i < args->argc + 1; i++)
-    printf ("\t%2d)\t%s\n", i, args->argv[i]);
-}
-#endif /*DEBUG*/
-
-static void
-args_free (Args *args)
-{
-  int i;
-
-  for (i = 0; i < args->n; i++)
-    IM_FREE (args->str[i]);
-  args->n = 0;
-  args->argc = 0;
-  IM_FREE (args->str);
-  IM_FREE (args->argv);
-  IM_FREE (args);
-}
-
-/* Get argv/argc from python.
- */
-static Args *
-args_new (void)
-{
-  Args *args;
-  PyObject *av;
-  int i;
-  int n;
-
-  args = g_new (Args, 1);
-  args->n = 0;
-  args->str = NULL;
-  args->argc = 0;
-  args->argv = NULL;
-
-  if (!(av = PySys_GetObject ((char *) "argv"))) 
-    return (args);
-  if (!PyList_Check (av)) {
-    PyErr_Warn (PyExc_Warning, "ignoring sys.argv: "
-      "it must be a list of strings");
-    return args;
-  }
-
-  n = PyList_Size (av);
-  args->str = g_new (char *, n);
-  for (i = 0; i < n; i++)
-    args->str[i] = g_strdup (PyString_AsString (PyList_GetItem (av, i)));
-  args->n = n;
-
-  /* +1 for NULL termination.
-   */
-  args->argc = n;
-  args->argv = g_new (char *, n + 1);
-  for (i = 0; i < n; i++)
-    args->argv[i] = args->str[i];
-  args->argv[i] = NULL;
-
-  return args;
-}
-
-static void
-vips_fatal (const char *msg)
-{
-  char buf[256];
-
-  im_snprintf (buf, 256, "%s\n%s", msg, im_error_buffer());
-  im_error_clear ();
-  Py_FatalError (buf);
-}
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-SWIGINTERN PyObject *_wrap_delete_SwigPyIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_SwigPyIterator",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SwigPyIterator" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_value",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_value" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  try {
-    result = (PyObject *)((swig::SwigPyIterator const *)arg1)->value();
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = result;
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_incr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  size_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_incr",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_incr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_incr" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  try {
-    result = (swig::SwigPyIterator *)(arg1)->incr(arg2);
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_incr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_incr",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_incr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  try {
-    result = (swig::SwigPyIterator *)(arg1)->incr();
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_incr(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_SwigPyIterator_incr__SWIG_1(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_SwigPyIterator_incr__SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'SwigPyIterator_incr'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    swig::SwigPyIterator::incr(size_t)\n"
-    "    swig::SwigPyIterator::incr()\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_decr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  size_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_decr",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_decr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_decr" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  try {
-    result = (swig::SwigPyIterator *)(arg1)->decr(arg2);
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_decr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_decr",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_decr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  try {
-    result = (swig::SwigPyIterator *)(arg1)->decr();
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_decr(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_SwigPyIterator_decr__SWIG_1(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_SwigPyIterator_decr__SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'SwigPyIterator_decr'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    swig::SwigPyIterator::decr(size_t)\n"
-    "    swig::SwigPyIterator::decr()\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_distance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  swig::SwigPyIterator *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  ptrdiff_t result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_distance",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_distance" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
-  try {
-    result = ((swig::SwigPyIterator const *)arg1)->distance((swig::SwigPyIterator const &)*arg2);
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_equal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  swig::SwigPyIterator *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_equal",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_equal" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
-  try {
-    result = (bool)((swig::SwigPyIterator const *)arg1)->equal((swig::SwigPyIterator const &)*arg2);
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_copy",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_copy" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->copy();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_next",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_next" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  try {
-    result = (PyObject *)(arg1)->next();
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = result;
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator___next__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator___next__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___next__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  try {
-    result = (PyObject *)(arg1)->__next__();
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = result;
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_previous(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_previous",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_previous" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  try {
-    result = (PyObject *)(arg1)->previous();
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = result;
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator_advance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  ptrdiff_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_advance",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_advance" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_advance" "', argument " "2"" of type '" "ptrdiff_t""'");
-  } 
-  arg2 = static_cast< ptrdiff_t >(val2);
-  try {
-    result = (swig::SwigPyIterator *)(arg1)->advance(arg2);
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  swig::SwigPyIterator *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___eq__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___eq__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
-  result = (bool)((swig::SwigPyIterator const *)arg1)->operator ==((swig::SwigPyIterator const &)*arg2);
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  swig::SwigPyIterator *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___ne__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___ne__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
-  result = (bool)((swig::SwigPyIterator const *)arg1)->operator !=((swig::SwigPyIterator const &)*arg2);
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator___iadd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  ptrdiff_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___iadd__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___iadd__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___iadd__" "', argument " "2"" of type '" "ptrdiff_t""'");
-  } 
-  arg2 = static_cast< ptrdiff_t >(val2);
-  try {
-    result = (swig::SwigPyIterator *) &(arg1)->operator +=(arg2);
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator___isub__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  ptrdiff_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___isub__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___isub__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___isub__" "', argument " "2"" of type '" "ptrdiff_t""'");
-  } 
-  arg2 = static_cast< ptrdiff_t >(val2);
-  try {
-    result = (swig::SwigPyIterator *) &(arg1)->operator -=(arg2);
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  ptrdiff_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___add__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___add__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___add__" "', argument " "2"" of type '" "ptrdiff_t""'");
-  } 
-  arg2 = static_cast< ptrdiff_t >(val2);
-  try {
-    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator +(arg2);
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  ptrdiff_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___sub__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "ptrdiff_t""'");
-  } 
-  arg2 = static_cast< ptrdiff_t >(val2);
-  try {
-    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator -(arg2);
-  }
-  catch(swig::stop_iteration &_e) {
-    {
-      (void)_e;
-      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
-      SWIG_fail;
-    }
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
-  swig::SwigPyIterator *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  ptrdiff_t result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___sub__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
-  }
-  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
-  }
-  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
-  result = ((swig::SwigPyIterator const *)arg1)->operator -((swig::SwigPyIterator const &)*arg2);
-  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_SwigPyIterator___sub__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_swig__SwigPyIterator, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_SwigPyIterator___sub____SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_SwigPyIterator___sub____SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  Py_INCREF(Py_NotImplemented);
-  return Py_NotImplemented;
-}
-
-
-SWIGINTERN PyObject *SwigPyIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_swig__SwigPyIterator, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject *_wrap_IntVector_iterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  PyObject **arg2 = (PyObject **) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  arg2 = &obj0;
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_iterator",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_iterator" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (swig::SwigPyIterator *)std_vector_Sl_int_Sg__iterator(arg1,arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector___nonzero__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___nonzero__" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (bool)std_vector_Sl_int_Sg____nonzero__((std::vector< int > const *)arg1);
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___bool__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector___bool__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___bool__" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (bool)std_vector_Sl_int_Sg____bool__((std::vector< int > const *)arg1);
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::size_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector___len__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___len__" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = std_vector_Sl_int_Sg____len__((std::vector< int > const *)arg1);
-  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_pop(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::value_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_pop",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_pop" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  try {
-    result = (std::vector< int >::value_type)std_vector_Sl_int_Sg__pop(arg1);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___getslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::difference_type arg2 ;
-  std::vector< int >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  std::vector< int,std::allocator< int > > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:IntVector___getslice__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___getslice__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector___getslice__" "', argument " "2"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IntVector___getslice__" "', argument " "3"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< int >::difference_type >(val3);
-  try {
-    result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg____getslice__(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___setslice____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::difference_type arg2 ;
-  std::vector< int >::difference_type arg3 ;
-  std::vector< int,std::allocator< int > > *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  int res4 = SWIG_OLDOBJ ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:IntVector___setslice__",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___setslice__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector___setslice__" "', argument " "2"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IntVector___setslice__" "', argument " "3"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< int >::difference_type >(val3);
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    res4 = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res4)) {
-      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "IntVector___setslice__" "', argument " "4"" of type '" "std::vector< int,std::allocator< int > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IntVector___setslice__" "', argument " "4"" of type '" "std::vector< int,std::allocator< int > > const &""'"); 
-    }
-    arg4 = ptr;
-  }
-  try {
-    std_vector_Sl_int_Sg____setslice____SWIG_0(arg1,arg2,arg3,(std::vector< int,std::allocator< int > > const &)*arg4);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return resultobj;
-fail:
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___setslice____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::difference_type arg2 ;
-  std::vector< int >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:IntVector___setslice__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___setslice__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector___setslice__" "', argument " "2"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IntVector___setslice__" "', argument " "3"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< int >::difference_type >(val3);
-  try {
-    std_vector_Sl_int_Sg____setslice____SWIG_0(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___setslice__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[5];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_IntVector___setslice____SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          int res = swig::asptr(argv[3], (std::vector<int,std::allocator< int > >**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_IntVector___setslice____SWIG_0(self, args);
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'IntVector___setslice__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< int >::__setslice__(std::vector< int >::difference_type,std::vector< int >::difference_type,std::vector< int,std::allocator< int > > const &)\n"
-    "    std::vector< int >::__setslice__(std::vector< int >::difference_type,std::vector< int >::difference_type)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___delslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::difference_type arg2 ;
-  std::vector< int >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:IntVector___delslice__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___delslice__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector___delslice__" "', argument " "2"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IntVector___delslice__" "', argument " "3"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< int >::difference_type >(val3);
-  try {
-    std_vector_Sl_int_Sg____delslice__(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___delitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector___delitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___delitem__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector___delitem__" "', argument " "2"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::difference_type >(val2);
-  try {
-    std_vector_Sl_int_Sg____delitem____SWIG_0(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___getitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< int,std::allocator< int > > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector___getitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___getitem__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector___getitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  try {
-    result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg____getitem____SWIG_0(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___setitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  std::vector< int,std::allocator< int > > *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res3 = SWIG_OLDOBJ ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:IntVector___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___setitem__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector___setitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    res3 = swig::asptr(obj2, &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "IntVector___setitem__" "', argument " "3"" of type '" "std::vector< int,std::allocator< int > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IntVector___setitem__" "', argument " "3"" of type '" "std::vector< int,std::allocator< int > > const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  try {
-    std_vector_Sl_int_Sg____setitem____SWIG_0(arg1,arg2,(std::vector< int,std::allocator< int > > const &)*arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return resultobj;
-fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___setitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector___setitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___setitem__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector___setitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  try {
-    std_vector_Sl_int_Sg____setitem____SWIG_1(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___delitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector___delitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___delitem__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector___delitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  try {
-    std_vector_Sl_int_Sg____delitem____SWIG_1(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___delitem__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        return _wrap_IntVector___delitem____SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_IntVector___delitem____SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'IntVector___delitem__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< int >::__delitem__(std::vector< int >::difference_type)\n"
-    "    std::vector< int >::__delitem__(PySliceObject *)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___getitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< int >::value_type *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector___getitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___getitem__" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector___getitem__" "', argument " "2"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::difference_type >(val2);
-  try {
-    result = (std::vector< int >::value_type *) &std_vector_Sl_int_Sg____getitem____SWIG_1((std::vector< int > const *)arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(*result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___getitem__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        return _wrap_IntVector___getitem____SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_IntVector___getitem____SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'IntVector___getitem__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< int >::__getitem__(PySliceObject *)\n"
-    "    std::vector< int >::__getitem__(std::vector< int >::difference_type) const\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___setitem____SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::difference_type arg2 ;
-  std::vector< int >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  std::vector< int >::value_type temp3 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:IntVector___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector___setitem__" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector___setitem__" "', argument " "2"" of type '" "std::vector< int >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IntVector___setitem__" "', argument " "3"" of type '" "std::vector< int >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< int >::value_type >(val3);
-  arg3 = &temp3;
-  try {
-    std_vector_Sl_int_Sg____setitem____SWIG_2(arg1,arg2,(int const &)*arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector___setitem__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        return _wrap_IntVector___setitem____SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector<int,std::allocator< int > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_IntVector___setitem____SWIG_0(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_IntVector___setitem____SWIG_2(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'IntVector___setitem__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< int >::__setitem__(PySliceObject *,std::vector< int,std::allocator< int > > const &)\n"
-    "    std::vector< int >::__setitem__(PySliceObject *)\n"
-    "    std::vector< int >::__setitem__(std::vector< int >::difference_type,std::vector< int >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::value_type *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  std::vector< int >::value_type temp2 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector_append",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_append" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector_append" "', argument " "2"" of type '" "std::vector< int >::value_type""'");
-  } 
-  temp2 = static_cast< std::vector< int >::value_type >(val2);
-  arg2 = &temp2;
-  std_vector_Sl_int_Sg__append(arg1,(int const &)*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_IntVector__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)":new_IntVector")) SWIG_fail;
-  result = (std::vector< int > *)new std::vector< int >();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_IntVector__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = 0 ;
-  int res1 = SWIG_OLDOBJ ;
-  PyObject * obj0 = 0 ;
-  std::vector< int > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_IntVector",&obj0)) SWIG_fail;
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    res1 = swig::asptr(obj0, &ptr);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_IntVector" "', argument " "1"" of type '" "std::vector< int > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IntVector" "', argument " "1"" of type '" "std::vector< int > const &""'"); 
-    }
-    arg1 = ptr;
-  }
-  result = (std::vector< int > *)new std::vector< int >((std::vector< int > const &)*arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_NEW |  0 );
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return resultobj;
-fail:
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_empty",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_empty" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (bool)((std::vector< int > const *)arg1)->empty();
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::size_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_size",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_size" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = ((std::vector< int > const *)arg1)->size();
-  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_clear",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_clear" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  (arg1)->clear();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_swap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int > *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector_swap",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_swap" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IntVector_swap" "', argument " "2"" of type '" "std::vector< int > &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IntVector_swap" "', argument " "2"" of type '" "std::vector< int > &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< int > * >(argp2);
-  (arg1)->swap(*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_get_allocator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  SwigValueWrapper< std::allocator< int > > result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_get_allocator",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_get_allocator" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = ((std::vector< int > const *)arg1)->get_allocator();
-  resultobj = SWIG_NewPointerObj((new std::vector< int >::allocator_type(static_cast< const std::vector< int >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_int_t, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_begin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_begin",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_begin" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (arg1)->begin();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< int >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_end(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_end",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_end" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (arg1)->end();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< int >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_rbegin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::reverse_iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_rbegin",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_rbegin" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (arg1)->rbegin();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< int >::reverse_iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_rend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::reverse_iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_rend",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_rend" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (arg1)->rend();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< int >::reverse_iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_IntVector__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int >::size_type arg1 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_IntVector",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_IntVector" "', argument " "1"" of type '" "std::vector< int >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< int >::size_type >(val1);
-  result = (std::vector< int > *)new std::vector< int >(arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_pop_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_pop_back",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_pop_back" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  (arg1)->pop_back();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_resize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector_resize",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_resize" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector_resize" "', argument " "2"" of type '" "std::vector< int >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::size_type >(val2);
-  (arg1)->resize(arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::iterator arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< int >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector_erase",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_erase" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_erase" "', argument " "2"" of type '" "std::vector< int >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_erase" "', argument " "2"" of type '" "std::vector< int >::iterator""'");
-    }
-  }
-  result = (arg1)->erase(arg2);
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< int >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::iterator arg2 ;
-  std::vector< int >::iterator arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  swig::SwigPyIterator *iter3 = 0 ;
-  int res3 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  std::vector< int >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:IntVector_erase",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_erase" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_erase" "', argument " "2"" of type '" "std::vector< int >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_erase" "', argument " "2"" of type '" "std::vector< int >::iterator""'");
-    }
-  }
-  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res3) || !iter3) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_erase" "', argument " "3"" of type '" "std::vector< int >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter3);
-    if (iter_t) {
-      arg3 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_erase" "', argument " "3"" of type '" "std::vector< int >::iterator""'");
-    }
-  }
-  result = (arg1)->erase(arg2,arg3);
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< int >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_erase(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter) != 0));
-      if (_v) {
-        return _wrap_IntVector_erase__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter) != 0));
-      if (_v) {
-        swig::SwigPyIterator *iter = 0;
-        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter) != 0));
-        if (_v) {
-          return _wrap_IntVector_erase__SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'IntVector_erase'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< int >::erase(std::vector< int >::iterator)\n"
-    "    std::vector< int >::erase(std::vector< int >::iterator,std::vector< int >::iterator)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_IntVector__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int >::size_type arg1 ;
-  std::vector< int >::value_type *arg2 = 0 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  std::vector< int >::value_type temp2 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< int > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:new_IntVector",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_IntVector" "', argument " "1"" of type '" "std::vector< int >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< int >::size_type >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_IntVector" "', argument " "2"" of type '" "std::vector< int >::value_type""'");
-  } 
-  temp2 = static_cast< std::vector< int >::value_type >(val2);
-  arg2 = &temp2;
-  result = (std::vector< int > *)new std::vector< int >(arg1,(std::vector< int >::value_type const &)*arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_IntVector(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_new_IntVector__SWIG_0(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      return _wrap_new_IntVector__SWIG_2(self, args);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_IntVector__SWIG_1(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_new_IntVector__SWIG_3(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_IntVector'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< int >::vector()\n"
-    "    std::vector< int >::vector(std::vector< int > const &)\n"
-    "    std::vector< int >::vector(std::vector< int >::size_type)\n"
-    "    std::vector< int >::vector(std::vector< int >::size_type,std::vector< int >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_push_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::value_type *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  std::vector< int >::value_type temp2 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector_push_back",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_push_back" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector_push_back" "', argument " "2"" of type '" "std::vector< int >::value_type""'");
-  } 
-  temp2 = static_cast< std::vector< int >::value_type >(val2);
-  arg2 = &temp2;
-  (arg1)->push_back((std::vector< int >::value_type const &)*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_front(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::value_type *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_front",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_front" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (std::vector< int >::value_type *) &((std::vector< int > const *)arg1)->front();
-  resultobj = SWIG_From_int(static_cast< int >(*result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::value_type *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_back",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_back" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = (std::vector< int >::value_type *) &((std::vector< int > const *)arg1)->back();
-  resultobj = SWIG_From_int(static_cast< int >(*result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_assign(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::size_type arg2 ;
-  std::vector< int >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  std::vector< int >::value_type temp3 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:IntVector_assign",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_assign" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector_assign" "', argument " "2"" of type '" "std::vector< int >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::size_type >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IntVector_assign" "', argument " "3"" of type '" "std::vector< int >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< int >::value_type >(val3);
-  arg3 = &temp3;
-  (arg1)->assign(arg2,(std::vector< int >::value_type const &)*arg3);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_resize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::size_type arg2 ;
-  std::vector< int >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  std::vector< int >::value_type temp3 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:IntVector_resize",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_resize" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector_resize" "', argument " "2"" of type '" "std::vector< int >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::size_type >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IntVector_resize" "', argument " "3"" of type '" "std::vector< int >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< int >::value_type >(val3);
-  arg3 = &temp3;
-  (arg1)->resize(arg2,(std::vector< int >::value_type const &)*arg3);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_resize(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_IntVector_resize__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_IntVector_resize__SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'IntVector_resize'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< int >::resize(std::vector< int >::size_type)\n"
-    "    std::vector< int >::resize(std::vector< int >::size_type,std::vector< int >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_insert__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::iterator arg2 ;
-  std::vector< int >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  std::vector< int >::value_type temp3 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  std::vector< int >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:IntVector_insert",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_insert" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_insert" "', argument " "2"" of type '" "std::vector< int >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_insert" "', argument " "2"" of type '" "std::vector< int >::iterator""'");
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IntVector_insert" "', argument " "3"" of type '" "std::vector< int >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< int >::value_type >(val3);
-  arg3 = &temp3;
-  result = (arg1)->insert(arg2,(std::vector< int >::value_type const &)*arg3);
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< int >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_insert__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::iterator arg2 ;
-  std::vector< int >::size_type arg3 ;
-  std::vector< int >::value_type *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  size_t val3 ;
-  int ecode3 = 0 ;
-  std::vector< int >::value_type temp4 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:IntVector_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_insert" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_insert" "', argument " "2"" of type '" "std::vector< int >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IntVector_insert" "', argument " "2"" of type '" "std::vector< int >::iterator""'");
-    }
-  }
-  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IntVector_insert" "', argument " "3"" of type '" "std::vector< int >::size_type""'");
-  } 
-  arg3 = static_cast< std::vector< int >::size_type >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "IntVector_insert" "', argument " "4"" of type '" "std::vector< int >::value_type""'");
-  } 
-  temp4 = static_cast< std::vector< int >::value_type >(val4);
-  arg4 = &temp4;
-  (arg1)->insert(arg2,arg3,(std::vector< int >::value_type const &)*arg4);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_insert(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[5];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_IntVector_insert__SWIG_0(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<int,std::allocator< int > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< int >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_size_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            return _wrap_IntVector_insert__SWIG_1(self, args);
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'IntVector_insert'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< int >::insert(std::vector< int >::iterator,std::vector< int >::value_type const &)\n"
-    "    std::vector< int >::insert(std::vector< int >::iterator,std::vector< int >::size_type,std::vector< int >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_reserve(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  std::vector< int >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:IntVector_reserve",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_reserve" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntVector_reserve" "', argument " "2"" of type '" "std::vector< int >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< int >::size_type >(val2);
-  (arg1)->reserve(arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_IntVector_capacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< int >::size_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:IntVector_capacity",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntVector_capacity" "', argument " "1"" of type '" "std::vector< int > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  result = ((std::vector< int > const *)arg1)->capacity();
-  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_IntVector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_IntVector",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IntVector" "', argument " "1"" of type '" "std::vector< int > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *IntVector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject *_wrap_DoubleVector_iterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  PyObject **arg2 = (PyObject **) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  arg2 = &obj0;
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_iterator",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_iterator" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (swig::SwigPyIterator *)std_vector_Sl_double_Sg__iterator(arg1,arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector___nonzero__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___nonzero__" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (bool)std_vector_Sl_double_Sg____nonzero__((std::vector< double > const *)arg1);
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___bool__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector___bool__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___bool__" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (bool)std_vector_Sl_double_Sg____bool__((std::vector< double > const *)arg1);
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::size_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector___len__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___len__" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = std_vector_Sl_double_Sg____len__((std::vector< double > const *)arg1);
-  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_pop(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::value_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_pop",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_pop" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  try {
-    result = (std::vector< double >::value_type)std_vector_Sl_double_Sg__pop(arg1);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___getslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::difference_type arg2 ;
-  std::vector< double >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  std::vector< double,std::allocator< double > > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector___getslice__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___getslice__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector___getslice__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DoubleVector___getslice__" "', argument " "3"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< double >::difference_type >(val3);
-  try {
-    result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg____getslice__(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___setslice____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::difference_type arg2 ;
-  std::vector< double >::difference_type arg3 ;
-  std::vector< double,std::allocator< double > > *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  int res4 = SWIG_OLDOBJ ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:DoubleVector___setslice__",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___setslice__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector___setslice__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DoubleVector___setslice__" "', argument " "3"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< double >::difference_type >(val3);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    res4 = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res4)) {
-      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "DoubleVector___setslice__" "', argument " "4"" of type '" "std::vector< double,std::allocator< double > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DoubleVector___setslice__" "', argument " "4"" of type '" "std::vector< double,std::allocator< double > > const &""'"); 
-    }
-    arg4 = ptr;
-  }
-  try {
-    std_vector_Sl_double_Sg____setslice____SWIG_0(arg1,arg2,arg3,(std::vector< double,std::allocator< double > > const &)*arg4);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return resultobj;
-fail:
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___setslice____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::difference_type arg2 ;
-  std::vector< double >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector___setslice__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___setslice__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector___setslice__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DoubleVector___setslice__" "', argument " "3"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< double >::difference_type >(val3);
-  try {
-    std_vector_Sl_double_Sg____setslice____SWIG_0(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___setslice__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[5];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_DoubleVector___setslice____SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          int res = swig::asptr(argv[3], (std::vector<double,std::allocator< double > >**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_DoubleVector___setslice____SWIG_0(self, args);
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'DoubleVector___setslice__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< double >::__setslice__(std::vector< double >::difference_type,std::vector< double >::difference_type,std::vector< double,std::allocator< double > > const &)\n"
-    "    std::vector< double >::__setslice__(std::vector< double >::difference_type,std::vector< double >::difference_type)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___delslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::difference_type arg2 ;
-  std::vector< double >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector___delslice__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___delslice__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector___delslice__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DoubleVector___delslice__" "', argument " "3"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< double >::difference_type >(val3);
-  try {
-    std_vector_Sl_double_Sg____delslice__(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___delitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector___delitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___delitem__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector___delitem__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::difference_type >(val2);
-  try {
-    std_vector_Sl_double_Sg____delitem____SWIG_0(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___getitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< double,std::allocator< double > > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector___getitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___getitem__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector___getitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  try {
-    result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg____getitem____SWIG_0(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___setitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  std::vector< double,std::allocator< double > > *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res3 = SWIG_OLDOBJ ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___setitem__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector___setitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    res3 = swig::asptr(obj2, &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DoubleVector___setitem__" "', argument " "3"" of type '" "std::vector< double,std::allocator< double > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DoubleVector___setitem__" "', argument " "3"" of type '" "std::vector< double,std::allocator< double > > const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  try {
-    std_vector_Sl_double_Sg____setitem____SWIG_0(arg1,arg2,(std::vector< double,std::allocator< double > > const &)*arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return resultobj;
-fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___setitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector___setitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___setitem__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector___setitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  try {
-    std_vector_Sl_double_Sg____setitem____SWIG_1(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___delitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector___delitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___delitem__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector___delitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  try {
-    std_vector_Sl_double_Sg____delitem____SWIG_1(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___delitem__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        return _wrap_DoubleVector___delitem____SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_DoubleVector___delitem____SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'DoubleVector___delitem__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< double >::__delitem__(std::vector< double >::difference_type)\n"
-    "    std::vector< double >::__delitem__(PySliceObject *)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___getitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< double >::value_type *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector___getitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___getitem__" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector___getitem__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::difference_type >(val2);
-  try {
-    result = (std::vector< double >::value_type *) &std_vector_Sl_double_Sg____getitem____SWIG_1((std::vector< double > const *)arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(*result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___getitem__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        return _wrap_DoubleVector___getitem____SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_DoubleVector___getitem____SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'DoubleVector___getitem__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< double >::__getitem__(PySliceObject *)\n"
-    "    std::vector< double >::__getitem__(std::vector< double >::difference_type) const\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___setitem____SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::difference_type arg2 ;
-  std::vector< double >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  std::vector< double >::value_type temp3 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector___setitem__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector___setitem__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DoubleVector___setitem__" "', argument " "3"" of type '" "std::vector< double >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< double >::value_type >(val3);
-  arg3 = &temp3;
-  try {
-    std_vector_Sl_double_Sg____setitem____SWIG_2(arg1,arg2,(double const &)*arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector___setitem__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        return _wrap_DoubleVector___setitem____SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector<double,std::allocator< double > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_DoubleVector___setitem____SWIG_0(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_double(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_DoubleVector___setitem____SWIG_2(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'DoubleVector___setitem__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< double >::__setitem__(PySliceObject *,std::vector< double,std::allocator< double > > const &)\n"
-    "    std::vector< double >::__setitem__(PySliceObject *)\n"
-    "    std::vector< double >::__setitem__(std::vector< double >::difference_type,std::vector< double >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::value_type *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  std::vector< double >::value_type temp2 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_append",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_append" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector_append" "', argument " "2"" of type '" "std::vector< double >::value_type""'");
-  } 
-  temp2 = static_cast< std::vector< double >::value_type >(val2);
-  arg2 = &temp2;
-  std_vector_Sl_double_Sg__append(arg1,(double const &)*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_DoubleVector__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)":new_DoubleVector")) SWIG_fail;
-  result = (std::vector< double > *)new std::vector< double >();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_DoubleVector__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = 0 ;
-  int res1 = SWIG_OLDOBJ ;
-  PyObject * obj0 = 0 ;
-  std::vector< double > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_DoubleVector",&obj0)) SWIG_fail;
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    res1 = swig::asptr(obj0, &ptr);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DoubleVector" "', argument " "1"" of type '" "std::vector< double > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DoubleVector" "', argument " "1"" of type '" "std::vector< double > const &""'"); 
-    }
-    arg1 = ptr;
-  }
-  result = (std::vector< double > *)new std::vector< double >((std::vector< double > const &)*arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_NEW |  0 );
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return resultobj;
-fail:
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_empty",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_empty" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (bool)((std::vector< double > const *)arg1)->empty();
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::size_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_size",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_size" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = ((std::vector< double > const *)arg1)->size();
-  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_clear",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_clear" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  (arg1)->clear();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_swap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double > *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_swap",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_swap" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoubleVector_swap" "', argument " "2"" of type '" "std::vector< double > &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DoubleVector_swap" "', argument " "2"" of type '" "std::vector< double > &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< double > * >(argp2);
-  (arg1)->swap(*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_get_allocator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  SwigValueWrapper< std::allocator< double > > result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_get_allocator",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_get_allocator" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = ((std::vector< double > const *)arg1)->get_allocator();
-  resultobj = SWIG_NewPointerObj((new std::vector< double >::allocator_type(static_cast< const std::vector< double >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_double_t, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_begin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_begin",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_begin" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (arg1)->begin();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< double >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_end(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_end",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_end" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (arg1)->end();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< double >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_rbegin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::reverse_iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_rbegin",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_rbegin" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (arg1)->rbegin();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< double >::reverse_iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_rend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::reverse_iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_rend",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_rend" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (arg1)->rend();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< double >::reverse_iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_DoubleVector__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double >::size_type arg1 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_DoubleVector",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DoubleVector" "', argument " "1"" of type '" "std::vector< double >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< double >::size_type >(val1);
-  result = (std::vector< double > *)new std::vector< double >(arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_pop_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_pop_back",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_pop_back" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  (arg1)->pop_back();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_resize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_resize",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_resize" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector_resize" "', argument " "2"" of type '" "std::vector< double >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::size_type >(val2);
-  (arg1)->resize(arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::iterator arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< double >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_erase",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_erase" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_erase" "', argument " "2"" of type '" "std::vector< double >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_erase" "', argument " "2"" of type '" "std::vector< double >::iterator""'");
-    }
-  }
-  result = (arg1)->erase(arg2);
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< double >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::iterator arg2 ;
-  std::vector< double >::iterator arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  swig::SwigPyIterator *iter3 = 0 ;
-  int res3 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  std::vector< double >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector_erase",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_erase" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_erase" "', argument " "2"" of type '" "std::vector< double >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_erase" "', argument " "2"" of type '" "std::vector< double >::iterator""'");
-    }
-  }
-  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res3) || !iter3) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_erase" "', argument " "3"" of type '" "std::vector< double >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter3);
-    if (iter_t) {
-      arg3 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_erase" "', argument " "3"" of type '" "std::vector< double >::iterator""'");
-    }
-  }
-  result = (arg1)->erase(arg2,arg3);
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< double >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_erase(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter) != 0));
-      if (_v) {
-        return _wrap_DoubleVector_erase__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter) != 0));
-      if (_v) {
-        swig::SwigPyIterator *iter = 0;
-        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter) != 0));
-        if (_v) {
-          return _wrap_DoubleVector_erase__SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'DoubleVector_erase'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< double >::erase(std::vector< double >::iterator)\n"
-    "    std::vector< double >::erase(std::vector< double >::iterator,std::vector< double >::iterator)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_DoubleVector__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double >::size_type arg1 ;
-  std::vector< double >::value_type *arg2 = 0 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  std::vector< double >::value_type temp2 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< double > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:new_DoubleVector",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DoubleVector" "', argument " "1"" of type '" "std::vector< double >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< double >::size_type >(val1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_DoubleVector" "', argument " "2"" of type '" "std::vector< double >::value_type""'");
-  } 
-  temp2 = static_cast< std::vector< double >::value_type >(val2);
-  arg2 = &temp2;
-  result = (std::vector< double > *)new std::vector< double >(arg1,(std::vector< double >::value_type const &)*arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_DoubleVector(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_new_DoubleVector__SWIG_0(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      return _wrap_new_DoubleVector__SWIG_2(self, args);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_DoubleVector__SWIG_1(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_new_DoubleVector__SWIG_3(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_DoubleVector'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< double >::vector()\n"
-    "    std::vector< double >::vector(std::vector< double > const &)\n"
-    "    std::vector< double >::vector(std::vector< double >::size_type)\n"
-    "    std::vector< double >::vector(std::vector< double >::size_type,std::vector< double >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_push_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::value_type *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  std::vector< double >::value_type temp2 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_push_back",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_push_back" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector_push_back" "', argument " "2"" of type '" "std::vector< double >::value_type""'");
-  } 
-  temp2 = static_cast< std::vector< double >::value_type >(val2);
-  arg2 = &temp2;
-  (arg1)->push_back((std::vector< double >::value_type const &)*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_front(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::value_type *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_front",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_front" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (std::vector< double >::value_type *) &((std::vector< double > const *)arg1)->front();
-  resultobj = SWIG_From_double(static_cast< double >(*result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::value_type *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_back",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_back" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = (std::vector< double >::value_type *) &((std::vector< double > const *)arg1)->back();
-  resultobj = SWIG_From_double(static_cast< double >(*result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_assign(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::size_type arg2 ;
-  std::vector< double >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  std::vector< double >::value_type temp3 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector_assign",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_assign" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector_assign" "', argument " "2"" of type '" "std::vector< double >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::size_type >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DoubleVector_assign" "', argument " "3"" of type '" "std::vector< double >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< double >::value_type >(val3);
-  arg3 = &temp3;
-  (arg1)->assign(arg2,(std::vector< double >::value_type const &)*arg3);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_resize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::size_type arg2 ;
-  std::vector< double >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  std::vector< double >::value_type temp3 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector_resize",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_resize" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector_resize" "', argument " "2"" of type '" "std::vector< double >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::size_type >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DoubleVector_resize" "', argument " "3"" of type '" "std::vector< double >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< double >::value_type >(val3);
-  arg3 = &temp3;
-  (arg1)->resize(arg2,(std::vector< double >::value_type const &)*arg3);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_resize(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_DoubleVector_resize__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_double(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_DoubleVector_resize__SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'DoubleVector_resize'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< double >::resize(std::vector< double >::size_type)\n"
-    "    std::vector< double >::resize(std::vector< double >::size_type,std::vector< double >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_insert__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::iterator arg2 ;
-  std::vector< double >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  std::vector< double >::value_type temp3 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  std::vector< double >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:DoubleVector_insert",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_insert" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_insert" "', argument " "2"" of type '" "std::vector< double >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_insert" "', argument " "2"" of type '" "std::vector< double >::iterator""'");
-    }
-  }
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DoubleVector_insert" "', argument " "3"" of type '" "std::vector< double >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< double >::value_type >(val3);
-  arg3 = &temp3;
-  result = (arg1)->insert(arg2,(std::vector< double >::value_type const &)*arg3);
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< double >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_insert__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::iterator arg2 ;
-  std::vector< double >::size_type arg3 ;
-  std::vector< double >::value_type *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  size_t val3 ;
-  int ecode3 = 0 ;
-  std::vector< double >::value_type temp4 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:DoubleVector_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_insert" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_insert" "', argument " "2"" of type '" "std::vector< double >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "DoubleVector_insert" "', argument " "2"" of type '" "std::vector< double >::iterator""'");
-    }
-  }
-  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "DoubleVector_insert" "', argument " "3"" of type '" "std::vector< double >::size_type""'");
-  } 
-  arg3 = static_cast< std::vector< double >::size_type >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DoubleVector_insert" "', argument " "4"" of type '" "std::vector< double >::value_type""'");
-  } 
-  temp4 = static_cast< std::vector< double >::value_type >(val4);
-  arg4 = &temp4;
-  (arg1)->insert(arg2,arg3,(std::vector< double >::value_type const &)*arg4);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_insert(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[5];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_double(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_DoubleVector_insert__SWIG_0(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<double,std::allocator< double > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< double >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_size_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_double(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            return _wrap_DoubleVector_insert__SWIG_1(self, args);
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'DoubleVector_insert'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< double >::insert(std::vector< double >::iterator,std::vector< double >::value_type const &)\n"
-    "    std::vector< double >::insert(std::vector< double >::iterator,std::vector< double >::size_type,std::vector< double >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_reserve(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  std::vector< double >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:DoubleVector_reserve",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_reserve" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DoubleVector_reserve" "', argument " "2"" of type '" "std::vector< double >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< double >::size_type >(val2);
-  (arg1)->reserve(arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_DoubleVector_capacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< double >::size_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:DoubleVector_capacity",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoubleVector_capacity" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  result = ((std::vector< double > const *)arg1)->capacity();
-  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_DoubleVector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_DoubleVector",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DoubleVector" "', argument " "1"" of type '" "std::vector< double > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *DoubleVector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject *_wrap_ImageVector_iterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  PyObject **arg2 = (PyObject **) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  swig::SwigPyIterator *result = 0 ;
-  
-  arg2 = &obj0;
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_iterator",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_iterator" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (swig::SwigPyIterator *)std_vector_Sl_vips_VImage_Sg__iterator(arg1,arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector___nonzero__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___nonzero__" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (bool)std_vector_Sl_vips_VImage_Sg____nonzero__((std::vector< vips::VImage > const *)arg1);
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___bool__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector___bool__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___bool__" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (bool)std_vector_Sl_vips_VImage_Sg____bool__((std::vector< vips::VImage > const *)arg1);
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::size_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector___len__",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___len__" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = std_vector_Sl_vips_VImage_Sg____len__((std::vector< vips::VImage > const *)arg1);
-  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_pop(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::value_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_pop",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_pop" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  try {
-    result = std_vector_Sl_vips_VImage_Sg__pop(arg1);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_NewPointerObj((new std::vector< vips::VImage >::value_type(static_cast< const std::vector< vips::VImage >::value_type& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___getslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::difference_type arg2 ;
-  std::vector< vips::VImage >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  std::vector< vips::VImage,std::allocator< vips::VImage > > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:ImageVector___getslice__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___getslice__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector___getslice__" "', argument " "2"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ImageVector___getslice__" "', argument " "3"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< vips::VImage >::difference_type >(val3);
-  try {
-    result = (std::vector< vips::VImage,std::allocator< vips::VImage > > *)std_vector_Sl_vips_VImage_Sg____getslice__(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___setslice____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::difference_type arg2 ;
-  std::vector< vips::VImage >::difference_type arg3 ;
-  std::vector< vips::VImage,std::allocator< vips::VImage > > *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  int res4 = SWIG_OLDOBJ ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:ImageVector___setslice__",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___setslice__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector___setslice__" "', argument " "2"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ImageVector___setslice__" "', argument " "3"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< vips::VImage >::difference_type >(val3);
-  {
-    std::vector<vips::VImage,std::allocator< vips::VImage > > *ptr = (std::vector<vips::VImage,std::allocator< vips::VImage > > *)0;
-    res4 = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res4)) {
-      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ImageVector___setslice__" "', argument " "4"" of type '" "std::vector< vips::VImage,std::allocator< vips::VImage > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector___setslice__" "', argument " "4"" of type '" "std::vector< vips::VImage,std::allocator< vips::VImage > > const &""'"); 
-    }
-    arg4 = ptr;
-  }
-  try {
-    std_vector_Sl_vips_VImage_Sg____setslice____SWIG_0(arg1,arg2,arg3,(std::vector< vips::VImage,std::allocator< vips::VImage > > const &)*arg4);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return resultobj;
-fail:
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___setslice____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::difference_type arg2 ;
-  std::vector< vips::VImage >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:ImageVector___setslice__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___setslice__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector___setslice__" "', argument " "2"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ImageVector___setslice__" "', argument " "3"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< vips::VImage >::difference_type >(val3);
-  try {
-    std_vector_Sl_vips_VImage_Sg____setslice____SWIG_0(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___setslice__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[5];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_ImageVector___setslice____SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          int res = swig::asptr(argv[3], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_ImageVector___setslice____SWIG_0(self, args);
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ImageVector___setslice__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< vips::VImage >::__setslice__(std::vector< vips::VImage >::difference_type,std::vector< vips::VImage >::difference_type,std::vector< vips::VImage,std::allocator< vips::VImage > > const &)\n"
-    "    std::vector< vips::VImage >::__setslice__(std::vector< vips::VImage >::difference_type,std::vector< vips::VImage >::difference_type)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___delslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::difference_type arg2 ;
-  std::vector< vips::VImage >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:ImageVector___delslice__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___delslice__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector___delslice__" "', argument " "2"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::difference_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ImageVector___delslice__" "', argument " "3"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< vips::VImage >::difference_type >(val3);
-  try {
-    std_vector_Sl_vips_VImage_Sg____delslice__(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___delitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector___delitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___delitem__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector___delitem__" "', argument " "2"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::difference_type >(val2);
-  try {
-    std_vector_Sl_vips_VImage_Sg____delitem____SWIG_0(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___getitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< vips::VImage,std::allocator< vips::VImage > > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector___getitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___getitem__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector___getitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  try {
-    result = (std::vector< vips::VImage,std::allocator< vips::VImage > > *)std_vector_Sl_vips_VImage_Sg____getitem____SWIG_0(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___setitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  std::vector< vips::VImage,std::allocator< vips::VImage > > *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res3 = SWIG_OLDOBJ ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:ImageVector___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___setitem__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector___setitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  {
-    std::vector<vips::VImage,std::allocator< vips::VImage > > *ptr = (std::vector<vips::VImage,std::allocator< vips::VImage > > *)0;
-    res3 = swig::asptr(obj2, &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ImageVector___setitem__" "', argument " "3"" of type '" "std::vector< vips::VImage,std::allocator< vips::VImage > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector___setitem__" "', argument " "3"" of type '" "std::vector< vips::VImage,std::allocator< vips::VImage > > const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  try {
-    std_vector_Sl_vips_VImage_Sg____setitem____SWIG_0(arg1,arg2,(std::vector< vips::VImage,std::allocator< vips::VImage > > const &)*arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return resultobj;
-fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___setitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector___setitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___setitem__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector___setitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  try {
-    std_vector_Sl_vips_VImage_Sg____setitem____SWIG_1(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___delitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  PySliceObject *arg2 = (PySliceObject *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector___delitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___delitem__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  {
-    if (!PySlice_Check(obj1)) {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector___delitem__" "', argument " "2"" of type '" "PySliceObject *""'");
-    }
-    arg2 = (PySliceObject *) obj1;
-  }
-  try {
-    std_vector_Sl_vips_VImage_Sg____delitem____SWIG_1(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  catch(std::invalid_argument &_e) {
-    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___delitem__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        return _wrap_ImageVector___delitem____SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_ImageVector___delitem____SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ImageVector___delitem__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< vips::VImage >::__delitem__(std::vector< vips::VImage >::difference_type)\n"
-    "    std::vector< vips::VImage >::__delitem__(PySliceObject *)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___getitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< vips::VImage >::value_type *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector___getitem__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___getitem__" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector___getitem__" "', argument " "2"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::difference_type >(val2);
-  try {
-    result = (std::vector< vips::VImage >::value_type *) &std_vector_Sl_vips_VImage_Sg____getitem____SWIG_1((std::vector< vips::VImage > const *)arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___getitem__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        return _wrap_ImageVector___getitem____SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_ImageVector___getitem____SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ImageVector___getitem__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< vips::VImage >::__getitem__(PySliceObject *)\n"
-    "    std::vector< vips::VImage >::__getitem__(std::vector< vips::VImage >::difference_type) const\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___setitem____SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::difference_type arg2 ;
-  std::vector< vips::VImage >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:ImageVector___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector___setitem__" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector___setitem__" "', argument " "2"" of type '" "std::vector< vips::VImage >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::difference_type >(val2);
-  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ImageVector___setitem__" "', argument " "3"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector___setitem__" "', argument " "3"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< vips::VImage >::value_type * >(argp3);
-  try {
-    std_vector_Sl_vips_VImage_Sg____setitem____SWIG_2(arg1,arg2,(vips::VImage const &)*arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector___setitem__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        return _wrap_ImageVector___setitem____SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        _v = PySlice_Check(argv[1]);
-      }
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_ImageVector___setitem____SWIG_0(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_vips__VImage, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_ImageVector___setitem____SWIG_2(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ImageVector___setitem__'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< vips::VImage >::__setitem__(PySliceObject *,std::vector< vips::VImage,std::allocator< vips::VImage > > const &)\n"
-    "    std::vector< vips::VImage >::__setitem__(PySliceObject *)\n"
-    "    std::vector< vips::VImage >::__setitem__(std::vector< vips::VImage >::difference_type,std::vector< vips::VImage >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::value_type *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector_append",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_append" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ImageVector_append" "', argument " "2"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector_append" "', argument " "2"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< vips::VImage >::value_type * >(argp2);
-  std_vector_Sl_vips_VImage_Sg__append(arg1,(vips::VImage const &)*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_ImageVector__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)":new_ImageVector")) SWIG_fail;
-  result = (std::vector< vips::VImage > *)new std::vector< vips::VImage >();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_ImageVector__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = 0 ;
-  int res1 = SWIG_OLDOBJ ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_ImageVector",&obj0)) SWIG_fail;
-  {
-    std::vector<vips::VImage,std::allocator< vips::VImage > > *ptr = (std::vector<vips::VImage,std::allocator< vips::VImage > > *)0;
-    res1 = swig::asptr(obj0, &ptr);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ImageVector" "', argument " "1"" of type '" "std::vector< vips::VImage > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ImageVector" "', argument " "1"" of type '" "std::vector< vips::VImage > const &""'"); 
-    }
-    arg1 = ptr;
-  }
-  result = (std::vector< vips::VImage > *)new std::vector< vips::VImage >((std::vector< vips::VImage > const &)*arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, SWIG_POINTER_NEW |  0 );
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return resultobj;
-fail:
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_empty",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_empty" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (bool)((std::vector< vips::VImage > const *)arg1)->empty();
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::size_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_size",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_size" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = ((std::vector< vips::VImage > const *)arg1)->size();
-  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_clear",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_clear" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  (arg1)->clear();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_swap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage > *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector_swap",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_swap" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ImageVector_swap" "', argument " "2"" of type '" "std::vector< vips::VImage > &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector_swap" "', argument " "2"" of type '" "std::vector< vips::VImage > &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< vips::VImage > * >(argp2);
-  (arg1)->swap(*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_get_allocator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  SwigValueWrapper< std::allocator< vips::VImage > > result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_get_allocator",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_get_allocator" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = ((std::vector< vips::VImage > const *)arg1)->get_allocator();
-  resultobj = SWIG_NewPointerObj((new std::vector< vips::VImage >::allocator_type(static_cast< const std::vector< vips::VImage >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_vips__VImage_t, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_begin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_begin",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_begin" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (arg1)->begin();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< vips::VImage >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_end(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_end",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_end" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (arg1)->end();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< vips::VImage >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_rbegin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::reverse_iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_rbegin",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_rbegin" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (arg1)->rbegin();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< vips::VImage >::reverse_iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_rend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::reverse_iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_rend",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_rend" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (arg1)->rend();
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< vips::VImage >::reverse_iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_ImageVector__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage >::size_type arg1 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_ImageVector",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ImageVector" "', argument " "1"" of type '" "std::vector< vips::VImage >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< vips::VImage >::size_type >(val1);
-  result = (std::vector< vips::VImage > *)new std::vector< vips::VImage >(arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_pop_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_pop_back",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_pop_back" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  (arg1)->pop_back();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_resize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector_resize",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_resize" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector_resize" "', argument " "2"" of type '" "std::vector< vips::VImage >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::size_type >(val2);
-  (arg1)->resize(arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::iterator arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< vips::VImage >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector_erase",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_erase" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_erase" "', argument " "2"" of type '" "std::vector< vips::VImage >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_erase" "', argument " "2"" of type '" "std::vector< vips::VImage >::iterator""'");
-    }
-  }
-  result = (arg1)->erase(arg2);
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< vips::VImage >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::iterator arg2 ;
-  std::vector< vips::VImage >::iterator arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  swig::SwigPyIterator *iter3 = 0 ;
-  int res3 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  std::vector< vips::VImage >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:ImageVector_erase",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_erase" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_erase" "', argument " "2"" of type '" "std::vector< vips::VImage >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_erase" "', argument " "2"" of type '" "std::vector< vips::VImage >::iterator""'");
-    }
-  }
-  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res3) || !iter3) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_erase" "', argument " "3"" of type '" "std::vector< vips::VImage >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter3);
-    if (iter_t) {
-      arg3 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_erase" "', argument " "3"" of type '" "std::vector< vips::VImage >::iterator""'");
-    }
-  }
-  result = (arg1)->erase(arg2,arg3);
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< vips::VImage >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_erase(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter) != 0));
-      if (_v) {
-        return _wrap_ImageVector_erase__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter) != 0));
-      if (_v) {
-        swig::SwigPyIterator *iter = 0;
-        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter) != 0));
-        if (_v) {
-          return _wrap_ImageVector_erase__SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ImageVector_erase'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< vips::VImage >::erase(std::vector< vips::VImage >::iterator)\n"
-    "    std::vector< vips::VImage >::erase(std::vector< vips::VImage >::iterator,std::vector< vips::VImage >::iterator)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_ImageVector__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage >::size_type arg1 ;
-  std::vector< vips::VImage >::value_type *arg2 = 0 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::vector< vips::VImage > *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:new_ImageVector",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ImageVector" "', argument " "1"" of type '" "std::vector< vips::VImage >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< vips::VImage >::size_type >(val1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ImageVector" "', argument " "2"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ImageVector" "', argument " "2"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< vips::VImage >::value_type * >(argp2);
-  result = (std::vector< vips::VImage > *)new std::vector< vips::VImage >(arg1,(std::vector< vips::VImage >::value_type const &)*arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_ImageVector(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_new_ImageVector__SWIG_0(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      return _wrap_new_ImageVector__SWIG_2(self, args);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_ImageVector__SWIG_1(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_new_ImageVector__SWIG_3(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_ImageVector'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< vips::VImage >::vector()\n"
-    "    std::vector< vips::VImage >::vector(std::vector< vips::VImage > const &)\n"
-    "    std::vector< vips::VImage >::vector(std::vector< vips::VImage >::size_type)\n"
-    "    std::vector< vips::VImage >::vector(std::vector< vips::VImage >::size_type,std::vector< vips::VImage >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_push_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::value_type *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector_push_back",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_push_back" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ImageVector_push_back" "', argument " "2"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector_push_back" "', argument " "2"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< vips::VImage >::value_type * >(argp2);
-  (arg1)->push_back((std::vector< vips::VImage >::value_type const &)*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_front(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::value_type *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_front",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_front" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (std::vector< vips::VImage >::value_type *) &((std::vector< vips::VImage > const *)arg1)->front();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::value_type *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_back",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_back" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = (std::vector< vips::VImage >::value_type *) &((std::vector< vips::VImage > const *)arg1)->back();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_assign(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::size_type arg2 ;
-  std::vector< vips::VImage >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:ImageVector_assign",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_assign" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector_assign" "', argument " "2"" of type '" "std::vector< vips::VImage >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::size_type >(val2);
-  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ImageVector_assign" "', argument " "3"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector_assign" "', argument " "3"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< vips::VImage >::value_type * >(argp3);
-  (arg1)->assign(arg2,(std::vector< vips::VImage >::value_type const &)*arg3);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_resize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::size_type arg2 ;
-  std::vector< vips::VImage >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:ImageVector_resize",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_resize" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector_resize" "', argument " "2"" of type '" "std::vector< vips::VImage >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::size_type >(val2);
-  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ImageVector_resize" "', argument " "3"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector_resize" "', argument " "3"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< vips::VImage >::value_type * >(argp3);
-  (arg1)->resize(arg2,(std::vector< vips::VImage >::value_type const &)*arg3);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_resize(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_ImageVector_resize__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_vips__VImage, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_ImageVector_resize__SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ImageVector_resize'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< vips::VImage >::resize(std::vector< vips::VImage >::size_type)\n"
-    "    std::vector< vips::VImage >::resize(std::vector< vips::VImage >::size_type,std::vector< vips::VImage >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_insert__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::iterator arg2 ;
-  std::vector< vips::VImage >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  std::vector< vips::VImage >::iterator result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:ImageVector_insert",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_insert" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_insert" "', argument " "2"" of type '" "std::vector< vips::VImage >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_insert" "', argument " "2"" of type '" "std::vector< vips::VImage >::iterator""'");
-    }
-  }
-  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ImageVector_insert" "', argument " "3"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector_insert" "', argument " "3"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< vips::VImage >::value_type * >(argp3);
-  result = (arg1)->insert(arg2,(std::vector< vips::VImage >::value_type const &)*arg3);
-  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< vips::VImage >::iterator & >(result)),
-    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_insert__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::iterator arg2 ;
-  std::vector< vips::VImage >::size_type arg3 ;
-  std::vector< vips::VImage >::value_type *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::SwigPyIterator *iter2 = 0 ;
-  int res2 ;
-  size_t val3 ;
-  int ecode3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:ImageVector_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_insert" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_insert" "', argument " "2"" of type '" "std::vector< vips::VImage >::iterator""'");
-  } else {
-    swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "ImageVector_insert" "', argument " "2"" of type '" "std::vector< vips::VImage >::iterator""'");
-    }
-  }
-  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ImageVector_insert" "', argument " "3"" of type '" "std::vector< vips::VImage >::size_type""'");
-  } 
-  arg3 = static_cast< std::vector< vips::VImage >::size_type >(val3);
-  res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ImageVector_insert" "', argument " "4"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ImageVector_insert" "', argument " "4"" of type '" "std::vector< vips::VImage >::value_type const &""'"); 
-  }
-  arg4 = reinterpret_cast< std::vector< vips::VImage >::value_type * >(argp4);
-  (arg1)->insert(arg2,arg3,(std::vector< vips::VImage >::value_type const &)*arg4);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_insert(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[5];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter) != 0));
-      if (_v) {
-        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_vips__VImage, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_ImageVector_insert__SWIG_0(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector<vips::VImage,std::allocator< vips::VImage > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::SwigPyIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::vector< vips::VImage >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_size_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          int res = SWIG_ConvertPtr(argv[3], 0, SWIGTYPE_p_vips__VImage, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_ImageVector_insert__SWIG_1(self, args);
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ImageVector_insert'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< vips::VImage >::insert(std::vector< vips::VImage >::iterator,std::vector< vips::VImage >::value_type const &)\n"
-    "    std::vector< vips::VImage >::insert(std::vector< vips::VImage >::iterator,std::vector< vips::VImage >::size_type,std::vector< vips::VImage >::value_type const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_reserve(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  std::vector< vips::VImage >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:ImageVector_reserve",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_reserve" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ImageVector_reserve" "', argument " "2"" of type '" "std::vector< vips::VImage >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< vips::VImage >::size_type >(val2);
-  (arg1)->reserve(arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_ImageVector_capacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::vector< vips::VImage >::size_type result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:ImageVector_capacity",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImageVector_capacity" "', argument " "1"" of type '" "std::vector< vips::VImage > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  result = ((std::vector< vips::VImage > const *)arg1)->capacity();
-  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_ImageVector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage > *arg1 = (std::vector< vips::VImage > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_ImageVector",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ImageVector" "', argument " "1"" of type '" "std::vector< vips::VImage > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< vips::VImage > * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *ImageVector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject *_wrap_init__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:init",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "init" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  result = (bool)vips::init((char const *)arg1);
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_init__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  bool result;
-  
-  if (!PyArg_ParseTuple(args,(char *)":init")) SWIG_fail;
-  result = (bool)vips::init();
-  resultobj = SWIG_From_bool(static_cast< bool >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_init(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[2];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_init__SWIG_1(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_init__SWIG_0(self, args);
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'init'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::init(char const *)\n"
-    "    vips::init()\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_shutdown(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  
-  if (!PyArg_ParseTuple(args,(char *)":shutdown")) SWIG_fail;
-  vips::shutdown();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_print_all(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  
-  if (!PyArg_ParseTuple(args,(char *)":VImage_print_all")) SWIG_fail;
-  vips::VImage::print_all();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VImage__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:new_VImage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VImage" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_VImage" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (vips::VImage *)new vips::VImage((char const *)arg1,(char const *)arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, SWIG_POINTER_NEW |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VImage__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_VImage",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VImage" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = (vips::VImage *)new vips::VImage((char const *)arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, SWIG_POINTER_NEW |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VImage__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  void *arg1 = (void *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  vips::VImage::TBandFmt arg5 ;
-  int res1 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_VImage",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0,SWIG_as_voidptrptr(&arg1), 0, 0);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VImage" "', argument " "1"" of type '" "void *""'"); 
-  }
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_VImage" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_VImage" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_VImage" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_VImage" "', argument " "5"" of type '" "vips::VImage::TBandFmt""'");
-  } 
-  arg5 = static_cast< vips::VImage::TBandFmt >(val5);
-  try {
-    result = (vips::VImage *)new vips::VImage(arg1,arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VImage__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  _VipsImage *arg1 = (_VipsImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_VImage",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p__VipsImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VImage" "', argument " "1"" of type '" "_VipsImage *""'"); 
-  }
-  arg1 = reinterpret_cast< _VipsImage * >(argp1);
-  result = (vips::VImage *)new vips::VImage(arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VImage__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)":new_VImage")) SWIG_fail;
-  try {
-    result = (vips::VImage *)new vips::VImage();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convert2disc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  char *arg3 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int res3 ;
-  char *buf3 = 0 ;
-  int alloc3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_convert2disc",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_convert2disc" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_convert2disc" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_convert2disc" "', argument " "3"" of type '" "char const *""'");
-  }
-  arg3 = reinterpret_cast< char * >(buf3);
-  try {
-    result = vips::VImage::convert2disc((char const *)arg1,(char const *)arg2,(char const *)arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VImage__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_VImage",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VImage" "', argument " "1"" of type '" "vips::VImage const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VImage" "', argument " "1"" of type '" "vips::VImage const &""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (vips::VImage *)new vips::VImage((vips::VImage const &)*arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VImage(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[6];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 5) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_new_VImage__SWIG_4(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__VipsImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VImage__SWIG_3(self, args);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VImage__SWIG_5(self, args);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VImage__SWIG_1(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_new_VImage__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 5) {
-    int _v;
-    void *ptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &ptr, 0, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            {
-              int res = SWIG_AsVal_int(argv[4], NULL);
-              _v = SWIG_CheckState(res);
-            }
-            if (_v) {
-              return _wrap_new_VImage__SWIG_2(self, args);
-            }
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_VImage'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::VImage(char const *,char const *)\n"
-    "    vips::VImage::VImage(char const *)\n"
-    "    vips::VImage::VImage(void *,int,int,int,vips::VImage::TBandFmt)\n"
-    "    vips::VImage::VImage(_VipsImage *)\n"
-    "    vips::VImage::VImage()\n"
-    "    vips::VImage::VImage(vips::VImage const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage___assign__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage___assign__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage___assign__" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage___assign__" "', argument " "2"" of type '" "vips::VImage const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage___assign__" "', argument " "2"" of type '" "vips::VImage const &""'"); 
-  }
-  arg2 = reinterpret_cast< vips::VImage * >(argp2);
-  try {
-    result = (vips::VImage *) &(arg1)->operator =((vips::VImage const &)*arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VImage, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_VImage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_VImage",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VImage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  _VipsImage *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_image",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_image" "', argument " "1"" of type '" "vips::VImage const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (_VipsImage *)((vips::VImage const *)arg1)->image();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__VipsImage, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_data(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  void *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_data",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_data" "', argument " "1"" of type '" "vips::VImage const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (void *)((vips::VImage const *)arg1)->data();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_write__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_write",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_write" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_write" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_write" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->write(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_write__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_write",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_write" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_write" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (arg1)->write((char const *)arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_write__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_write",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_write" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->write();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_write(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_VImage_write__SWIG_2(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_write__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_write__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_write'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::write(vips::VImage)\n"
-    "    vips::VImage::write(char const *)\n"
-    "    vips::VImage::write()\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_debug_print(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_debug_print",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_debug_print" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  (arg1)->debug_print();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Xsize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Xsize",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Xsize" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (int)(arg1)->Xsize();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Ysize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Ysize",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Ysize" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (int)(arg1)->Ysize();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Bands(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Bands",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Bands" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (int)(arg1)->Bands();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_BandFmt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage::TBandFmt result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_BandFmt",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_BandFmt" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (vips::VImage::TBandFmt)(arg1)->BandFmt();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Coding(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage::TCoding result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Coding",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Coding" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (vips::VImage::TCoding)(arg1)->Coding();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage::TType result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Type",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Type" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (vips::VImage::TType)(arg1)->Type();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Xres(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  float result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Xres",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Xres" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (float)(arg1)->Xres();
-  resultobj = SWIG_From_float(static_cast< float >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Yres(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  float result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Yres",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Yres" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (float)(arg1)->Yres();
-  resultobj = SWIG_From_float(static_cast< float >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Length(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Length",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Length" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (int)(arg1)->Length();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Compression(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage::TCompression result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Compression",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Compression" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (vips::VImage::TCompression)(arg1)->Compression();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Level(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  short result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Level",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Level" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (short)(arg1)->Level();
-  resultobj = SWIG_From_short(static_cast< short >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Xoffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Xoffset",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Xoffset" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (int)(arg1)->Xoffset();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Yoffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Yoffset",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Yoffset" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (int)(arg1)->Yoffset();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_filename",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_filename" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (char *)(arg1)->filename();
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Hist(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Hist",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Hist" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  result = (char *)(arg1)->Hist();
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  gboolean result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_meta_remove",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_remove" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_remove" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  result = (arg1)->meta_remove((char const *)arg2);
-  resultobj = SWIG_NewPointerObj((new gboolean(static_cast< const gboolean& >(result))), SWIGTYPE_p_gboolean, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_get_typeof(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  GType result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_meta_get_typeof",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_get_typeof" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_get_typeof" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  result = (arg1)->meta_get_typeof((char const *)arg2);
-  resultobj = SWIG_NewPointerObj((new GType(static_cast< const GType& >(result))), SWIGTYPE_p_GType, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_get_int(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_meta_get_int",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_get_int" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_get_int" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (int)(arg1)->meta_get_int((char const *)arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_get_double(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_meta_get_double",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_get_double" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_get_double" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (double)(arg1)->meta_get_double((char const *)arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_get_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_meta_get_string",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_get_string" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_get_string" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (char *)(arg1)->meta_get_string((char const *)arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_get_area(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  void *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_meta_get_area",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_get_area" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_get_area" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (void *)(arg1)->meta_get_area((char const *)arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_get_blob(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  size_t *arg3 = (size_t *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  void *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_meta_get_blob",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_get_blob" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_get_blob" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_size_t, 0 |  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_meta_get_blob" "', argument " "3"" of type '" "size_t *""'"); 
-  }
-  arg3 = reinterpret_cast< size_t * >(argp3);
-  try {
-    result = (void *)(arg1)->meta_get_blob((char const *)arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_set__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_meta_set",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_set" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_set" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_meta_set" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    (arg1)->meta_set((char const *)arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_set__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  double arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_meta_set",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_set" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_set" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_meta_set" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  try {
-    (arg1)->meta_set((char const *)arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_set__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  char *arg3 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int res3 ;
-  char *buf3 = 0 ;
-  int alloc3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_meta_set",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_meta_set" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_meta_set" "', argument " "2"" of type '" "char const *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_meta_set" "', argument " "3"" of type '" "char const *""'");
-  }
-  arg3 = reinterpret_cast< char * >(buf3);
-  try {
-    (arg1)->meta_set((char const *)arg2,(char const *)arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_meta_set(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_VImage_meta_set__SWIG_0(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        {
-          int res = SWIG_AsVal_double(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_VImage_meta_set__SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_VImage_meta_set__SWIG_2(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_meta_set'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::meta_set(char const *,int)\n"
-    "    vips::VImage::meta_set(char const *,double)\n"
-    "    vips::VImage::meta_set(char const *,char const *)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_initdesc__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  vips::VImage::TBandFmt arg5 ;
-  vips::VImage::TCoding arg6 ;
-  vips::VImage::TType arg7 ;
-  float arg8 ;
-  float arg9 ;
-  int arg10 ;
-  int arg11 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  float val8 ;
-  int ecode8 = 0 ;
-  float val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:VImage_initdesc",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_initdesc" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_initdesc" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_initdesc" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_initdesc" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_initdesc" "', argument " "5"" of type '" "vips::VImage::TBandFmt""'");
-  } 
-  arg5 = static_cast< vips::VImage::TBandFmt >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_initdesc" "', argument " "6"" of type '" "vips::VImage::TCoding""'");
-  } 
-  arg6 = static_cast< vips::VImage::TCoding >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_initdesc" "', argument " "7"" of type '" "vips::VImage::TType""'");
-  } 
-  arg7 = static_cast< vips::VImage::TType >(val7);
-  ecode8 = SWIG_AsVal_float(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_initdesc" "', argument " "8"" of type '" "float""'");
-  } 
-  arg8 = static_cast< float >(val8);
-  ecode9 = SWIG_AsVal_float(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_initdesc" "', argument " "9"" of type '" "float""'");
-  } 
-  arg9 = static_cast< float >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_initdesc" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_initdesc" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  try {
-    (arg1)->initdesc(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_initdesc__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  vips::VImage::TBandFmt arg5 ;
-  vips::VImage::TCoding arg6 ;
-  vips::VImage::TType arg7 ;
-  float arg8 ;
-  float arg9 ;
-  int arg10 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  float val8 ;
-  int ecode8 = 0 ;
-  float val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:VImage_initdesc",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_initdesc" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_initdesc" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_initdesc" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_initdesc" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_initdesc" "', argument " "5"" of type '" "vips::VImage::TBandFmt""'");
-  } 
-  arg5 = static_cast< vips::VImage::TBandFmt >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_initdesc" "', argument " "6"" of type '" "vips::VImage::TCoding""'");
-  } 
-  arg6 = static_cast< vips::VImage::TCoding >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_initdesc" "', argument " "7"" of type '" "vips::VImage::TType""'");
-  } 
-  arg7 = static_cast< vips::VImage::TType >(val7);
-  ecode8 = SWIG_AsVal_float(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_initdesc" "', argument " "8"" of type '" "float""'");
-  } 
-  arg8 = static_cast< float >(val8);
-  ecode9 = SWIG_AsVal_float(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_initdesc" "', argument " "9"" of type '" "float""'");
-  } 
-  arg9 = static_cast< float >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_initdesc" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  try {
-    (arg1)->initdesc(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_initdesc__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  vips::VImage::TBandFmt arg5 ;
-  vips::VImage::TCoding arg6 ;
-  vips::VImage::TType arg7 ;
-  float arg8 ;
-  float arg9 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  float val8 ;
-  int ecode8 = 0 ;
-  float val9 ;
-  int ecode9 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:VImage_initdesc",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_initdesc" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_initdesc" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_initdesc" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_initdesc" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_initdesc" "', argument " "5"" of type '" "vips::VImage::TBandFmt""'");
-  } 
-  arg5 = static_cast< vips::VImage::TBandFmt >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_initdesc" "', argument " "6"" of type '" "vips::VImage::TCoding""'");
-  } 
-  arg6 = static_cast< vips::VImage::TCoding >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_initdesc" "', argument " "7"" of type '" "vips::VImage::TType""'");
-  } 
-  arg7 = static_cast< vips::VImage::TType >(val7);
-  ecode8 = SWIG_AsVal_float(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_initdesc" "', argument " "8"" of type '" "float""'");
-  } 
-  arg8 = static_cast< float >(val8);
-  ecode9 = SWIG_AsVal_float(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_initdesc" "', argument " "9"" of type '" "float""'");
-  } 
-  arg9 = static_cast< float >(val9);
-  try {
-    (arg1)->initdesc(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_initdesc__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  vips::VImage::TBandFmt arg5 ;
-  vips::VImage::TCoding arg6 ;
-  vips::VImage::TType arg7 ;
-  float arg8 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  float val8 ;
-  int ecode8 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:VImage_initdesc",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_initdesc" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_initdesc" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_initdesc" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_initdesc" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_initdesc" "', argument " "5"" of type '" "vips::VImage::TBandFmt""'");
-  } 
-  arg5 = static_cast< vips::VImage::TBandFmt >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_initdesc" "', argument " "6"" of type '" "vips::VImage::TCoding""'");
-  } 
-  arg6 = static_cast< vips::VImage::TCoding >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_initdesc" "', argument " "7"" of type '" "vips::VImage::TType""'");
-  } 
-  arg7 = static_cast< vips::VImage::TType >(val7);
-  ecode8 = SWIG_AsVal_float(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_initdesc" "', argument " "8"" of type '" "float""'");
-  } 
-  arg8 = static_cast< float >(val8);
-  try {
-    (arg1)->initdesc(arg2,arg3,arg4,arg5,arg6,arg7,arg8);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_initdesc__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  vips::VImage::TBandFmt arg5 ;
-  vips::VImage::TCoding arg6 ;
-  vips::VImage::TType arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_initdesc",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_initdesc" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_initdesc" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_initdesc" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_initdesc" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_initdesc" "', argument " "5"" of type '" "vips::VImage::TBandFmt""'");
-  } 
-  arg5 = static_cast< vips::VImage::TBandFmt >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_initdesc" "', argument " "6"" of type '" "vips::VImage::TCoding""'");
-  } 
-  arg6 = static_cast< vips::VImage::TCoding >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_initdesc" "', argument " "7"" of type '" "vips::VImage::TType""'");
-  } 
-  arg7 = static_cast< vips::VImage::TType >(val7);
-  try {
-    (arg1)->initdesc(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_initdesc(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[12];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 11) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 7) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            {
-              int res = SWIG_AsVal_int(argv[4], NULL);
-              _v = SWIG_CheckState(res);
-            }
-            if (_v) {
-              {
-                int res = SWIG_AsVal_int(argv[5], NULL);
-                _v = SWIG_CheckState(res);
-              }
-              if (_v) {
-                {
-                  int res = SWIG_AsVal_int(argv[6], NULL);
-                  _v = SWIG_CheckState(res);
-                }
-                if (_v) {
-                  return _wrap_VImage_initdesc__SWIG_4(self, args);
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-  }
-  if (argc == 8) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            {
-              int res = SWIG_AsVal_int(argv[4], NULL);
-              _v = SWIG_CheckState(res);
-            }
-            if (_v) {
-              {
-                int res = SWIG_AsVal_int(argv[5], NULL);
-                _v = SWIG_CheckState(res);
-              }
-              if (_v) {
-                {
-                  int res = SWIG_AsVal_int(argv[6], NULL);
-                  _v = SWIG_CheckState(res);
-                }
-                if (_v) {
-                  {
-                    int res = SWIG_AsVal_float(argv[7], NULL);
-                    _v = SWIG_CheckState(res);
-                  }
-                  if (_v) {
-                    return _wrap_VImage_initdesc__SWIG_3(self, args);
-                  }
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-  }
-  if (argc == 9) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            {
-              int res = SWIG_AsVal_int(argv[4], NULL);
-              _v = SWIG_CheckState(res);
-            }
-            if (_v) {
-              {
-                int res = SWIG_AsVal_int(argv[5], NULL);
-                _v = SWIG_CheckState(res);
-              }
-              if (_v) {
-                {
-                  int res = SWIG_AsVal_int(argv[6], NULL);
-                  _v = SWIG_CheckState(res);
-                }
-                if (_v) {
-                  {
-                    int res = SWIG_AsVal_float(argv[7], NULL);
-                    _v = SWIG_CheckState(res);
-                  }
-                  if (_v) {
-                    {
-                      int res = SWIG_AsVal_float(argv[8], NULL);
-                      _v = SWIG_CheckState(res);
-                    }
-                    if (_v) {
-                      return _wrap_VImage_initdesc__SWIG_2(self, args);
-                    }
-                  }
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-  }
-  if (argc == 10) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            {
-              int res = SWIG_AsVal_int(argv[4], NULL);
-              _v = SWIG_CheckState(res);
-            }
-            if (_v) {
-              {
-                int res = SWIG_AsVal_int(argv[5], NULL);
-                _v = SWIG_CheckState(res);
-              }
-              if (_v) {
-                {
-                  int res = SWIG_AsVal_int(argv[6], NULL);
-                  _v = SWIG_CheckState(res);
-                }
-                if (_v) {
-                  {
-                    int res = SWIG_AsVal_float(argv[7], NULL);
-                    _v = SWIG_CheckState(res);
-                  }
-                  if (_v) {
-                    {
-                      int res = SWIG_AsVal_float(argv[8], NULL);
-                      _v = SWIG_CheckState(res);
-                    }
-                    if (_v) {
-                      {
-                        int res = SWIG_AsVal_int(argv[9], NULL);
-                        _v = SWIG_CheckState(res);
-                      }
-                      if (_v) {
-                        return _wrap_VImage_initdesc__SWIG_1(self, args);
-                      }
-                    }
-                  }
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-  }
-  if (argc == 11) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            {
-              int res = SWIG_AsVal_int(argv[4], NULL);
-              _v = SWIG_CheckState(res);
-            }
-            if (_v) {
-              {
-                int res = SWIG_AsVal_int(argv[5], NULL);
-                _v = SWIG_CheckState(res);
-              }
-              if (_v) {
-                {
-                  int res = SWIG_AsVal_int(argv[6], NULL);
-                  _v = SWIG_CheckState(res);
-                }
-                if (_v) {
-                  {
-                    int res = SWIG_AsVal_float(argv[7], NULL);
-                    _v = SWIG_CheckState(res);
-                  }
-                  if (_v) {
-                    {
-                      int res = SWIG_AsVal_float(argv[8], NULL);
-                      _v = SWIG_CheckState(res);
-                    }
-                    if (_v) {
-                      {
-                        int res = SWIG_AsVal_int(argv[9], NULL);
-                        _v = SWIG_CheckState(res);
-                      }
-                      if (_v) {
-                        {
-                          int res = SWIG_AsVal_int(argv[10], NULL);
-                          _v = SWIG_CheckState(res);
-                        }
-                        if (_v) {
-                          return _wrap_VImage_initdesc__SWIG_0(self, args);
-                        }
-                      }
-                    }
-                  }
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_initdesc'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::initdesc(int,int,int,vips::VImage::TBandFmt,vips::VImage::TCoding,vips::VImage::TType,float,float,int,int)\n"
-    "    vips::VImage::initdesc(int,int,int,vips::VImage::TBandFmt,vips::VImage::TCoding,vips::VImage::TType,float,float,int)\n"
-    "    vips::VImage::initdesc(int,int,int,vips::VImage::TBandFmt,vips::VImage::TCoding,vips::VImage::TType,float,float)\n"
-    "    vips::VImage::initdesc(int,int,int,vips::VImage::TBandFmt,vips::VImage::TCoding,vips::VImage::TType,float)\n"
-    "    vips::VImage::initdesc(int,int,int,vips::VImage::TBandFmt,vips::VImage::TCoding,vips::VImage::TType)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_abs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_abs",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_abs" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->abs();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_acos(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_acos",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_acos" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->acos();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_add",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_add" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_add" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_add" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->add(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_asin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_asin",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_asin" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->asin();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_atan(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_atan",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_atan" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->atan();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_avg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_avg",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_avg" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (double)(arg1)->avg();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  double arg3 ;
-  double arg4 ;
-  int arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_point",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_point" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_point" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_point" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_point" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_point" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    result = (double)(arg1)->point(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_point_bilinear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_point_bilinear",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_point_bilinear" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_point_bilinear" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_point_bilinear" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_point_bilinear" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (double)(arg1)->point_bilinear(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_bandmean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_bandmean",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_bandmean" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->bandmean();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_ceil(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_ceil",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_ceil" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->ceil();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_cos(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_cos",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_cos" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->cos();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_cross_phase(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_cross_phase",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_cross_phase" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_cross_phase" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_cross_phase" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->cross_phase(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_deviate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_deviate",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_deviate" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (double)(arg1)->deviate();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_divide(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_divide",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_divide" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_divide" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_divide" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->divide(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_exp10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_exp10",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_exp10" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->exp10();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_expn__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_expn",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_expn" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_expn" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->expn(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_expn__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_expn",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_expn" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_expn" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->expn(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_expn(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_expn__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_expn__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_expn'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::expn(double)\n"
-    "    vips::VImage::expn(std::vector< double,std::allocator< double > >)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_exp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_exp",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_exp" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->exp();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_floor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_floor",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_floor" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->floor();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_invert(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_invert",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_invert" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->invert();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_lin",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lin" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_lin" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_lin" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  try {
-    result = (arg1)->lin(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_linreg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage,std::allocator< vips::VImage > > arg1 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_linreg",&obj0,&obj1)) SWIG_fail;
-  {
-    std::vector<vips::VImage,std::allocator< vips::VImage > > *ptr = (std::vector<vips::VImage,std::allocator< vips::VImage > > *)0;
-    int res = swig::asptr(obj0, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_linreg" "', argument " "1"" of type '" "std::vector< vips::VImage,std::allocator< vips::VImage > >""'"); 
-    }
-    arg1 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_linreg" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = vips::VImage::linreg(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  std::vector< double,std::allocator< double > > arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_lin",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lin" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_lin" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj2, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_lin" "', argument " "3"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg3 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->lin(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lin(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[4];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 3) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_double(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_VImage_lin__SWIG_0(self, args);
-        }
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector<double,std::allocator< double > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_VImage_lin__SWIG_1(self, args);
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_lin'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::lin(double,double)\n"
-    "    vips::VImage::lin(std::vector< double,std::allocator< double > >,std::vector< double,std::allocator< double > >)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_log10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_log10",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_log10" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->log10();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_log(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_log",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_log" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->log();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_max(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_max",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_max" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (double)(arg1)->max();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_maxpos(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::complex< double > result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_maxpos",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_maxpos" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->maxpos();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_std_complex_Sl_double_Sg_(static_cast< std::complex<double> >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_maxpos_avg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double *arg2 = 0 ;
-  double *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double temp2 ;
-  int res2 = SWIG_TMPOBJ ;
-  double temp3 ;
-  int res3 = SWIG_TMPOBJ ;
-  PyObject * obj0 = 0 ;
-  double result;
-  
-  arg2 = &temp2;
-  arg3 = &temp3;
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_maxpos_avg",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_maxpos_avg" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (double)(arg1)->maxpos_avg(*arg2,*arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  if (SWIG_IsTmpObj(res2)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
-  }
-  if (SWIG_IsTmpObj(res3)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_measure(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_measure",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_measure" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_measure" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_measure" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_measure" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_measure" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_measure" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_measure" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  try {
-    result = (arg1)->measure(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_min(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_min",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_min" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (double)(arg1)->min();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_minpos(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  std::complex< double > result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_minpos",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_minpos" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->minpos();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_std_complex_Sl_double_Sg_(static_cast< std::complex<double> >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_multiply(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_multiply",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_multiply" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_multiply" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_multiply" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->multiply(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_pow__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_pow",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_pow" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_pow" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->pow(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_pow__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_pow",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_pow" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_pow" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->pow(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_pow(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_pow__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_pow__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_pow'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::pow(double)\n"
-    "    vips::VImage::pow(std::vector< double,std::allocator< double > >)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_recomb(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_recomb",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_recomb" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_recomb" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_recomb" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->recomb(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_remainder__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_remainder",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_remainder" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_remainder" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_remainder" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->remainder(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_remainder__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_remainder",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_remainder" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_remainder" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->remainder(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_remainder__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_remainder",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_remainder" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_remainder" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->remainder(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_remainder(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_remainder__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_remainder__SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_remainder__SWIG_2(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_remainder'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::remainder(vips::VImage)\n"
-    "    vips::VImage::remainder(double)\n"
-    "    vips::VImage::remainder(std::vector< double,std::allocator< double > >)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_rint",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_rint" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->rint();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_sign(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_sign",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_sign" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->sign();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_sin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_sin",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_sin" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->sin();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_stats(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_stats",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_stats" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->stats();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_subtract(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_subtract",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_subtract" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_subtract" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_subtract" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->subtract(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tan(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_tan",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tan" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->tan();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_greyc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  double arg8 ;
-  double arg9 ;
-  double arg10 ;
-  int arg11 ;
-  int arg12 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  double val8 ;
-  int ecode8 = 0 ;
-  double val9 ;
-  int ecode9 = 0 ;
-  double val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  int val12 ;
-  int ecode12 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  PyObject * obj11 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOO:VImage_greyc",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_greyc" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_greyc" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_greyc" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_greyc" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_greyc" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_greyc" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_greyc" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  ecode8 = SWIG_AsVal_double(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_greyc" "', argument " "8"" of type '" "double""'");
-  } 
-  arg8 = static_cast< double >(val8);
-  ecode9 = SWIG_AsVal_double(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_greyc" "', argument " "9"" of type '" "double""'");
-  } 
-  arg9 = static_cast< double >(val9);
-  ecode10 = SWIG_AsVal_double(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_greyc" "', argument " "10"" of type '" "double""'");
-  } 
-  arg10 = static_cast< double >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_greyc" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  ecode12 = SWIG_AsVal_int(obj11, &val12);
-  if (!SWIG_IsOK(ecode12)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "VImage_greyc" "', argument " "12"" of type '" "int""'");
-  } 
-  arg12 = static_cast< int >(val12);
-  try {
-    result = (arg1)->greyc(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_greyc_mask(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  double arg8 ;
-  double arg9 ;
-  double arg10 ;
-  double arg11 ;
-  int arg12 ;
-  int arg13 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  double val8 ;
-  int ecode8 = 0 ;
-  double val9 ;
-  int ecode9 = 0 ;
-  double val10 ;
-  int ecode10 = 0 ;
-  double val11 ;
-  int ecode11 = 0 ;
-  int val12 ;
-  int ecode12 = 0 ;
-  int val13 ;
-  int ecode13 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  PyObject * obj11 = 0 ;
-  PyObject * obj12 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOOO:VImage_greyc_mask",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_greyc_mask" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_greyc_mask" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_greyc_mask" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_greyc_mask" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_greyc_mask" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_greyc_mask" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_greyc_mask" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_greyc_mask" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  ecode8 = SWIG_AsVal_double(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_greyc_mask" "', argument " "8"" of type '" "double""'");
-  } 
-  arg8 = static_cast< double >(val8);
-  ecode9 = SWIG_AsVal_double(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_greyc_mask" "', argument " "9"" of type '" "double""'");
-  } 
-  arg9 = static_cast< double >(val9);
-  ecode10 = SWIG_AsVal_double(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_greyc_mask" "', argument " "10"" of type '" "double""'");
-  } 
-  arg10 = static_cast< double >(val10);
-  ecode11 = SWIG_AsVal_double(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_greyc_mask" "', argument " "11"" of type '" "double""'");
-  } 
-  arg11 = static_cast< double >(val11);
-  ecode12 = SWIG_AsVal_int(obj11, &val12);
-  if (!SWIG_IsOK(ecode12)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "VImage_greyc_mask" "', argument " "12"" of type '" "int""'");
-  } 
-  arg12 = static_cast< int >(val12);
-  ecode13 = SWIG_AsVal_int(obj12, &val13);
-  if (!SWIG_IsOK(ecode13)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "VImage_greyc_mask" "', argument " "13"" of type '" "int""'");
-  } 
-  arg13 = static_cast< int >(val13);
-  try {
-    result = (arg1)->greyc_mask(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_LCh2Lab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_LCh2Lab",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_LCh2Lab" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->LCh2Lab();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_LCh2UCS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_LCh2UCS",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_LCh2UCS" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->LCh2UCS();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Lab2LCh(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Lab2LCh",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Lab2LCh" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->Lab2LCh();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Lab2LabQ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Lab2LabQ",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Lab2LabQ" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->Lab2LabQ();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Lab2LabS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Lab2LabS",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Lab2LabS" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->Lab2LabS();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Lab2UCS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Lab2UCS",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Lab2UCS" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->Lab2UCS();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Lab2XYZ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Lab2XYZ",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Lab2XYZ" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->Lab2XYZ();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Lab2XYZ_temp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_Lab2XYZ_temp",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Lab2XYZ_temp" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_Lab2XYZ_temp" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_Lab2XYZ_temp" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_Lab2XYZ_temp" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  try {
-    result = (arg1)->Lab2XYZ_temp(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Lab2disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDisplay arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_Lab2disp",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Lab2disp" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDisplay,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_Lab2disp" "', argument " "2"" of type '" "vips::VDisplay""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_Lab2disp" "', argument " "2"" of type '" "vips::VDisplay""'");
-    } else {
-      vips::VDisplay * temp = reinterpret_cast< vips::VDisplay * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->Lab2disp(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_LabQ2LabS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_LabQ2LabS",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_LabQ2LabS" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->LabQ2LabS();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_LabQ2Lab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_LabQ2Lab",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_LabQ2Lab" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->LabQ2Lab();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_LabQ2XYZ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_LabQ2XYZ",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_LabQ2XYZ" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->LabQ2XYZ();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_LabQ2disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDisplay arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_LabQ2disp",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_LabQ2disp" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDisplay,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_LabQ2disp" "', argument " "2"" of type '" "vips::VDisplay""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_LabQ2disp" "', argument " "2"" of type '" "vips::VDisplay""'");
-    } else {
-      vips::VDisplay * temp = reinterpret_cast< vips::VDisplay * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->LabQ2disp(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_LabS2LabQ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_LabS2LabQ",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_LabS2LabQ" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->LabS2LabQ();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_LabS2Lab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_LabS2Lab",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_LabS2Lab" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->LabS2Lab();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_UCS2LCh(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_UCS2LCh",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_UCS2LCh" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->UCS2LCh();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_UCS2Lab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_UCS2Lab",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_UCS2Lab" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->UCS2Lab();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_UCS2XYZ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_UCS2XYZ",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_UCS2XYZ" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->UCS2XYZ();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_XYZ2Lab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_XYZ2Lab",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_XYZ2Lab" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->XYZ2Lab();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_XYZ2Lab_temp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_XYZ2Lab_temp",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_XYZ2Lab_temp" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_XYZ2Lab_temp" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_XYZ2Lab_temp" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_XYZ2Lab_temp" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  try {
-    result = (arg1)->XYZ2Lab_temp(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_XYZ2UCS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_XYZ2UCS",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_XYZ2UCS" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->XYZ2UCS();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_XYZ2Yxy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_XYZ2Yxy",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_XYZ2Yxy" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->XYZ2Yxy();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_XYZ2disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDisplay arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_XYZ2disp",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_XYZ2disp" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDisplay,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_XYZ2disp" "', argument " "2"" of type '" "vips::VDisplay""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_XYZ2disp" "', argument " "2"" of type '" "vips::VDisplay""'");
-    } else {
-      vips::VDisplay * temp = reinterpret_cast< vips::VDisplay * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->XYZ2disp(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_XYZ2sRGB(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_XYZ2sRGB",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_XYZ2sRGB" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->XYZ2sRGB();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_Yxy2XYZ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_Yxy2XYZ",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_Yxy2XYZ" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->Yxy2XYZ();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_dE00_fromLab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_dE00_fromLab",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_dE00_fromLab" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_dE00_fromLab" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dE00_fromLab" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->dE00_fromLab(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_dECMC_fromLab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_dECMC_fromLab",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_dECMC_fromLab" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_dECMC_fromLab" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dECMC_fromLab" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->dECMC_fromLab(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_dECMC_fromdisp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  vips::VDisplay arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_dECMC_fromdisp",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_dECMC_fromdisp" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_dECMC_fromdisp" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dECMC_fromdisp" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  {
-    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VDisplay,  0  | 0);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_dECMC_fromdisp" "', argument " "3"" of type '" "vips::VDisplay""'"); 
-    }  
-    if (!argp3) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dECMC_fromdisp" "', argument " "3"" of type '" "vips::VDisplay""'");
-    } else {
-      vips::VDisplay * temp = reinterpret_cast< vips::VDisplay * >(argp3);
-      arg3 = *temp;
-      if (SWIG_IsNewObj(res3)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->dECMC_fromdisp(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_dE_fromLab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_dE_fromLab",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_dE_fromLab" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_dE_fromLab" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dE_fromLab" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->dE_fromLab(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_dE_fromXYZ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_dE_fromXYZ",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_dE_fromXYZ" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_dE_fromXYZ" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dE_fromXYZ" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->dE_fromXYZ(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_dE_fromdisp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  vips::VDisplay arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_dE_fromdisp",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_dE_fromdisp" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_dE_fromdisp" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dE_fromdisp" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  {
-    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VDisplay,  0  | 0);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_dE_fromdisp" "', argument " "3"" of type '" "vips::VDisplay""'"); 
-    }  
-    if (!argp3) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dE_fromdisp" "', argument " "3"" of type '" "vips::VDisplay""'");
-    } else {
-      vips::VDisplay * temp = reinterpret_cast< vips::VDisplay * >(argp3);
-      arg3 = *temp;
-      if (SWIG_IsNewObj(res3)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->dE_fromdisp(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_disp2Lab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDisplay arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_disp2Lab",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_disp2Lab" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDisplay,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_disp2Lab" "', argument " "2"" of type '" "vips::VDisplay""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_disp2Lab" "', argument " "2"" of type '" "vips::VDisplay""'");
-    } else {
-      vips::VDisplay * temp = reinterpret_cast< vips::VDisplay * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->disp2Lab(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_disp2XYZ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDisplay arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_disp2XYZ",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_disp2XYZ" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDisplay,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_disp2XYZ" "', argument " "2"" of type '" "vips::VDisplay""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_disp2XYZ" "', argument " "2"" of type '" "vips::VDisplay""'");
-    } else {
-      vips::VDisplay * temp = reinterpret_cast< vips::VDisplay * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->disp2XYZ(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_float2rad(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_float2rad",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_float2rad" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->float2rad();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_icc_ac2rc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_icc_ac2rc",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_icc_ac2rc" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_icc_ac2rc" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (arg1)->icc_ac2rc(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_icc_export_depth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  char *arg3 = (char *) 0 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int res3 ;
-  char *buf3 = 0 ;
-  int alloc3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_icc_export_depth",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_icc_export_depth" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_icc_export_depth" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_icc_export_depth" "', argument " "3"" of type '" "char *""'");
-  }
-  arg3 = reinterpret_cast< char * >(buf3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_icc_export_depth" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->icc_export_depth(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return resultobj;
-fail:
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_icc_import(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_icc_import",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_icc_import" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_icc_import" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_icc_import" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->icc_import(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_icc_import_embedded(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_icc_import_embedded",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_icc_import_embedded" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_icc_import_embedded" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->icc_import_embedded(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_icc_transform(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  char *arg3 = (char *) 0 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int res3 ;
-  char *buf3 = 0 ;
-  int alloc3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_icc_transform",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_icc_transform" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_icc_transform" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_icc_transform" "', argument " "3"" of type '" "char *""'");
-  }
-  arg3 = reinterpret_cast< char * >(buf3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_icc_transform" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->icc_transform(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lab_morph(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:VImage_lab_morph",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lab_morph" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_lab_morph" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_lab_morph" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_lab_morph" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_lab_morph" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_lab_morph" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_lab_morph" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  try {
-    result = (arg1)->lab_morph(arg2,arg3,arg4,arg5,arg6);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rad2float(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_rad2float",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_rad2float" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->rad2float();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_sRGB2XYZ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_sRGB2XYZ",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_sRGB2XYZ" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->sRGB2XYZ();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_gaussnoise(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  double arg3 ;
-  double arg4 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_gaussnoise",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_gaussnoise" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_gaussnoise" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_gaussnoise" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_gaussnoise" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  try {
-    result = vips::VImage::gaussnoise(arg1,arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_bandjoin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_bandjoin",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_bandjoin" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_bandjoin" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_bandjoin" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->bandjoin(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_black(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int arg3 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_black",&obj0,&obj1,&obj2)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_black" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_black" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_black" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = vips::VImage::black(arg1,arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_c2amph(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_c2amph",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_c2amph" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->c2amph();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_c2imag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_c2imag",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_c2imag" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->c2imag();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_c2real(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_c2real",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_c2real" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->c2real();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_c2rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_c2rect",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_c2rect" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->c2rect();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2fmt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_clip2fmt",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2fmt" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_clip2fmt" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->clip2fmt(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_copy",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_copy" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->copy();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_copy_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_copy_file",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_copy_file" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->copy_file();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_copy_morph(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_copy_morph",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_copy_morph" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_copy_morph" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_copy_morph" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_copy_morph" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->copy_morph(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_copy_swap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_copy_swap",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_copy_swap" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->copy_swap();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_copy_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  double arg3 ;
-  double arg4 ;
-  int arg5 ;
-  int arg6 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:VImage_copy_set",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_copy_set" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_copy_set" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_copy_set" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_copy_set" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_copy_set" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_copy_set" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  try {
-    result = (arg1)->copy_set(arg2,arg3,arg4,arg5,arg6);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_extract_area(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_extract_area",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_extract_area" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_extract_area" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_extract_area" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_extract_area" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_extract_area" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    result = (arg1)->extract_area(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_extract_areabands(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_extract_areabands",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_extract_areabands" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_extract_areabands" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_extract_areabands" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_extract_areabands" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_extract_areabands" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_extract_areabands" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_extract_areabands" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  try {
-    result = (arg1)->extract_areabands(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_extract_band(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_extract_band",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_extract_band" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_extract_band" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->extract_band(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_extract_bands(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_extract_bands",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_extract_bands" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_extract_bands" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_extract_bands" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->extract_bands(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_extract(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:VImage_extract",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_extract" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_extract" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_extract" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_extract" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_extract" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_extract" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  try {
-    result = (arg1)->extract(arg2,arg3,arg4,arg5,arg6);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_falsecolour(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_falsecolour",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_falsecolour" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->falsecolour();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fliphor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_fliphor",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_fliphor" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->fliphor();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_flipver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_flipver",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_flipver" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->flipver();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_gbandjoin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage,std::allocator< vips::VImage > > arg1 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_gbandjoin",&obj0)) SWIG_fail;
-  {
-    std::vector<vips::VImage,std::allocator< vips::VImage > > *ptr = (std::vector<vips::VImage,std::allocator< vips::VImage > > *)0;
-    int res = swig::asptr(obj0, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_gbandjoin" "', argument " "1"" of type '" "std::vector< vips::VImage,std::allocator< vips::VImage > >""'"); 
-    }
-    arg1 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = vips::VImage::gbandjoin(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_grid(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_grid",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_grid" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_grid" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_grid" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_grid" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->grid(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_insert__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_insert" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_insert" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_insert" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_insert" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_insert" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->insert(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_insert__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  std::vector< int,std::allocator< int > > arg3 ;
-  std::vector< int,std::allocator< int > > arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_insert" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_insert" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_insert" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    int res = swig::asptr(obj2, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_insert" "', argument " "3"" of type '" "std::vector< int,std::allocator< int > >""'"); 
-    }
-    arg3 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    int res = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_insert" "', argument " "4"" of type '" "std::vector< int,std::allocator< int > >""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->insert(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_insert(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[5];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            return _wrap_VImage_insert__SWIG_0(self, args);
-          }
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector<int,std::allocator< int > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          int res = swig::asptr(argv[3], (std::vector<int,std::allocator< int > >**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_VImage_insert__SWIG_1(self, args);
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_insert'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::insert(vips::VImage,int,int)\n"
-    "    vips::VImage::insert(vips::VImage,std::vector< int,std::allocator< int > >,std::vector< int,std::allocator< int > >)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_insert_noexpand(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_insert_noexpand",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_insert_noexpand" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_insert_noexpand" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_insert_noexpand" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_insert_noexpand" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_insert_noexpand" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->insert_noexpand(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_embed(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:VImage_embed",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_embed" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_embed" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_embed" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_embed" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_embed" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_embed" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  try {
-    result = (arg1)->embed(arg2,arg3,arg4,arg5,arg6);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lrjoin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_lrjoin",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lrjoin" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_lrjoin" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_lrjoin" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->lrjoin(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_msb(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_msb",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_msb" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->msb();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_msb_band(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_msb_band",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_msb_band" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_msb_band" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->msb_band(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_replicate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_replicate",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_replicate" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_replicate" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_replicate" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->replicate(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_ri2c(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_ri2c",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_ri2c" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_ri2c" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_ri2c" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->ri2c(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rot180(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_rot180",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_rot180" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->rot180();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rot270(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_rot270",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_rot270" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->rot270();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rot90(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_rot90",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_rot90" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->rot90();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_scale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_scale",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_scale" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->scale();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_scaleps(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_scaleps",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_scaleps" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->scaleps();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_subsample(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_subsample",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_subsample" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_subsample" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_subsample" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->subsample(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_system(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_system",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_system" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_system" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (char *)(arg1)->system(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_system_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  char *arg3 = (char *) 0 ;
-  char *arg4 = (char *) 0 ;
-  char **arg5 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int res3 ;
-  char *buf3 = 0 ;
-  int alloc3 = 0 ;
-  int res4 ;
-  char *buf4 = 0 ;
-  int alloc4 = 0 ;
-  void *argp5 = 0 ;
-  int res5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_system_image",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_system_image" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_system_image" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_system_image" "', argument " "3"" of type '" "char *""'");
-  }
-  arg3 = reinterpret_cast< char * >(buf3);
-  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "VImage_system_image" "', argument " "4"" of type '" "char *""'");
-  }
-  arg4 = reinterpret_cast< char * >(buf4);
-  res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_p_char,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "VImage_system_image" "', argument " "5"" of type '" "char *&""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_system_image" "', argument " "5"" of type '" "char *&""'"); 
-  }
-  arg5 = reinterpret_cast< char ** >(argp5);
-  try {
-    result = (arg1)->system_image(arg2,arg3,arg4,*arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tbjoin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_tbjoin",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tbjoin" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_tbjoin" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_tbjoin" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->tbjoin(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_text(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  char *arg2 = (char *) 0 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_text",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_text" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_text" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_text" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_text" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_text" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    result = vips::VImage::text(arg1,arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_wrap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_wrap",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_wrap" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_wrap" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_wrap" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->wrap(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_zoom(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_zoom",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_zoom" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_zoom" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_zoom" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->zoom(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_aconvsep(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_aconvsep",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_aconvsep" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_aconvsep" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_aconvsep" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_aconvsep" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->aconvsep(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_aconv(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_aconv",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_aconv" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_aconv" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_aconv" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_aconv" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_aconv" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->aconv(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_addgnoise(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_addgnoise",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_addgnoise" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_addgnoise" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->addgnoise(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_compass(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_compass",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_compass" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_compass" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_compass" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->compass(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_contrast_surface(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_contrast_surface",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_contrast_surface" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_contrast_surface" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_contrast_surface" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->contrast_surface(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_conv__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_conv",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_conv" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_conv" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_conv" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->conv(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_conv__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_conv",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_conv" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_conv" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_conv" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->conv(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_conv(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VIMask, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_conv__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VDMask, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_conv__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_conv'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::conv(vips::VIMask)\n"
-    "    vips::VImage::conv(vips::VDMask)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convsep__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_convsep",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_convsep" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_convsep" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_convsep" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->convsep(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convsep__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_convsep",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_convsep" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_convsep" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_convsep" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->convsep(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convsep(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VIMask, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_convsep__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VDMask, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_convsep__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_convsep'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::convsep(vips::VIMask)\n"
-    "    vips::VImage::convsep(vips::VDMask)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fastcor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_fastcor",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_fastcor" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_fastcor" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_fastcor" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->fastcor(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_gradcor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_gradcor",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_gradcor" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_gradcor" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_gradcor" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->gradcor(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_gradient(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_gradient",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_gradient" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_gradient" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_gradient" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->gradient(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_grad_x(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_grad_x",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_grad_x" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->grad_x();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_grad_y(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_grad_y",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_grad_y" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->grad_y();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lindetect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_lindetect",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lindetect" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_lindetect" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_lindetect" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->lindetect(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_sharpen(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_sharpen",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_sharpen" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_sharpen" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_sharpen" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_sharpen" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_sharpen" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_sharpen" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_sharpen" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  try {
-    result = (arg1)->sharpen(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_spcor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_spcor",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_spcor" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_spcor" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_spcor" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->spcor(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_argb2rgba(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_argb2rgba",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_argb2rgba" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->argb2rgba();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_flood_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  std::vector< double,std::allocator< double > > arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_flood_copy",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_flood_copy" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_flood_copy" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_flood_copy" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_flood_copy" "', argument " "4"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->flood_copy(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_flood_blob_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  std::vector< double,std::allocator< double > > arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_flood_blob_copy",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_flood_blob_copy" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_flood_blob_copy" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_flood_blob_copy" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_flood_blob_copy" "', argument " "4"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->flood_blob_copy(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_flood_other_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_flood_other_copy",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_flood_other_copy" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_flood_other_copy" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_flood_other_copy" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_flood_other_copy" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_flood_other_copy" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_flood_other_copy" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    result = (arg1)->flood_other_copy(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_c2ps(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_c2ps",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_c2ps" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->c2ps();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_resize_linear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_resize_linear",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_resize_linear" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_resize_linear" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_resize_linear" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->resize_linear(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_cmulnorm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_cmulnorm",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_cmulnorm" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_cmulnorm" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_cmulnorm" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->cmulnorm(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fav4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  vips::VImage arg3 ;
-  vips::VImage arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_fav4",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_fav4" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_fav4" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_fav4" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  {
-    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_fav4" "', argument " "3"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp3) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_fav4" "', argument " "3"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp3);
-      arg3 = *temp;
-      if (SWIG_IsNewObj(res3)) delete temp;
-    }
-  }
-  {
-    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res4)) {
-      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "VImage_fav4" "', argument " "4"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp4) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_fav4" "', argument " "4"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp4);
-      arg4 = *temp;
-      if (SWIG_IsNewObj(res4)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->fav4(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_gadd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  vips::VImage arg4 ;
-  double arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_gadd",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_gadd" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_gadd" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_gadd" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  {
-    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res4)) {
-      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "VImage_gadd" "', argument " "4"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp4) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_gadd" "', argument " "4"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp4);
-      arg4 = *temp;
-      if (SWIG_IsNewObj(res4)) delete temp;
-    }
-  }
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_gadd" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  try {
-    result = (arg1)->gadd(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_icc_export(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_icc_export",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_icc_export" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_icc_export" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_icc_export" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->icc_export(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_litecor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  double arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_litecor",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_litecor" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_litecor" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_litecor" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_litecor" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_litecor" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  try {
-    result = (arg1)->litecor(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_affine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int arg10 ;
-  int arg11 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:VImage_affine",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_affine" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_affine" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_affine" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_affine" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_affine" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_affine" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_affine" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_affine" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_affine" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_affine" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_affine" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  try {
-    result = (arg1)->affine(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2c(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip2c",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2c" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip2c();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2cm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip2cm",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2cm" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip2cm();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2d(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip2d",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2d" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip2d();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2dcm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip2dcm",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2dcm" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip2dcm();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2f(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip2f",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2f" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip2f();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2i(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip2i",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2i" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip2i();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convsub(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_convsub",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_convsub" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_convsub" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_convsub" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_convsub" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_convsub" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->convsub(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_convf",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_convf" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_convf" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_convf" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->convf(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convsepf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_convsepf",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_convsepf" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_convsepf" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_convsepf" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->convsepf(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2s(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip2s",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2s" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip2s();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2ui(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip2ui",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2ui" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip2ui();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_insertplace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  std::vector< int,std::allocator< int > > arg3 ;
-  std::vector< int,std::allocator< int > > arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_insertplace",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_insertplace" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_insertplace" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_insertplace" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    int res = swig::asptr(obj2, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_insertplace" "', argument " "3"" of type '" "std::vector< int,std::allocator< int > >""'"); 
-    }
-    arg3 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    int res = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_insertplace" "', argument " "4"" of type '" "std::vector< int,std::allocator< int > >""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->insertplace(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_clip2us(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_clip2us",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_clip2us" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->clip2us();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_slice(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_slice",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_slice" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_slice" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_slice" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  try {
-    result = (arg1)->slice(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_segment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int temp2 ;
-  int res2 = SWIG_TMPOBJ ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  arg2 = &temp2;
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_segment",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_segment" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->segment(*arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (SWIG_IsTmpObj(res2)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_line__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:VImage_line",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_line" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_line" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_line" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_line" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_line" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_line" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  try {
-    (arg1)->line(arg2,arg3,arg4,arg5,arg6);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_thresh(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_thresh",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_thresh" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_thresh" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->thresh(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convf_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_convf_raw",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_convf_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_convf_raw" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_convf_raw" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->convf_raw(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_conv_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_conv_raw",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_conv_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_conv_raw" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_conv_raw" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->conv_raw(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_contrast_surface_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_contrast_surface_raw",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_contrast_surface_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_contrast_surface_raw" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_contrast_surface_raw" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->contrast_surface_raw(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convsepf_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_convsepf_raw",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_convsepf_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_convsepf_raw" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_convsepf_raw" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->convsepf_raw(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_convsep_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_convsep_raw",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_convsep_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_convsep_raw" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_convsep_raw" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->convsep_raw(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fastcor_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_fastcor_raw",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_fastcor_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_fastcor_raw" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_fastcor_raw" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->fastcor_raw(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_gradcor_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_gradcor_raw",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_gradcor_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_gradcor_raw" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_gradcor_raw" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->gradcor_raw(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_spcor_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_spcor_raw",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_spcor_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_spcor_raw" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_spcor_raw" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->spcor_raw(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lhisteq_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_lhisteq_raw",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lhisteq_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_lhisteq_raw" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_lhisteq_raw" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->lhisteq_raw(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_stdif_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  int arg6 ;
-  int arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_stdif_raw",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_stdif_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_stdif_raw" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_stdif_raw" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_stdif_raw" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_stdif_raw" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_stdif_raw" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_stdif_raw" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  try {
-    result = (arg1)->stdif_raw(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rank_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_rank_raw",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_rank_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_rank_raw" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_rank_raw" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_rank_raw" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->rank_raw(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_dilate_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_dilate_raw",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_dilate_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_dilate_raw" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dilate_raw" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->dilate_raw(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_erode_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_erode_raw",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_erode_raw" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_erode_raw" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_erode_raw" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->erode_raw(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_similarity_area(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:VImage_similarity_area",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_similarity_area" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_similarity_area" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_similarity_area" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_similarity_area" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_similarity_area" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_similarity_area" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_similarity_area" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_similarity_area" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_similarity_area" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  try {
-    result = (arg1)->similarity_area(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_similarity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_similarity",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_similarity" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_similarity" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_similarity" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_similarity" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_similarity" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  try {
-    result = (arg1)->similarity(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_mask2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask arg1 ;
-  void *argp1 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_mask2vips",&obj0)) SWIG_fail;
-  {
-    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_mask2vips" "', argument " "1"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp1) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_mask2vips" "', argument " "1"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp1);
-      arg1 = *temp;
-      if (SWIG_IsNewObj(res1)) delete temp;
-    }
-  }
-  try {
-    result = vips::VImage::mask2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_vips2mask(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_vips2mask",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_vips2mask" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->vips2mask();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_insertplace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_insertplace",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_insertplace" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_insertplace" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_insertplace" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_insertplace" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_insertplace" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    (arg1)->insertplace(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_insertplace(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[5];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 4) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            return _wrap_VImage_insertplace__SWIG_1(self, args);
-          }
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector<int,std::allocator< int > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          int res = swig::asptr(argv[3], (std::vector<int,std::allocator< int > >**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_VImage_insertplace__SWIG_0(self, args);
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_insertplace'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::insertplace(vips::VImage,std::vector< int,std::allocator< int > >,std::vector< int,std::allocator< int > >)\n"
-    "    vips::VImage::insertplace(vips::VImage,int,int)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_circle(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_circle",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_circle" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_circle" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_circle" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_circle" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_circle" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    (arg1)->circle(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_andimage__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_andimage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_andimage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_andimage" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_andimage" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->andimage(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_andimage__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_andimage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_andimage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_andimage" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->andimage(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_andimage__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_andimage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_andimage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_andimage" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->andimage(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_andimage(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_andimage__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_andimage__SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_andimage__SWIG_2(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_andimage'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::andimage(vips::VImage)\n"
-    "    vips::VImage::andimage(int)\n"
-    "    vips::VImage::andimage(std::vector< double,std::allocator< double > >)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_orimage__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_orimage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_orimage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_orimage" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_orimage" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->orimage(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_orimage__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_orimage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_orimage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_orimage" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->orimage(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_orimage__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_orimage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_orimage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_orimage" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->orimage(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_orimage(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_orimage__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_orimage__SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_orimage__SWIG_2(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_orimage'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::orimage(vips::VImage)\n"
-    "    vips::VImage::orimage(int)\n"
-    "    vips::VImage::orimage(std::vector< double,std::allocator< double > >)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_eorimage__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_eorimage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_eorimage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_eorimage" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_eorimage" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->eorimage(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_eorimage__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_eorimage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_eorimage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_eorimage" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->eorimage(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_eorimage__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_eorimage",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_eorimage" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_eorimage" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->eorimage(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_eorimage(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_eorimage__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_eorimage__SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_eorimage__SWIG_2(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_eorimage'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::eorimage(vips::VImage)\n"
-    "    vips::VImage::eorimage(int)\n"
-    "    vips::VImage::eorimage(std::vector< double,std::allocator< double > >)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_shiftleft__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_shiftleft",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_shiftleft" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_shiftleft" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->shiftleft(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_shiftleft__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_shiftleft",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_shiftleft" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_shiftleft" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->shiftleft(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_shiftleft(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_shiftleft__SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_shiftleft__SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_shiftleft'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::shiftleft(std::vector< double,std::allocator< double > >)\n"
-    "    vips::VImage::shiftleft(int)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_shiftright__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_shiftright",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_shiftright" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_shiftright" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->shiftright(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_shiftright__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_shiftright",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_shiftright" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_shiftright" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->shiftright(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_shiftright(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_shiftright__SWIG_1(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_shiftright__SWIG_0(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_shiftright'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::shiftright(std::vector< double,std::allocator< double > >)\n"
-    "    vips::VImage::shiftright(int)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_blend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  vips::VImage arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_blend",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_blend" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_blend" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_blend" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  {
-    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_blend" "', argument " "3"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp3) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_blend" "', argument " "3"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp3);
-      arg3 = *temp;
-      if (SWIG_IsNewObj(res3)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->blend(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_equal__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_equal",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_equal" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_equal" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_equal" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->equal(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_equal__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_equal",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_equal" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_equal" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->equal(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_equal__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_equal",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_equal" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_equal" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->equal(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_equal(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_equal__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_equal__SWIG_2(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_equal__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_equal'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::equal(vips::VImage)\n"
-    "    vips::VImage::equal(std::vector< double,std::allocator< double > >)\n"
-    "    vips::VImage::equal(double)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_ifthenelse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  vips::VImage arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_ifthenelse",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_ifthenelse" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_ifthenelse" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_ifthenelse" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  {
-    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_ifthenelse" "', argument " "3"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp3) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_ifthenelse" "', argument " "3"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp3);
-      arg3 = *temp;
-      if (SWIG_IsNewObj(res3)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->ifthenelse(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_less__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_less",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_less" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_less" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_less" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->less(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_less__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_less",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_less" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_less" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->less(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_less__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_less",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_less" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_less" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->less(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_less(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_less__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_less__SWIG_2(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_less__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_less'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::less(vips::VImage)\n"
-    "    vips::VImage::less(std::vector< double,std::allocator< double > >)\n"
-    "    vips::VImage::less(double)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lesseq__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_lesseq",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lesseq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_lesseq" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_lesseq" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->lesseq(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lesseq__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_lesseq",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lesseq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_lesseq" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->lesseq(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lesseq__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_lesseq",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lesseq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_lesseq" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->lesseq(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lesseq(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_lesseq__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_lesseq__SWIG_2(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_lesseq__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_lesseq'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::lesseq(vips::VImage)\n"
-    "    vips::VImage::lesseq(std::vector< double,std::allocator< double > >)\n"
-    "    vips::VImage::lesseq(double)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_more__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_more",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_more" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_more" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_more" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->more(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_more__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_more",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_more" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_more" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->more(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_more__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_more",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_more" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_more" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->more(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_more(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_more__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_more__SWIG_2(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_more__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_more'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::more(vips::VImage)\n"
-    "    vips::VImage::more(std::vector< double,std::allocator< double > >)\n"
-    "    vips::VImage::more(double)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_moreeq__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_moreeq",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_moreeq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_moreeq" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_moreeq" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->moreeq(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_moreeq__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_moreeq",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_moreeq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_moreeq" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->moreeq(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_moreeq__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_moreeq",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_moreeq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_moreeq" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->moreeq(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_moreeq(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_moreeq__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_moreeq__SWIG_2(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_moreeq__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_moreeq'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::moreeq(vips::VImage)\n"
-    "    vips::VImage::moreeq(std::vector< double,std::allocator< double > >)\n"
-    "    vips::VImage::moreeq(double)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_notequal__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_notequal",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_notequal" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_notequal" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_notequal" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->notequal(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_notequal__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  std::vector< double,std::allocator< double > > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_notequal",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_notequal" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj1, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_notequal" "', argument " "2"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->notequal(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_notequal__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_notequal",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_notequal" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_notequal" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->notequal(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_notequal(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_notequal__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_double(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VImage_notequal__SWIG_2(self, args);
-      }
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector<double,std::allocator< double > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_VImage_notequal__SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_notequal'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::notequal(vips::VImage)\n"
-    "    vips::VImage::notequal(std::vector< double,std::allocator< double > >)\n"
-    "    vips::VImage::notequal(double)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_quadratic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_quadratic",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_quadratic" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_quadratic" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_quadratic" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->quadratic(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_csv2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_csv2vips",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_csv2vips" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = vips::VImage::csv2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fits2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_fits2vips",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_fits2vips" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = vips::VImage::fits2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_jpeg2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_jpeg2vips",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_jpeg2vips" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = vips::VImage::jpeg2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_magick2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_magick2vips",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_magick2vips" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = vips::VImage::magick2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_png2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_png2vips",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_png2vips" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = vips::VImage::png2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_exr2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_exr2vips",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_exr2vips" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = vips::VImage::exr2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_ppm2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_ppm2vips",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_ppm2vips" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = vips::VImage::ppm2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_analyze2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_analyze2vips",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_analyze2vips" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = vips::VImage::analyze2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tiff2vips(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_tiff2vips",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tiff2vips" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  try {
-    result = vips::VImage::tiff2vips(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_vips2csv(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_vips2csv",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_vips2csv" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_vips2csv" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    (arg1)->vips2csv(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_vips2dz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_vips2dz",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_vips2dz" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_vips2dz" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    (arg1)->vips2dz(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_vips2jpeg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_vips2jpeg",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_vips2jpeg" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_vips2jpeg" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    (arg1)->vips2jpeg(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_vips2mimejpeg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_vips2mimejpeg",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_vips2mimejpeg" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_vips2mimejpeg" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    (arg1)->vips2mimejpeg(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_vips2png(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_vips2png",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_vips2png" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_vips2png" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    (arg1)->vips2png(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_vips2ppm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_vips2ppm",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_vips2ppm" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_vips2ppm" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    (arg1)->vips2ppm(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_vips2tiff(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_vips2tiff",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_vips2tiff" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_vips2tiff" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    (arg1)->vips2tiff(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_create_fmask(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  double arg8 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  double val8 ;
-  int ecode8 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:VImage_create_fmask",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_create_fmask" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_create_fmask" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_create_fmask" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_create_fmask" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_create_fmask" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_create_fmask" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_create_fmask" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  ecode8 = SWIG_AsVal_double(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_create_fmask" "', argument " "8"" of type '" "double""'");
-  } 
-  arg8 = static_cast< double >(val8);
-  try {
-    result = vips::VImage::create_fmask(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_disp_ps(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_disp_ps",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_disp_ps" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->disp_ps();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_flt_image_freq(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_flt_image_freq",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_flt_image_freq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_flt_image_freq" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_flt_image_freq" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_flt_image_freq" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_flt_image_freq" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_flt_image_freq" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_flt_image_freq" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  try {
-    result = (arg1)->flt_image_freq(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fractsurf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  double arg2 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_fractsurf",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_fractsurf" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_fractsurf" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = vips::VImage::fractsurf(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_freqflt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_freqflt",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_freqflt" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_freqflt" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_freqflt" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->freqflt(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fwfft(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_fwfft",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_fwfft" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->fwfft();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rotquad(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_rotquad",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_rotquad" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->rotquad();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_invfft(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_invfft",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_invfft" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->invfft();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_phasecor_fft(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_phasecor_fft",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_phasecor_fft" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_phasecor_fft" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_phasecor_fft" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->phasecor_fft(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_invfftr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_invfftr",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_invfftr" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->invfftr();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_gammacorrect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_gammacorrect",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_gammacorrect" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_gammacorrect" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->gammacorrect(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_heq(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_heq",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_heq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_heq" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->heq(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_hist(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_hist",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_hist" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_hist" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->hist(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_histcum(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_histcum",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_histcum" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->histcum();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_histeq(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_histeq",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_histeq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->histeq();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_hist_indexed(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_hist_indexed",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_hist_indexed" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_hist_indexed" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_hist_indexed" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->hist_indexed(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_histgr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_histgr",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_histgr" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_histgr" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->histgr(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_histnD(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_histnD",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_histnD" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_histnD" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->histnD(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_histnorm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_histnorm",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_histnorm" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->histnorm();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_histplot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_histplot",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_histplot" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->histplot();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_histspec(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_histspec",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_histspec" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_histspec" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_histspec" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->histspec(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_hsp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_hsp",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_hsp" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_hsp" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_hsp" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->hsp(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_identity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_identity",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_identity" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  try {
-    result = vips::VImage::identity(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_identity_ushort(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_identity_ushort",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_identity_ushort" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_identity_ushort" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = vips::VImage::identity_ushort(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_ismonotonic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_ismonotonic",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_ismonotonic" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (int)(arg1)->ismonotonic();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lhisteq(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_lhisteq",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lhisteq" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_lhisteq" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_lhisteq" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (arg1)->lhisteq(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_mpercent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_mpercent",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_mpercent" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_mpercent" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (int)(arg1)->mpercent(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_invertlut(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask arg1 ;
-  int arg2 ;
-  void *argp1 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_invertlut",&obj0,&obj1)) SWIG_fail;
-  {
-    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_invertlut" "', argument " "1"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp1) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_invertlut" "', argument " "1"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp1);
-      arg1 = *temp;
-      if (SWIG_IsNewObj(res1)) delete temp;
-    }
-  }
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_invertlut" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = vips::VImage::invertlut(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_buildlut(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask arg1 ;
-  void *argp1 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_buildlut",&obj0)) SWIG_fail;
-  {
-    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_buildlut" "', argument " "1"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp1) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_buildlut" "', argument " "1"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp1);
-      arg1 = *temp;
-      if (SWIG_IsNewObj(res1)) delete temp;
-    }
-  }
-  try {
-    result = vips::VImage::buildlut(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_maplut(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_maplut",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_maplut" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_maplut" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_maplut" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->maplut(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_project(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_project",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_project" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_project" "', argument " "2"" of type '" "vips::VImage &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_project" "', argument " "2"" of type '" "vips::VImage &""'"); 
-  }
-  arg2 = reinterpret_cast< vips::VImage * >(argp2);
-  try {
-    result = (arg1)->project(*arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_stdif(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  int arg6 ;
-  int arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_stdif",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_stdif" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_stdif" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_stdif" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_stdif" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_stdif" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_stdif" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_stdif" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  try {
-    result = (arg1)->stdif(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tone_analyse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_tone_analyse",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tone_analyse" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_tone_analyse" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_tone_analyse" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_tone_analyse" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_tone_analyse" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_tone_analyse" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_tone_analyse" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  try {
-    result = (arg1)->tone_analyse(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tone_build(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  double arg1 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  double arg8 ;
-  double val1 ;
-  int ecode1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  double val8 ;
-  int ecode8 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:VImage_tone_build",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
-  ecode1 = SWIG_AsVal_double(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_tone_build" "', argument " "1"" of type '" "double""'");
-  } 
-  arg1 = static_cast< double >(val1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_tone_build" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_tone_build" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_tone_build" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_tone_build" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_tone_build" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_tone_build" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  ecode8 = SWIG_AsVal_double(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_tone_build" "', argument " "8"" of type '" "double""'");
-  } 
-  arg8 = static_cast< double >(val8);
-  try {
-    result = vips::VImage::tone_build(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tone_build_range(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  double arg8 ;
-  double arg9 ;
-  double arg10 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  double val8 ;
-  int ecode8 = 0 ;
-  double val9 ;
-  int ecode9 = 0 ;
-  double val10 ;
-  int ecode10 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:VImage_tone_build_range",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_tone_build_range" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_tone_build_range" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_tone_build_range" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_tone_build_range" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_tone_build_range" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_tone_build_range" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_tone_build_range" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  ecode8 = SWIG_AsVal_double(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_tone_build_range" "', argument " "8"" of type '" "double""'");
-  } 
-  arg8 = static_cast< double >(val8);
-  ecode9 = SWIG_AsVal_double(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_tone_build_range" "', argument " "9"" of type '" "double""'");
-  } 
-  arg9 = static_cast< double >(val9);
-  ecode10 = SWIG_AsVal_double(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_tone_build_range" "', argument " "10"" of type '" "double""'");
-  } 
-  arg10 = static_cast< double >(val10);
-  try {
-    result = vips::VImage::tone_build_range(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tone_map(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_tone_map",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tone_map" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_tone_map" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_tone_map" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->tone_map(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_circle(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  std::vector< double,std::allocator< double > > arg6 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:VImage_draw_circle",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_circle" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_draw_circle" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_circle" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_draw_circle" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_draw_circle" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj5, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_draw_circle" "', argument " "6"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg6 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    (arg1)->draw_circle(arg2,arg3,arg4,arg5,arg6);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  std::vector< double,std::allocator< double > > arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_draw_rect",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_rect" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_draw_rect" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_rect" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_draw_rect" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_draw_rect" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_draw_rect" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj6, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_draw_rect" "', argument " "7"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg7 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    (arg1)->draw_rect(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_line(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  std::vector< double,std::allocator< double > > arg6 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:VImage_draw_line",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_line" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_draw_line" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_line" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_draw_line" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_draw_line" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj5, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_draw_line" "', argument " "6"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg6 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    (arg1)->draw_line(arg2,arg3,arg4,arg5,arg6);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  std::vector< double,std::allocator< double > > arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_draw_point",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_point" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_draw_point" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_point" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_draw_point" "', argument " "4"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    (arg1)->draw_point(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_smudge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_draw_smudge",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_smudge" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_draw_smudge" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_smudge" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_draw_smudge" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_draw_smudge" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    (arg1)->draw_smudge(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_flood(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  std::vector< double,std::allocator< double > > arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_draw_flood",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_flood" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_draw_flood" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_flood" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_draw_flood" "', argument " "4"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    (arg1)->draw_flood(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_flood_blob(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  std::vector< double,std::allocator< double > > arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_draw_flood_blob",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_flood_blob" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_draw_flood_blob" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_flood_blob" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_draw_flood_blob" "', argument " "4"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    (arg1)->draw_flood_blob(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_flood_other(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_draw_flood_other",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_flood_other" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_draw_flood_other" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_draw_flood_other" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_flood_other" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_draw_flood_other" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_draw_flood_other" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    (arg1)->draw_flood_other(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_draw_image",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_image" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_draw_image" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_draw_image" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_image" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_draw_image" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    (arg1)->draw_image(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_draw_mask(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  std::vector< double,std::allocator< double > > arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_draw_mask",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_draw_mask" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_draw_mask" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_draw_mask" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_draw_mask" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_draw_mask" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj4, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_draw_mask" "', argument " "5"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg5 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    (arg1)->draw_mask(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_line__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  vips::VImage arg3 ;
-  std::vector< int,std::allocator< int > > arg4 ;
-  std::vector< int,std::allocator< int > > arg5 ;
-  std::vector< int,std::allocator< int > > arg6 ;
-  std::vector< int,std::allocator< int > > arg7 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_line",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_line" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_line" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_line" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  {
-    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_line" "', argument " "3"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp3) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_line" "', argument " "3"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp3);
-      arg3 = *temp;
-      if (SWIG_IsNewObj(res3)) delete temp;
-    }
-  }
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    int res = swig::asptr(obj3, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_line" "', argument " "4"" of type '" "std::vector< int,std::allocator< int > >""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    int res = swig::asptr(obj4, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_line" "', argument " "5"" of type '" "std::vector< int,std::allocator< int > >""'"); 
-    }
-    arg5 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    int res = swig::asptr(obj5, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_line" "', argument " "6"" of type '" "std::vector< int,std::allocator< int > >""'"); 
-    }
-    arg6 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    int res = swig::asptr(obj6, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_line" "', argument " "7"" of type '" "std::vector< int,std::allocator< int > >""'"); 
-    }
-    arg7 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = (arg1)->line(arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_line(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[8];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 7) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 6) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            {
-              int res = SWIG_AsVal_int(argv[4], NULL);
-              _v = SWIG_CheckState(res);
-            }
-            if (_v) {
-              {
-                int res = SWIG_AsVal_int(argv[5], NULL);
-                _v = SWIG_CheckState(res);
-              }
-              if (_v) {
-                return _wrap_VImage_line__SWIG_0(self, args);
-              }
-            }
-          }
-        }
-      }
-    }
-  }
-  if (argc == 7) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_vips__VImage, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VImage, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_vips__VImage, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          int res = swig::asptr(argv[3], (std::vector<int,std::allocator< int > >**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            int res = swig::asptr(argv[4], (std::vector<int,std::allocator< int > >**)(0));
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              int res = swig::asptr(argv[5], (std::vector<int,std::allocator< int > >**)(0));
-              _v = SWIG_CheckState(res);
-              if (_v) {
-                int res = swig::asptr(argv[6], (std::vector<int,std::allocator< int > >**)(0));
-                _v = SWIG_CheckState(res);
-                if (_v) {
-                  return _wrap_VImage_line__SWIG_1(self, args);
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'VImage_line'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VImage::line(int,int,int,int,int)\n"
-    "    vips::VImage::line(vips::VImage,vips::VImage,std::vector< int,std::allocator< int > >,std::vector< int,std::allocator< int > >,std::vector< int,std::allocator< int > >,std::vector< int,std::allocator< int > >)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_binfile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_binfile",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_binfile" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_binfile" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_binfile" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_binfile" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_binfile" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    result = vips::VImage::binfile(arg1,arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_cache(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_cache",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_cache" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_cache" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_cache" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_cache" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->cache(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_getext(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_getext",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_getext" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (char *)(arg1)->getext();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_header_get_typeof(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_header_get_typeof",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_header_get_typeof" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_header_get_typeof" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (int)(arg1)->header_get_typeof(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_header_int(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_header_int",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_header_int" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_header_int" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (int)(arg1)->header_int(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_header_double(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_header_double",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_header_double" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_header_double" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (double)(arg1)->header_double(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_header_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_header_string",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_header_string" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_header_string" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  try {
-    result = (char *)(arg1)->header_string(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_history_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_history_get",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_history_get" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (char *)(arg1)->history_get();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_printdesc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_printdesc",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_printdesc" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    (arg1)->printdesc();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_cntlines(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_cntlines",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_cntlines" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_cntlines" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (double)(arg1)->cntlines(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_dilate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_dilate",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_dilate" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_dilate" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_dilate" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->dilate(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rank(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_rank",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_rank" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_rank" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_rank" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_rank" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->rank(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rank_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage,std::allocator< vips::VImage > > arg1 ;
-  int arg2 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_rank_image",&obj0,&obj1)) SWIG_fail;
-  {
-    std::vector<vips::VImage,std::allocator< vips::VImage > > *ptr = (std::vector<vips::VImage,std::allocator< vips::VImage > > *)0;
-    int res = swig::asptr(obj0, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_rank_image" "', argument " "1"" of type '" "std::vector< vips::VImage,std::allocator< vips::VImage > >""'"); 
-    }
-    arg1 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_rank_image" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = vips::VImage::rank_image(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_maxvalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::vector< vips::VImage,std::allocator< vips::VImage > > arg1 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_maxvalue",&obj0)) SWIG_fail;
-  {
-    std::vector<vips::VImage,std::allocator< vips::VImage > > *ptr = (std::vector<vips::VImage,std::allocator< vips::VImage > > *)0;
-    int res = swig::asptr(obj0, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_maxvalue" "', argument " "1"" of type '" "std::vector< vips::VImage,std::allocator< vips::VImage > >""'"); 
-    }
-    arg1 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  try {
-    result = vips::VImage::maxvalue(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_label_regions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int temp2 ;
-  int res2 = SWIG_TMPOBJ ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  arg2 = &temp2;
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_label_regions",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_label_regions" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->label_regions(*arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (SWIG_IsTmpObj(res2)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_zerox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_zerox",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_zerox" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_zerox" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->zerox(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_erode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VIMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_erode",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_erode" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VIMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_erode" "', argument " "2"" of type '" "vips::VIMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_erode" "', argument " "2"" of type '" "vips::VIMask""'");
-    } else {
-      vips::VIMask * temp = reinterpret_cast< vips::VIMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->erode(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_profile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_profile",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_profile" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_profile" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->profile(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_align_bands(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_align_bands",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_align_bands" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->align_bands();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_correl(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int *arg9 = 0 ;
-  int *arg10 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int temp9 ;
-  int res9 = SWIG_TMPOBJ ;
-  int temp10 ;
-  int res10 = SWIG_TMPOBJ ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  double result;
-  
-  arg9 = &temp9;
-  arg10 = &temp10;
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:VImage_correl",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_correl" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_correl" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_correl" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_correl" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_correl" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_correl" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_correl" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_correl" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_correl" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  try {
-    result = (double)(arg1)->correl(arg2,arg3,arg4,arg5,arg6,arg7,arg8,*arg9,*arg10);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  if (SWIG_IsTmpObj(res9)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
-  }
-  if (SWIG_IsTmpObj(res10)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg10)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_int, new_flags));
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage__find_lroverlap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int *arg10 = 0 ;
-  double *arg11 = 0 ;
-  double *arg12 = 0 ;
-  double *arg13 = 0 ;
-  double *arg14 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int temp10 ;
-  int res10 = SWIG_TMPOBJ ;
-  double temp11 ;
-  int res11 = SWIG_TMPOBJ ;
-  double temp12 ;
-  int res12 = SWIG_TMPOBJ ;
-  double temp13 ;
-  int res13 = SWIG_TMPOBJ ;
-  double temp14 ;
-  int res14 = SWIG_TMPOBJ ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  int result;
-  
-  arg10 = &temp10;
-  arg11 = &temp11;
-  arg12 = &temp12;
-  arg13 = &temp13;
-  arg14 = &temp14;
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:VImage__find_lroverlap",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage__find_lroverlap" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage__find_lroverlap" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage__find_lroverlap" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage__find_lroverlap" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage__find_lroverlap" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage__find_lroverlap" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage__find_lroverlap" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage__find_lroverlap" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage__find_lroverlap" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage__find_lroverlap" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  try {
-    result = (int)(arg1)->_find_lroverlap(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,*arg10,*arg11,*arg12,*arg13,*arg14);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if (SWIG_IsTmpObj(res10)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg10)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_int, new_flags));
-  }
-  if (SWIG_IsTmpObj(res11)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg11)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_double, new_flags));
-  }
-  if (SWIG_IsTmpObj(res12)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg12)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res12) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg12), SWIGTYPE_p_double, new_flags));
-  }
-  if (SWIG_IsTmpObj(res13)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg13)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res13) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg13), SWIGTYPE_p_double, new_flags));
-  }
-  if (SWIG_IsTmpObj(res14)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg14)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res14) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg14), SWIGTYPE_p_double, new_flags));
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage__find_tboverlap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int *arg10 = 0 ;
-  double *arg11 = 0 ;
-  double *arg12 = 0 ;
-  double *arg13 = 0 ;
-  double *arg14 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int temp10 ;
-  int res10 = SWIG_TMPOBJ ;
-  double temp11 ;
-  int res11 = SWIG_TMPOBJ ;
-  double temp12 ;
-  int res12 = SWIG_TMPOBJ ;
-  double temp13 ;
-  int res13 = SWIG_TMPOBJ ;
-  double temp14 ;
-  int res14 = SWIG_TMPOBJ ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  int result;
-  
-  arg10 = &temp10;
-  arg11 = &temp11;
-  arg12 = &temp12;
-  arg13 = &temp13;
-  arg14 = &temp14;
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:VImage__find_tboverlap",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage__find_tboverlap" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage__find_tboverlap" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage__find_tboverlap" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage__find_tboverlap" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage__find_tboverlap" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage__find_tboverlap" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage__find_tboverlap" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage__find_tboverlap" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage__find_tboverlap" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage__find_tboverlap" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  try {
-    result = (int)(arg1)->_find_tboverlap(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,*arg10,*arg11,*arg12,*arg13,*arg14);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if (SWIG_IsTmpObj(res10)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg10)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_int, new_flags));
-  }
-  if (SWIG_IsTmpObj(res11)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg11)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_double, new_flags));
-  }
-  if (SWIG_IsTmpObj(res12)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg12)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res12) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg12), SWIGTYPE_p_double, new_flags));
-  }
-  if (SWIG_IsTmpObj(res13)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg13)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res13) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg13), SWIGTYPE_p_double, new_flags));
-  }
-  if (SWIG_IsTmpObj(res14)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg14)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res14) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg14), SWIGTYPE_p_double, new_flags));
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_global_balance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_global_balance",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_global_balance" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_global_balance" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->global_balance(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_global_balancef(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_global_balancef",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_global_balancef" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_global_balancef" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = (arg1)->global_balancef(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lrmerge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_lrmerge",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lrmerge" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_lrmerge" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_lrmerge" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_lrmerge" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_lrmerge" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_lrmerge" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    result = (arg1)->lrmerge(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lrmerge1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int arg10 ;
-  int arg11 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:VImage_lrmerge1",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lrmerge1" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_lrmerge1" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_lrmerge1" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_lrmerge1" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_lrmerge1" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_lrmerge1" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_lrmerge1" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_lrmerge1" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_lrmerge1" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_lrmerge1" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_lrmerge1" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_lrmerge1" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  try {
-    result = (arg1)->lrmerge1(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lrmosaic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int arg10 ;
-  int arg11 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:VImage_lrmosaic",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lrmosaic" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_lrmosaic" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_lrmosaic" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_lrmosaic" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_lrmosaic" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_lrmosaic" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_lrmosaic" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_lrmosaic" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_lrmosaic" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_lrmosaic" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_lrmosaic" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_lrmosaic" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  try {
-    result = (arg1)->lrmosaic(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_lrmosaic1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int arg10 ;
-  int arg11 ;
-  int arg12 ;
-  int arg13 ;
-  int arg14 ;
-  int arg15 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  int val12 ;
-  int ecode12 = 0 ;
-  int val13 ;
-  int ecode13 = 0 ;
-  int val14 ;
-  int ecode14 = 0 ;
-  int val15 ;
-  int ecode15 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  PyObject * obj11 = 0 ;
-  PyObject * obj12 = 0 ;
-  PyObject * obj13 = 0 ;
-  PyObject * obj14 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOOOOO:VImage_lrmosaic1",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_lrmosaic1" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_lrmosaic1" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_lrmosaic1" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_lrmosaic1" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_lrmosaic1" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_lrmosaic1" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_lrmosaic1" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_lrmosaic1" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_lrmosaic1" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_lrmosaic1" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_lrmosaic1" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_lrmosaic1" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  ecode12 = SWIG_AsVal_int(obj11, &val12);
-  if (!SWIG_IsOK(ecode12)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "VImage_lrmosaic1" "', argument " "12"" of type '" "int""'");
-  } 
-  arg12 = static_cast< int >(val12);
-  ecode13 = SWIG_AsVal_int(obj12, &val13);
-  if (!SWIG_IsOK(ecode13)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "VImage_lrmosaic1" "', argument " "13"" of type '" "int""'");
-  } 
-  arg13 = static_cast< int >(val13);
-  ecode14 = SWIG_AsVal_int(obj13, &val14);
-  if (!SWIG_IsOK(ecode14)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "VImage_lrmosaic1" "', argument " "14"" of type '" "int""'");
-  } 
-  arg14 = static_cast< int >(val14);
-  ecode15 = SWIG_AsVal_int(obj14, &val15);
-  if (!SWIG_IsOK(ecode15)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "VImage_lrmosaic1" "', argument " "15"" of type '" "int""'");
-  } 
-  arg15 = static_cast< int >(val15);
-  try {
-    result = (arg1)->lrmosaic1(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_match_linear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int arg10 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:VImage_match_linear",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_match_linear" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_match_linear" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_match_linear" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_match_linear" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_match_linear" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_match_linear" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_match_linear" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_match_linear" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_match_linear" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_match_linear" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_match_linear" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  try {
-    result = (arg1)->match_linear(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_match_linear_search(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int arg10 ;
-  int arg11 ;
-  int arg12 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  int val12 ;
-  int ecode12 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  PyObject * obj11 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOO:VImage_match_linear_search",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_match_linear_search" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_match_linear_search" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_match_linear_search" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_match_linear_search" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_match_linear_search" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_match_linear_search" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_match_linear_search" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_match_linear_search" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_match_linear_search" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_match_linear_search" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_match_linear_search" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_match_linear_search" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  ecode12 = SWIG_AsVal_int(obj11, &val12);
-  if (!SWIG_IsOK(ecode12)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "VImage_match_linear_search" "', argument " "12"" of type '" "int""'");
-  } 
-  arg12 = static_cast< int >(val12);
-  try {
-    result = (arg1)->match_linear_search(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_maxpos_subpel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double temp2 ;
-  int res2 = SWIG_TMPOBJ ;
-  PyObject * obj0 = 0 ;
-  double result;
-  
-  arg2 = &temp2;
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_maxpos_subpel",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_maxpos_subpel" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (double)(arg1)->maxpos_subpel(*arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  if (SWIG_IsTmpObj(res2)) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
-  } else {
-    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_remosaic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  char *arg3 = (char *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  int res3 ;
-  char *buf3 = 0 ;
-  int alloc3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_remosaic",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_remosaic" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_remosaic" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VImage_remosaic" "', argument " "3"" of type '" "char *""'");
-  }
-  arg3 = reinterpret_cast< char * >(buf3);
-  try {
-    result = (arg1)->remosaic(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tbmerge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_tbmerge",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tbmerge" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_tbmerge" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_tbmerge" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_tbmerge" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_tbmerge" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_tbmerge" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  try {
-    result = (arg1)->tbmerge(arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tbmerge1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int arg10 ;
-  int arg11 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:VImage_tbmerge1",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tbmerge1" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_tbmerge1" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_tbmerge1" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_tbmerge1" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_tbmerge1" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_tbmerge1" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_tbmerge1" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_tbmerge1" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_tbmerge1" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_tbmerge1" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_tbmerge1" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_tbmerge1" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  try {
-    result = (arg1)->tbmerge1(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tbmosaic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int arg10 ;
-  int arg11 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:VImage_tbmosaic",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tbmosaic" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_tbmosaic" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_tbmosaic" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_tbmosaic" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_tbmosaic" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_tbmosaic" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_tbmosaic" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_tbmosaic" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_tbmosaic" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_tbmosaic" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_tbmosaic" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_tbmosaic" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  try {
-    result = (arg1)->tbmosaic(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tbmosaic1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  vips::VImage arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int arg8 ;
-  int arg9 ;
-  int arg10 ;
-  int arg11 ;
-  int arg12 ;
-  int arg13 ;
-  int arg14 ;
-  int arg15 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  int val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  int val12 ;
-  int ecode12 = 0 ;
-  int val13 ;
-  int ecode13 = 0 ;
-  int val14 ;
-  int ecode14 = 0 ;
-  int val15 ;
-  int ecode15 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  PyObject * obj11 = 0 ;
-  PyObject * obj12 = 0 ;
-  PyObject * obj13 = 0 ;
-  PyObject * obj14 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOOOOO:VImage_tbmosaic1",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tbmosaic1" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VImage,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_tbmosaic1" "', argument " "2"" of type '" "vips::VImage""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VImage_tbmosaic1" "', argument " "2"" of type '" "vips::VImage""'");
-    } else {
-      vips::VImage * temp = reinterpret_cast< vips::VImage * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_tbmosaic1" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_tbmosaic1" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_tbmosaic1" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_tbmosaic1" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_tbmosaic1" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  ecode8 = SWIG_AsVal_int(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_tbmosaic1" "', argument " "8"" of type '" "int""'");
-  } 
-  arg8 = static_cast< int >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_tbmosaic1" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_tbmosaic1" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_tbmosaic1" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  ecode12 = SWIG_AsVal_int(obj11, &val12);
-  if (!SWIG_IsOK(ecode12)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "VImage_tbmosaic1" "', argument " "12"" of type '" "int""'");
-  } 
-  arg12 = static_cast< int >(val12);
-  ecode13 = SWIG_AsVal_int(obj12, &val13);
-  if (!SWIG_IsOK(ecode13)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "VImage_tbmosaic1" "', argument " "13"" of type '" "int""'");
-  } 
-  arg13 = static_cast< int >(val13);
-  ecode14 = SWIG_AsVal_int(obj13, &val14);
-  if (!SWIG_IsOK(ecode14)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "VImage_tbmosaic1" "', argument " "14"" of type '" "int""'");
-  } 
-  arg14 = static_cast< int >(val14);
-  ecode15 = SWIG_AsVal_int(obj14, &val15);
-  if (!SWIG_IsOK(ecode15)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "VImage_tbmosaic1" "', argument " "15"" of type '" "int""'");
-  } 
-  arg15 = static_cast< int >(val15);
-  try {
-    result = (arg1)->tbmosaic1(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_benchmark(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_benchmark",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_benchmark" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (arg1)->benchmark();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_benchmark2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_benchmark2",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_benchmark2" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = (double)(arg1)->benchmark2();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_benchmarkn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_benchmarkn",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_benchmarkn" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_benchmarkn" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (arg1)->benchmarkn(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_eye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  double arg3 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_eye",&obj0,&obj1,&obj2)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_eye" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_eye" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_eye" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  try {
-    result = vips::VImage::eye(arg1,arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_grey(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_grey",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_grey" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_grey" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = vips::VImage::grey(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_feye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  double arg3 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_feye",&obj0,&obj1,&obj2)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_feye" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_feye" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_feye" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  try {
-    result = vips::VImage::feye(arg1,arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fgrey(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_fgrey",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_fgrey" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_fgrey" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = vips::VImage::fgrey(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fzone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_fzone",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_fzone" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  try {
-    result = vips::VImage::fzone(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_make_xy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_make_xy",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_make_xy" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_make_xy" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = vips::VImage::make_xy(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_sines(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  double arg3 ;
-  double arg4 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_sines",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_sines" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_sines" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_sines" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_sines" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  try {
-    result = vips::VImage::sines(arg1,arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_zone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_zone",&obj0)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_zone" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  try {
-    result = vips::VImage::zone(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_rightshift_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOO:VImage_rightshift_size",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_rightshift_size" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_rightshift_size" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_rightshift_size" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_rightshift_size" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  try {
-    result = (arg1)->rightshift_size(arg2,arg3,arg4);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_shrink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_shrink",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_shrink" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_shrink" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_shrink" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  try {
-    result = (arg1)->shrink(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_stretch3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  double arg2 ;
-  double arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VImage_stretch3",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_stretch3" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_stretch3" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_stretch3" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  try {
-    result = (arg1)->stretch3(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_affinei(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  double arg8 ;
-  int arg9 ;
-  int arg10 ;
-  int arg11 ;
-  int arg12 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  double val8 ;
-  int ecode8 = 0 ;
-  int val9 ;
-  int ecode9 = 0 ;
-  int val10 ;
-  int ecode10 = 0 ;
-  int val11 ;
-  int ecode11 = 0 ;
-  int val12 ;
-  int ecode12 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  PyObject * obj8 = 0 ;
-  PyObject * obj9 = 0 ;
-  PyObject * obj10 = 0 ;
-  PyObject * obj11 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOO:VImage_affinei",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_affinei" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_affinei" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_affinei" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_affinei" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_affinei" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_affinei" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_affinei" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  ecode8 = SWIG_AsVal_double(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_affinei" "', argument " "8"" of type '" "double""'");
-  } 
-  arg8 = static_cast< double >(val8);
-  ecode9 = SWIG_AsVal_int(obj8, &val9);
-  if (!SWIG_IsOK(ecode9)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "VImage_affinei" "', argument " "9"" of type '" "int""'");
-  } 
-  arg9 = static_cast< int >(val9);
-  ecode10 = SWIG_AsVal_int(obj9, &val10);
-  if (!SWIG_IsOK(ecode10)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "VImage_affinei" "', argument " "10"" of type '" "int""'");
-  } 
-  arg10 = static_cast< int >(val10);
-  ecode11 = SWIG_AsVal_int(obj10, &val11);
-  if (!SWIG_IsOK(ecode11)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "VImage_affinei" "', argument " "11"" of type '" "int""'");
-  } 
-  arg11 = static_cast< int >(val11);
-  ecode12 = SWIG_AsVal_int(obj11, &val12);
-  if (!SWIG_IsOK(ecode12)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "VImage_affinei" "', argument " "12"" of type '" "int""'");
-  } 
-  arg12 = static_cast< int >(val12);
-  try {
-    result = (arg1)->affinei(arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_affinei_all(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char *arg2 = (char *) 0 ;
-  double arg3 ;
-  double arg4 ;
-  double arg5 ;
-  double arg6 ;
-  double arg7 ;
-  double arg8 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 ;
-  char *buf2 = 0 ;
-  int alloc2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
-  double val6 ;
-  int ecode6 = 0 ;
-  double val7 ;
-  int ecode7 = 0 ;
-  double val8 ;
-  int ecode8 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  PyObject * obj7 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:VImage_affinei_all",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_affinei_all" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VImage_affinei_all" "', argument " "2"" of type '" "char *""'");
-  }
-  arg2 = reinterpret_cast< char * >(buf2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_affinei_all" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_affinei_all" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  ecode5 = SWIG_AsVal_double(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_affinei_all" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  ecode6 = SWIG_AsVal_double(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_affinei_all" "', argument " "6"" of type '" "double""'");
-  } 
-  arg6 = static_cast< double >(val6);
-  ecode7 = SWIG_AsVal_double(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_affinei_all" "', argument " "7"" of type '" "double""'");
-  } 
-  arg7 = static_cast< double >(val7);
-  ecode8 = SWIG_AsVal_double(obj7, &val8);
-  if (!SWIG_IsOK(ecode8)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "VImage_affinei_all" "', argument " "8"" of type '" "double""'");
-  } 
-  arg8 = static_cast< double >(val8);
-  try {
-    result = (arg1)->affinei_all(arg2,arg3,arg4,arg5,arg6,arg7,arg8);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return resultobj;
-fail:
-  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_video_test(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VImage_video_test",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VImage_video_test" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_video_test" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = vips::VImage::video_test(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_video_v4l1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  int arg5 ;
-  int arg6 ;
-  int arg7 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  int val6 ;
-  int ecode6 = 0 ;
-  int val7 ;
-  int ecode7 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  PyObject * obj6 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:VImage_video_v4l1",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_video_v4l1" "', argument " "1"" of type '" "char *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_video_v4l1" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_video_v4l1" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_video_v4l1" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_video_v4l1" "', argument " "5"" of type '" "int""'");
-  } 
-  arg5 = static_cast< int >(val5);
-  ecode6 = SWIG_AsVal_int(obj5, &val6);
-  if (!SWIG_IsOK(ecode6)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "VImage_video_v4l1" "', argument " "6"" of type '" "int""'");
-  } 
-  arg6 = static_cast< int >(val6);
-  ecode7 = SWIG_AsVal_int(obj6, &val7);
-  if (!SWIG_IsOK(ecode7)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "VImage_video_v4l1" "', argument " "7"" of type '" "int""'");
-  } 
-  arg7 = static_cast< int >(val7);
-  try {
-    result = vips::VImage::video_v4l1(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tobuffer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  VBuffer result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_tobuffer",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tobuffer" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    result = vips_VImage_tobuffer(arg1);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  {
-    resultobj = PyBuffer_FromMemory ((&result)->data, (&result)->size);
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_frombuffer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  VBuffer arg1 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  vips::VImage::TBandFmt arg5 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_frombuffer",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  {
-    const char *buffer;
-    Py_ssize_t buffer_len;
-    
-    if (PyObject_AsCharBuffer (obj0, &buffer, &buffer_len) == -1) {
-      PyErr_SetString (PyExc_TypeError,"Type error. Unable to get char pointer from buffer");
-      return NULL;
-    }
-    
-    (&arg1)->data = (void *) buffer;
-    (&arg1)->size = buffer_len;
-  }
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_frombuffer" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_frombuffer" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_frombuffer" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_frombuffer" "', argument " "5"" of type '" "vips::VImage::TBandFmt""'");
-  } 
-  arg5 = static_cast< vips::VImage::TBandFmt >(val5);
-  try {
-    result = vips_VImage_frombuffer(arg1,arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_tostring(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VImage *arg1 = (vips::VImage *) 0 ;
-  char **arg2 = (char **) 0 ;
-  int *arg3 = (int *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  char *temp2 = 0 ;
-  int tempn2 ;
-  PyObject * obj0 = 0 ;
-  
-  arg2 = &temp2; arg3 = &tempn2;
-  if (!PyArg_ParseTuple(args,(char *)"O:VImage_tostring",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VImage, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VImage_tostring" "', argument " "1"" of type '" "vips::VImage *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VImage * >(argp1);
-  try {
-    vips_VImage_tostring(arg1,arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  if (*arg2) {
-    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg2,*arg3));
-    im_free (*arg2);
-  }
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VImage_fromstring(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::string arg1 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  vips::VImage::TBandFmt arg5 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  int val5 ;
-  int ecode5 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VImage result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:VImage_fromstring",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(obj0, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "VImage_fromstring" "', argument " "1"" of type '" "std::string""'"); 
-    }
-    arg1 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VImage_fromstring" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VImage_fromstring" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "VImage_fromstring" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  ecode5 = SWIG_AsVal_int(obj4, &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "VImage_fromstring" "', argument " "5"" of type '" "vips::VImage::TBandFmt""'");
-  } 
-  arg5 = static_cast< vips::VImage::TBandFmt >(val5);
-  try {
-    result = vips_VImage_fromstring(arg1,arg2,arg3,arg4,arg5);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VImage(static_cast< const vips::VImage& >(result))), SWIGTYPE_p_vips__VImage, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *VImage_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_vips__VImage, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject *_wrap_im_init_world(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:im_init_world",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "im_init_world" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  result = (int)im_init_world((char const *)arg1);
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_im__print_all(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  
-  if (!PyArg_ParseTuple(args,(char *)":im__print_all")) SWIG_fail;
-  im__print_all();
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_im_col_Lab2XYZ(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  float arg1 ;
-  float arg2 ;
-  float arg3 ;
-  float *arg4 = (float *) 0 ;
-  float *arg5 = (float *) 0 ;
-  float *arg6 = (float *) 0 ;
-  float val1 ;
-  int ecode1 = 0 ;
-  float val2 ;
-  int ecode2 = 0 ;
-  float val3 ;
-  int ecode3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
-  void *argp5 = 0 ;
-  int res5 = 0 ;
-  void *argp6 = 0 ;
-  int res6 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  PyObject * obj5 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:im_col_Lab2XYZ",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
-  ecode1 = SWIG_AsVal_float(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "im_col_Lab2XYZ" "', argument " "1"" of type '" "float""'");
-  } 
-  arg1 = static_cast< float >(val1);
-  ecode2 = SWIG_AsVal_float(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "im_col_Lab2XYZ" "', argument " "2"" of type '" "float""'");
-  } 
-  arg2 = static_cast< float >(val2);
-  ecode3 = SWIG_AsVal_float(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "im_col_Lab2XYZ" "', argument " "3"" of type '" "float""'");
-  } 
-  arg3 = static_cast< float >(val3);
-  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_float, 0 |  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "im_col_Lab2XYZ" "', argument " "4"" of type '" "float *""'"); 
-  }
-  arg4 = reinterpret_cast< float * >(argp4);
-  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_float, 0 |  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "im_col_Lab2XYZ" "', argument " "5"" of type '" "float *""'"); 
-  }
-  arg5 = reinterpret_cast< float * >(argp5);
-  res6 = SWIG_ConvertPtr(obj5, &argp6,SWIGTYPE_p_float, 0 |  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "im_col_Lab2XYZ" "', argument " "6"" of type '" "float *""'"); 
-  }
-  arg6 = reinterpret_cast< float * >(argp6);
-  im_col_Lab2XYZ(arg1,arg2,arg3,arg4,arg5,arg6);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-static PyMethodDef SwigMethods[] = {
-	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { (char *)"delete_SwigPyIterator", _wrap_delete_SwigPyIterator, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_value", _wrap_SwigPyIterator_value, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_incr", _wrap_SwigPyIterator_incr, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_decr", _wrap_SwigPyIterator_decr, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_distance", _wrap_SwigPyIterator_distance, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_equal", _wrap_SwigPyIterator_equal, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_copy", _wrap_SwigPyIterator_copy, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_next", _wrap_SwigPyIterator_next, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator___next__", _wrap_SwigPyIterator___next__, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_previous", _wrap_SwigPyIterator_previous, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_advance", _wrap_SwigPyIterator_advance, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator___eq__", _wrap_SwigPyIterator___eq__, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator___ne__", _wrap_SwigPyIterator___ne__, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator___iadd__", _wrap_SwigPyIterator___iadd__, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator___isub__", _wrap_SwigPyIterator___isub__, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator___add__", _wrap_SwigPyIterator___add__, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator___sub__", _wrap_SwigPyIterator___sub__, METH_VARARGS, NULL},
-	 { (char *)"SwigPyIterator_swigregister", SwigPyIterator_swigregister, METH_VARARGS, NULL},
-	 { (char *)"IntVector_iterator", _wrap_IntVector_iterator, METH_VARARGS, NULL},
-	 { (char *)"IntVector___nonzero__", _wrap_IntVector___nonzero__, METH_VARARGS, NULL},
-	 { (char *)"IntVector___bool__", _wrap_IntVector___bool__, METH_VARARGS, NULL},
-	 { (char *)"IntVector___len__", _wrap_IntVector___len__, METH_VARARGS, NULL},
-	 { (char *)"IntVector_pop", _wrap_IntVector_pop, METH_VARARGS, NULL},
-	 { (char *)"IntVector___getslice__", _wrap_IntVector___getslice__, METH_VARARGS, NULL},
-	 { (char *)"IntVector___setslice__", _wrap_IntVector___setslice__, METH_VARARGS, NULL},
-	 { (char *)"IntVector___delslice__", _wrap_IntVector___delslice__, METH_VARARGS, NULL},
-	 { (char *)"IntVector___delitem__", _wrap_IntVector___delitem__, METH_VARARGS, NULL},
-	 { (char *)"IntVector___getitem__", _wrap_IntVector___getitem__, METH_VARARGS, NULL},
-	 { (char *)"IntVector___setitem__", _wrap_IntVector___setitem__, METH_VARARGS, NULL},
-	 { (char *)"IntVector_append", _wrap_IntVector_append, METH_VARARGS, NULL},
-	 { (char *)"IntVector_empty", _wrap_IntVector_empty, METH_VARARGS, NULL},
-	 { (char *)"IntVector_size", _wrap_IntVector_size, METH_VARARGS, NULL},
-	 { (char *)"IntVector_clear", _wrap_IntVector_clear, METH_VARARGS, NULL},
-	 { (char *)"IntVector_swap", _wrap_IntVector_swap, METH_VARARGS, NULL},
-	 { (char *)"IntVector_get_allocator", _wrap_IntVector_get_allocator, METH_VARARGS, NULL},
-	 { (char *)"IntVector_begin", _wrap_IntVector_begin, METH_VARARGS, NULL},
-	 { (char *)"IntVector_end", _wrap_IntVector_end, METH_VARARGS, NULL},
-	 { (char *)"IntVector_rbegin", _wrap_IntVector_rbegin, METH_VARARGS, NULL},
-	 { (char *)"IntVector_rend", _wrap_IntVector_rend, METH_VARARGS, NULL},
-	 { (char *)"IntVector_pop_back", _wrap_IntVector_pop_back, METH_VARARGS, NULL},
-	 { (char *)"IntVector_erase", _wrap_IntVector_erase, METH_VARARGS, NULL},
-	 { (char *)"new_IntVector", _wrap_new_IntVector, METH_VARARGS, NULL},
-	 { (char *)"IntVector_push_back", _wrap_IntVector_push_back, METH_VARARGS, NULL},
-	 { (char *)"IntVector_front", _wrap_IntVector_front, METH_VARARGS, NULL},
-	 { (char *)"IntVector_back", _wrap_IntVector_back, METH_VARARGS, NULL},
-	 { (char *)"IntVector_assign", _wrap_IntVector_assign, METH_VARARGS, NULL},
-	 { (char *)"IntVector_resize", _wrap_IntVector_resize, METH_VARARGS, NULL},
-	 { (char *)"IntVector_insert", _wrap_IntVector_insert, METH_VARARGS, NULL},
-	 { (char *)"IntVector_reserve", _wrap_IntVector_reserve, METH_VARARGS, NULL},
-	 { (char *)"IntVector_capacity", _wrap_IntVector_capacity, METH_VARARGS, NULL},
-	 { (char *)"delete_IntVector", _wrap_delete_IntVector, METH_VARARGS, NULL},
-	 { (char *)"IntVector_swigregister", IntVector_swigregister, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_iterator", _wrap_DoubleVector_iterator, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector___nonzero__", _wrap_DoubleVector___nonzero__, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector___bool__", _wrap_DoubleVector___bool__, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector___len__", _wrap_DoubleVector___len__, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_pop", _wrap_DoubleVector_pop, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector___getslice__", _wrap_DoubleVector___getslice__, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector___setslice__", _wrap_DoubleVector___setslice__, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector___delslice__", _wrap_DoubleVector___delslice__, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector___delitem__", _wrap_DoubleVector___delitem__, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector___getitem__", _wrap_DoubleVector___getitem__, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector___setitem__", _wrap_DoubleVector___setitem__, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_append", _wrap_DoubleVector_append, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_empty", _wrap_DoubleVector_empty, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_size", _wrap_DoubleVector_size, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_clear", _wrap_DoubleVector_clear, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_swap", _wrap_DoubleVector_swap, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_get_allocator", _wrap_DoubleVector_get_allocator, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_begin", _wrap_DoubleVector_begin, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_end", _wrap_DoubleVector_end, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_rbegin", _wrap_DoubleVector_rbegin, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_rend", _wrap_DoubleVector_rend, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_pop_back", _wrap_DoubleVector_pop_back, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_erase", _wrap_DoubleVector_erase, METH_VARARGS, NULL},
-	 { (char *)"new_DoubleVector", _wrap_new_DoubleVector, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_push_back", _wrap_DoubleVector_push_back, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_front", _wrap_DoubleVector_front, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_back", _wrap_DoubleVector_back, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_assign", _wrap_DoubleVector_assign, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_resize", _wrap_DoubleVector_resize, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_insert", _wrap_DoubleVector_insert, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_reserve", _wrap_DoubleVector_reserve, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_capacity", _wrap_DoubleVector_capacity, METH_VARARGS, NULL},
-	 { (char *)"delete_DoubleVector", _wrap_delete_DoubleVector, METH_VARARGS, NULL},
-	 { (char *)"DoubleVector_swigregister", DoubleVector_swigregister, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_iterator", _wrap_ImageVector_iterator, METH_VARARGS, NULL},
-	 { (char *)"ImageVector___nonzero__", _wrap_ImageVector___nonzero__, METH_VARARGS, NULL},
-	 { (char *)"ImageVector___bool__", _wrap_ImageVector___bool__, METH_VARARGS, NULL},
-	 { (char *)"ImageVector___len__", _wrap_ImageVector___len__, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_pop", _wrap_ImageVector_pop, METH_VARARGS, NULL},
-	 { (char *)"ImageVector___getslice__", _wrap_ImageVector___getslice__, METH_VARARGS, NULL},
-	 { (char *)"ImageVector___setslice__", _wrap_ImageVector___setslice__, METH_VARARGS, NULL},
-	 { (char *)"ImageVector___delslice__", _wrap_ImageVector___delslice__, METH_VARARGS, NULL},
-	 { (char *)"ImageVector___delitem__", _wrap_ImageVector___delitem__, METH_VARARGS, NULL},
-	 { (char *)"ImageVector___getitem__", _wrap_ImageVector___getitem__, METH_VARARGS, NULL},
-	 { (char *)"ImageVector___setitem__", _wrap_ImageVector___setitem__, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_append", _wrap_ImageVector_append, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_empty", _wrap_ImageVector_empty, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_size", _wrap_ImageVector_size, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_clear", _wrap_ImageVector_clear, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_swap", _wrap_ImageVector_swap, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_get_allocator", _wrap_ImageVector_get_allocator, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_begin", _wrap_ImageVector_begin, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_end", _wrap_ImageVector_end, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_rbegin", _wrap_ImageVector_rbegin, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_rend", _wrap_ImageVector_rend, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_pop_back", _wrap_ImageVector_pop_back, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_erase", _wrap_ImageVector_erase, METH_VARARGS, NULL},
-	 { (char *)"new_ImageVector", _wrap_new_ImageVector, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_push_back", _wrap_ImageVector_push_back, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_front", _wrap_ImageVector_front, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_back", _wrap_ImageVector_back, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_assign", _wrap_ImageVector_assign, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_resize", _wrap_ImageVector_resize, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_insert", _wrap_ImageVector_insert, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_reserve", _wrap_ImageVector_reserve, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_capacity", _wrap_ImageVector_capacity, METH_VARARGS, NULL},
-	 { (char *)"delete_ImageVector", _wrap_delete_ImageVector, METH_VARARGS, NULL},
-	 { (char *)"ImageVector_swigregister", ImageVector_swigregister, METH_VARARGS, NULL},
-	 { (char *)"init", _wrap_init, METH_VARARGS, NULL},
-	 { (char *)"shutdown", _wrap_shutdown, METH_VARARGS, NULL},
-	 { (char *)"VImage_print_all", _wrap_VImage_print_all, METH_VARARGS, NULL},
-	 { (char *)"VImage_convert2disc", _wrap_VImage_convert2disc, METH_VARARGS, NULL},
-	 { (char *)"new_VImage", _wrap_new_VImage, METH_VARARGS, NULL},
-	 { (char *)"VImage___assign__", _wrap_VImage___assign__, METH_VARARGS, NULL},
-	 { (char *)"delete_VImage", _wrap_delete_VImage, METH_VARARGS, NULL},
-	 { (char *)"VImage_image", _wrap_VImage_image, METH_VARARGS, NULL},
-	 { (char *)"VImage_data", _wrap_VImage_data, METH_VARARGS, NULL},
-	 { (char *)"VImage_write", _wrap_VImage_write, METH_VARARGS, NULL},
-	 { (char *)"VImage_debug_print", _wrap_VImage_debug_print, METH_VARARGS, NULL},
-	 { (char *)"VImage_Xsize", _wrap_VImage_Xsize, METH_VARARGS, NULL},
-	 { (char *)"VImage_Ysize", _wrap_VImage_Ysize, METH_VARARGS, NULL},
-	 { (char *)"VImage_Bands", _wrap_VImage_Bands, METH_VARARGS, NULL},
-	 { (char *)"VImage_BandFmt", _wrap_VImage_BandFmt, METH_VARARGS, NULL},
-	 { (char *)"VImage_Coding", _wrap_VImage_Coding, METH_VARARGS, NULL},
-	 { (char *)"VImage_Type", _wrap_VImage_Type, METH_VARARGS, NULL},
-	 { (char *)"VImage_Xres", _wrap_VImage_Xres, METH_VARARGS, NULL},
-	 { (char *)"VImage_Yres", _wrap_VImage_Yres, METH_VARARGS, NULL},
-	 { (char *)"VImage_Length", _wrap_VImage_Length, METH_VARARGS, NULL},
-	 { (char *)"VImage_Compression", _wrap_VImage_Compression, METH_VARARGS, NULL},
-	 { (char *)"VImage_Level", _wrap_VImage_Level, METH_VARARGS, NULL},
-	 { (char *)"VImage_Xoffset", _wrap_VImage_Xoffset, METH_VARARGS, NULL},
-	 { (char *)"VImage_Yoffset", _wrap_VImage_Yoffset, METH_VARARGS, NULL},
-	 { (char *)"VImage_filename", _wrap_VImage_filename, METH_VARARGS, NULL},
-	 { (char *)"VImage_Hist", _wrap_VImage_Hist, METH_VARARGS, NULL},
-	 { (char *)"VImage_meta_remove", _wrap_VImage_meta_remove, METH_VARARGS, NULL},
-	 { (char *)"VImage_meta_get_typeof", _wrap_VImage_meta_get_typeof, METH_VARARGS, NULL},
-	 { (char *)"VImage_meta_get_int", _wrap_VImage_meta_get_int, METH_VARARGS, NULL},
-	 { (char *)"VImage_meta_get_double", _wrap_VImage_meta_get_double, METH_VARARGS, NULL},
-	 { (char *)"VImage_meta_get_string", _wrap_VImage_meta_get_string, METH_VARARGS, NULL},
-	 { (char *)"VImage_meta_get_area", _wrap_VImage_meta_get_area, METH_VARARGS, NULL},
-	 { (char *)"VImage_meta_get_blob", _wrap_VImage_meta_get_blob, METH_VARARGS, NULL},
-	 { (char *)"VImage_meta_set", _wrap_VImage_meta_set, METH_VARARGS, NULL},
-	 { (char *)"VImage_initdesc", _wrap_VImage_initdesc, METH_VARARGS, NULL},
-	 { (char *)"VImage_abs", _wrap_VImage_abs, METH_VARARGS, NULL},
-	 { (char *)"VImage_acos", _wrap_VImage_acos, METH_VARARGS, NULL},
-	 { (char *)"VImage_add", _wrap_VImage_add, METH_VARARGS, NULL},
-	 { (char *)"VImage_asin", _wrap_VImage_asin, METH_VARARGS, NULL},
-	 { (char *)"VImage_atan", _wrap_VImage_atan, METH_VARARGS, NULL},
-	 { (char *)"VImage_avg", _wrap_VImage_avg, METH_VARARGS, NULL},
-	 { (char *)"VImage_point", _wrap_VImage_point, METH_VARARGS, NULL},
-	 { (char *)"VImage_point_bilinear", _wrap_VImage_point_bilinear, METH_VARARGS, NULL},
-	 { (char *)"VImage_bandmean", _wrap_VImage_bandmean, METH_VARARGS, NULL},
-	 { (char *)"VImage_ceil", _wrap_VImage_ceil, METH_VARARGS, NULL},
-	 { (char *)"VImage_cos", _wrap_VImage_cos, METH_VARARGS, NULL},
-	 { (char *)"VImage_cross_phase", _wrap_VImage_cross_phase, METH_VARARGS, NULL},
-	 { (char *)"VImage_deviate", _wrap_VImage_deviate, METH_VARARGS, NULL},
-	 { (char *)"VImage_divide", _wrap_VImage_divide, METH_VARARGS, NULL},
-	 { (char *)"VImage_exp10", _wrap_VImage_exp10, METH_VARARGS, NULL},
-	 { (char *)"VImage_expn", _wrap_VImage_expn, METH_VARARGS, NULL},
-	 { (char *)"VImage_exp", _wrap_VImage_exp, METH_VARARGS, NULL},
-	 { (char *)"VImage_floor", _wrap_VImage_floor, METH_VARARGS, NULL},
-	 { (char *)"VImage_invert", _wrap_VImage_invert, METH_VARARGS, NULL},
-	 { (char *)"VImage_linreg", _wrap_VImage_linreg, METH_VARARGS, NULL},
-	 { (char *)"VImage_lin", _wrap_VImage_lin, METH_VARARGS, NULL},
-	 { (char *)"VImage_log10", _wrap_VImage_log10, METH_VARARGS, NULL},
-	 { (char *)"VImage_log", _wrap_VImage_log, METH_VARARGS, NULL},
-	 { (char *)"VImage_max", _wrap_VImage_max, METH_VARARGS, NULL},
-	 { (char *)"VImage_maxpos", _wrap_VImage_maxpos, METH_VARARGS, NULL},
-	 { (char *)"VImage_maxpos_avg", _wrap_VImage_maxpos_avg, METH_VARARGS, NULL},
-	 { (char *)"VImage_measure", _wrap_VImage_measure, METH_VARARGS, NULL},
-	 { (char *)"VImage_min", _wrap_VImage_min, METH_VARARGS, NULL},
-	 { (char *)"VImage_minpos", _wrap_VImage_minpos, METH_VARARGS, NULL},
-	 { (char *)"VImage_multiply", _wrap_VImage_multiply, METH_VARARGS, NULL},
-	 { (char *)"VImage_pow", _wrap_VImage_pow, METH_VARARGS, NULL},
-	 { (char *)"VImage_recomb", _wrap_VImage_recomb, METH_VARARGS, NULL},
-	 { (char *)"VImage_remainder", _wrap_VImage_remainder, METH_VARARGS, NULL},
-	 { (char *)"VImage_rint", _wrap_VImage_rint, METH_VARARGS, NULL},
-	 { (char *)"VImage_sign", _wrap_VImage_sign, METH_VARARGS, NULL},
-	 { (char *)"VImage_sin", _wrap_VImage_sin, METH_VARARGS, NULL},
-	 { (char *)"VImage_stats", _wrap_VImage_stats, METH_VARARGS, NULL},
-	 { (char *)"VImage_subtract", _wrap_VImage_subtract, METH_VARARGS, NULL},
-	 { (char *)"VImage_tan", _wrap_VImage_tan, METH_VARARGS, NULL},
-	 { (char *)"VImage_greyc", _wrap_VImage_greyc, METH_VARARGS, NULL},
-	 { (char *)"VImage_greyc_mask", _wrap_VImage_greyc_mask, METH_VARARGS, NULL},
-	 { (char *)"VImage_LCh2Lab", _wrap_VImage_LCh2Lab, METH_VARARGS, NULL},
-	 { (char *)"VImage_LCh2UCS", _wrap_VImage_LCh2UCS, METH_VARARGS, NULL},
-	 { (char *)"VImage_Lab2LCh", _wrap_VImage_Lab2LCh, METH_VARARGS, NULL},
-	 { (char *)"VImage_Lab2LabQ", _wrap_VImage_Lab2LabQ, METH_VARARGS, NULL},
-	 { (char *)"VImage_Lab2LabS", _wrap_VImage_Lab2LabS, METH_VARARGS, NULL},
-	 { (char *)"VImage_Lab2UCS", _wrap_VImage_Lab2UCS, METH_VARARGS, NULL},
-	 { (char *)"VImage_Lab2XYZ", _wrap_VImage_Lab2XYZ, METH_VARARGS, NULL},
-	 { (char *)"VImage_Lab2XYZ_temp", _wrap_VImage_Lab2XYZ_temp, METH_VARARGS, NULL},
-	 { (char *)"VImage_Lab2disp", _wrap_VImage_Lab2disp, METH_VARARGS, NULL},
-	 { (char *)"VImage_LabQ2LabS", _wrap_VImage_LabQ2LabS, METH_VARARGS, NULL},
-	 { (char *)"VImage_LabQ2Lab", _wrap_VImage_LabQ2Lab, METH_VARARGS, NULL},
-	 { (char *)"VImage_LabQ2XYZ", _wrap_VImage_LabQ2XYZ, METH_VARARGS, NULL},
-	 { (char *)"VImage_LabQ2disp", _wrap_VImage_LabQ2disp, METH_VARARGS, NULL},
-	 { (char *)"VImage_LabS2LabQ", _wrap_VImage_LabS2LabQ, METH_VARARGS, NULL},
-	 { (char *)"VImage_LabS2Lab", _wrap_VImage_LabS2Lab, METH_VARARGS, NULL},
-	 { (char *)"VImage_UCS2LCh", _wrap_VImage_UCS2LCh, METH_VARARGS, NULL},
-	 { (char *)"VImage_UCS2Lab", _wrap_VImage_UCS2Lab, METH_VARARGS, NULL},
-	 { (char *)"VImage_UCS2XYZ", _wrap_VImage_UCS2XYZ, METH_VARARGS, NULL},
-	 { (char *)"VImage_XYZ2Lab", _wrap_VImage_XYZ2Lab, METH_VARARGS, NULL},
-	 { (char *)"VImage_XYZ2Lab_temp", _wrap_VImage_XYZ2Lab_temp, METH_VARARGS, NULL},
-	 { (char *)"VImage_XYZ2UCS", _wrap_VImage_XYZ2UCS, METH_VARARGS, NULL},
-	 { (char *)"VImage_XYZ2Yxy", _wrap_VImage_XYZ2Yxy, METH_VARARGS, NULL},
-	 { (char *)"VImage_XYZ2disp", _wrap_VImage_XYZ2disp, METH_VARARGS, NULL},
-	 { (char *)"VImage_XYZ2sRGB", _wrap_VImage_XYZ2sRGB, METH_VARARGS, NULL},
-	 { (char *)"VImage_Yxy2XYZ", _wrap_VImage_Yxy2XYZ, METH_VARARGS, NULL},
-	 { (char *)"VImage_dE00_fromLab", _wrap_VImage_dE00_fromLab, METH_VARARGS, NULL},
-	 { (char *)"VImage_dECMC_fromLab", _wrap_VImage_dECMC_fromLab, METH_VARARGS, NULL},
-	 { (char *)"VImage_dECMC_fromdisp", _wrap_VImage_dECMC_fromdisp, METH_VARARGS, NULL},
-	 { (char *)"VImage_dE_fromLab", _wrap_VImage_dE_fromLab, METH_VARARGS, NULL},
-	 { (char *)"VImage_dE_fromXYZ", _wrap_VImage_dE_fromXYZ, METH_VARARGS, NULL},
-	 { (char *)"VImage_dE_fromdisp", _wrap_VImage_dE_fromdisp, METH_VARARGS, NULL},
-	 { (char *)"VImage_disp2Lab", _wrap_VImage_disp2Lab, METH_VARARGS, NULL},
-	 { (char *)"VImage_disp2XYZ", _wrap_VImage_disp2XYZ, METH_VARARGS, NULL},
-	 { (char *)"VImage_float2rad", _wrap_VImage_float2rad, METH_VARARGS, NULL},
-	 { (char *)"VImage_icc_ac2rc", _wrap_VImage_icc_ac2rc, METH_VARARGS, NULL},
-	 { (char *)"VImage_icc_export_depth", _wrap_VImage_icc_export_depth, METH_VARARGS, NULL},
-	 { (char *)"VImage_icc_import", _wrap_VImage_icc_import, METH_VARARGS, NULL},
-	 { (char *)"VImage_icc_import_embedded", _wrap_VImage_icc_import_embedded, METH_VARARGS, NULL},
-	 { (char *)"VImage_icc_transform", _wrap_VImage_icc_transform, METH_VARARGS, NULL},
-	 { (char *)"VImage_lab_morph", _wrap_VImage_lab_morph, METH_VARARGS, NULL},
-	 { (char *)"VImage_rad2float", _wrap_VImage_rad2float, METH_VARARGS, NULL},
-	 { (char *)"VImage_sRGB2XYZ", _wrap_VImage_sRGB2XYZ, METH_VARARGS, NULL},
-	 { (char *)"VImage_gaussnoise", _wrap_VImage_gaussnoise, METH_VARARGS, NULL},
-	 { (char *)"VImage_bandjoin", _wrap_VImage_bandjoin, METH_VARARGS, NULL},
-	 { (char *)"VImage_black", _wrap_VImage_black, METH_VARARGS, NULL},
-	 { (char *)"VImage_c2amph", _wrap_VImage_c2amph, METH_VARARGS, NULL},
-	 { (char *)"VImage_c2imag", _wrap_VImage_c2imag, METH_VARARGS, NULL},
-	 { (char *)"VImage_c2real", _wrap_VImage_c2real, METH_VARARGS, NULL},
-	 { (char *)"VImage_c2rect", _wrap_VImage_c2rect, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2fmt", _wrap_VImage_clip2fmt, METH_VARARGS, NULL},
-	 { (char *)"VImage_copy", _wrap_VImage_copy, METH_VARARGS, NULL},
-	 { (char *)"VImage_copy_file", _wrap_VImage_copy_file, METH_VARARGS, NULL},
-	 { (char *)"VImage_copy_morph", _wrap_VImage_copy_morph, METH_VARARGS, NULL},
-	 { (char *)"VImage_copy_swap", _wrap_VImage_copy_swap, METH_VARARGS, NULL},
-	 { (char *)"VImage_copy_set", _wrap_VImage_copy_set, METH_VARARGS, NULL},
-	 { (char *)"VImage_extract_area", _wrap_VImage_extract_area, METH_VARARGS, NULL},
-	 { (char *)"VImage_extract_areabands", _wrap_VImage_extract_areabands, METH_VARARGS, NULL},
-	 { (char *)"VImage_extract_band", _wrap_VImage_extract_band, METH_VARARGS, NULL},
-	 { (char *)"VImage_extract_bands", _wrap_VImage_extract_bands, METH_VARARGS, NULL},
-	 { (char *)"VImage_extract", _wrap_VImage_extract, METH_VARARGS, NULL},
-	 { (char *)"VImage_falsecolour", _wrap_VImage_falsecolour, METH_VARARGS, NULL},
-	 { (char *)"VImage_fliphor", _wrap_VImage_fliphor, METH_VARARGS, NULL},
-	 { (char *)"VImage_flipver", _wrap_VImage_flipver, METH_VARARGS, NULL},
-	 { (char *)"VImage_gbandjoin", _wrap_VImage_gbandjoin, METH_VARARGS, NULL},
-	 { (char *)"VImage_grid", _wrap_VImage_grid, METH_VARARGS, NULL},
-	 { (char *)"VImage_insert", _wrap_VImage_insert, METH_VARARGS, NULL},
-	 { (char *)"VImage_insert_noexpand", _wrap_VImage_insert_noexpand, METH_VARARGS, NULL},
-	 { (char *)"VImage_embed", _wrap_VImage_embed, METH_VARARGS, NULL},
-	 { (char *)"VImage_lrjoin", _wrap_VImage_lrjoin, METH_VARARGS, NULL},
-	 { (char *)"VImage_msb", _wrap_VImage_msb, METH_VARARGS, NULL},
-	 { (char *)"VImage_msb_band", _wrap_VImage_msb_band, METH_VARARGS, NULL},
-	 { (char *)"VImage_replicate", _wrap_VImage_replicate, METH_VARARGS, NULL},
-	 { (char *)"VImage_ri2c", _wrap_VImage_ri2c, METH_VARARGS, NULL},
-	 { (char *)"VImage_rot180", _wrap_VImage_rot180, METH_VARARGS, NULL},
-	 { (char *)"VImage_rot270", _wrap_VImage_rot270, METH_VARARGS, NULL},
-	 { (char *)"VImage_rot90", _wrap_VImage_rot90, METH_VARARGS, NULL},
-	 { (char *)"VImage_scale", _wrap_VImage_scale, METH_VARARGS, NULL},
-	 { (char *)"VImage_scaleps", _wrap_VImage_scaleps, METH_VARARGS, NULL},
-	 { (char *)"VImage_subsample", _wrap_VImage_subsample, METH_VARARGS, NULL},
-	 { (char *)"VImage_system", _wrap_VImage_system, METH_VARARGS, NULL},
-	 { (char *)"VImage_system_image", _wrap_VImage_system_image, METH_VARARGS, NULL},
-	 { (char *)"VImage_tbjoin", _wrap_VImage_tbjoin, METH_VARARGS, NULL},
-	 { (char *)"VImage_text", _wrap_VImage_text, METH_VARARGS, NULL},
-	 { (char *)"VImage_wrap", _wrap_VImage_wrap, METH_VARARGS, NULL},
-	 { (char *)"VImage_zoom", _wrap_VImage_zoom, METH_VARARGS, NULL},
-	 { (char *)"VImage_aconvsep", _wrap_VImage_aconvsep, METH_VARARGS, NULL},
-	 { (char *)"VImage_aconv", _wrap_VImage_aconv, METH_VARARGS, NULL},
-	 { (char *)"VImage_addgnoise", _wrap_VImage_addgnoise, METH_VARARGS, NULL},
-	 { (char *)"VImage_compass", _wrap_VImage_compass, METH_VARARGS, NULL},
-	 { (char *)"VImage_contrast_surface", _wrap_VImage_contrast_surface, METH_VARARGS, NULL},
-	 { (char *)"VImage_conv", _wrap_VImage_conv, METH_VARARGS, NULL},
-	 { (char *)"VImage_convsep", _wrap_VImage_convsep, METH_VARARGS, NULL},
-	 { (char *)"VImage_fastcor", _wrap_VImage_fastcor, METH_VARARGS, NULL},
-	 { (char *)"VImage_gradcor", _wrap_VImage_gradcor, METH_VARARGS, NULL},
-	 { (char *)"VImage_gradient", _wrap_VImage_gradient, METH_VARARGS, NULL},
-	 { (char *)"VImage_grad_x", _wrap_VImage_grad_x, METH_VARARGS, NULL},
-	 { (char *)"VImage_grad_y", _wrap_VImage_grad_y, METH_VARARGS, NULL},
-	 { (char *)"VImage_lindetect", _wrap_VImage_lindetect, METH_VARARGS, NULL},
-	 { (char *)"VImage_sharpen", _wrap_VImage_sharpen, METH_VARARGS, NULL},
-	 { (char *)"VImage_spcor", _wrap_VImage_spcor, METH_VARARGS, NULL},
-	 { (char *)"VImage_argb2rgba", _wrap_VImage_argb2rgba, METH_VARARGS, NULL},
-	 { (char *)"VImage_flood_copy", _wrap_VImage_flood_copy, METH_VARARGS, NULL},
-	 { (char *)"VImage_flood_blob_copy", _wrap_VImage_flood_blob_copy, METH_VARARGS, NULL},
-	 { (char *)"VImage_flood_other_copy", _wrap_VImage_flood_other_copy, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip", _wrap_VImage_clip, METH_VARARGS, NULL},
-	 { (char *)"VImage_c2ps", _wrap_VImage_c2ps, METH_VARARGS, NULL},
-	 { (char *)"VImage_resize_linear", _wrap_VImage_resize_linear, METH_VARARGS, NULL},
-	 { (char *)"VImage_cmulnorm", _wrap_VImage_cmulnorm, METH_VARARGS, NULL},
-	 { (char *)"VImage_fav4", _wrap_VImage_fav4, METH_VARARGS, NULL},
-	 { (char *)"VImage_gadd", _wrap_VImage_gadd, METH_VARARGS, NULL},
-	 { (char *)"VImage_icc_export", _wrap_VImage_icc_export, METH_VARARGS, NULL},
-	 { (char *)"VImage_litecor", _wrap_VImage_litecor, METH_VARARGS, NULL},
-	 { (char *)"VImage_affine", _wrap_VImage_affine, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2c", _wrap_VImage_clip2c, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2cm", _wrap_VImage_clip2cm, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2d", _wrap_VImage_clip2d, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2dcm", _wrap_VImage_clip2dcm, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2f", _wrap_VImage_clip2f, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2i", _wrap_VImage_clip2i, METH_VARARGS, NULL},
-	 { (char *)"VImage_convsub", _wrap_VImage_convsub, METH_VARARGS, NULL},
-	 { (char *)"VImage_convf", _wrap_VImage_convf, METH_VARARGS, NULL},
-	 { (char *)"VImage_convsepf", _wrap_VImage_convsepf, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2s", _wrap_VImage_clip2s, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2ui", _wrap_VImage_clip2ui, METH_VARARGS, NULL},
-	 { (char *)"VImage_clip2us", _wrap_VImage_clip2us, METH_VARARGS, NULL},
-	 { (char *)"VImage_slice", _wrap_VImage_slice, METH_VARARGS, NULL},
-	 { (char *)"VImage_segment", _wrap_VImage_segment, METH_VARARGS, NULL},
-	 { (char *)"VImage_thresh", _wrap_VImage_thresh, METH_VARARGS, NULL},
-	 { (char *)"VImage_convf_raw", _wrap_VImage_convf_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_conv_raw", _wrap_VImage_conv_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_contrast_surface_raw", _wrap_VImage_contrast_surface_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_convsepf_raw", _wrap_VImage_convsepf_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_convsep_raw", _wrap_VImage_convsep_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_fastcor_raw", _wrap_VImage_fastcor_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_gradcor_raw", _wrap_VImage_gradcor_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_spcor_raw", _wrap_VImage_spcor_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_lhisteq_raw", _wrap_VImage_lhisteq_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_stdif_raw", _wrap_VImage_stdif_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_rank_raw", _wrap_VImage_rank_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_dilate_raw", _wrap_VImage_dilate_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_erode_raw", _wrap_VImage_erode_raw, METH_VARARGS, NULL},
-	 { (char *)"VImage_similarity_area", _wrap_VImage_similarity_area, METH_VARARGS, NULL},
-	 { (char *)"VImage_similarity", _wrap_VImage_similarity, METH_VARARGS, NULL},
-	 { (char *)"VImage_mask2vips", _wrap_VImage_mask2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_vips2mask", _wrap_VImage_vips2mask, METH_VARARGS, NULL},
-	 { (char *)"VImage_insertplace", _wrap_VImage_insertplace, METH_VARARGS, NULL},
-	 { (char *)"VImage_circle", _wrap_VImage_circle, METH_VARARGS, NULL},
-	 { (char *)"VImage_andimage", _wrap_VImage_andimage, METH_VARARGS, NULL},
-	 { (char *)"VImage_orimage", _wrap_VImage_orimage, METH_VARARGS, NULL},
-	 { (char *)"VImage_eorimage", _wrap_VImage_eorimage, METH_VARARGS, NULL},
-	 { (char *)"VImage_shiftleft", _wrap_VImage_shiftleft, METH_VARARGS, NULL},
-	 { (char *)"VImage_shiftright", _wrap_VImage_shiftright, METH_VARARGS, NULL},
-	 { (char *)"VImage_blend", _wrap_VImage_blend, METH_VARARGS, NULL},
-	 { (char *)"VImage_equal", _wrap_VImage_equal, METH_VARARGS, NULL},
-	 { (char *)"VImage_ifthenelse", _wrap_VImage_ifthenelse, METH_VARARGS, NULL},
-	 { (char *)"VImage_less", _wrap_VImage_less, METH_VARARGS, NULL},
-	 { (char *)"VImage_lesseq", _wrap_VImage_lesseq, METH_VARARGS, NULL},
-	 { (char *)"VImage_more", _wrap_VImage_more, METH_VARARGS, NULL},
-	 { (char *)"VImage_moreeq", _wrap_VImage_moreeq, METH_VARARGS, NULL},
-	 { (char *)"VImage_notequal", _wrap_VImage_notequal, METH_VARARGS, NULL},
-	 { (char *)"VImage_quadratic", _wrap_VImage_quadratic, METH_VARARGS, NULL},
-	 { (char *)"VImage_csv2vips", _wrap_VImage_csv2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_fits2vips", _wrap_VImage_fits2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_jpeg2vips", _wrap_VImage_jpeg2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_magick2vips", _wrap_VImage_magick2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_png2vips", _wrap_VImage_png2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_exr2vips", _wrap_VImage_exr2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_ppm2vips", _wrap_VImage_ppm2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_analyze2vips", _wrap_VImage_analyze2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_tiff2vips", _wrap_VImage_tiff2vips, METH_VARARGS, NULL},
-	 { (char *)"VImage_vips2csv", _wrap_VImage_vips2csv, METH_VARARGS, NULL},
-	 { (char *)"VImage_vips2dz", _wrap_VImage_vips2dz, METH_VARARGS, NULL},
-	 { (char *)"VImage_vips2jpeg", _wrap_VImage_vips2jpeg, METH_VARARGS, NULL},
-	 { (char *)"VImage_vips2mimejpeg", _wrap_VImage_vips2mimejpeg, METH_VARARGS, NULL},
-	 { (char *)"VImage_vips2png", _wrap_VImage_vips2png, METH_VARARGS, NULL},
-	 { (char *)"VImage_vips2ppm", _wrap_VImage_vips2ppm, METH_VARARGS, NULL},
-	 { (char *)"VImage_vips2tiff", _wrap_VImage_vips2tiff, METH_VARARGS, NULL},
-	 { (char *)"VImage_create_fmask", _wrap_VImage_create_fmask, METH_VARARGS, NULL},
-	 { (char *)"VImage_disp_ps", _wrap_VImage_disp_ps, METH_VARARGS, NULL},
-	 { (char *)"VImage_flt_image_freq", _wrap_VImage_flt_image_freq, METH_VARARGS, NULL},
-	 { (char *)"VImage_fractsurf", _wrap_VImage_fractsurf, METH_VARARGS, NULL},
-	 { (char *)"VImage_freqflt", _wrap_VImage_freqflt, METH_VARARGS, NULL},
-	 { (char *)"VImage_fwfft", _wrap_VImage_fwfft, METH_VARARGS, NULL},
-	 { (char *)"VImage_rotquad", _wrap_VImage_rotquad, METH_VARARGS, NULL},
-	 { (char *)"VImage_invfft", _wrap_VImage_invfft, METH_VARARGS, NULL},
-	 { (char *)"VImage_phasecor_fft", _wrap_VImage_phasecor_fft, METH_VARARGS, NULL},
-	 { (char *)"VImage_invfftr", _wrap_VImage_invfftr, METH_VARARGS, NULL},
-	 { (char *)"VImage_gammacorrect", _wrap_VImage_gammacorrect, METH_VARARGS, NULL},
-	 { (char *)"VImage_heq", _wrap_VImage_heq, METH_VARARGS, NULL},
-	 { (char *)"VImage_hist", _wrap_VImage_hist, METH_VARARGS, NULL},
-	 { (char *)"VImage_histcum", _wrap_VImage_histcum, METH_VARARGS, NULL},
-	 { (char *)"VImage_histeq", _wrap_VImage_histeq, METH_VARARGS, NULL},
-	 { (char *)"VImage_hist_indexed", _wrap_VImage_hist_indexed, METH_VARARGS, NULL},
-	 { (char *)"VImage_histgr", _wrap_VImage_histgr, METH_VARARGS, NULL},
-	 { (char *)"VImage_histnD", _wrap_VImage_histnD, METH_VARARGS, NULL},
-	 { (char *)"VImage_histnorm", _wrap_VImage_histnorm, METH_VARARGS, NULL},
-	 { (char *)"VImage_histplot", _wrap_VImage_histplot, METH_VARARGS, NULL},
-	 { (char *)"VImage_histspec", _wrap_VImage_histspec, METH_VARARGS, NULL},
-	 { (char *)"VImage_hsp", _wrap_VImage_hsp, METH_VARARGS, NULL},
-	 { (char *)"VImage_identity", _wrap_VImage_identity, METH_VARARGS, NULL},
-	 { (char *)"VImage_identity_ushort", _wrap_VImage_identity_ushort, METH_VARARGS, NULL},
-	 { (char *)"VImage_ismonotonic", _wrap_VImage_ismonotonic, METH_VARARGS, NULL},
-	 { (char *)"VImage_lhisteq", _wrap_VImage_lhisteq, METH_VARARGS, NULL},
-	 { (char *)"VImage_mpercent", _wrap_VImage_mpercent, METH_VARARGS, NULL},
-	 { (char *)"VImage_invertlut", _wrap_VImage_invertlut, METH_VARARGS, NULL},
-	 { (char *)"VImage_buildlut", _wrap_VImage_buildlut, METH_VARARGS, NULL},
-	 { (char *)"VImage_maplut", _wrap_VImage_maplut, METH_VARARGS, NULL},
-	 { (char *)"VImage_project", _wrap_VImage_project, METH_VARARGS, NULL},
-	 { (char *)"VImage_stdif", _wrap_VImage_stdif, METH_VARARGS, NULL},
-	 { (char *)"VImage_tone_analyse", _wrap_VImage_tone_analyse, METH_VARARGS, NULL},
-	 { (char *)"VImage_tone_build", _wrap_VImage_tone_build, METH_VARARGS, NULL},
-	 { (char *)"VImage_tone_build_range", _wrap_VImage_tone_build_range, METH_VARARGS, NULL},
-	 { (char *)"VImage_tone_map", _wrap_VImage_tone_map, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_circle", _wrap_VImage_draw_circle, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_rect", _wrap_VImage_draw_rect, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_line", _wrap_VImage_draw_line, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_point", _wrap_VImage_draw_point, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_smudge", _wrap_VImage_draw_smudge, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_flood", _wrap_VImage_draw_flood, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_flood_blob", _wrap_VImage_draw_flood_blob, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_flood_other", _wrap_VImage_draw_flood_other, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_image", _wrap_VImage_draw_image, METH_VARARGS, NULL},
-	 { (char *)"VImage_draw_mask", _wrap_VImage_draw_mask, METH_VARARGS, NULL},
-	 { (char *)"VImage_line", _wrap_VImage_line, METH_VARARGS, NULL},
-	 { (char *)"VImage_binfile", _wrap_VImage_binfile, METH_VARARGS, NULL},
-	 { (char *)"VImage_cache", _wrap_VImage_cache, METH_VARARGS, NULL},
-	 { (char *)"VImage_getext", _wrap_VImage_getext, METH_VARARGS, NULL},
-	 { (char *)"VImage_header_get_typeof", _wrap_VImage_header_get_typeof, METH_VARARGS, NULL},
-	 { (char *)"VImage_header_int", _wrap_VImage_header_int, METH_VARARGS, NULL},
-	 { (char *)"VImage_header_double", _wrap_VImage_header_double, METH_VARARGS, NULL},
-	 { (char *)"VImage_header_string", _wrap_VImage_header_string, METH_VARARGS, NULL},
-	 { (char *)"VImage_history_get", _wrap_VImage_history_get, METH_VARARGS, NULL},
-	 { (char *)"VImage_printdesc", _wrap_VImage_printdesc, METH_VARARGS, NULL},
-	 { (char *)"VImage_cntlines", _wrap_VImage_cntlines, METH_VARARGS, NULL},
-	 { (char *)"VImage_dilate", _wrap_VImage_dilate, METH_VARARGS, NULL},
-	 { (char *)"VImage_rank", _wrap_VImage_rank, METH_VARARGS, NULL},
-	 { (char *)"VImage_rank_image", _wrap_VImage_rank_image, METH_VARARGS, NULL},
-	 { (char *)"VImage_maxvalue", _wrap_VImage_maxvalue, METH_VARARGS, NULL},
-	 { (char *)"VImage_label_regions", _wrap_VImage_label_regions, METH_VARARGS, NULL},
-	 { (char *)"VImage_zerox", _wrap_VImage_zerox, METH_VARARGS, NULL},
-	 { (char *)"VImage_erode", _wrap_VImage_erode, METH_VARARGS, NULL},
-	 { (char *)"VImage_profile", _wrap_VImage_profile, METH_VARARGS, NULL},
-	 { (char *)"VImage_align_bands", _wrap_VImage_align_bands, METH_VARARGS, NULL},
-	 { (char *)"VImage_correl", _wrap_VImage_correl, METH_VARARGS, NULL},
-	 { (char *)"VImage__find_lroverlap", _wrap_VImage__find_lroverlap, METH_VARARGS, NULL},
-	 { (char *)"VImage__find_tboverlap", _wrap_VImage__find_tboverlap, METH_VARARGS, NULL},
-	 { (char *)"VImage_global_balance", _wrap_VImage_global_balance, METH_VARARGS, NULL},
-	 { (char *)"VImage_global_balancef", _wrap_VImage_global_balancef, METH_VARARGS, NULL},
-	 { (char *)"VImage_lrmerge", _wrap_VImage_lrmerge, METH_VARARGS, NULL},
-	 { (char *)"VImage_lrmerge1", _wrap_VImage_lrmerge1, METH_VARARGS, NULL},
-	 { (char *)"VImage_lrmosaic", _wrap_VImage_lrmosaic, METH_VARARGS, NULL},
-	 { (char *)"VImage_lrmosaic1", _wrap_VImage_lrmosaic1, METH_VARARGS, NULL},
-	 { (char *)"VImage_match_linear", _wrap_VImage_match_linear, METH_VARARGS, NULL},
-	 { (char *)"VImage_match_linear_search", _wrap_VImage_match_linear_search, METH_VARARGS, NULL},
-	 { (char *)"VImage_maxpos_subpel", _wrap_VImage_maxpos_subpel, METH_VARARGS, NULL},
-	 { (char *)"VImage_remosaic", _wrap_VImage_remosaic, METH_VARARGS, NULL},
-	 { (char *)"VImage_tbmerge", _wrap_VImage_tbmerge, METH_VARARGS, NULL},
-	 { (char *)"VImage_tbmerge1", _wrap_VImage_tbmerge1, METH_VARARGS, NULL},
-	 { (char *)"VImage_tbmosaic", _wrap_VImage_tbmosaic, METH_VARARGS, NULL},
-	 { (char *)"VImage_tbmosaic1", _wrap_VImage_tbmosaic1, METH_VARARGS, NULL},
-	 { (char *)"VImage_benchmark", _wrap_VImage_benchmark, METH_VARARGS, NULL},
-	 { (char *)"VImage_benchmark2", _wrap_VImage_benchmark2, METH_VARARGS, NULL},
-	 { (char *)"VImage_benchmarkn", _wrap_VImage_benchmarkn, METH_VARARGS, NULL},
-	 { (char *)"VImage_eye", _wrap_VImage_eye, METH_VARARGS, NULL},
-	 { (char *)"VImage_grey", _wrap_VImage_grey, METH_VARARGS, NULL},
-	 { (char *)"VImage_feye", _wrap_VImage_feye, METH_VARARGS, NULL},
-	 { (char *)"VImage_fgrey", _wrap_VImage_fgrey, METH_VARARGS, NULL},
-	 { (char *)"VImage_fzone", _wrap_VImage_fzone, METH_VARARGS, NULL},
-	 { (char *)"VImage_make_xy", _wrap_VImage_make_xy, METH_VARARGS, NULL},
-	 { (char *)"VImage_sines", _wrap_VImage_sines, METH_VARARGS, NULL},
-	 { (char *)"VImage_zone", _wrap_VImage_zone, METH_VARARGS, NULL},
-	 { (char *)"VImage_rightshift_size", _wrap_VImage_rightshift_size, METH_VARARGS, NULL},
-	 { (char *)"VImage_shrink", _wrap_VImage_shrink, METH_VARARGS, NULL},
-	 { (char *)"VImage_stretch3", _wrap_VImage_stretch3, METH_VARARGS, NULL},
-	 { (char *)"VImage_affinei", _wrap_VImage_affinei, METH_VARARGS, NULL},
-	 { (char *)"VImage_affinei_all", _wrap_VImage_affinei_all, METH_VARARGS, NULL},
-	 { (char *)"VImage_video_test", _wrap_VImage_video_test, METH_VARARGS, NULL},
-	 { (char *)"VImage_video_v4l1", _wrap_VImage_video_v4l1, METH_VARARGS, NULL},
-	 { (char *)"VImage_tobuffer", _wrap_VImage_tobuffer, METH_VARARGS, NULL},
-	 { (char *)"VImage_frombuffer", _wrap_VImage_frombuffer, METH_VARARGS, NULL},
-	 { (char *)"VImage_tostring", _wrap_VImage_tostring, METH_VARARGS, NULL},
-	 { (char *)"VImage_fromstring", _wrap_VImage_fromstring, METH_VARARGS, NULL},
-	 { (char *)"VImage_swigregister", VImage_swigregister, METH_VARARGS, NULL},
-	 { (char *)"im_init_world", _wrap_im_init_world, METH_VARARGS, NULL},
-	 { (char *)"im__print_all", _wrap_im__print_all, METH_VARARGS, NULL},
-	 { (char *)"im_col_Lab2XYZ", _wrap_im_col_Lab2XYZ, METH_VARARGS, NULL},
-	 { NULL, NULL, 0, NULL }
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static swig_type_info _swigt__p_GType = {"_p_GType", "GType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_VBuffer = {"_p_VBuffer", "VBuffer *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__VipsImage = {"_p__VipsImage", "_VipsImage *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_float = {"_p_float", "float *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_gboolean = {"_p_gboolean", "gboolean *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_matrix = {"_p_matrix", "matrix *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p_PyObject = {"_p_p_PyObject", "PyObject **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__allocatorT_double_t = {"_p_std__allocatorT_double_t", "std::vector< double >::allocator_type *|std::allocator< double > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__allocatorT_int_t = {"_p_std__allocatorT_int_t", "std::vector< int >::allocator_type *|std::allocator< int > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__allocatorT_vips__VImage_t = {"_p_std__allocatorT_vips__VImage_t", "std::vector< vips::VImage >::allocator_type *|std::allocator< vips::VImage > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__invalid_argument = {"_p_std__invalid_argument", "std::invalid_argument *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__vectorT__Tp__Alloc_t = {"_p_std__vectorT__Tp__Alloc_t", "std::vector< _Tp,_Alloc > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__vectorT_double_std__allocatorT_double_t_t = {"_p_std__vectorT_double_std__allocatorT_double_t_t", "std::vector< double,std::allocator< double > > *|std::vector< double > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__vectorT_int_std__allocatorT_int_t_t = {"_p_std__vectorT_int_std__allocatorT_int_t_t", "std::vector< int,std::allocator< int > > *|std::vector< int > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t = {"_p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t", "std::vector< vips::VImage > *|std::vector< vips::VImage,std::allocator< vips::VImage > > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_swig__SwigPyIterator = {"_p_swig__SwigPyIterator", "swig::SwigPyIterator *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VDMask = {"_p_vips__VDMask", "vips::VDMask *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VDisplay = {"_p_vips__VDisplay", "vips::VDisplay *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VError = {"_p_vips__VError", "vips::VError *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VIMask = {"_p_vips__VIMask", "vips::VIMask *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VImage = {"_p_vips__VImage", "vips::VImage *|std::vector< vips::VImage >::value_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};
-
-static swig_type_info *swig_type_initial[] = {
-  &_swigt__p_GType,
-  &_swigt__p_VBuffer,
-  &_swigt__p__VipsImage,
-  &_swigt__p_allocator_type,
-  &_swigt__p_char,
-  &_swigt__p_difference_type,
-  &_swigt__p_double,
-  &_swigt__p_float,
-  &_swigt__p_gboolean,
-  &_swigt__p_int,
-  &_swigt__p_matrix,
-  &_swigt__p_p_PyObject,
-  &_swigt__p_p_char,
-  &_swigt__p_size_t,
-  &_swigt__p_size_type,
-  &_swigt__p_std__allocatorT_double_t,
-  &_swigt__p_std__allocatorT_int_t,
-  &_swigt__p_std__allocatorT_vips__VImage_t,
-  &_swigt__p_std__invalid_argument,
-  &_swigt__p_std__vectorT__Tp__Alloc_t,
-  &_swigt__p_std__vectorT_double_std__allocatorT_double_t_t,
-  &_swigt__p_std__vectorT_int_std__allocatorT_int_t_t,
-  &_swigt__p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t,
-  &_swigt__p_swig__SwigPyIterator,
-  &_swigt__p_value_type,
-  &_swigt__p_vips__VDMask,
-  &_swigt__p_vips__VDisplay,
-  &_swigt__p_vips__VError,
-  &_swigt__p_vips__VIMask,
-  &_swigt__p_vips__VImage,
-  &_swigt__p_void,
-};
-
-static swig_cast_info _swigc__p_GType[] = {  {&_swigt__p_GType, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_VBuffer[] = {  {&_swigt__p_VBuffer, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p__VipsImage[] = {  {&_swigt__p__VipsImage, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_gboolean[] = {  {&_swigt__p_gboolean, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_matrix[] = {  {&_swigt__p_matrix, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_p_PyObject[] = {  {&_swigt__p_p_PyObject, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__allocatorT_double_t[] = {  {&_swigt__p_std__allocatorT_double_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__allocatorT_int_t[] = {  {&_swigt__p_std__allocatorT_int_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__allocatorT_vips__VImage_t[] = {  {&_swigt__p_std__allocatorT_vips__VImage_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__invalid_argument[] = {  {&_swigt__p_std__invalid_argument, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__vectorT__Tp__Alloc_t[] = {  {&_swigt__p_std__vectorT__Tp__Alloc_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__vectorT_double_std__allocatorT_double_t_t[] = {  {&_swigt__p_std__vectorT_double_std__allocatorT_double_t_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__vectorT_int_std__allocatorT_int_t_t[] = {  {&_swigt__p_std__vectorT_int_std__allocatorT_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t[] = {  {&_swigt__p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_swig__SwigPyIterator[] = {  {&_swigt__p_swig__SwigPyIterator, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VDMask[] = {  {&_swigt__p_vips__VDMask, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VDisplay[] = {  {&_swigt__p_vips__VDisplay, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VError[] = {  {&_swigt__p_vips__VError, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VIMask[] = {  {&_swigt__p_vips__VIMask, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VImage[] = {  {&_swigt__p_vips__VImage, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};
-
-static swig_cast_info *swig_cast_initial[] = {
-  _swigc__p_GType,
-  _swigc__p_VBuffer,
-  _swigc__p__VipsImage,
-  _swigc__p_allocator_type,
-  _swigc__p_char,
-  _swigc__p_difference_type,
-  _swigc__p_double,
-  _swigc__p_float,
-  _swigc__p_gboolean,
-  _swigc__p_int,
-  _swigc__p_matrix,
-  _swigc__p_p_PyObject,
-  _swigc__p_p_char,
-  _swigc__p_size_t,
-  _swigc__p_size_type,
-  _swigc__p_std__allocatorT_double_t,
-  _swigc__p_std__allocatorT_int_t,
-  _swigc__p_std__allocatorT_vips__VImage_t,
-  _swigc__p_std__invalid_argument,
-  _swigc__p_std__vectorT__Tp__Alloc_t,
-  _swigc__p_std__vectorT_double_std__allocatorT_double_t_t,
-  _swigc__p_std__vectorT_int_std__allocatorT_int_t_t,
-  _swigc__p_std__vectorT_vips__VImage_std__allocatorT_vips__VImage_t_t,
-  _swigc__p_swig__SwigPyIterator,
-  _swigc__p_value_type,
-  _swigc__p_vips__VDMask,
-  _swigc__p_vips__VDisplay,
-  _swigc__p_vips__VError,
-  _swigc__p_vips__VIMask,
-  _swigc__p_vips__VImage,
-  _swigc__p_void,
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-static swig_const_info swig_const_table[] = {
-{0, 0, 0, 0.0, 0, 0}};
-
-#ifdef __cplusplus
-}
-#endif
-/* -----------------------------------------------------------------------------
- * Type initialization:
- * This problem is tough by the requirement that no dynamic 
- * memory is used. Also, since swig_type_info structures store pointers to 
- * swig_cast_info structures and swig_cast_info structures store pointers back
- * to swig_type_info structures, we need some lookup code at initialization. 
- * The idea is that swig generates all the structures that are needed. 
- * The runtime then collects these partially filled structures. 
- * The SWIG_InitializeModule function takes these initial arrays out of 
- * swig_module, and does all the lookup, filling in the swig_module.types
- * array with the correct data and linking the correct swig_cast_info
- * structures together.
- *
- * The generated swig_type_info structures are assigned staticly to an initial 
- * array. We just loop through that array, and handle each type individually.
- * First we lookup if this type has been already loaded, and if so, use the
- * loaded structure instead of the generated one. Then we have to fill in the
- * cast linked list. The cast data is initially stored in something like a
- * two-dimensional array. Each row corresponds to a type (there are the same
- * number of rows as there are in the swig_type_initial array). Each entry in
- * a column is one of the swig_cast_info structures for that type.
- * The cast_initial array is actually an array of arrays, because each row has
- * a variable number of columns. So to actually build the cast linked list,
- * we find the array of casts associated with the type, and loop through it 
- * adding the casts to the list. The one last trick we need to do is making
- * sure the type pointer in the swig_cast_info struct is correct.
- *
- * First off, we lookup the cast->type name to see if it is already loaded. 
- * There are three cases to handle:
- *  1) If the cast->type has already been loaded AND the type we are adding
- *     casting info to has not been loaded (it is in this module), THEN we
- *     replace the cast->type pointer with the type pointer that has already
- *     been loaded.
- *  2) If BOTH types (the one we are adding casting info to, and the 
- *     cast->type) are loaded, THEN the cast info has already been loaded by
- *     the previous module so we just ignore it.
- *  3) Finally, if cast->type has not already been loaded, then we add that
- *     swig_cast_info to the linked list (because the cast->type) pointer will
- *     be correct.
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#if 0
-} /* c-mode */
-#endif
-#endif
-
-#if 0
-#define SWIGRUNTIME_DEBUG
-#endif
-
-
-SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
-  size_t i;
-  swig_module_info *module_head, *iter;
-  int found, init;
-  
-  /* check to see if the circular list has been setup, if not, set it up */
-  if (swig_module.next==0) {
-    /* Initialize the swig_module */
-    swig_module.type_initial = swig_type_initial;
-    swig_module.cast_initial = swig_cast_initial;
-    swig_module.next = &swig_module;
-    init = 1;
-  } else {
-    init = 0;
-  }
-  
-  /* Try and load any already created modules */
-  module_head = SWIG_GetModule(clientdata);
-  if (!module_head) {
-    /* This is the first module loaded for this interpreter */
-    /* so set the swig module into the interpreter */
-    SWIG_SetModule(clientdata, &swig_module);
-    module_head = &swig_module;
-  } else {
-    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
-    found=0;
-    iter=module_head;
-    do {
-      if (iter==&swig_module) {
-        found=1;
-        break;
-      }
-      iter=iter->next;
-    } while (iter!= module_head);
-    
-    /* if the is found in the list, then all is done and we may leave */
-    if (found) return;
-    /* otherwise we must add out module into the list */
-    swig_module.next = module_head->next;
-    module_head->next = &swig_module;
-  }
-  
-  /* When multiple interpeters are used, a module could have already been initialized in
-       a different interpreter, but not yet have a pointer in this interpreter.
-       In this case, we do not want to continue adding types... everything should be
-       set up already */
-  if (init == 0) return;
-  
-  /* Now work on filling in swig_module.types */
-#ifdef SWIGRUNTIME_DEBUG
-  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
-#endif
-  for (i = 0; i < swig_module.size; ++i) {
-    swig_type_info *type = 0;
-    swig_type_info *ret;
-    swig_cast_info *cast;
-    
-#ifdef SWIGRUNTIME_DEBUG
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-#endif
-    
-    /* if there is another module already loaded */
-    if (swig_module.next != &swig_module) {
-      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
-    }
-    if (type) {
-      /* Overwrite clientdata field */
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: found type %s\n", type->name);
-#endif
-      if (swig_module.type_initial[i]->clientdata) {
-        type->clientdata = swig_module.type_initial[i]->clientdata;
-#ifdef SWIGRUNTIME_DEBUG
-        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
-#endif
-      }
-    } else {
-      type = swig_module.type_initial[i];
-    }
-    
-    /* Insert casting types */
-    cast = swig_module.cast_initial[i];
-    while (cast->type) {
-      /* Don't need to add information already in the list */
-      ret = 0;
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
-#endif
-      if (swig_module.next != &swig_module) {
-        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
-#ifdef SWIGRUNTIME_DEBUG
-        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
-#endif
-      }
-      if (ret) {
-        if (type == swig_module.type_initial[i]) {
-#ifdef SWIGRUNTIME_DEBUG
-          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
-#endif
-          cast->type = ret;
-          ret = 0;
-        } else {
-          /* Check for casting already in the list */
-          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
-#ifdef SWIGRUNTIME_DEBUG
-          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
-#endif
-          if (!ocast) ret = 0;
-        }
-      }
-      
-      if (!ret) {
-#ifdef SWIGRUNTIME_DEBUG
-        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
-#endif
-        if (type->cast) {
-          type->cast->prev = cast;
-          cast->next = type->cast;
-        }
-        type->cast = cast;
-      }
-      cast++;
-    }
-    /* Set entry in modules->types array equal to the type */
-    swig_module.types[i] = type;
-  }
-  swig_module.types[i] = 0;
-  
-#ifdef SWIGRUNTIME_DEBUG
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-  for (i = 0; i < swig_module.size; ++i) {
-    int j = 0;
-    swig_cast_info *cast = swig_module.cast_initial[i];
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-    while (cast->type) {
-      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
-      cast++;
-      ++j;
-    }
-    printf("---- Total casts: %d\n",j);
-  }
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-#endif
-}
-
-/* This function will propagate the clientdata field of type to
-* any new swig_type_info structures that have been added into the list
-* of equivalent types.  It is like calling
-* SWIG_TypeClientData(type, clientdata) a second time.
-*/
-SWIGRUNTIME void
-SWIG_PropagateClientData(void) {
-  size_t i;
-  swig_cast_info *equiv;
-  static int init_run = 0;
-  
-  if (init_run) return;
-  init_run = 1;
-  
-  for (i = 0; i < swig_module.size; i++) {
-    if (swig_module.types[i]->clientdata) {
-      equiv = swig_module.types[i]->cast;
-      while (equiv) {
-        if (!equiv->converter) {
-          if (equiv->type && !equiv->type->clientdata)
-          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
-        }
-        equiv = equiv->next;
-      }
-    }
-  }
-}
-
-#ifdef __cplusplus
-#if 0
-{
-  /* c-mode */
-#endif
-}
-#endif
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-  
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
-    char *tmp;
-    PyObject *str = swig_varlink_str(v);
-    fprintf(fp,"Swig global variables ");
-    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
-    SWIG_Python_str_DelForPy3(tmp);
-    Py_DECREF(str);
-    return 0;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-        /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        (char *)"swigvarlink",              /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        (printfunc) swig_varlink_print,     /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-        0,                                  /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-        0,                                  /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-        0,0,0,0                             /* tp_alloc -> tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-      varlink_type.ob_type = &PyType_Type;
-#else
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-#endif
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        strncpy(gv->name,name,size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *_SWIG_globals = 0; 
-    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
-    return _SWIG_globals;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * constants/methods manipulation
-   * ----------------------------------------------------------------------------- */
-  
-  /* Install Constants */
-  SWIGINTERN void
-  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
-    PyObject *obj = 0;
-    size_t i;
-    for (i = 0; constants[i].type; ++i) {
-      switch(constants[i].type) {
-      case SWIG_PY_POINTER:
-        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
-        break;
-      case SWIG_PY_BINARY:
-        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
-        break;
-      default:
-        obj = 0;
-        break;
-      }
-      if (obj) {
-        PyDict_SetItemString(d, constants[i].name, obj);
-        Py_DECREF(obj);
-      }
-    }
-  }
-  
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
-  
-  SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
-    size_t i;
-    for (i = 0; methods[i].ml_name; ++i) {
-      const char *c = methods[i].ml_doc;
-      if (c && (c = strstr(c, "swig_ptr: "))) {
-        int j;
-        swig_const_info *ci = 0;
-        const char *name = c + 10;
-        for (j = 0; const_table[j].type; ++j) {
-          if (strncmp(const_table[j].name, name, 
-              strlen(const_table[j].name)) == 0) {
-            ci = &(const_table[j]);
-            break;
-          }
-        }
-        if (ci) {
-          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
-          if (ptr) {
-            size_t shift = (ci->ptype) - types;
-            swig_type_info *ty = types_initial[shift];
-            size_t ldoc = (c - methods[i].ml_doc);
-            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
-            char *ndoc = (char*)malloc(ldoc + lptr + 10);
-            if (ndoc) {
-              char *buff = ndoc;
-              strncpy(buff, methods[i].ml_doc, ldoc);
-              buff += ldoc;
-              strncpy(buff, "swig_ptr: ", 10);
-              buff += 10;
-              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
-              methods[i].ml_doc = ndoc;
-            }
-          }
-        }
-      }
-    }
-  } 
-  
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------*
- *  Partial Init method
- * -----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern "C"
-#endif
-
-SWIGEXPORT 
-#if PY_VERSION_HEX >= 0x03000000
-PyObject*
-#else
-void
-#endif
-SWIG_init(void) {
-  PyObject *m, *d, *md;
-#if PY_VERSION_HEX >= 0x03000000
-  static struct PyModuleDef SWIG_module = {
-# if PY_VERSION_HEX >= 0x03020000
-    PyModuleDef_HEAD_INIT,
-# else
-    {
-      PyObject_HEAD_INIT(NULL)
-      NULL, /* m_init */
-      0,    /* m_index */
-      NULL, /* m_copy */
-    },
-# endif
-    (char *) SWIG_name,
-    NULL,
-    -1,
-    SwigMethods,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-  };
-#endif
-  
-#if defined(SWIGPYTHON_BUILTIN)
-  static SwigPyClientData SwigPyObject_clientdata = {
-    0, 0, 0, 0, 0, 0, 0
-  };
-  static PyGetSetDef this_getset_def = {
-    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
-  };
-  static SwigPyGetSet thisown_getset_closure = {
-    (PyCFunction) SwigPyObject_own,
-    (PyCFunction) SwigPyObject_own
-  };
-  static PyGetSetDef thisown_getset_def = {
-    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
-  };
-  PyObject *metatype_args;
-  PyTypeObject *builtin_pytype;
-  int builtin_base_count;
-  swig_type_info *builtin_basetype;
-  PyObject *tuple;
-  PyGetSetDescrObject *static_getset;
-  PyTypeObject *metatype;
-  SwigPyClientData *cd;
-  PyObject *public_interface, *public_symbol;
-  PyObject *this_descr;
-  PyObject *thisown_descr;
-  int i;
-  
-  (void)builtin_pytype;
-  (void)builtin_base_count;
-  (void)builtin_basetype;
-  (void)tuple;
-  (void)static_getset;
-  
-  /* metatype is used to implement static member variables. */
-  metatype_args = Py_BuildValue("(s(O){})", "SwigPyObjectType", &PyType_Type);
-  assert(metatype_args);
-  metatype = (PyTypeObject *) PyType_Type.tp_call((PyObject *) &PyType_Type, metatype_args, NULL);
-  assert(metatype);
-  Py_DECREF(metatype_args);
-  metatype->tp_setattro = (setattrofunc) &SwigPyObjectType_setattro;
-  assert(PyType_Ready(metatype) >= 0);
-#endif
-  
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
-  
-#if PY_VERSION_HEX >= 0x03000000
-  m = PyModule_Create(&SWIG_module);
-#else
-  m = Py_InitModule((char *) SWIG_name, SwigMethods);
-#endif
-  md = d = PyModule_GetDict(m);
-  (void)md;
-  
-  SWIG_InitializeModule(0);
-  
-#ifdef SWIGPYTHON_BUILTIN
-  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
-  assert(SwigPyObject_stype);
-  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
-  if (!cd) {
-    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
-    SwigPyObject_clientdata.pytype = SwigPyObject_TypeOnce();
-  } else if (SwigPyObject_TypeOnce()->tp_basicsize != cd->pytype->tp_basicsize) {
-    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
-# if PY_VERSION_HEX >= 0x03000000
-    return NULL;
-# else
-    return;
-# endif
-  }
-  
-  /* All objects have a 'this' attribute */
-  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
-  (void)this_descr;
-  
-  /* All objects have a 'thisown' attribute */
-  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
-  (void)thisown_descr;
-  
-  public_interface = PyList_New(0);
-  public_symbol = 0;
-  (void)public_symbol;
-  
-  PyDict_SetItemString(md, "__all__", public_interface);
-  Py_DECREF(public_interface);
-  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
-  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
-  for (i = 0; swig_const_table[i].name != 0; ++i)
-  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
-#endif
-  
-  SWIG_InstallConstants(d,swig_const_table);
-  
-  SWIG_Python_SetConstant(d, "VImage_MULTIBAND",SWIG_From_int(static_cast< int >(vips::VImage::MULTIBAND)));
-  SWIG_Python_SetConstant(d, "VImage_B_W",SWIG_From_int(static_cast< int >(vips::VImage::B_W)));
-  SWIG_Python_SetConstant(d, "VImage_LUMINACE",SWIG_From_int(static_cast< int >(vips::VImage::LUMINACE)));
-  SWIG_Python_SetConstant(d, "VImage_XRAY",SWIG_From_int(static_cast< int >(vips::VImage::XRAY)));
-  SWIG_Python_SetConstant(d, "VImage_IR",SWIG_From_int(static_cast< int >(vips::VImage::IR)));
-  SWIG_Python_SetConstant(d, "VImage_YUV",SWIG_From_int(static_cast< int >(vips::VImage::YUV)));
-  SWIG_Python_SetConstant(d, "VImage_RED_ONLY",SWIG_From_int(static_cast< int >(vips::VImage::RED_ONLY)));
-  SWIG_Python_SetConstant(d, "VImage_GREEN_ONLY",SWIG_From_int(static_cast< int >(vips::VImage::GREEN_ONLY)));
-  SWIG_Python_SetConstant(d, "VImage_BLUE_ONLY",SWIG_From_int(static_cast< int >(vips::VImage::BLUE_ONLY)));
-  SWIG_Python_SetConstant(d, "VImage_POWER_SPECTRUM",SWIG_From_int(static_cast< int >(vips::VImage::POWER_SPECTRUM)));
-  SWIG_Python_SetConstant(d, "VImage_HISTOGRAM",SWIG_From_int(static_cast< int >(vips::VImage::HISTOGRAM)));
-  SWIG_Python_SetConstant(d, "VImage_LUT",SWIG_From_int(static_cast< int >(vips::VImage::LUT)));
-  SWIG_Python_SetConstant(d, "VImage_XYZ",SWIG_From_int(static_cast< int >(vips::VImage::XYZ)));
-  SWIG_Python_SetConstant(d, "VImage_LAB",SWIG_From_int(static_cast< int >(vips::VImage::LAB)));
-  SWIG_Python_SetConstant(d, "VImage_CMC",SWIG_From_int(static_cast< int >(vips::VImage::CMC)));
-  SWIG_Python_SetConstant(d, "VImage_CMYK",SWIG_From_int(static_cast< int >(vips::VImage::CMYK)));
-  SWIG_Python_SetConstant(d, "VImage_LABQ",SWIG_From_int(static_cast< int >(vips::VImage::LABQ)));
-  SWIG_Python_SetConstant(d, "VImage_RGB",SWIG_From_int(static_cast< int >(vips::VImage::RGB)));
-  SWIG_Python_SetConstant(d, "VImage_UCS",SWIG_From_int(static_cast< int >(vips::VImage::UCS)));
-  SWIG_Python_SetConstant(d, "VImage_LCH",SWIG_From_int(static_cast< int >(vips::VImage::LCH)));
-  SWIG_Python_SetConstant(d, "VImage_LABS",SWIG_From_int(static_cast< int >(vips::VImage::LABS)));
-  SWIG_Python_SetConstant(d, "VImage_sRGB",SWIG_From_int(static_cast< int >(vips::VImage::sRGB)));
-  SWIG_Python_SetConstant(d, "VImage_YXY",SWIG_From_int(static_cast< int >(vips::VImage::YXY)));
-  SWIG_Python_SetConstant(d, "VImage_FOURIER",SWIG_From_int(static_cast< int >(vips::VImage::FOURIER)));
-  SWIG_Python_SetConstant(d, "VImage_RGB16",SWIG_From_int(static_cast< int >(vips::VImage::RGB16)));
-  SWIG_Python_SetConstant(d, "VImage_GREY16",SWIG_From_int(static_cast< int >(vips::VImage::GREY16)));
-  SWIG_Python_SetConstant(d, "VImage_FMTNOTSET",SWIG_From_int(static_cast< int >(vips::VImage::FMTNOTSET)));
-  SWIG_Python_SetConstant(d, "VImage_FMTUCHAR",SWIG_From_int(static_cast< int >(vips::VImage::FMTUCHAR)));
-  SWIG_Python_SetConstant(d, "VImage_FMTCHAR",SWIG_From_int(static_cast< int >(vips::VImage::FMTCHAR)));
-  SWIG_Python_SetConstant(d, "VImage_FMTUSHORT",SWIG_From_int(static_cast< int >(vips::VImage::FMTUSHORT)));
-  SWIG_Python_SetConstant(d, "VImage_FMTSHORT",SWIG_From_int(static_cast< int >(vips::VImage::FMTSHORT)));
-  SWIG_Python_SetConstant(d, "VImage_FMTUINT",SWIG_From_int(static_cast< int >(vips::VImage::FMTUINT)));
-  SWIG_Python_SetConstant(d, "VImage_FMTINT",SWIG_From_int(static_cast< int >(vips::VImage::FMTINT)));
-  SWIG_Python_SetConstant(d, "VImage_FMTFLOAT",SWIG_From_int(static_cast< int >(vips::VImage::FMTFLOAT)));
-  SWIG_Python_SetConstant(d, "VImage_FMTCOMPLEX",SWIG_From_int(static_cast< int >(vips::VImage::FMTCOMPLEX)));
-  SWIG_Python_SetConstant(d, "VImage_FMTDOUBLE",SWIG_From_int(static_cast< int >(vips::VImage::FMTDOUBLE)));
-  SWIG_Python_SetConstant(d, "VImage_FMTDPCOMPLEX",SWIG_From_int(static_cast< int >(vips::VImage::FMTDPCOMPLEX)));
-  SWIG_Python_SetConstant(d, "VImage_NOCODING",SWIG_From_int(static_cast< int >(vips::VImage::NOCODING)));
-  SWIG_Python_SetConstant(d, "VImage_COLQUANT",SWIG_From_int(static_cast< int >(vips::VImage::COLQUANT)));
-  SWIG_Python_SetConstant(d, "VImage_LABPACK",SWIG_From_int(static_cast< int >(vips::VImage::LABPACK)));
-  SWIG_Python_SetConstant(d, "VImage_LABPACK_COMPRESSED",SWIG_From_int(static_cast< int >(vips::VImage::LABPACK_COMPRESSED)));
-  SWIG_Python_SetConstant(d, "VImage_RGB_COMPRESSED",SWIG_From_int(static_cast< int >(vips::VImage::RGB_COMPRESSED)));
-  SWIG_Python_SetConstant(d, "VImage_LUM_COMPRESSED",SWIG_From_int(static_cast< int >(vips::VImage::LUM_COMPRESSED)));
-  SWIG_Python_SetConstant(d, "VImage_RAD",SWIG_From_int(static_cast< int >(vips::VImage::RAD)));
-  SWIG_Python_SetConstant(d, "VImage_NO_COMPRESSION",SWIG_From_int(static_cast< int >(vips::VImage::NO_COMPRESSION)));
-  SWIG_Python_SetConstant(d, "VImage_TCSF_COMPRESSION",SWIG_From_int(static_cast< int >(vips::VImage::TCSF_COMPRESSION)));
-  SWIG_Python_SetConstant(d, "VImage_JPEG_COMPRESSION",SWIG_From_int(static_cast< int >(vips::VImage::JPEG_COMPRESSION)));
-  
-  {
-    Args *args;
-    
-    args = args_new ();
-    
-#ifdef DEBUG
-    printf ("on startup:\n");
-    args_print (args);
-#endif /*DEBUG*/
-    
-    if (im_init_world (args->argv[0])) {
-      args_free (args);
-      vips_fatal ("can't initialise module vips");
-    }
-    
-    /* Now parse any GOptions. 
-       */
-    GError *error = NULL;
-    GOptionContext *context;
-    
-    context = g_option_context_new ("- vips");
-    g_option_context_add_group (context, im_get_option_group());
-    
-    g_option_context_set_ignore_unknown_options (context, TRUE);
-    if (!g_option_context_parse (context, 
-        &args->argc, &args->argv, &error)) {
-      g_option_context_free (context);
-      args_free (args);
-      im_error ("vipsmodule", "%s", error->message);
-      g_error_free (error);
-      vips_fatal ("can't initialise module vips");
-    }
-    g_option_context_free (context);
-    
-#ifdef DEBUG
-    printf ("after parse:\n");
-    args_print (args);
-#endif /*DEBUG*/
-    
-    // Write (possibly) modified argc/argv back again.
-    if (args->argv) 
-    PySys_SetArgv (args->argc, args->argv);
-    
-    args_free (args);
-  }
-  
-#if PY_VERSION_HEX >= 0x03000000
-  return m;
-#else
-  return;
-#endif
-}
-
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/VImage.py vips-7.38.5/swig/vipsCC/VImage.py
--- vips-7.38.5-vanilla/swig/vipsCC/VImage.py	2014-07-17 23:48:36.208794473 -0400
+++ vips-7.38.5/swig/vipsCC/VImage.py	1969-12-31 19:00:00.000000000 -0500
@@ -1,919 +0,0 @@
-# This file was automatically generated by SWIG (http://www.swig.org).
-# Version 2.0.10
-#
-# Do not make changes to this file unless you know what you are doing--modify
-# the SWIG interface file instead.
-
-
-
-from sys import version_info
-if version_info >= (2,6,0):
-    def swig_import_helper():
-        from os.path import dirname
-        import imp
-        fp = None
-        try:
-            fp, pathname, description = imp.find_module('vimagemodule', [dirname(__file__)])
-        except ImportError:
-            import vimagemodule
-            return vimagemodule
-        if fp is not None:
-            try:
-                _mod = imp.load_module('vimagemodule', fp, pathname, description)
-            finally:
-                fp.close()
-            return _mod
-    vimagemodule = swig_import_helper()
-    del swig_import_helper
-else:
-    import vimagemodule
-del version_info
-try:
-    _swig_property = property
-except NameError:
-    pass # Python < 2.2 doesn't have 'property'.
-def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
-    if (name == "thisown"): return self.this.own(value)
-    if (name == "this"):
-        if type(value).__name__ == 'SwigPyObject':
-            self.__dict__[name] = value
-            return
-    method = class_type.__swig_setmethods__.get(name,None)
-    if method: return method(self,value)
-    if (not static):
-        self.__dict__[name] = value
-    else:
-        raise AttributeError("You cannot add attributes to %s" % self)
-
-def _swig_setattr(self,class_type,name,value):
-    return _swig_setattr_nondynamic(self,class_type,name,value,0)
-
-def _swig_getattr(self,class_type,name):
-    if (name == "thisown"): return self.this.own()
-    method = class_type.__swig_getmethods__.get(name,None)
-    if method: return method(self)
-    raise AttributeError(name)
-
-def _swig_repr(self):
-    try: strthis = "proxy of " + self.this.__repr__()
-    except: strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-try:
-    _object = object
-    _newclass = 1
-except AttributeError:
-    class _object : pass
-    _newclass = 0
-
-
-class SwigPyIterator(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
-    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = vimagemodule.delete_SwigPyIterator
-    __del__ = lambda self : None;
-    def value(self): return vimagemodule.SwigPyIterator_value(self)
-    def incr(self, n=1): return vimagemodule.SwigPyIterator_incr(self, n)
-    def decr(self, n=1): return vimagemodule.SwigPyIterator_decr(self, n)
-    def distance(self, *args): return vimagemodule.SwigPyIterator_distance(self, *args)
-    def equal(self, *args): return vimagemodule.SwigPyIterator_equal(self, *args)
-    def copy(self): return vimagemodule.SwigPyIterator_copy(self)
-    def next(self): return vimagemodule.SwigPyIterator_next(self)
-    def __next__(self): return vimagemodule.SwigPyIterator___next__(self)
-    def previous(self): return vimagemodule.SwigPyIterator_previous(self)
-    def advance(self, *args): return vimagemodule.SwigPyIterator_advance(self, *args)
-    def __eq__(self, *args): return vimagemodule.SwigPyIterator___eq__(self, *args)
-    def __ne__(self, *args): return vimagemodule.SwigPyIterator___ne__(self, *args)
-    def __iadd__(self, *args): return vimagemodule.SwigPyIterator___iadd__(self, *args)
-    def __isub__(self, *args): return vimagemodule.SwigPyIterator___isub__(self, *args)
-    def __add__(self, *args): return vimagemodule.SwigPyIterator___add__(self, *args)
-    def __sub__(self, *args): return vimagemodule.SwigPyIterator___sub__(self, *args)
-    def __iter__(self): return self
-SwigPyIterator_swigregister = vimagemodule.SwigPyIterator_swigregister
-SwigPyIterator_swigregister(SwigPyIterator)
-
-import VError
-import VMask
-import VDisplay
-class IntVector(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
-    __repr__ = _swig_repr
-    def iterator(self): return vimagemodule.IntVector_iterator(self)
-    def __iter__(self): return self.iterator()
-    def __nonzero__(self): return vimagemodule.IntVector___nonzero__(self)
-    def __bool__(self): return vimagemodule.IntVector___bool__(self)
-    def __len__(self): return vimagemodule.IntVector___len__(self)
-    def pop(self): return vimagemodule.IntVector_pop(self)
-    def __getslice__(self, *args): return vimagemodule.IntVector___getslice__(self, *args)
-    def __setslice__(self, *args): return vimagemodule.IntVector___setslice__(self, *args)
-    def __delslice__(self, *args): return vimagemodule.IntVector___delslice__(self, *args)
-    def __delitem__(self, *args): return vimagemodule.IntVector___delitem__(self, *args)
-    def __getitem__(self, *args): return vimagemodule.IntVector___getitem__(self, *args)
-    def __setitem__(self, *args): return vimagemodule.IntVector___setitem__(self, *args)
-    def append(self, *args): return vimagemodule.IntVector_append(self, *args)
-    def empty(self): return vimagemodule.IntVector_empty(self)
-    def size(self): return vimagemodule.IntVector_size(self)
-    def clear(self): return vimagemodule.IntVector_clear(self)
-    def swap(self, *args): return vimagemodule.IntVector_swap(self, *args)
-    def get_allocator(self): return vimagemodule.IntVector_get_allocator(self)
-    def begin(self): return vimagemodule.IntVector_begin(self)
-    def end(self): return vimagemodule.IntVector_end(self)
-    def rbegin(self): return vimagemodule.IntVector_rbegin(self)
-    def rend(self): return vimagemodule.IntVector_rend(self)
-    def pop_back(self): return vimagemodule.IntVector_pop_back(self)
-    def erase(self, *args): return vimagemodule.IntVector_erase(self, *args)
-    def __init__(self, *args): 
-        this = vimagemodule.new_IntVector(*args)
-        try: self.this.append(this)
-        except: self.this = this
-    def push_back(self, *args): return vimagemodule.IntVector_push_back(self, *args)
-    def front(self): return vimagemodule.IntVector_front(self)
-    def back(self): return vimagemodule.IntVector_back(self)
-    def assign(self, *args): return vimagemodule.IntVector_assign(self, *args)
-    def resize(self, *args): return vimagemodule.IntVector_resize(self, *args)
-    def insert(self, *args): return vimagemodule.IntVector_insert(self, *args)
-    def reserve(self, *args): return vimagemodule.IntVector_reserve(self, *args)
-    def capacity(self): return vimagemodule.IntVector_capacity(self)
-    __swig_destroy__ = vimagemodule.delete_IntVector
-    __del__ = lambda self : None;
-IntVector_swigregister = vimagemodule.IntVector_swigregister
-IntVector_swigregister(IntVector)
-
-class DoubleVector(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
-    __repr__ = _swig_repr
-    def iterator(self): return vimagemodule.DoubleVector_iterator(self)
-    def __iter__(self): return self.iterator()
-    def __nonzero__(self): return vimagemodule.DoubleVector___nonzero__(self)
-    def __bool__(self): return vimagemodule.DoubleVector___bool__(self)
-    def __len__(self): return vimagemodule.DoubleVector___len__(self)
-    def pop(self): return vimagemodule.DoubleVector_pop(self)
-    def __getslice__(self, *args): return vimagemodule.DoubleVector___getslice__(self, *args)
-    def __setslice__(self, *args): return vimagemodule.DoubleVector___setslice__(self, *args)
-    def __delslice__(self, *args): return vimagemodule.DoubleVector___delslice__(self, *args)
-    def __delitem__(self, *args): return vimagemodule.DoubleVector___delitem__(self, *args)
-    def __getitem__(self, *args): return vimagemodule.DoubleVector___getitem__(self, *args)
-    def __setitem__(self, *args): return vimagemodule.DoubleVector___setitem__(self, *args)
-    def append(self, *args): return vimagemodule.DoubleVector_append(self, *args)
-    def empty(self): return vimagemodule.DoubleVector_empty(self)
-    def size(self): return vimagemodule.DoubleVector_size(self)
-    def clear(self): return vimagemodule.DoubleVector_clear(self)
-    def swap(self, *args): return vimagemodule.DoubleVector_swap(self, *args)
-    def get_allocator(self): return vimagemodule.DoubleVector_get_allocator(self)
-    def begin(self): return vimagemodule.DoubleVector_begin(self)
-    def end(self): return vimagemodule.DoubleVector_end(self)
-    def rbegin(self): return vimagemodule.DoubleVector_rbegin(self)
-    def rend(self): return vimagemodule.DoubleVector_rend(self)
-    def pop_back(self): return vimagemodule.DoubleVector_pop_back(self)
-    def erase(self, *args): return vimagemodule.DoubleVector_erase(self, *args)
-    def __init__(self, *args): 
-        this = vimagemodule.new_DoubleVector(*args)
-        try: self.this.append(this)
-        except: self.this = this
-    def push_back(self, *args): return vimagemodule.DoubleVector_push_back(self, *args)
-    def front(self): return vimagemodule.DoubleVector_front(self)
-    def back(self): return vimagemodule.DoubleVector_back(self)
-    def assign(self, *args): return vimagemodule.DoubleVector_assign(self, *args)
-    def resize(self, *args): return vimagemodule.DoubleVector_resize(self, *args)
-    def insert(self, *args): return vimagemodule.DoubleVector_insert(self, *args)
-    def reserve(self, *args): return vimagemodule.DoubleVector_reserve(self, *args)
-    def capacity(self): return vimagemodule.DoubleVector_capacity(self)
-    __swig_destroy__ = vimagemodule.delete_DoubleVector
-    __del__ = lambda self : None;
-DoubleVector_swigregister = vimagemodule.DoubleVector_swigregister
-DoubleVector_swigregister(DoubleVector)
-
-class ImageVector(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageVector, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, ImageVector, name)
-    __repr__ = _swig_repr
-    def iterator(self): return vimagemodule.ImageVector_iterator(self)
-    def __iter__(self): return self.iterator()
-    def __nonzero__(self): return vimagemodule.ImageVector___nonzero__(self)
-    def __bool__(self): return vimagemodule.ImageVector___bool__(self)
-    def __len__(self): return vimagemodule.ImageVector___len__(self)
-    def pop(self): return vimagemodule.ImageVector_pop(self)
-    def __getslice__(self, *args): return vimagemodule.ImageVector___getslice__(self, *args)
-    def __setslice__(self, *args): return vimagemodule.ImageVector___setslice__(self, *args)
-    def __delslice__(self, *args): return vimagemodule.ImageVector___delslice__(self, *args)
-    def __delitem__(self, *args): return vimagemodule.ImageVector___delitem__(self, *args)
-    def __getitem__(self, *args): return vimagemodule.ImageVector___getitem__(self, *args)
-    def __setitem__(self, *args): return vimagemodule.ImageVector___setitem__(self, *args)
-    def append(self, *args): return vimagemodule.ImageVector_append(self, *args)
-    def empty(self): return vimagemodule.ImageVector_empty(self)
-    def size(self): return vimagemodule.ImageVector_size(self)
-    def clear(self): return vimagemodule.ImageVector_clear(self)
-    def swap(self, *args): return vimagemodule.ImageVector_swap(self, *args)
-    def get_allocator(self): return vimagemodule.ImageVector_get_allocator(self)
-    def begin(self): return vimagemodule.ImageVector_begin(self)
-    def end(self): return vimagemodule.ImageVector_end(self)
-    def rbegin(self): return vimagemodule.ImageVector_rbegin(self)
-    def rend(self): return vimagemodule.ImageVector_rend(self)
-    def pop_back(self): return vimagemodule.ImageVector_pop_back(self)
-    def erase(self, *args): return vimagemodule.ImageVector_erase(self, *args)
-    def __init__(self, *args): 
-        this = vimagemodule.new_ImageVector(*args)
-        try: self.this.append(this)
-        except: self.this = this
-    def push_back(self, *args): return vimagemodule.ImageVector_push_back(self, *args)
-    def front(self): return vimagemodule.ImageVector_front(self)
-    def back(self): return vimagemodule.ImageVector_back(self)
-    def assign(self, *args): return vimagemodule.ImageVector_assign(self, *args)
-    def resize(self, *args): return vimagemodule.ImageVector_resize(self, *args)
-    def insert(self, *args): return vimagemodule.ImageVector_insert(self, *args)
-    def reserve(self, *args): return vimagemodule.ImageVector_reserve(self, *args)
-    def capacity(self): return vimagemodule.ImageVector_capacity(self)
-    __swig_destroy__ = vimagemodule.delete_ImageVector
-    __del__ = lambda self : None;
-ImageVector_swigregister = vimagemodule.ImageVector_swigregister
-ImageVector_swigregister(ImageVector)
-
-
-def init(argv0="nothing"):
-  return vimagemodule.init(argv0)
-init = vimagemodule.init
-
-def shutdown():
-  return vimagemodule.shutdown()
-shutdown = vimagemodule.shutdown
-class VImage(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, VImage, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, VImage, name)
-    __repr__ = _swig_repr
-    __swig_getmethods__["print_all"] = lambda x: vimagemodule.VImage_print_all
-    if _newclass:print_all = staticmethod(vimagemodule.VImage_print_all)
-    MULTIBAND = vimagemodule.VImage_MULTIBAND
-    B_W = vimagemodule.VImage_B_W
-    LUMINACE = vimagemodule.VImage_LUMINACE
-    XRAY = vimagemodule.VImage_XRAY
-    IR = vimagemodule.VImage_IR
-    YUV = vimagemodule.VImage_YUV
-    RED_ONLY = vimagemodule.VImage_RED_ONLY
-    GREEN_ONLY = vimagemodule.VImage_GREEN_ONLY
-    BLUE_ONLY = vimagemodule.VImage_BLUE_ONLY
-    POWER_SPECTRUM = vimagemodule.VImage_POWER_SPECTRUM
-    HISTOGRAM = vimagemodule.VImage_HISTOGRAM
-    LUT = vimagemodule.VImage_LUT
-    XYZ = vimagemodule.VImage_XYZ
-    LAB = vimagemodule.VImage_LAB
-    CMC = vimagemodule.VImage_CMC
-    CMYK = vimagemodule.VImage_CMYK
-    LABQ = vimagemodule.VImage_LABQ
-    RGB = vimagemodule.VImage_RGB
-    UCS = vimagemodule.VImage_UCS
-    LCH = vimagemodule.VImage_LCH
-    LABS = vimagemodule.VImage_LABS
-    sRGB = vimagemodule.VImage_sRGB
-    YXY = vimagemodule.VImage_YXY
-    FOURIER = vimagemodule.VImage_FOURIER
-    RGB16 = vimagemodule.VImage_RGB16
-    GREY16 = vimagemodule.VImage_GREY16
-    FMTNOTSET = vimagemodule.VImage_FMTNOTSET
-    FMTUCHAR = vimagemodule.VImage_FMTUCHAR
-    FMTCHAR = vimagemodule.VImage_FMTCHAR
-    FMTUSHORT = vimagemodule.VImage_FMTUSHORT
-    FMTSHORT = vimagemodule.VImage_FMTSHORT
-    FMTUINT = vimagemodule.VImage_FMTUINT
-    FMTINT = vimagemodule.VImage_FMTINT
-    FMTFLOAT = vimagemodule.VImage_FMTFLOAT
-    FMTCOMPLEX = vimagemodule.VImage_FMTCOMPLEX
-    FMTDOUBLE = vimagemodule.VImage_FMTDOUBLE
-    FMTDPCOMPLEX = vimagemodule.VImage_FMTDPCOMPLEX
-    NOCODING = vimagemodule.VImage_NOCODING
-    COLQUANT = vimagemodule.VImage_COLQUANT
-    LABPACK = vimagemodule.VImage_LABPACK
-    LABPACK_COMPRESSED = vimagemodule.VImage_LABPACK_COMPRESSED
-    RGB_COMPRESSED = vimagemodule.VImage_RGB_COMPRESSED
-    LUM_COMPRESSED = vimagemodule.VImage_LUM_COMPRESSED
-    RAD = vimagemodule.VImage_RAD
-    NO_COMPRESSION = vimagemodule.VImage_NO_COMPRESSION
-    TCSF_COMPRESSION = vimagemodule.VImage_TCSF_COMPRESSION
-    JPEG_COMPRESSION = vimagemodule.VImage_JPEG_COMPRESSION
-    __swig_getmethods__["convert2disc"] = lambda x: vimagemodule.VImage_convert2disc
-    if _newclass:convert2disc = staticmethod(vimagemodule.VImage_convert2disc)
-    def __init__(self, *args): 
-        this = vimagemodule.new_VImage(*args)
-        try: self.this.append(this)
-        except: self.this = this
-    def __assign__(self, *args): return vimagemodule.VImage___assign__(self, *args)
-    __swig_destroy__ = vimagemodule.delete_VImage
-    __del__ = lambda self : None;
-    def image(self): return vimagemodule.VImage_image(self)
-    def data(self): return vimagemodule.VImage_data(self)
-    def write(self, *args): return vimagemodule.VImage_write(self, *args)
-    def debug_print(self): return vimagemodule.VImage_debug_print(self)
-    def Xsize(self): return vimagemodule.VImage_Xsize(self)
-    def Ysize(self): return vimagemodule.VImage_Ysize(self)
-    def Bands(self): return vimagemodule.VImage_Bands(self)
-    def BandFmt(self): return vimagemodule.VImage_BandFmt(self)
-    def Coding(self): return vimagemodule.VImage_Coding(self)
-    def Type(self): return vimagemodule.VImage_Type(self)
-    def Xres(self): return vimagemodule.VImage_Xres(self)
-    def Yres(self): return vimagemodule.VImage_Yres(self)
-    def Length(self): return vimagemodule.VImage_Length(self)
-    def Compression(self): return vimagemodule.VImage_Compression(self)
-    def Level(self): return vimagemodule.VImage_Level(self)
-    def Xoffset(self): return vimagemodule.VImage_Xoffset(self)
-    def Yoffset(self): return vimagemodule.VImage_Yoffset(self)
-    def filename(self): return vimagemodule.VImage_filename(self)
-    def Hist(self): return vimagemodule.VImage_Hist(self)
-    def meta_remove(self, *args): return vimagemodule.VImage_meta_remove(self, *args)
-    def meta_get_typeof(self, *args): return vimagemodule.VImage_meta_get_typeof(self, *args)
-    def meta_get_int(self, *args): return vimagemodule.VImage_meta_get_int(self, *args)
-    def meta_get_double(self, *args): return vimagemodule.VImage_meta_get_double(self, *args)
-    def meta_get_string(self, *args): return vimagemodule.VImage_meta_get_string(self, *args)
-    def meta_get_area(self, *args): return vimagemodule.VImage_meta_get_area(self, *args)
-    def meta_get_blob(self, *args): return vimagemodule.VImage_meta_get_blob(self, *args)
-    def meta_set(self, *args): return vimagemodule.VImage_meta_set(self, *args)
-    def initdesc(self, *args): return vimagemodule.VImage_initdesc(self, *args)
-    def abs(self): return vimagemodule.VImage_abs(self)
-    def acos(self): return vimagemodule.VImage_acos(self)
-    def add(self, *args): return vimagemodule.VImage_add(self, *args)
-    def asin(self): return vimagemodule.VImage_asin(self)
-    def atan(self): return vimagemodule.VImage_atan(self)
-    def avg(self): return vimagemodule.VImage_avg(self)
-    def point(self, *args): return vimagemodule.VImage_point(self, *args)
-    def point_bilinear(self, *args): return vimagemodule.VImage_point_bilinear(self, *args)
-    def bandmean(self): return vimagemodule.VImage_bandmean(self)
-    def ceil(self): return vimagemodule.VImage_ceil(self)
-    def cos(self): return vimagemodule.VImage_cos(self)
-    def cross_phase(self, *args): return vimagemodule.VImage_cross_phase(self, *args)
-    def deviate(self): return vimagemodule.VImage_deviate(self)
-    def divide(self, *args): return vimagemodule.VImage_divide(self, *args)
-    def exp10(self): return vimagemodule.VImage_exp10(self)
-    def expn(self, *args): return vimagemodule.VImage_expn(self, *args)
-    def exp(self): return vimagemodule.VImage_exp(self)
-    def floor(self): return vimagemodule.VImage_floor(self)
-    def invert(self): return vimagemodule.VImage_invert(self)
-    __swig_getmethods__["linreg"] = lambda x: vimagemodule.VImage_linreg
-    if _newclass:linreg = staticmethod(vimagemodule.VImage_linreg)
-    def lin(self, *args): return vimagemodule.VImage_lin(self, *args)
-    def log10(self): return vimagemodule.VImage_log10(self)
-    def log(self): return vimagemodule.VImage_log(self)
-    def max(self): return vimagemodule.VImage_max(self)
-    def maxpos(self): return vimagemodule.VImage_maxpos(self)
-    def maxpos_avg(self): return vimagemodule.VImage_maxpos_avg(self)
-    def measure(self, *args): return vimagemodule.VImage_measure(self, *args)
-    def min(self): return vimagemodule.VImage_min(self)
-    def minpos(self): return vimagemodule.VImage_minpos(self)
-    def multiply(self, *args): return vimagemodule.VImage_multiply(self, *args)
-    def pow(self, *args): return vimagemodule.VImage_pow(self, *args)
-    def recomb(self, *args): return vimagemodule.VImage_recomb(self, *args)
-    def remainder(self, *args): return vimagemodule.VImage_remainder(self, *args)
-    def rint(self): return vimagemodule.VImage_rint(self)
-    def sign(self): return vimagemodule.VImage_sign(self)
-    def sin(self): return vimagemodule.VImage_sin(self)
-    def stats(self): return vimagemodule.VImage_stats(self)
-    def subtract(self, *args): return vimagemodule.VImage_subtract(self, *args)
-    def tan(self): return vimagemodule.VImage_tan(self)
-    def greyc(self, *args): return vimagemodule.VImage_greyc(self, *args)
-    def greyc_mask(self, *args): return vimagemodule.VImage_greyc_mask(self, *args)
-    def LCh2Lab(self): return vimagemodule.VImage_LCh2Lab(self)
-    def LCh2UCS(self): return vimagemodule.VImage_LCh2UCS(self)
-    def Lab2LCh(self): return vimagemodule.VImage_Lab2LCh(self)
-    def Lab2LabQ(self): return vimagemodule.VImage_Lab2LabQ(self)
-    def Lab2LabS(self): return vimagemodule.VImage_Lab2LabS(self)
-    def Lab2UCS(self): return vimagemodule.VImage_Lab2UCS(self)
-    def Lab2XYZ(self): return vimagemodule.VImage_Lab2XYZ(self)
-    def Lab2XYZ_temp(self, *args): return vimagemodule.VImage_Lab2XYZ_temp(self, *args)
-    def Lab2disp(self, *args): return vimagemodule.VImage_Lab2disp(self, *args)
-    def LabQ2LabS(self): return vimagemodule.VImage_LabQ2LabS(self)
-    def LabQ2Lab(self): return vimagemodule.VImage_LabQ2Lab(self)
-    def LabQ2XYZ(self): return vimagemodule.VImage_LabQ2XYZ(self)
-    def LabQ2disp(self, *args): return vimagemodule.VImage_LabQ2disp(self, *args)
-    def LabS2LabQ(self): return vimagemodule.VImage_LabS2LabQ(self)
-    def LabS2Lab(self): return vimagemodule.VImage_LabS2Lab(self)
-    def UCS2LCh(self): return vimagemodule.VImage_UCS2LCh(self)
-    def UCS2Lab(self): return vimagemodule.VImage_UCS2Lab(self)
-    def UCS2XYZ(self): return vimagemodule.VImage_UCS2XYZ(self)
-    def XYZ2Lab(self): return vimagemodule.VImage_XYZ2Lab(self)
-    def XYZ2Lab_temp(self, *args): return vimagemodule.VImage_XYZ2Lab_temp(self, *args)
-    def XYZ2UCS(self): return vimagemodule.VImage_XYZ2UCS(self)
-    def XYZ2Yxy(self): return vimagemodule.VImage_XYZ2Yxy(self)
-    def XYZ2disp(self, *args): return vimagemodule.VImage_XYZ2disp(self, *args)
-    def XYZ2sRGB(self): return vimagemodule.VImage_XYZ2sRGB(self)
-    def Yxy2XYZ(self): return vimagemodule.VImage_Yxy2XYZ(self)
-    def dE00_fromLab(self, *args): return vimagemodule.VImage_dE00_fromLab(self, *args)
-    def dECMC_fromLab(self, *args): return vimagemodule.VImage_dECMC_fromLab(self, *args)
-    def dECMC_fromdisp(self, *args): return vimagemodule.VImage_dECMC_fromdisp(self, *args)
-    def dE_fromLab(self, *args): return vimagemodule.VImage_dE_fromLab(self, *args)
-    def dE_fromXYZ(self, *args): return vimagemodule.VImage_dE_fromXYZ(self, *args)
-    def dE_fromdisp(self, *args): return vimagemodule.VImage_dE_fromdisp(self, *args)
-    def disp2Lab(self, *args): return vimagemodule.VImage_disp2Lab(self, *args)
-    def disp2XYZ(self, *args): return vimagemodule.VImage_disp2XYZ(self, *args)
-    def float2rad(self): return vimagemodule.VImage_float2rad(self)
-    def icc_ac2rc(self, *args): return vimagemodule.VImage_icc_ac2rc(self, *args)
-    def icc_export_depth(self, *args): return vimagemodule.VImage_icc_export_depth(self, *args)
-    def icc_import(self, *args): return vimagemodule.VImage_icc_import(self, *args)
-    def icc_import_embedded(self, *args): return vimagemodule.VImage_icc_import_embedded(self, *args)
-    def icc_transform(self, *args): return vimagemodule.VImage_icc_transform(self, *args)
-    def lab_morph(self, *args): return vimagemodule.VImage_lab_morph(self, *args)
-    def rad2float(self): return vimagemodule.VImage_rad2float(self)
-    def sRGB2XYZ(self): return vimagemodule.VImage_sRGB2XYZ(self)
-    __swig_getmethods__["gaussnoise"] = lambda x: vimagemodule.VImage_gaussnoise
-    if _newclass:gaussnoise = staticmethod(vimagemodule.VImage_gaussnoise)
-    def bandjoin(self, *args): return vimagemodule.VImage_bandjoin(self, *args)
-    __swig_getmethods__["black"] = lambda x: vimagemodule.VImage_black
-    if _newclass:black = staticmethod(vimagemodule.VImage_black)
-    def c2amph(self): return vimagemodule.VImage_c2amph(self)
-    def c2imag(self): return vimagemodule.VImage_c2imag(self)
-    def c2real(self): return vimagemodule.VImage_c2real(self)
-    def c2rect(self): return vimagemodule.VImage_c2rect(self)
-    def clip2fmt(self, *args): return vimagemodule.VImage_clip2fmt(self, *args)
-    def copy(self): return vimagemodule.VImage_copy(self)
-    def copy_file(self): return vimagemodule.VImage_copy_file(self)
-    def copy_morph(self, *args): return vimagemodule.VImage_copy_morph(self, *args)
-    def copy_swap(self): return vimagemodule.VImage_copy_swap(self)
-    def copy_set(self, *args): return vimagemodule.VImage_copy_set(self, *args)
-    def extract_area(self, *args): return vimagemodule.VImage_extract_area(self, *args)
-    def extract_areabands(self, *args): return vimagemodule.VImage_extract_areabands(self, *args)
-    def extract_band(self, *args): return vimagemodule.VImage_extract_band(self, *args)
-    def extract_bands(self, *args): return vimagemodule.VImage_extract_bands(self, *args)
-    def extract(self, *args): return vimagemodule.VImage_extract(self, *args)
-    def falsecolour(self): return vimagemodule.VImage_falsecolour(self)
-    def fliphor(self): return vimagemodule.VImage_fliphor(self)
-    def flipver(self): return vimagemodule.VImage_flipver(self)
-    __swig_getmethods__["gbandjoin"] = lambda x: vimagemodule.VImage_gbandjoin
-    if _newclass:gbandjoin = staticmethod(vimagemodule.VImage_gbandjoin)
-    def grid(self, *args): return vimagemodule.VImage_grid(self, *args)
-    def insert(self, *args): return vimagemodule.VImage_insert(self, *args)
-    def insert_noexpand(self, *args): return vimagemodule.VImage_insert_noexpand(self, *args)
-    def embed(self, *args): return vimagemodule.VImage_embed(self, *args)
-    def lrjoin(self, *args): return vimagemodule.VImage_lrjoin(self, *args)
-    def msb(self): return vimagemodule.VImage_msb(self)
-    def msb_band(self, *args): return vimagemodule.VImage_msb_band(self, *args)
-    def replicate(self, *args): return vimagemodule.VImage_replicate(self, *args)
-    def ri2c(self, *args): return vimagemodule.VImage_ri2c(self, *args)
-    def rot180(self): return vimagemodule.VImage_rot180(self)
-    def rot270(self): return vimagemodule.VImage_rot270(self)
-    def rot90(self): return vimagemodule.VImage_rot90(self)
-    def scale(self): return vimagemodule.VImage_scale(self)
-    def scaleps(self): return vimagemodule.VImage_scaleps(self)
-    def subsample(self, *args): return vimagemodule.VImage_subsample(self, *args)
-    def system(self, *args): return vimagemodule.VImage_system(self, *args)
-    def system_image(self, *args): return vimagemodule.VImage_system_image(self, *args)
-    def tbjoin(self, *args): return vimagemodule.VImage_tbjoin(self, *args)
-    __swig_getmethods__["text"] = lambda x: vimagemodule.VImage_text
-    if _newclass:text = staticmethod(vimagemodule.VImage_text)
-    def wrap(self, *args): return vimagemodule.VImage_wrap(self, *args)
-    def zoom(self, *args): return vimagemodule.VImage_zoom(self, *args)
-    def aconvsep(self, *args): return vimagemodule.VImage_aconvsep(self, *args)
-    def aconv(self, *args): return vimagemodule.VImage_aconv(self, *args)
-    def addgnoise(self, *args): return vimagemodule.VImage_addgnoise(self, *args)
-    def compass(self, *args): return vimagemodule.VImage_compass(self, *args)
-    def contrast_surface(self, *args): return vimagemodule.VImage_contrast_surface(self, *args)
-    def conv(self, *args): return vimagemodule.VImage_conv(self, *args)
-    def convsep(self, *args): return vimagemodule.VImage_convsep(self, *args)
-    def fastcor(self, *args): return vimagemodule.VImage_fastcor(self, *args)
-    def gradcor(self, *args): return vimagemodule.VImage_gradcor(self, *args)
-    def gradient(self, *args): return vimagemodule.VImage_gradient(self, *args)
-    def grad_x(self): return vimagemodule.VImage_grad_x(self)
-    def grad_y(self): return vimagemodule.VImage_grad_y(self)
-    def lindetect(self, *args): return vimagemodule.VImage_lindetect(self, *args)
-    def sharpen(self, *args): return vimagemodule.VImage_sharpen(self, *args)
-    def spcor(self, *args): return vimagemodule.VImage_spcor(self, *args)
-    def argb2rgba(self): return vimagemodule.VImage_argb2rgba(self)
-    def flood_copy(self, *args): return vimagemodule.VImage_flood_copy(self, *args)
-    def flood_blob_copy(self, *args): return vimagemodule.VImage_flood_blob_copy(self, *args)
-    def flood_other_copy(self, *args): return vimagemodule.VImage_flood_other_copy(self, *args)
-    def clip(self): return vimagemodule.VImage_clip(self)
-    def c2ps(self): return vimagemodule.VImage_c2ps(self)
-    def resize_linear(self, *args): return vimagemodule.VImage_resize_linear(self, *args)
-    def cmulnorm(self, *args): return vimagemodule.VImage_cmulnorm(self, *args)
-    def fav4(self, *args): return vimagemodule.VImage_fav4(self, *args)
-    def gadd(self, *args): return vimagemodule.VImage_gadd(self, *args)
-    def icc_export(self, *args): return vimagemodule.VImage_icc_export(self, *args)
-    def litecor(self, *args): return vimagemodule.VImage_litecor(self, *args)
-    def affine(self, *args): return vimagemodule.VImage_affine(self, *args)
-    def clip2c(self): return vimagemodule.VImage_clip2c(self)
-    def clip2cm(self): return vimagemodule.VImage_clip2cm(self)
-    def clip2d(self): return vimagemodule.VImage_clip2d(self)
-    def clip2dcm(self): return vimagemodule.VImage_clip2dcm(self)
-    def clip2f(self): return vimagemodule.VImage_clip2f(self)
-    def clip2i(self): return vimagemodule.VImage_clip2i(self)
-    def convsub(self, *args): return vimagemodule.VImage_convsub(self, *args)
-    def convf(self, *args): return vimagemodule.VImage_convf(self, *args)
-    def convsepf(self, *args): return vimagemodule.VImage_convsepf(self, *args)
-    def clip2s(self): return vimagemodule.VImage_clip2s(self)
-    def clip2ui(self): return vimagemodule.VImage_clip2ui(self)
-    def clip2us(self): return vimagemodule.VImage_clip2us(self)
-    def slice(self, *args): return vimagemodule.VImage_slice(self, *args)
-    def segment(self): return vimagemodule.VImage_segment(self)
-    def thresh(self, *args): return vimagemodule.VImage_thresh(self, *args)
-    def convf_raw(self, *args): return vimagemodule.VImage_convf_raw(self, *args)
-    def conv_raw(self, *args): return vimagemodule.VImage_conv_raw(self, *args)
-    def contrast_surface_raw(self, *args): return vimagemodule.VImage_contrast_surface_raw(self, *args)
-    def convsepf_raw(self, *args): return vimagemodule.VImage_convsepf_raw(self, *args)
-    def convsep_raw(self, *args): return vimagemodule.VImage_convsep_raw(self, *args)
-    def fastcor_raw(self, *args): return vimagemodule.VImage_fastcor_raw(self, *args)
-    def gradcor_raw(self, *args): return vimagemodule.VImage_gradcor_raw(self, *args)
-    def spcor_raw(self, *args): return vimagemodule.VImage_spcor_raw(self, *args)
-    def lhisteq_raw(self, *args): return vimagemodule.VImage_lhisteq_raw(self, *args)
-    def stdif_raw(self, *args): return vimagemodule.VImage_stdif_raw(self, *args)
-    def rank_raw(self, *args): return vimagemodule.VImage_rank_raw(self, *args)
-    def dilate_raw(self, *args): return vimagemodule.VImage_dilate_raw(self, *args)
-    def erode_raw(self, *args): return vimagemodule.VImage_erode_raw(self, *args)
-    def similarity_area(self, *args): return vimagemodule.VImage_similarity_area(self, *args)
-    def similarity(self, *args): return vimagemodule.VImage_similarity(self, *args)
-    __swig_getmethods__["mask2vips"] = lambda x: vimagemodule.VImage_mask2vips
-    if _newclass:mask2vips = staticmethod(vimagemodule.VImage_mask2vips)
-    def vips2mask(self): return vimagemodule.VImage_vips2mask(self)
-    def insertplace(self, *args): return vimagemodule.VImage_insertplace(self, *args)
-    def circle(self, *args): return vimagemodule.VImage_circle(self, *args)
-    def andimage(self, *args): return vimagemodule.VImage_andimage(self, *args)
-    def orimage(self, *args): return vimagemodule.VImage_orimage(self, *args)
-    def eorimage(self, *args): return vimagemodule.VImage_eorimage(self, *args)
-    def shiftleft(self, *args): return vimagemodule.VImage_shiftleft(self, *args)
-    def shiftright(self, *args): return vimagemodule.VImage_shiftright(self, *args)
-    def blend(self, *args): return vimagemodule.VImage_blend(self, *args)
-    def equal(self, *args): return vimagemodule.VImage_equal(self, *args)
-    def ifthenelse(self, *args): return vimagemodule.VImage_ifthenelse(self, *args)
-    def less(self, *args): return vimagemodule.VImage_less(self, *args)
-    def lesseq(self, *args): return vimagemodule.VImage_lesseq(self, *args)
-    def more(self, *args): return vimagemodule.VImage_more(self, *args)
-    def moreeq(self, *args): return vimagemodule.VImage_moreeq(self, *args)
-    def notequal(self, *args): return vimagemodule.VImage_notequal(self, *args)
-    def quadratic(self, *args): return vimagemodule.VImage_quadratic(self, *args)
-    __swig_getmethods__["csv2vips"] = lambda x: vimagemodule.VImage_csv2vips
-    if _newclass:csv2vips = staticmethod(vimagemodule.VImage_csv2vips)
-    __swig_getmethods__["fits2vips"] = lambda x: vimagemodule.VImage_fits2vips
-    if _newclass:fits2vips = staticmethod(vimagemodule.VImage_fits2vips)
-    __swig_getmethods__["jpeg2vips"] = lambda x: vimagemodule.VImage_jpeg2vips
-    if _newclass:jpeg2vips = staticmethod(vimagemodule.VImage_jpeg2vips)
-    __swig_getmethods__["magick2vips"] = lambda x: vimagemodule.VImage_magick2vips
-    if _newclass:magick2vips = staticmethod(vimagemodule.VImage_magick2vips)
-    __swig_getmethods__["png2vips"] = lambda x: vimagemodule.VImage_png2vips
-    if _newclass:png2vips = staticmethod(vimagemodule.VImage_png2vips)
-    __swig_getmethods__["exr2vips"] = lambda x: vimagemodule.VImage_exr2vips
-    if _newclass:exr2vips = staticmethod(vimagemodule.VImage_exr2vips)
-    __swig_getmethods__["ppm2vips"] = lambda x: vimagemodule.VImage_ppm2vips
-    if _newclass:ppm2vips = staticmethod(vimagemodule.VImage_ppm2vips)
-    __swig_getmethods__["analyze2vips"] = lambda x: vimagemodule.VImage_analyze2vips
-    if _newclass:analyze2vips = staticmethod(vimagemodule.VImage_analyze2vips)
-    __swig_getmethods__["tiff2vips"] = lambda x: vimagemodule.VImage_tiff2vips
-    if _newclass:tiff2vips = staticmethod(vimagemodule.VImage_tiff2vips)
-    def vips2csv(self, *args): return vimagemodule.VImage_vips2csv(self, *args)
-    def vips2dz(self, *args): return vimagemodule.VImage_vips2dz(self, *args)
-    def vips2jpeg(self, *args): return vimagemodule.VImage_vips2jpeg(self, *args)
-    def vips2mimejpeg(self, *args): return vimagemodule.VImage_vips2mimejpeg(self, *args)
-    def vips2png(self, *args): return vimagemodule.VImage_vips2png(self, *args)
-    def vips2ppm(self, *args): return vimagemodule.VImage_vips2ppm(self, *args)
-    def vips2tiff(self, *args): return vimagemodule.VImage_vips2tiff(self, *args)
-    __swig_getmethods__["create_fmask"] = lambda x: vimagemodule.VImage_create_fmask
-    if _newclass:create_fmask = staticmethod(vimagemodule.VImage_create_fmask)
-    def disp_ps(self): return vimagemodule.VImage_disp_ps(self)
-    def flt_image_freq(self, *args): return vimagemodule.VImage_flt_image_freq(self, *args)
-    __swig_getmethods__["fractsurf"] = lambda x: vimagemodule.VImage_fractsurf
-    if _newclass:fractsurf = staticmethod(vimagemodule.VImage_fractsurf)
-    def freqflt(self, *args): return vimagemodule.VImage_freqflt(self, *args)
-    def fwfft(self): return vimagemodule.VImage_fwfft(self)
-    def rotquad(self): return vimagemodule.VImage_rotquad(self)
-    def invfft(self): return vimagemodule.VImage_invfft(self)
-    def phasecor_fft(self, *args): return vimagemodule.VImage_phasecor_fft(self, *args)
-    def invfftr(self): return vimagemodule.VImage_invfftr(self)
-    def gammacorrect(self, *args): return vimagemodule.VImage_gammacorrect(self, *args)
-    def heq(self, *args): return vimagemodule.VImage_heq(self, *args)
-    def hist(self, *args): return vimagemodule.VImage_hist(self, *args)
-    def histcum(self): return vimagemodule.VImage_histcum(self)
-    def histeq(self): return vimagemodule.VImage_histeq(self)
-    def hist_indexed(self, *args): return vimagemodule.VImage_hist_indexed(self, *args)
-    def histgr(self, *args): return vimagemodule.VImage_histgr(self, *args)
-    def histnD(self, *args): return vimagemodule.VImage_histnD(self, *args)
-    def histnorm(self): return vimagemodule.VImage_histnorm(self)
-    def histplot(self): return vimagemodule.VImage_histplot(self)
-    def histspec(self, *args): return vimagemodule.VImage_histspec(self, *args)
-    def hsp(self, *args): return vimagemodule.VImage_hsp(self, *args)
-    __swig_getmethods__["identity"] = lambda x: vimagemodule.VImage_identity
-    if _newclass:identity = staticmethod(vimagemodule.VImage_identity)
-    __swig_getmethods__["identity_ushort"] = lambda x: vimagemodule.VImage_identity_ushort
-    if _newclass:identity_ushort = staticmethod(vimagemodule.VImage_identity_ushort)
-    def ismonotonic(self): return vimagemodule.VImage_ismonotonic(self)
-    def lhisteq(self, *args): return vimagemodule.VImage_lhisteq(self, *args)
-    def mpercent(self, *args): return vimagemodule.VImage_mpercent(self, *args)
-    __swig_getmethods__["invertlut"] = lambda x: vimagemodule.VImage_invertlut
-    if _newclass:invertlut = staticmethod(vimagemodule.VImage_invertlut)
-    __swig_getmethods__["buildlut"] = lambda x: vimagemodule.VImage_buildlut
-    if _newclass:buildlut = staticmethod(vimagemodule.VImage_buildlut)
-    def maplut(self, *args): return vimagemodule.VImage_maplut(self, *args)
-    def project(self, *args): return vimagemodule.VImage_project(self, *args)
-    def stdif(self, *args): return vimagemodule.VImage_stdif(self, *args)
-    def tone_analyse(self, *args): return vimagemodule.VImage_tone_analyse(self, *args)
-    __swig_getmethods__["tone_build"] = lambda x: vimagemodule.VImage_tone_build
-    if _newclass:tone_build = staticmethod(vimagemodule.VImage_tone_build)
-    __swig_getmethods__["tone_build_range"] = lambda x: vimagemodule.VImage_tone_build_range
-    if _newclass:tone_build_range = staticmethod(vimagemodule.VImage_tone_build_range)
-    def tone_map(self, *args): return vimagemodule.VImage_tone_map(self, *args)
-    def draw_circle(self, *args): return vimagemodule.VImage_draw_circle(self, *args)
-    def draw_rect(self, *args): return vimagemodule.VImage_draw_rect(self, *args)
-    def draw_line(self, *args): return vimagemodule.VImage_draw_line(self, *args)
-    def draw_point(self, *args): return vimagemodule.VImage_draw_point(self, *args)
-    def draw_smudge(self, *args): return vimagemodule.VImage_draw_smudge(self, *args)
-    def draw_flood(self, *args): return vimagemodule.VImage_draw_flood(self, *args)
-    def draw_flood_blob(self, *args): return vimagemodule.VImage_draw_flood_blob(self, *args)
-    def draw_flood_other(self, *args): return vimagemodule.VImage_draw_flood_other(self, *args)
-    def draw_image(self, *args): return vimagemodule.VImage_draw_image(self, *args)
-    def draw_mask(self, *args): return vimagemodule.VImage_draw_mask(self, *args)
-    def line(self, *args): return vimagemodule.VImage_line(self, *args)
-    __swig_getmethods__["binfile"] = lambda x: vimagemodule.VImage_binfile
-    if _newclass:binfile = staticmethod(vimagemodule.VImage_binfile)
-    def cache(self, *args): return vimagemodule.VImage_cache(self, *args)
-    def getext(self): return vimagemodule.VImage_getext(self)
-    def header_get_typeof(self, *args): return vimagemodule.VImage_header_get_typeof(self, *args)
-    def header_int(self, *args): return vimagemodule.VImage_header_int(self, *args)
-    def header_double(self, *args): return vimagemodule.VImage_header_double(self, *args)
-    def header_string(self, *args): return vimagemodule.VImage_header_string(self, *args)
-    def history_get(self): return vimagemodule.VImage_history_get(self)
-    def printdesc(self): return vimagemodule.VImage_printdesc(self)
-    def cntlines(self, *args): return vimagemodule.VImage_cntlines(self, *args)
-    def dilate(self, *args): return vimagemodule.VImage_dilate(self, *args)
-    def rank(self, *args): return vimagemodule.VImage_rank(self, *args)
-    __swig_getmethods__["rank_image"] = lambda x: vimagemodule.VImage_rank_image
-    if _newclass:rank_image = staticmethod(vimagemodule.VImage_rank_image)
-    __swig_getmethods__["maxvalue"] = lambda x: vimagemodule.VImage_maxvalue
-    if _newclass:maxvalue = staticmethod(vimagemodule.VImage_maxvalue)
-    def label_regions(self): return vimagemodule.VImage_label_regions(self)
-    def zerox(self, *args): return vimagemodule.VImage_zerox(self, *args)
-    def erode(self, *args): return vimagemodule.VImage_erode(self, *args)
-    def profile(self, *args): return vimagemodule.VImage_profile(self, *args)
-    def align_bands(self): return vimagemodule.VImage_align_bands(self)
-    def correl(self, *args): return vimagemodule.VImage_correl(self, *args)
-    def _find_lroverlap(self, *args): return vimagemodule.VImage__find_lroverlap(self, *args)
-    def _find_tboverlap(self, *args): return vimagemodule.VImage__find_tboverlap(self, *args)
-    def global_balance(self, *args): return vimagemodule.VImage_global_balance(self, *args)
-    def global_balancef(self, *args): return vimagemodule.VImage_global_balancef(self, *args)
-    def lrmerge(self, *args): return vimagemodule.VImage_lrmerge(self, *args)
-    def lrmerge1(self, *args): return vimagemodule.VImage_lrmerge1(self, *args)
-    def lrmosaic(self, *args): return vimagemodule.VImage_lrmosaic(self, *args)
-    def lrmosaic1(self, *args): return vimagemodule.VImage_lrmosaic1(self, *args)
-    def match_linear(self, *args): return vimagemodule.VImage_match_linear(self, *args)
-    def match_linear_search(self, *args): return vimagemodule.VImage_match_linear_search(self, *args)
-    def maxpos_subpel(self): return vimagemodule.VImage_maxpos_subpel(self)
-    def remosaic(self, *args): return vimagemodule.VImage_remosaic(self, *args)
-    def tbmerge(self, *args): return vimagemodule.VImage_tbmerge(self, *args)
-    def tbmerge1(self, *args): return vimagemodule.VImage_tbmerge1(self, *args)
-    def tbmosaic(self, *args): return vimagemodule.VImage_tbmosaic(self, *args)
-    def tbmosaic1(self, *args): return vimagemodule.VImage_tbmosaic1(self, *args)
-    def benchmark(self): return vimagemodule.VImage_benchmark(self)
-    def benchmark2(self): return vimagemodule.VImage_benchmark2(self)
-    def benchmarkn(self, *args): return vimagemodule.VImage_benchmarkn(self, *args)
-    __swig_getmethods__["eye"] = lambda x: vimagemodule.VImage_eye
-    if _newclass:eye = staticmethod(vimagemodule.VImage_eye)
-    __swig_getmethods__["grey"] = lambda x: vimagemodule.VImage_grey
-    if _newclass:grey = staticmethod(vimagemodule.VImage_grey)
-    __swig_getmethods__["feye"] = lambda x: vimagemodule.VImage_feye
-    if _newclass:feye = staticmethod(vimagemodule.VImage_feye)
-    __swig_getmethods__["fgrey"] = lambda x: vimagemodule.VImage_fgrey
-    if _newclass:fgrey = staticmethod(vimagemodule.VImage_fgrey)
-    __swig_getmethods__["fzone"] = lambda x: vimagemodule.VImage_fzone
-    if _newclass:fzone = staticmethod(vimagemodule.VImage_fzone)
-    __swig_getmethods__["make_xy"] = lambda x: vimagemodule.VImage_make_xy
-    if _newclass:make_xy = staticmethod(vimagemodule.VImage_make_xy)
-    __swig_getmethods__["sines"] = lambda x: vimagemodule.VImage_sines
-    if _newclass:sines = staticmethod(vimagemodule.VImage_sines)
-    __swig_getmethods__["zone"] = lambda x: vimagemodule.VImage_zone
-    if _newclass:zone = staticmethod(vimagemodule.VImage_zone)
-    def rightshift_size(self, *args): return vimagemodule.VImage_rightshift_size(self, *args)
-    def shrink(self, *args): return vimagemodule.VImage_shrink(self, *args)
-    def stretch3(self, *args): return vimagemodule.VImage_stretch3(self, *args)
-    def affinei(self, *args): return vimagemodule.VImage_affinei(self, *args)
-    def affinei_all(self, *args): return vimagemodule.VImage_affinei_all(self, *args)
-    __swig_getmethods__["video_test"] = lambda x: vimagemodule.VImage_video_test
-    if _newclass:video_test = staticmethod(vimagemodule.VImage_video_test)
-    __swig_getmethods__["video_v4l1"] = lambda x: vimagemodule.VImage_video_v4l1
-    if _newclass:video_v4l1 = staticmethod(vimagemodule.VImage_video_v4l1)
-    def tobuffer(self): return vimagemodule.VImage_tobuffer(self)
-    __swig_getmethods__["frombuffer"] = lambda x: vimagemodule.VImage_frombuffer
-    if _newclass:frombuffer = staticmethod(vimagemodule.VImage_frombuffer)
-    def tostring(self): return vimagemodule.VImage_tostring(self)
-    __swig_getmethods__["fromstring"] = lambda x: vimagemodule.VImage_fromstring
-    if _newclass:fromstring = staticmethod(vimagemodule.VImage_fromstring)
-VImage_swigregister = vimagemodule.VImage_swigregister
-VImage_swigregister(VImage)
-
-def VImage_print_all():
-  return vimagemodule.VImage_print_all()
-VImage_print_all = vimagemodule.VImage_print_all
-
-def VImage_convert2disc(*args):
-  return vimagemodule.VImage_convert2disc(*args)
-VImage_convert2disc = vimagemodule.VImage_convert2disc
-
-def VImage_linreg(*args):
-  return vimagemodule.VImage_linreg(*args)
-VImage_linreg = vimagemodule.VImage_linreg
-
-def VImage_gaussnoise(*args):
-  return vimagemodule.VImage_gaussnoise(*args)
-VImage_gaussnoise = vimagemodule.VImage_gaussnoise
-
-def VImage_black(*args):
-  return vimagemodule.VImage_black(*args)
-VImage_black = vimagemodule.VImage_black
-
-def VImage_gbandjoin(*args):
-  return vimagemodule.VImage_gbandjoin(*args)
-VImage_gbandjoin = vimagemodule.VImage_gbandjoin
-
-def VImage_text(*args):
-  return vimagemodule.VImage_text(*args)
-VImage_text = vimagemodule.VImage_text
-
-def VImage_mask2vips(*args):
-  return vimagemodule.VImage_mask2vips(*args)
-VImage_mask2vips = vimagemodule.VImage_mask2vips
-
-def VImage_csv2vips(*args):
-  return vimagemodule.VImage_csv2vips(*args)
-VImage_csv2vips = vimagemodule.VImage_csv2vips
-
-def VImage_fits2vips(*args):
-  return vimagemodule.VImage_fits2vips(*args)
-VImage_fits2vips = vimagemodule.VImage_fits2vips
-
-def VImage_jpeg2vips(*args):
-  return vimagemodule.VImage_jpeg2vips(*args)
-VImage_jpeg2vips = vimagemodule.VImage_jpeg2vips
-
-def VImage_magick2vips(*args):
-  return vimagemodule.VImage_magick2vips(*args)
-VImage_magick2vips = vimagemodule.VImage_magick2vips
-
-def VImage_png2vips(*args):
-  return vimagemodule.VImage_png2vips(*args)
-VImage_png2vips = vimagemodule.VImage_png2vips
-
-def VImage_exr2vips(*args):
-  return vimagemodule.VImage_exr2vips(*args)
-VImage_exr2vips = vimagemodule.VImage_exr2vips
-
-def VImage_ppm2vips(*args):
-  return vimagemodule.VImage_ppm2vips(*args)
-VImage_ppm2vips = vimagemodule.VImage_ppm2vips
-
-def VImage_analyze2vips(*args):
-  return vimagemodule.VImage_analyze2vips(*args)
-VImage_analyze2vips = vimagemodule.VImage_analyze2vips
-
-def VImage_tiff2vips(*args):
-  return vimagemodule.VImage_tiff2vips(*args)
-VImage_tiff2vips = vimagemodule.VImage_tiff2vips
-
-def VImage_create_fmask(*args):
-  return vimagemodule.VImage_create_fmask(*args)
-VImage_create_fmask = vimagemodule.VImage_create_fmask
-
-def VImage_fractsurf(*args):
-  return vimagemodule.VImage_fractsurf(*args)
-VImage_fractsurf = vimagemodule.VImage_fractsurf
-
-def VImage_identity(*args):
-  return vimagemodule.VImage_identity(*args)
-VImage_identity = vimagemodule.VImage_identity
-
-def VImage_identity_ushort(*args):
-  return vimagemodule.VImage_identity_ushort(*args)
-VImage_identity_ushort = vimagemodule.VImage_identity_ushort
-
-def VImage_invertlut(*args):
-  return vimagemodule.VImage_invertlut(*args)
-VImage_invertlut = vimagemodule.VImage_invertlut
-
-def VImage_buildlut(*args):
-  return vimagemodule.VImage_buildlut(*args)
-VImage_buildlut = vimagemodule.VImage_buildlut
-
-def VImage_tone_build(*args):
-  return vimagemodule.VImage_tone_build(*args)
-VImage_tone_build = vimagemodule.VImage_tone_build
-
-def VImage_tone_build_range(*args):
-  return vimagemodule.VImage_tone_build_range(*args)
-VImage_tone_build_range = vimagemodule.VImage_tone_build_range
-
-def VImage_binfile(*args):
-  return vimagemodule.VImage_binfile(*args)
-VImage_binfile = vimagemodule.VImage_binfile
-
-def VImage_rank_image(*args):
-  return vimagemodule.VImage_rank_image(*args)
-VImage_rank_image = vimagemodule.VImage_rank_image
-
-def VImage_maxvalue(*args):
-  return vimagemodule.VImage_maxvalue(*args)
-VImage_maxvalue = vimagemodule.VImage_maxvalue
-
-def VImage_eye(*args):
-  return vimagemodule.VImage_eye(*args)
-VImage_eye = vimagemodule.VImage_eye
-
-def VImage_grey(*args):
-  return vimagemodule.VImage_grey(*args)
-VImage_grey = vimagemodule.VImage_grey
-
-def VImage_feye(*args):
-  return vimagemodule.VImage_feye(*args)
-VImage_feye = vimagemodule.VImage_feye
-
-def VImage_fgrey(*args):
-  return vimagemodule.VImage_fgrey(*args)
-VImage_fgrey = vimagemodule.VImage_fgrey
-
-def VImage_fzone(*args):
-  return vimagemodule.VImage_fzone(*args)
-VImage_fzone = vimagemodule.VImage_fzone
-
-def VImage_make_xy(*args):
-  return vimagemodule.VImage_make_xy(*args)
-VImage_make_xy = vimagemodule.VImage_make_xy
-
-def VImage_sines(*args):
-  return vimagemodule.VImage_sines(*args)
-VImage_sines = vimagemodule.VImage_sines
-
-def VImage_zone(*args):
-  return vimagemodule.VImage_zone(*args)
-VImage_zone = vimagemodule.VImage_zone
-
-def VImage_video_test(*args):
-  return vimagemodule.VImage_video_test(*args)
-VImage_video_test = vimagemodule.VImage_video_test
-
-def VImage_video_v4l1(*args):
-  return vimagemodule.VImage_video_v4l1(*args)
-VImage_video_v4l1 = vimagemodule.VImage_video_v4l1
-
-def VImage_frombuffer(*args):
-  return vimagemodule.VImage_frombuffer(*args)
-VImage_frombuffer = vimagemodule.VImage_frombuffer
-
-def VImage_fromstring(*args):
-  return vimagemodule.VImage_fromstring(*args)
-VImage_fromstring = vimagemodule.VImage_fromstring
-
-
-def im_init_world(*args):
-  return vimagemodule.im_init_world(*args)
-im_init_world = vimagemodule.im_init_world
-
-def im__print_all():
-  return vimagemodule.im__print_all()
-im__print_all = vimagemodule.im__print_all
-
-def im_col_Lab2XYZ(*args):
-  return vimagemodule.im_col_Lab2XYZ(*args)
-im_col_Lab2XYZ = vimagemodule.im_col_Lab2XYZ
-# try to guess a PIL mode string from a VIPS image
-def PIL_mode_from_vips (vim):
-  if vim.Bands () == 3 and vim.BandFmt () == VImage.FMTUCHAR:
-    return 'RGB'
-  elif vim.Bands () == 4 and vim.BandFmt () == VImage.FMTUCHAR and vim.Type () == VImage.RGB:
-    return 'RGBA'
-  elif vim.Bands () == 4 and vim.BandFmt () == VImage.FMTUCHAR and vim.Type () == VImage.CMYK:
-    return 'CMYK'
-  elif vim.Bands () == 1 and vim.BandFmt () == VImage.FMTUCHAR:
-    return 'L'
-  elif vim.Bands () == 1 and vim.BandFmt () == VImage.FMTINT:
-    return 'I'
-  elif vim.Bands () == 1 and vim.BandFmt () == VImage.FMTFLOAT:
-    return 'F'
-  elif vim.Bands () == 2 and vim.BandFmt () == VImage.FMTUCHAR:
-    return 'LA'
-  else:
-    raise ValueError ('unsupported vips -> pil image')
-
-# return vips (bands, format, type) for a PIL mode
-def vips_from_PIL_mode (mode):
-  if mode == 'RGB':
-    return (3, VImage.FMTUCHAR, VImage.RGB)
-  elif mode == 'RGBA':
-    return (4, VImage.FMTUCHAR, VImage.RGB)
-  elif mode == 'CMYK':
-    return (4, VImage.FMTUCHAR, VImage.CMYK)
-  elif mode == 'L':
-    return (1, VImage.FMTUCHAR, VImage.B_W)
-  elif mode == 'I':
-    return (1, VImage.FMTINT, VImage.B_W)
-  elif mode == 'F':
-    return (1, VImage.FMTFLOAT, VImage.B_W)
-  elif mode == 'LA':
-    return (2, VImage.FMTUCHAR, VImage.B_W)
-  else:
-    raise ValueError ('unsupported pil -> vips image')
-
-# This file is compatible with both classic and new-style classes.
-
-
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/VMask.i vips-7.38.5/swig/vipsCC/VMask.i
--- vips-7.38.5-vanilla/swig/vipsCC/VMask.i	2014-07-17 23:48:36.207794473 -0400
+++ vips-7.38.5/swig/vipsCC/VMask.i	1969-12-31 19:00:00.000000000 -0500
@@ -1,35 +0,0 @@
-/* SWIG interface file for VMask.
- */
-
-%module VMask
-%{
-#include <stdexcept>
-#include <vips/vipscpp.h>
-%}
-
-%import "VError.i"
-%import "VImage.i"
-
-/* Need to override assignment to get refcounting working.
- */
-%rename(__assign__) *::operator=;
-
-/* [] is array subscript, as you'd expect.
- */
-%rename(__index__) vips::VIMask::operator[];
-%rename(__index__) vips::VDMask::operator[];
-
-/* () is 2d array subscript, how odd!
- */
-%rename(__call__) vips::VIMask::operator();
-%rename(__call__) vips::VDMask::operator();
-
-/* Type conversion operators renamed as functions.
- */
-%rename(convert_VImage) vips::VIMask::operator vips::VImage;
-%rename(convert_VImage) vips::VDMask::operator vips::VImage;
-
-%rename(convert_VIMask) vips::VDMask::operator vips::VIMask;
-%rename(convert_VDMask) vips::VIMask::operator vips::VDMask;
-
-%include vips/VMask.h
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/vmaskmodule.cxx vips-7.38.5/swig/vipsCC/vmaskmodule.cxx
--- vips-7.38.5-vanilla/swig/vipsCC/vmaskmodule.cxx	2014-07-17 23:48:36.208794473 -0400
+++ vips-7.38.5/swig/vipsCC/vmaskmodule.cxx	1969-12-31 19:00:00.000000000 -0500
@@ -1,7363 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 2.0.10
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-#define SWIGPYTHON
-#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
-
-
-#ifdef __cplusplus
-/* SwigValueWrapper is described in swig.swg */
-template<typename T> class SwigValueWrapper {
-  struct SwigMovePointer {
-    T *ptr;
-    SwigMovePointer(T *p) : ptr(p) { }
-    ~SwigMovePointer() { delete ptr; }
-    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
-  } pointer;
-  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
-  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
-public:
-  SwigValueWrapper() : pointer(0) { }
-  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
-  operator T&() const { return *pointer.ptr; }
-  T *operator&() { return pointer.ptr; }
-};
-
-template <typename T> T SwigValueInit() {
-  return T();
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- *  This section contains generic SWIG labels for method/variable
- *  declarations/attributes, and other compiler dependent labels.
- * ----------------------------------------------------------------------------- */
-
-/* template workaround for compilers that cannot correctly implement the C++ standard */
-#ifndef SWIGTEMPLATEDISAMBIGUATOR
-# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# elif defined(__HP_aCC)
-/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
-/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
-#  define SWIGTEMPLATEDISAMBIGUATOR template
-# else
-#  define SWIGTEMPLATEDISAMBIGUATOR
-# endif
-#endif
-
-/* inline attribute */
-#ifndef SWIGINLINE
-# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
-#   define SWIGINLINE inline
-# else
-#   define SWIGINLINE
-# endif
-#endif
-
-/* attribute recognised by some compilers to avoid 'unused' warnings */
-#ifndef SWIGUNUSED
-# if defined(__GNUC__)
-#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
-#     define SWIGUNUSED __attribute__ ((__unused__)) 
-#   else
-#     define SWIGUNUSED
-#   endif
-# elif defined(__ICC)
-#   define SWIGUNUSED __attribute__ ((__unused__)) 
-# else
-#   define SWIGUNUSED 
-# endif
-#endif
-
-#ifndef SWIG_MSC_UNSUPPRESS_4505
-# if defined(_MSC_VER)
-#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
-# endif 
-#endif
-
-#ifndef SWIGUNUSEDPARM
-# ifdef __cplusplus
-#   define SWIGUNUSEDPARM(p)
-# else
-#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
-# endif
-#endif
-
-/* internal SWIG method */
-#ifndef SWIGINTERN
-# define SWIGINTERN static SWIGUNUSED
-#endif
-
-/* internal inline SWIG method */
-#ifndef SWIGINTERNINLINE
-# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/* exporting methods */
-#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
-#  ifndef GCC_HASCLASSVISIBILITY
-#    define GCC_HASCLASSVISIBILITY
-#  endif
-#endif
-
-#ifndef SWIGEXPORT
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   if defined(STATIC_LINKED)
-#     define SWIGEXPORT
-#   else
-#     define SWIGEXPORT __declspec(dllexport)
-#   endif
-# else
-#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
-#     define SWIGEXPORT __attribute__ ((visibility("default")))
-#   else
-#     define SWIGEXPORT
-#   endif
-# endif
-#endif
-
-/* calling conventions for Windows */
-#ifndef SWIGSTDCALL
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   define SWIGSTDCALL __stdcall
-# else
-#   define SWIGSTDCALL
-# endif 
-#endif
-
-/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
-#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
-# define _CRT_SECURE_NO_DEPRECATE
-#endif
-
-/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
-#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
-# define _SCL_SECURE_NO_DEPRECATE
-#endif
-
-
-
-/* Python.h has to appear first */
-#include <Python.h>
-
-/* -----------------------------------------------------------------------------
- * swigrun.swg
- *
- * This file contains generic C API SWIG runtime support for pointer
- * type checking.
- * ----------------------------------------------------------------------------- */
-
-/* This should only be incremented when either the layout of swig_type_info changes,
-   or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION "4"
-
-/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
-#ifdef SWIG_TYPE_TABLE
-# define SWIG_QUOTE_STRING(x) #x
-# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
-# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
-#else
-# define SWIG_TYPE_TABLE_NAME
-#endif
-
-/*
-  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
-  creating a static or dynamic library from the SWIG runtime code.
-  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
-  
-  But only do this if strictly necessary, ie, if you have problems
-  with your compiler or suchlike.
-*/
-
-#ifndef SWIGRUNTIME
-# define SWIGRUNTIME SWIGINTERN
-#endif
-
-#ifndef SWIGRUNTIMEINLINE
-# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
-#endif
-
-/*  Generic buffer size */
-#ifndef SWIG_BUFFER_SIZE
-# define SWIG_BUFFER_SIZE 1024
-#endif
-
-/* Flags for pointer conversions */
-#define SWIG_POINTER_DISOWN        0x1
-#define SWIG_CAST_NEW_MEMORY       0x2
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_OWN           0x1
-
-
-/* 
-   Flags/methods for returning states.
-   
-   The SWIG conversion methods, as ConvertPtr, return an integer 
-   that tells if the conversion was successful or not. And if not,
-   an error code can be returned (see swigerrors.swg for the codes).
-   
-   Use the following macros/flags to set or process the returning
-   states.
-   
-   In old versions of SWIG, code such as the following was usually written:
-
-     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
-       // success code
-     } else {
-       //fail code
-     }
-
-   Now you can be more explicit:
-
-    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-    } else {
-      // fail code
-    }
-
-   which is the same really, but now you can also do
-
-    Type *ptr;
-    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
-    if (SWIG_IsOK(res)) {
-      // success code
-      if (SWIG_IsNewObj(res) {
-        ...
-	delete *ptr;
-      } else {
-        ...
-      }
-    } else {
-      // fail code
-    }
-    
-   I.e., now SWIG_ConvertPtr can return new objects and you can
-   identify the case and take care of the deallocation. Of course that
-   also requires SWIG_ConvertPtr to return new result values, such as
-
-      int SWIG_ConvertPtr(obj, ptr,...) {         
-        if (<obj is ok>) {			       
-          if (<need new object>) {		       
-            *ptr = <ptr to new allocated object>; 
-            return SWIG_NEWOBJ;		       
-          } else {				       
-            *ptr = <ptr to old object>;	       
-            return SWIG_OLDOBJ;		       
-          } 				       
-        } else {				       
-          return SWIG_BADOBJ;		       
-        }					       
-      }
-
-   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
-   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
-   SWIG errors code.
-
-   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
-   allows to return the 'cast rank', for example, if you have this
-
-       int food(double)
-       int fooi(int);
-
-   and you call
- 
-      food(1)   // cast rank '1'  (1 -> 1.0)
-      fooi(1)   // cast rank '0'
-
-   just use the SWIG_AddCast()/SWIG_CheckState()
-*/
-
-#define SWIG_OK                    (0) 
-#define SWIG_ERROR                 (-1)
-#define SWIG_IsOK(r)               (r >= 0)
-#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
-
-/* The CastRankLimit says how many bits are used for the cast rank */
-#define SWIG_CASTRANKLIMIT         (1 << 8)
-/* The NewMask denotes the object was created (using new/malloc) */
-#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
-/* The TmpMask is for in/out typemaps that use temporal objects */
-#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
-/* Simple returning values */
-#define SWIG_BADOBJ                (SWIG_ERROR)
-#define SWIG_OLDOBJ                (SWIG_OK)
-#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
-#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
-/* Check, add and del mask methods */
-#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
-#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
-#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
-#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
-#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
-#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))
-
-/* Cast-Rank Mode */
-#if defined(SWIG_CASTRANK_MODE)
-#  ifndef SWIG_TypeRank
-#    define SWIG_TypeRank             unsigned long
-#  endif
-#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
-#    define SWIG_MAXCASTRANK          (2)
-#  endif
-#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
-#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
-SWIGINTERNINLINE int SWIG_AddCast(int r) { 
-  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
-}
-SWIGINTERNINLINE int SWIG_CheckState(int r) { 
-  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
-}
-#else /* no cast-rank mode */
-#  define SWIG_AddCast(r) (r)
-#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
-#endif
-
-
-#include <string.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef void *(*swig_converter_func)(void *, int *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-/* Structure to store information on one type */
-typedef struct swig_type_info {
-  const char             *name;			/* mangled name of this type */
-  const char             *str;			/* human readable name of this type */
-  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
-  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
-  void                   *clientdata;		/* language specific type data */
-  int                    owndata;		/* flag if the structure owns the clientdata */
-} swig_type_info;
-
-/* Structure to store a type and conversion function used for casting */
-typedef struct swig_cast_info {
-  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
-  swig_converter_func     converter;		/* function to cast the void pointers */
-  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
-  struct swig_cast_info  *prev;			/* pointer to the previous cast */
-} swig_cast_info;
-
-/* Structure used to store module information
- * Each module generates one structure like this, and the runtime collects
- * all of these structures and stores them in a circularly linked list.*/
-typedef struct swig_module_info {
-  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
-  size_t                 size;		        /* Number of types in this module */
-  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
-  swig_type_info         **type_initial;	/* Array of initially generated type structures */
-  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
-  void                    *clientdata;		/* Language specific module data */
-} swig_module_info;
-
-/* 
-  Compare two type names skipping the space characters, therefore
-  "char*" == "char *" and "Class<int>" == "Class<int >", etc.
-
-  Return 0 when the two name types are equivalent, as in
-  strncmp, but skipping ' '.
-*/
-SWIGRUNTIME int
-SWIG_TypeNameComp(const char *f1, const char *l1,
-		  const char *f2, const char *l2) {
-  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
-    while ((*f1 == ' ') && (f1 != l1)) ++f1;
-    while ((*f2 == ' ') && (f2 != l2)) ++f2;
-    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
-  }
-  return (int)((l1 - f1) - (l2 - f2));
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
-*/
-SWIGRUNTIME int
-SWIG_TypeCmp(const char *nb, const char *tb) {
-  int equiv = 1;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (equiv != 0 && *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-/*
-  Check type equivalence in a name list like <name1>|<name2>|...
-  Return 0 if not equal, 1 if equal
-*/
-SWIGRUNTIME int
-SWIG_TypeEquiv(const char *nb, const char *tb) {
-  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
-}
-
-/*
-  Check the typename
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheck(const char *c, swig_type_info *ty) {
-  if (ty) {
-    swig_cast_info *iter = ty->cast;
-    while (iter) {
-      if (strcmp(iter->type->name, c) == 0) {
-        if (iter == ty->cast)
-          return iter;
-        /* Move iter to the top of the linked list */
-        iter->prev->next = iter->next;
-        if (iter->next)
-          iter->next->prev = iter->prev;
-        iter->next = ty->cast;
-        iter->prev = 0;
-        if (ty->cast) ty->cast->prev = iter;
-        ty->cast = iter;
-        return iter;
-      }
-      iter = iter->next;
-    }
-  }
-  return 0;
-}
-
-/* 
-  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
-  if (ty) {
-    swig_cast_info *iter = ty->cast;
-    while (iter) {
-      if (iter->type == from) {
-        if (iter == ty->cast)
-          return iter;
-        /* Move iter to the top of the linked list */
-        iter->prev->next = iter->next;
-        if (iter->next)
-          iter->next->prev = iter->prev;
-        iter->next = ty->cast;
-        iter->prev = 0;
-        if (ty->cast) ty->cast->prev = iter;
-        ty->cast = iter;
-        return iter;
-      }
-      iter = iter->next;
-    }
-  }
-  return 0;
-}
-
-/*
-  Cast a pointer up an inheritance hierarchy
-*/
-SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
-  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
-}
-
-/* 
-   Dynamic pointer casting. Down an inheritance hierarchy
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty->dcast) return ty;
-  while (ty && (ty->dcast)) {
-    ty = (*ty->dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/*
-  Return the name associated with this type
-*/
-SWIGRUNTIMEINLINE const char *
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty->name;
-}
-
-/*
-  Return the pretty name associated with this type,
-  that is an unmangled type name in a form presentable to the user.
-*/
-SWIGRUNTIME const char *
-SWIG_TypePrettyName(const swig_type_info *type) {
-  /* The "str" field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
-  if (!type) return NULL;
-  if (type->str != NULL) {
-    const char *last_name = type->str;
-    const char *s;
-    for (s = type->str; *s; s++)
-      if (*s == '|') last_name = s+1;
-    return last_name;
-  }
-  else
-    return type->name;
-}
-
-/* 
-   Set the clientdata field for a type
-*/
-SWIGRUNTIME void
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  swig_cast_info *cast = ti->cast;
-  /* if (ti->clientdata == clientdata) return; */
-  ti->clientdata = clientdata;
-  
-  while (cast) {
-    if (!cast->converter) {
-      swig_type_info *tc = cast->type;
-      if (!tc->clientdata) {
-	SWIG_TypeClientData(tc, clientdata);
-      }
-    }    
-    cast = cast->next;
-  }
-}
-SWIGRUNTIME void
-SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
-  SWIG_TypeClientData(ti, clientdata);
-  ti->owndata = 1;
-}
-  
-/*
-  Search for a swig_type_info structure only by mangled name
-  Search is a O(log #types)
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_MangledTypeQueryModule(swig_module_info *start, 
-                            swig_module_info *end, 
-		            const char *name) {
-  swig_module_info *iter = start;
-  do {
-    if (iter->size) {
-      register size_t l = 0;
-      register size_t r = iter->size - 1;
-      do {
-	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
-	register size_t i = (l + r) >> 1; 
-	const char *iname = iter->types[i]->name;
-	if (iname) {
-	  register int compare = strcmp(name, iname);
-	  if (compare == 0) {	    
-	    return iter->types[i];
-	  } else if (compare < 0) {
-	    if (i) {
-	      r = i - 1;
-	    } else {
-	      break;
-	    }
-	  } else if (compare > 0) {
-	    l = i + 1;
-	  }
-	} else {
-	  break; /* should never happen */
-	}
-      } while (l <= r);
-    }
-    iter = iter->next;
-  } while (iter != end);
-  return 0;
-}
-
-/*
-  Search for a swig_type_info structure for either a mangled name or a human readable name.
-  It first searches the mangled names of the types, which is a O(log #types)
-  If a type is not found it then searches the human readable names, which is O(#types).
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeQueryModule(swig_module_info *start, 
-                     swig_module_info *end, 
-		     const char *name) {
-  /* STEP 1: Search the name field using binary search */
-  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
-  if (ret) {
-    return ret;
-  } else {
-    /* STEP 2: If the type hasn't been found, do a complete search
-       of the str field (the human readable name) */
-    swig_module_info *iter = start;
-    do {
-      register size_t i = 0;
-      for (; i < iter->size; ++i) {
-	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
-	  return iter->types[i];
-      }
-      iter = iter->next;
-    } while (iter != end);
-  }
-  
-  /* neither found a match */
-  return 0;
-}
-
-/* 
-   Pack binary data into a string
-*/
-SWIGRUNTIME char *
-SWIG_PackData(char *c, void *ptr, size_t sz) {
-  static const char hex[17] = "0123456789abcdef";
-  register const unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu =  u + sz;
-  for (; u != eu; ++u) {
-    register unsigned char uu = *u;
-    *(c++) = hex[(uu & 0xf0) >> 4];
-    *(c++) = hex[uu & 0xf];
-  }
-  return c;
-}
-
-/* 
-   Unpack binary data from a string
-*/
-SWIGRUNTIME const char *
-SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
-  register unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu = u + sz;
-  for (; u != eu; ++u) {
-    register char d = *(c++);
-    register unsigned char uu;
-    if ((d >= '0') && (d <= '9'))
-      uu = ((d - '0') << 4);
-    else if ((d >= 'a') && (d <= 'f'))
-      uu = ((d - ('a'-10)) << 4);
-    else 
-      return (char *) 0;
-    d = *(c++);
-    if ((d >= '0') && (d <= '9'))
-      uu |= (d - '0');
-    else if ((d >= 'a') && (d <= 'f'))
-      uu |= (d - ('a'-10));
-    else 
-      return (char *) 0;
-    *u = uu;
-  }
-  return c;
-}
-
-/* 
-   Pack 'void *' into a string buffer.
-*/
-SWIGRUNTIME char *
-SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
-  char *r = buff;
-  if ((2*sizeof(void *) + 2) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,&ptr,sizeof(void *));
-  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
-  strcpy(r,name);
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      *ptr = (void *) 0;
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sizeof(void *));
-}
-
-SWIGRUNTIME char *
-SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
-  char *r = buff;
-  size_t lname = (name ? strlen(name) : 0);
-  if ((2*sz + 2 + lname) > bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  if (lname) {
-    strncpy(r,name,lname+1);
-  } else {
-    *r = 0;
-  }
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,"NULL") == 0) {
-      memset(ptr,0,sz);
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sz);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-/*  Errors in SWIG */
-#define  SWIG_UnknownError    	   -1 
-#define  SWIG_IOError        	   -2 
-#define  SWIG_RuntimeError   	   -3 
-#define  SWIG_IndexError     	   -4 
-#define  SWIG_TypeError      	   -5 
-#define  SWIG_DivisionByZero 	   -6 
-#define  SWIG_OverflowError  	   -7 
-#define  SWIG_SyntaxError    	   -8 
-#define  SWIG_ValueError     	   -9 
-#define  SWIG_SystemError    	   -10
-#define  SWIG_AttributeError 	   -11
-#define  SWIG_MemoryError    	   -12 
-#define  SWIG_NullReferenceError   -13
-
-
-
-/* Compatibility macros for Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-
-#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
-#define PyInt_Check(x) PyLong_Check(x)
-#define PyInt_AsLong(x) PyLong_AsLong(x)
-#define PyInt_FromLong(x) PyLong_FromLong(x)
-#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
-#define PyString_Check(name) PyBytes_Check(name)
-#define PyString_FromString(x) PyUnicode_FromString(x)
-#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
-#define PyString_AsString(str) PyBytes_AsString(str)
-#define PyString_Size(str) PyBytes_Size(str)	
-#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
-#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
-#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
-#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)
-
-#endif
-
-#ifndef Py_TYPE
-#  define Py_TYPE(op) ((op)->ob_type)
-#endif
-
-/* SWIG APIs for compatibility of both Python 2 & 3 */
-
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
-#else
-#  define SWIG_Python_str_FromFormat PyString_FromFormat
-#endif
-
-
-/* Warning: This function will allocate a new string in Python 3,
- * so please call SWIG_Python_str_DelForPy3(x) to free the space.
- */
-SWIGINTERN char*
-SWIG_Python_str_AsChar(PyObject *str)
-{
-#if PY_VERSION_HEX >= 0x03000000
-  char *cstr;
-  char *newstr;
-  Py_ssize_t len;
-  str = PyUnicode_AsUTF8String(str);
-  PyBytes_AsStringAndSize(str, &cstr, &len);
-  newstr = (char *) malloc(len+1);
-  memcpy(newstr, cstr, len+1);
-  Py_XDECREF(str);
-  return newstr;
-#else
-  return PyString_AsString(str);
-#endif
-}
-
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
-#else
-#  define SWIG_Python_str_DelForPy3(x) 
-#endif
-
-
-SWIGINTERN PyObject*
-SWIG_Python_str_FromChar(const char *c)
-{
-#if PY_VERSION_HEX >= 0x03000000
-  return PyUnicode_FromString(c); 
-#else
-  return PyString_FromString(c);
-#endif
-}
-
-/* Add PyOS_snprintf for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
-#  define PyOS_snprintf _snprintf
-# else
-#  define PyOS_snprintf snprintf
-# endif
-#endif
-
-/* A crude PyString_FromFormat implementation for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-
-#ifndef SWIG_PYBUFFER_SIZE
-# define SWIG_PYBUFFER_SIZE 1024
-#endif
-
-static PyObject *
-PyString_FromFormat(const char *fmt, ...) {
-  va_list ap;
-  char buf[SWIG_PYBUFFER_SIZE * 2];
-  int res;
-  va_start(ap, fmt);
-  res = vsnprintf(buf, sizeof(buf), fmt, ap);
-  va_end(ap);
-  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
-}
-#endif
-
-/* Add PyObject_Del for old Pythons */
-#if PY_VERSION_HEX < 0x01060000
-# define PyObject_Del(op) PyMem_DEL((op))
-#endif
-#ifndef PyObject_DEL
-# define PyObject_DEL PyObject_Del
-#endif
-
-/* A crude PyExc_StopIteration exception for old Pythons */
-#if PY_VERSION_HEX < 0x02020000
-# ifndef PyExc_StopIteration
-#  define PyExc_StopIteration PyExc_RuntimeError
-# endif
-# ifndef PyObject_GenericGetAttr
-#  define PyObject_GenericGetAttr 0
-# endif
-#endif
-
-/* Py_NotImplemented is defined in 2.1 and up. */
-#if PY_VERSION_HEX < 0x02010000
-# ifndef Py_NotImplemented
-#  define Py_NotImplemented PyExc_RuntimeError
-# endif
-#endif
-
-/* A crude PyString_AsStringAndSize implementation for old Pythons */
-#if PY_VERSION_HEX < 0x02010000
-# ifndef PyString_AsStringAndSize
-#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
-# endif
-#endif
-
-/* PySequence_Size for old Pythons */
-#if PY_VERSION_HEX < 0x02000000
-# ifndef PySequence_Size
-#  define PySequence_Size PySequence_Length
-# endif
-#endif
-
-/* PyBool_FromLong for old Pythons */
-#if PY_VERSION_HEX < 0x02030000
-static
-PyObject *PyBool_FromLong(long ok)
-{
-  PyObject *result = ok ? Py_True : Py_False;
-  Py_INCREF(result);
-  return result;
-}
-#endif
-
-/* Py_ssize_t for old Pythons */
-/* This code is as recommended by: */
-/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
-#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
-typedef int Py_ssize_t;
-# define PY_SSIZE_T_MAX INT_MAX
-# define PY_SSIZE_T_MIN INT_MIN
-typedef inquiry lenfunc;
-typedef intargfunc ssizeargfunc;
-typedef intintargfunc ssizessizeargfunc;
-typedef intobjargproc ssizeobjargproc;
-typedef intintobjargproc ssizessizeobjargproc;
-typedef getreadbufferproc readbufferproc;
-typedef getwritebufferproc writebufferproc;
-typedef getsegcountproc segcountproc;
-typedef getcharbufferproc charbufferproc;
-static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
-{
-  long result = 0;
-  PyObject *i = PyNumber_Int(x);
-  if (i) {
-    result = PyInt_AsLong(i);
-    Py_DECREF(i);
-  }
-  return result;
-}
-#endif
-
-#if PY_VERSION_HEX < 0x02050000
-#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
-#endif
-
-#if PY_VERSION_HEX < 0x02040000
-#define Py_VISIT(op)				\
-  do { 						\
-    if (op) {					\
-      int vret = visit((op), arg);		\
-      if (vret)					\
-        return vret;				\
-    }						\
-  } while (0)
-#endif
-
-#if PY_VERSION_HEX < 0x02030000
-typedef struct {
-  PyTypeObject type;
-  PyNumberMethods as_number;
-  PyMappingMethods as_mapping;
-  PySequenceMethods as_sequence;
-  PyBufferProcs as_buffer;
-  PyObject *name, *slots;
-} PyHeapTypeObject;
-#endif
-
-#if PY_VERSION_HEX < 0x02030000
-typedef destructor freefunc;
-#endif
-
-#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
-     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
-     (PY_MAJOR_VERSION > 3))
-# define SWIGPY_USE_CAPSULE
-# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
-#endif
-
-#if PY_VERSION_HEX < 0x03020000
-#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
-#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
-#endif
-
-/* -----------------------------------------------------------------------------
- * error manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIME PyObject*
-SWIG_Python_ErrorType(int code) {
-  PyObject* type = 0;
-  switch(code) {
-  case SWIG_MemoryError:
-    type = PyExc_MemoryError;
-    break;
-  case SWIG_IOError:
-    type = PyExc_IOError;
-    break;
-  case SWIG_RuntimeError:
-    type = PyExc_RuntimeError;
-    break;
-  case SWIG_IndexError:
-    type = PyExc_IndexError;
-    break;
-  case SWIG_TypeError:
-    type = PyExc_TypeError;
-    break;
-  case SWIG_DivisionByZero:
-    type = PyExc_ZeroDivisionError;
-    break;
-  case SWIG_OverflowError:
-    type = PyExc_OverflowError;
-    break;
-  case SWIG_SyntaxError:
-    type = PyExc_SyntaxError;
-    break;
-  case SWIG_ValueError:
-    type = PyExc_ValueError;
-    break;
-  case SWIG_SystemError:
-    type = PyExc_SystemError;
-    break;
-  case SWIG_AttributeError:
-    type = PyExc_AttributeError;
-    break;
-  default:
-    type = PyExc_RuntimeError;
-  }
-  return type;
-}
-
-
-SWIGRUNTIME void
-SWIG_Python_AddErrorMsg(const char* mesg)
-{
-  PyObject *type = 0;
-  PyObject *value = 0;
-  PyObject *traceback = 0;
-
-  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
-  if (value) {
-    char *tmp;
-    PyObject *old_str = PyObject_Str(value);
-    PyErr_Clear();
-    Py_XINCREF(type);
-
-    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
-    SWIG_Python_str_DelForPy3(tmp);
-    Py_DECREF(old_str);
-    Py_DECREF(value);
-  } else {
-    PyErr_SetString(PyExc_RuntimeError, mesg);
-  }
-}
-
-#if defined(SWIG_PYTHON_NO_THREADS)
-#  if defined(SWIG_PYTHON_THREADS)
-#    undef SWIG_PYTHON_THREADS
-#  endif
-#endif
-#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
-#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
-#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
-#      define SWIG_PYTHON_USE_GIL
-#    endif
-#  endif
-#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
-#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
-#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
-#    endif
-#    ifdef __cplusplus /* C++ code */
-       class SWIG_Python_Thread_Block {
-         bool status;
-         PyGILState_STATE state;
-       public:
-         void end() { if (status) { PyGILState_Release(state); status = false;} }
-         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
-         ~SWIG_Python_Thread_Block() { end(); }
-       };
-       class SWIG_Python_Thread_Allow {
-         bool status;
-         PyThreadState *save;
-       public:
-         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
-         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
-         ~SWIG_Python_Thread_Allow() { end(); }
-       };
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
-#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
-#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
-#    else /* C code */
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
-#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
-#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
-#    endif
-#  else /* Old thread way, not implemented, user must provide it */
-#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
-#      define SWIG_PYTHON_INITIALIZE_THREADS
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
-#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
-#      define SWIG_PYTHON_THREAD_END_BLOCK
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
-#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
-#    endif
-#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
-#      define SWIG_PYTHON_THREAD_END_ALLOW
-#    endif
-#  endif
-#else /* No thread support */
-#  define SWIG_PYTHON_INITIALIZE_THREADS
-#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
-#  define SWIG_PYTHON_THREAD_END_BLOCK
-#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
-#  define SWIG_PYTHON_THREAD_END_ALLOW
-#endif
-
-/* -----------------------------------------------------------------------------
- * Python API portion that goes into the runtime
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* -----------------------------------------------------------------------------
- * Constant declarations
- * ----------------------------------------------------------------------------- */
-
-/* Constant Types */
-#define SWIG_PY_POINTER 4
-#define SWIG_PY_BINARY  5
-
-/* Constant information structure */
-typedef struct swig_const_info {
-  int type;
-  char *name;
-  long lvalue;
-  double dvalue;
-  void   *pvalue;
-  swig_type_info **ptype;
-} swig_const_info;
-
-
-/* -----------------------------------------------------------------------------
- * Wrapper of PyInstanceMethod_New() used in Python 3
- * It is exported to the generated module, used for -fastproxy
- * ----------------------------------------------------------------------------- */
-#if PY_VERSION_HEX >= 0x03000000
-SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
-{
-  return PyInstanceMethod_New(func);
-}
-#else
-SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
-{
-  return NULL;
-}
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/* -----------------------------------------------------------------------------
- * pyrun.swg
- *
- * This file contains the runtime support for Python modules
- * and includes code for managing global variables and pointer
- * type checking.
- *
- * ----------------------------------------------------------------------------- */
-
-/* Common SWIG API */
-
-/* for raw pointers */
-#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
-#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
-#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
-
-#ifdef SWIGPYTHON_BUILTIN
-#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
-#else
-#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
-#endif
-
-#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
-
-#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
-#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
-#define swig_owntype                                    int
-
-/* for raw packed data */
-#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
-#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
-
-/* for class or struct pointers */
-#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
-#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
-
-/* for C or C++ function pointers */
-#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
-#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)
-
-/* for C++ member pointers, ie, member methods */
-#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
-#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
-
-
-/* Runtime API */
-
-#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
-#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
-#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)
-
-#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
-#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
-#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
-#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
-#define SWIG_fail                        		goto fail					   
-
-
-/* Runtime API implementation */
-
-/* Error manipulation */
-
-SWIGINTERN void 
-SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
-  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
-  PyErr_SetObject(errtype, obj);
-  Py_DECREF(obj);
-  SWIG_PYTHON_THREAD_END_BLOCK;
-}
-
-SWIGINTERN void 
-SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
-  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
-  PyErr_SetString(errtype, msg);
-  SWIG_PYTHON_THREAD_END_BLOCK;
-}
-
-#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)
-
-/* Set a constant value */
-
-#if defined(SWIGPYTHON_BUILTIN)
-
-SWIGINTERN void
-SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
-  PyObject *s = PyString_InternFromString(key);
-  PyList_Append(seq, s);
-  Py_DECREF(s);
-}
-
-SWIGINTERN void
-SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
-#if PY_VERSION_HEX < 0x02030000
-  PyDict_SetItemString(d, (char *)name, obj);
-#else
-  PyDict_SetItemString(d, name, obj);
-#endif
-  Py_DECREF(obj);
-  if (public_interface)
-    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
-}
-
-#else
-
-SWIGINTERN void
-SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
-#if PY_VERSION_HEX < 0x02030000
-  PyDict_SetItemString(d, (char *)name, obj);
-#else
-  PyDict_SetItemString(d, name, obj);
-#endif
-  Py_DECREF(obj);                            
-}
-
-#endif
-
-/* Append a value to the result obj */
-
-SWIGINTERN PyObject*
-SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
-#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
-  if (!result) {
-    result = obj;
-  } else if (result == Py_None) {
-    Py_DECREF(result);
-    result = obj;
-  } else {
-    if (!PyList_Check(result)) {
-      PyObject *o2 = result;
-      result = PyList_New(1);
-      PyList_SetItem(result, 0, o2);
-    }
-    PyList_Append(result,obj);
-    Py_DECREF(obj);
-  }
-  return result;
-#else
-  PyObject*   o2;
-  PyObject*   o3;
-  if (!result) {
-    result = obj;
-  } else if (result == Py_None) {
-    Py_DECREF(result);
-    result = obj;
-  } else {
-    if (!PyTuple_Check(result)) {
-      o2 = result;
-      result = PyTuple_New(1);
-      PyTuple_SET_ITEM(result, 0, o2);
-    }
-    o3 = PyTuple_New(1);
-    PyTuple_SET_ITEM(o3, 0, obj);
-    o2 = result;
-    result = PySequence_Concat(o2, o3);
-    Py_DECREF(o2);
-    Py_DECREF(o3);
-  }
-  return result;
-#endif
-}
-
-/* Unpack the argument tuple */
-
-SWIGINTERN int
-SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
-{
-  if (!args) {
-    if (!min && !max) {
-      return 1;
-    } else {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
-		   name, (min == max ? "" : "at least "), (int)min);
-      return 0;
-    }
-  }  
-  if (!PyTuple_Check(args)) {
-    if (min <= 1 && max >= 1) {
-      register int i;
-      objs[0] = args;
-      for (i = 1; i < max; ++i) {
-	objs[i] = 0;
-      }
-      return 2;
-    }
-    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
-    return 0;
-  } else {
-    register Py_ssize_t l = PyTuple_GET_SIZE(args);
-    if (l < min) {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at least "), (int)min, (int)l);
-      return 0;
-    } else if (l > max) {
-      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
-		   name, (min == max ? "" : "at most "), (int)max, (int)l);
-      return 0;
-    } else {
-      register int i;
-      for (i = 0; i < l; ++i) {
-	objs[i] = PyTuple_GET_ITEM(args, i);
-      }
-      for (; l < max; ++l) {
-	objs[l] = 0;
-      }
-      return i + 1;
-    }    
-  }
-}
-
-/* A functor is a function object with one single object argument */
-#if PY_VERSION_HEX >= 0x02020000
-#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
-#else
-#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
-#endif
-
-/*
-  Helper for static pointer initialization for both C and C++ code, for example
-  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
-*/
-#ifdef __cplusplus
-#define SWIG_STATIC_POINTER(var)  var
-#else
-#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
-#endif
-
-/* -----------------------------------------------------------------------------
- * Pointer declarations
- * ----------------------------------------------------------------------------- */
-
-/* Flags for new pointer objects */
-#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
-#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
-
-#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)
-
-#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
-#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*  How to access Py_None */
-#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#  ifndef SWIG_PYTHON_NO_BUILD_NONE
-#    ifndef SWIG_PYTHON_BUILD_NONE
-#      define SWIG_PYTHON_BUILD_NONE
-#    endif
-#  endif
-#endif
-
-#ifdef SWIG_PYTHON_BUILD_NONE
-#  ifdef Py_None
-#   undef Py_None
-#   define Py_None SWIG_Py_None()
-#  endif
-SWIGRUNTIMEINLINE PyObject * 
-_SWIG_Py_None(void)
-{
-  PyObject *none = Py_BuildValue((char*)"");
-  Py_DECREF(none);
-  return none;
-}
-SWIGRUNTIME PyObject * 
-SWIG_Py_None(void)
-{
-  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
-  return none;
-}
-#endif
-
-/* The python void return value */
-
-SWIGRUNTIMEINLINE PyObject * 
-SWIG_Py_Void(void)
-{
-  PyObject *none = Py_None;
-  Py_INCREF(none);
-  return none;
-}
-
-/* SwigPyClientData */
-
-typedef struct {
-  PyObject *klass;
-  PyObject *newraw;
-  PyObject *newargs;
-  PyObject *destroy;
-  int delargs;
-  int implicitconv;
-  PyTypeObject *pytype;
-} SwigPyClientData;
-
-SWIGRUNTIMEINLINE int 
-SWIG_Python_CheckImplicit(swig_type_info *ty)
-{
-  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
-  return data ? data->implicitconv : 0;
-}
-
-SWIGRUNTIMEINLINE PyObject *
-SWIG_Python_ExceptionType(swig_type_info *desc) {
-  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
-  PyObject *klass = data ? data->klass : 0;
-  return (klass ? klass : PyExc_RuntimeError);
-}
-
-
-SWIGRUNTIME SwigPyClientData * 
-SwigPyClientData_New(PyObject* obj)
-{
-  if (!obj) {
-    return 0;
-  } else {
-    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
-    /* the klass element */
-    data->klass = obj;
-    Py_INCREF(data->klass);
-    /* the newraw method and newargs arguments used to create a new raw instance */
-    if (PyClass_Check(obj)) {
-      data->newraw = 0;
-      data->newargs = obj;
-      Py_INCREF(obj);
-    } else {
-#if (PY_VERSION_HEX < 0x02020000)
-      data->newraw = 0;
-#else
-      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
-#endif
-      if (data->newraw) {
-	Py_INCREF(data->newraw);
-	data->newargs = PyTuple_New(1);
-	PyTuple_SetItem(data->newargs, 0, obj);
-      } else {
-	data->newargs = obj;
-      }
-      Py_INCREF(data->newargs);
-    }
-    /* the destroy method, aka as the C++ delete method */
-    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      data->destroy = 0;
-    }
-    if (data->destroy) {
-      int flags;
-      Py_INCREF(data->destroy);
-      flags = PyCFunction_GET_FLAGS(data->destroy);
-#ifdef METH_O
-      data->delargs = !(flags & (METH_O));
-#else
-      data->delargs = 0;
-#endif
-    } else {
-      data->delargs = 0;
-    }
-    data->implicitconv = 0;
-    data->pytype = 0;
-    return data;
-  }
-}
-
-SWIGRUNTIME void 
-SwigPyClientData_Del(SwigPyClientData *data) {
-  Py_XDECREF(data->newraw);
-  Py_XDECREF(data->newargs);
-  Py_XDECREF(data->destroy);
-}
-
-/* =============== SwigPyObject =====================*/
-
-typedef struct {
-  PyObject_HEAD
-  void *ptr;
-  swig_type_info *ty;
-  int own;
-  PyObject *next;
-#ifdef SWIGPYTHON_BUILTIN
-  PyObject *dict;
-#endif
-} SwigPyObject;
-
-SWIGRUNTIME PyObject *
-SwigPyObject_long(SwigPyObject *v)
-{
-  return PyLong_FromVoidPtr(v->ptr);
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_format(const char* fmt, SwigPyObject *v)
-{
-  PyObject *res = NULL;
-  PyObject *args = PyTuple_New(1);
-  if (args) {
-    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
-      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
-      if (ofmt) {
-#if PY_VERSION_HEX >= 0x03000000
-	res = PyUnicode_Format(ofmt,args);
-#else
-	res = PyString_Format(ofmt,args);
-#endif
-	Py_DECREF(ofmt);
-      }
-      Py_DECREF(args);
-    }
-  }
-  return res;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_oct(SwigPyObject *v)
-{
-  return SwigPyObject_format("%o",v);
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_hex(SwigPyObject *v)
-{
-  return SwigPyObject_format("%x",v);
-}
-
-SWIGRUNTIME PyObject *
-#ifdef METH_NOARGS
-SwigPyObject_repr(SwigPyObject *v)
-#else
-SwigPyObject_repr(SwigPyObject *v, PyObject *args)
-#endif
-{
-  const char *name = SWIG_TypePrettyName(v->ty);
-  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
-  if (v->next) {
-# ifdef METH_NOARGS
-    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
-# else
-    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
-# endif
-# if PY_VERSION_HEX >= 0x03000000
-    PyObject *joined = PyUnicode_Concat(repr, nrep);
-    Py_DecRef(repr);
-    Py_DecRef(nrep);
-    repr = joined;
-# else
-    PyString_ConcatAndDel(&repr,nrep);
-# endif
-  }
-  return repr;  
-}
-
-SWIGRUNTIME int
-SwigPyObject_print(SwigPyObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))
-{
-  char *str;
-#ifdef METH_NOARGS
-  PyObject *repr = SwigPyObject_repr(v);
-#else
-  PyObject *repr = SwigPyObject_repr(v, NULL);
-#endif
-  if (repr) {
-    str = SWIG_Python_str_AsChar(repr); 
-    fputs(str, fp);
-    SWIG_Python_str_DelForPy3(str);
-    Py_DECREF(repr);
-    return 0; 
-  } else {
-    return 1; 
-  }
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_str(SwigPyObject *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  return SWIG_PackVoidPtr(result, v->ptr, v->ty->name, sizeof(result)) ?
-    SWIG_Python_str_FromChar(result) : 0;
-}
-
-SWIGRUNTIME int
-SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
-{
-  void *i = v->ptr;
-  void *j = w->ptr;
-  return (i < j) ? -1 : ((i > j) ? 1 : 0);
-}
-
-/* Added for Python 3.x, would it also be useful for Python 2.x? */
-SWIGRUNTIME PyObject*
-SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
-{
-  PyObject* res;
-  if( op != Py_EQ && op != Py_NE ) {
-    Py_INCREF(Py_NotImplemented);
-    return Py_NotImplemented;
-  }
-  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
-  return res;  
-}
-
-
-SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);
-
-#ifdef SWIGPYTHON_BUILTIN
-static swig_type_info *SwigPyObject_stype = 0;
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_type(void) {
-    SwigPyClientData *cd;
-    assert(SwigPyObject_stype);
-    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
-    assert(cd);
-    assert(cd->pytype);
-    return cd->pytype;
-}
-#else
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_type(void) {
-  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
-  return type;
-}
-#endif
-
-SWIGRUNTIMEINLINE int
-SwigPyObject_Check(PyObject *op) {
-#ifdef SWIGPYTHON_BUILTIN
-  PyTypeObject *target_tp = SwigPyObject_type();
-  if (PyType_IsSubtype(op->ob_type, target_tp))
-    return 1;
-  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
-#else
-  return (Py_TYPE(op) == SwigPyObject_type())
-    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
-#endif
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_New(void *ptr, swig_type_info *ty, int own);
-
-SWIGRUNTIME void
-SwigPyObject_dealloc(PyObject *v)
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-  PyObject *next = sobj->next;
-  if (sobj->own == SWIG_POINTER_OWN) {
-    swig_type_info *ty = sobj->ty;
-    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
-    PyObject *destroy = data ? data->destroy : 0;
-    if (destroy) {
-      /* destroy is always a VARARGS method */
-      PyObject *res;
-      if (data->delargs) {
-	/* we need to create a temporary object to carry the destroy operation */
-	PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
-	res = SWIG_Python_CallFunctor(destroy, tmp);
-	Py_DECREF(tmp);
-      } else {
-	PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
-	PyObject *mself = PyCFunction_GET_SELF(destroy);
-	res = ((*meth)(mself, v));
-      }
-      Py_XDECREF(res);
-    } 
-#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
-    else {
-      const char *name = SWIG_TypePrettyName(ty);
-      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
-    }
-#endif
-  } 
-  Py_XDECREF(next);
-  PyObject_DEL(v);
-}
-
-SWIGRUNTIME PyObject* 
-SwigPyObject_append(PyObject* v, PyObject* next)
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-#ifndef METH_O
-  PyObject *tmp = 0;
-  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
-  next = tmp;
-#endif
-  if (!SwigPyObject_Check(next)) {
-    return NULL;
-  }
-  sobj->next = next;
-  Py_INCREF(next);
-  return SWIG_Py_Void();
-}
-
-SWIGRUNTIME PyObject* 
-#ifdef METH_NOARGS
-SwigPyObject_next(PyObject* v)
-#else
-SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *) v;
-  if (sobj->next) {    
-    Py_INCREF(sobj->next);
-    return sobj->next;
-  } else {
-    return SWIG_Py_Void();
-  }
-}
-
-SWIGINTERN PyObject*
-#ifdef METH_NOARGS
-SwigPyObject_disown(PyObject *v)
-#else
-SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *)v;
-  sobj->own = 0;
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject*
-#ifdef METH_NOARGS
-SwigPyObject_acquire(PyObject *v)
-#else
-SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
-#endif
-{
-  SwigPyObject *sobj = (SwigPyObject *)v;
-  sobj->own = SWIG_POINTER_OWN;
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject*
-SwigPyObject_own(PyObject *v, PyObject *args)
-{
-  PyObject *val = 0;
-#if (PY_VERSION_HEX < 0x02020000)
-  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
-#elif (PY_VERSION_HEX < 0x02050000)
-  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
-#else
-  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
-#endif
-    {
-      return NULL;
-    } 
-  else
-    {
-      SwigPyObject *sobj = (SwigPyObject *)v;
-      PyObject *obj = PyBool_FromLong(sobj->own);
-      if (val) {
-#ifdef METH_NOARGS
-	if (PyObject_IsTrue(val)) {
-	  SwigPyObject_acquire(v);
-	} else {
-	  SwigPyObject_disown(v);
-	}
-#else
-	if (PyObject_IsTrue(val)) {
-	  SwigPyObject_acquire(v,args);
-	} else {
-	  SwigPyObject_disown(v,args);
-	}
-#endif
-      } 
-      return obj;
-    }
-}
-
-#ifdef METH_O
-static PyMethodDef
-swigobject_methods[] = {
-  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
-  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
-  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
-  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
-  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
-  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
-  {0, 0, 0, 0}  
-};
-#else
-static PyMethodDef
-swigobject_methods[] = {
-  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
-  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"aquires ownership of the pointer"},
-  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
-  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
-  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
-  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
-  {0, 0, 0, 0}  
-};
-#endif
-
-#if PY_VERSION_HEX < 0x02020000
-SWIGINTERN PyObject *
-SwigPyObject_getattr(SwigPyObject *sobj,char *name)
-{
-  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
-}
-#endif
-
-SWIGRUNTIME PyTypeObject*
-SwigPyObject_TypeOnce(void) {
-  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";
-
-  static PyNumberMethods SwigPyObject_as_number = {
-    (binaryfunc)0, /*nb_add*/
-    (binaryfunc)0, /*nb_subtract*/
-    (binaryfunc)0, /*nb_multiply*/
-    /* nb_divide removed in Python 3 */
-#if PY_VERSION_HEX < 0x03000000
-    (binaryfunc)0, /*nb_divide*/
-#endif
-    (binaryfunc)0, /*nb_remainder*/
-    (binaryfunc)0, /*nb_divmod*/
-    (ternaryfunc)0,/*nb_power*/
-    (unaryfunc)0,  /*nb_negative*/
-    (unaryfunc)0,  /*nb_positive*/
-    (unaryfunc)0,  /*nb_absolute*/
-    (inquiry)0,    /*nb_nonzero*/
-    0,		   /*nb_invert*/
-    0,		   /*nb_lshift*/
-    0,		   /*nb_rshift*/
-    0,		   /*nb_and*/
-    0,		   /*nb_xor*/
-    0,		   /*nb_or*/
-#if PY_VERSION_HEX < 0x03000000
-    0,   /*nb_coerce*/
-#endif
-    (unaryfunc)SwigPyObject_long, /*nb_int*/
-#if PY_VERSION_HEX < 0x03000000
-    (unaryfunc)SwigPyObject_long, /*nb_long*/
-#else
-    0, /*nb_reserved*/
-#endif
-    (unaryfunc)0,                 /*nb_float*/
-#if PY_VERSION_HEX < 0x03000000
-    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
-    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
-#endif
-#if PY_VERSION_HEX >= 0x03000000 /* 3.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
-#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
-#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
-#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
-    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
-#endif
-  };
-
-  static PyTypeObject swigpyobject_type;
-  static int type_init = 0;
-  if (!type_init) {
-    const PyTypeObject tmp = {
-      /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-      PyVarObject_HEAD_INIT(NULL, 0)
-#else
-      PyObject_HEAD_INIT(NULL)
-      0,                                    /* ob_size */
-#endif
-      (char *)"SwigPyObject",               /* tp_name */
-      sizeof(SwigPyObject),                 /* tp_basicsize */
-      0,                                    /* tp_itemsize */
-      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
-      (printfunc)SwigPyObject_print,        /* tp_print */
-#if PY_VERSION_HEX < 0x02020000
-      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
-#else
-      (getattrfunc)0,                       /* tp_getattr */
-#endif
-      (setattrfunc)0,                       /* tp_setattr */
-#if PY_VERSION_HEX >= 0x03000000
-    0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
-#else
-      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
-#endif
-      (reprfunc)SwigPyObject_repr,          /* tp_repr */
-      &SwigPyObject_as_number,              /* tp_as_number */
-      0,                                    /* tp_as_sequence */
-      0,                                    /* tp_as_mapping */
-      (hashfunc)0,                          /* tp_hash */
-      (ternaryfunc)0,                       /* tp_call */
-      (reprfunc)SwigPyObject_str,           /* tp_str */
-      PyObject_GenericGetAttr,              /* tp_getattro */
-      0,                                    /* tp_setattro */
-      0,                                    /* tp_as_buffer */
-      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
-      swigobject_doc,                       /* tp_doc */
-      0,                                    /* tp_traverse */
-      0,                                    /* tp_clear */
-      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
-      0,                                    /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-      0,                                    /* tp_iter */
-      0,                                    /* tp_iternext */
-      swigobject_methods,                   /* tp_methods */
-      0,                                    /* tp_members */
-      0,                                    /* tp_getset */
-      0,                                    /* tp_base */
-      0,                                    /* tp_dict */
-      0,                                    /* tp_descr_get */
-      0,                                    /* tp_descr_set */
-      0,                                    /* tp_dictoffset */
-      0,                                    /* tp_init */
-      0,                                    /* tp_alloc */
-      0,                                    /* tp_new */
-      0,                                    /* tp_free */
-      0,                                    /* tp_is_gc */
-      0,                                    /* tp_bases */
-      0,                                    /* tp_mro */
-      0,                                    /* tp_cache */
-      0,                                    /* tp_subclasses */
-      0,                                    /* tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-      0,                                    /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-      0,                                    /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-      0,0,0,0                               /* tp_alloc -> tp_next */
-#endif
-    };
-    swigpyobject_type = tmp;
-    type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-    swigpyobject_type.ob_type = &PyType_Type;
-#else
-    if (PyType_Ready(&swigpyobject_type) < 0)
-      return NULL;
-#endif
-  }
-  return &swigpyobject_type;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
-{
-  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
-  if (sobj) {
-    sobj->ptr  = ptr;
-    sobj->ty   = ty;
-    sobj->own  = own;
-    sobj->next = 0;
-  }
-  return (PyObject *)sobj;
-}
-
-/* -----------------------------------------------------------------------------
- * Implements a simple Swig Packed type, and use it instead of string
- * ----------------------------------------------------------------------------- */
-
-typedef struct {
-  PyObject_HEAD
-  void *pack;
-  swig_type_info *ty;
-  size_t size;
-} SwigPyPacked;
-
-SWIGRUNTIME int
-SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
-{
-  char result[SWIG_BUFFER_SIZE];
-  fputs("<Swig Packed ", fp); 
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    fputs("at ", fp); 
-    fputs(result, fp); 
-  }
-  fputs(v->ty->name,fp); 
-  fputs(">", fp);
-  return 0; 
-}
-  
-SWIGRUNTIME PyObject *
-SwigPyPacked_repr(SwigPyPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
-    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
-  } else {
-    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
-  }  
-}
-
-SWIGRUNTIME PyObject *
-SwigPyPacked_str(SwigPyPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
-    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
-  } else {
-    return SWIG_Python_str_FromChar(v->ty->name);
-  }  
-}
-
-SWIGRUNTIME int
-SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
-{
-  size_t i = v->size;
-  size_t j = w->size;
-  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
-  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
-}
-
-SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);
-
-SWIGRUNTIME PyTypeObject*
-SwigPyPacked_type(void) {
-  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
-  return type;
-}
-
-SWIGRUNTIMEINLINE int
-SwigPyPacked_Check(PyObject *op) {
-  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
-    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
-}
-
-SWIGRUNTIME void
-SwigPyPacked_dealloc(PyObject *v)
-{
-  if (SwigPyPacked_Check(v)) {
-    SwigPyPacked *sobj = (SwigPyPacked *) v;
-    free(sobj->pack);
-  }
-  PyObject_DEL(v);
-}
-
-SWIGRUNTIME PyTypeObject*
-SwigPyPacked_TypeOnce(void) {
-  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
-  static PyTypeObject swigpypacked_type;
-  static int type_init = 0;
-  if (!type_init) {
-    const PyTypeObject tmp = {
-      /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX>=0x03000000
-      PyVarObject_HEAD_INIT(NULL, 0)
-#else
-      PyObject_HEAD_INIT(NULL)
-      0,                                    /* ob_size */
-#endif
-      (char *)"SwigPyPacked",               /* tp_name */
-      sizeof(SwigPyPacked),                 /* tp_basicsize */
-      0,                                    /* tp_itemsize */
-      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
-      (printfunc)SwigPyPacked_print,        /* tp_print */
-      (getattrfunc)0,                       /* tp_getattr */
-      (setattrfunc)0,                       /* tp_setattr */
-#if PY_VERSION_HEX>=0x03000000
-      0, /* tp_reserved in 3.0.1 */
-#else
-      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
-#endif
-      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
-      0,                                    /* tp_as_number */
-      0,                                    /* tp_as_sequence */
-      0,                                    /* tp_as_mapping */
-      (hashfunc)0,                          /* tp_hash */
-      (ternaryfunc)0,                       /* tp_call */
-      (reprfunc)SwigPyPacked_str,           /* tp_str */
-      PyObject_GenericGetAttr,              /* tp_getattro */
-      0,                                    /* tp_setattro */
-      0,                                    /* tp_as_buffer */
-      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
-      swigpacked_doc,                       /* tp_doc */
-      0,                                    /* tp_traverse */
-      0,                                    /* tp_clear */
-      0,                                    /* tp_richcompare */
-      0,                                    /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-      0,                                    /* tp_iter */
-      0,                                    /* tp_iternext */
-      0,                                    /* tp_methods */
-      0,                                    /* tp_members */
-      0,                                    /* tp_getset */
-      0,                                    /* tp_base */
-      0,                                    /* tp_dict */
-      0,                                    /* tp_descr_get */
-      0,                                    /* tp_descr_set */
-      0,                                    /* tp_dictoffset */
-      0,                                    /* tp_init */
-      0,                                    /* tp_alloc */
-      0,                                    /* tp_new */
-      0,                                    /* tp_free */
-      0,                                    /* tp_is_gc */
-      0,                                    /* tp_bases */
-      0,                                    /* tp_mro */
-      0,                                    /* tp_cache */
-      0,                                    /* tp_subclasses */
-      0,                                    /* tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-      0,                                    /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-      0,                                    /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-      0,0,0,0                               /* tp_alloc -> tp_next */
-#endif
-    };
-    swigpypacked_type = tmp;
-    type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-    swigpypacked_type.ob_type = &PyType_Type;
-#else
-    if (PyType_Ready(&swigpypacked_type) < 0)
-      return NULL;
-#endif
-  }
-  return &swigpypacked_type;
-}
-
-SWIGRUNTIME PyObject *
-SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
-{
-  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
-  if (sobj) {
-    void *pack = malloc(size);
-    if (pack) {
-      memcpy(pack, ptr, size);
-      sobj->pack = pack;
-      sobj->ty   = ty;
-      sobj->size = size;
-    } else {
-      PyObject_DEL((PyObject *) sobj);
-      sobj = 0;
-    }
-  }
-  return (PyObject *) sobj;
-}
-
-SWIGRUNTIME swig_type_info *
-SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
-{
-  if (SwigPyPacked_Check(obj)) {
-    SwigPyPacked *sobj = (SwigPyPacked *)obj;
-    if (sobj->size != size) return 0;
-    memcpy(ptr, sobj->pack, size);
-    return sobj->ty;
-  } else {
-    return 0;
-  }
-}
-
-/* -----------------------------------------------------------------------------
- * pointers/data manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIMEINLINE PyObject *
-_SWIG_This(void)
-{
-    return SWIG_Python_str_FromChar("this");
-}
-
-static PyObject *swig_this = NULL;
-
-SWIGRUNTIME PyObject *
-SWIG_This(void)
-{
-  if (swig_this == NULL)
-    swig_this = _SWIG_This();
-  return swig_this;
-}
-
-/* #define SWIG_PYTHON_SLOW_GETSET_THIS */
-
-/* TODO: I don't know how to implement the fast getset in Python 3 right now */
-#if PY_VERSION_HEX>=0x03000000
-#define SWIG_PYTHON_SLOW_GETSET_THIS 
-#endif
-
-SWIGRUNTIME SwigPyObject *
-SWIG_Python_GetSwigThis(PyObject *pyobj) 
-{
-  PyObject *obj;
-
-  if (SwigPyObject_Check(pyobj))
-    return (SwigPyObject *) pyobj;
-
-#ifdef SWIGPYTHON_BUILTIN
-  (void)obj;
-# ifdef PyWeakref_CheckProxy
-  if (PyWeakref_CheckProxy(pyobj)) {
-    pyobj = PyWeakref_GET_OBJECT(pyobj);
-    if (pyobj && SwigPyObject_Check(pyobj))
-      return (SwigPyObject*) pyobj;
-  }
-# endif
-  return NULL;
-#else
-
-  obj = 0;
-
-#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
-  if (PyInstance_Check(pyobj)) {
-    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
-  } else {
-    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
-    if (dictptr != NULL) {
-      PyObject *dict = *dictptr;
-      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
-    } else {
-#ifdef PyWeakref_CheckProxy
-      if (PyWeakref_CheckProxy(pyobj)) {
-	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
-	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
-      }
-#endif
-      obj = PyObject_GetAttr(pyobj,SWIG_This());
-      if (obj) {
-	Py_DECREF(obj);
-      } else {
-	if (PyErr_Occurred()) PyErr_Clear();
-	return 0;
-      }
-    }
-  }
-#else
-  obj = PyObject_GetAttr(pyobj,SWIG_This());
-  if (obj) {
-    Py_DECREF(obj);
-  } else {
-    if (PyErr_Occurred()) PyErr_Clear();
-    return 0;
-  }
-#endif
-  if (obj && !SwigPyObject_Check(obj)) {
-    /* a PyObject is called 'this', try to get the 'real this'
-       SwigPyObject from it */ 
-    return SWIG_Python_GetSwigThis(obj);
-  }
-  return (SwigPyObject *)obj;
-#endif
-}
-
-/* Acquire a pointer value */
-
-SWIGRUNTIME int
-SWIG_Python_AcquirePtr(PyObject *obj, int own) {
-  if (own == SWIG_POINTER_OWN) {
-    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
-    if (sobj) {
-      int oldown = sobj->own;
-      sobj->own = own;
-      return oldown;
-    }
-  }
-  return 0;
-}
-
-/* Convert a pointer value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
-  int res;
-  SwigPyObject *sobj;
-
-  if (!obj)
-    return SWIG_ERROR;
-  if (obj == Py_None) {
-    if (ptr)
-      *ptr = 0;
-    return SWIG_OK;
-  }
-
-  res = SWIG_ERROR;
-
-  sobj = SWIG_Python_GetSwigThis(obj);
-  if (own)
-    *own = 0;
-  while (sobj) {
-    void *vptr = sobj->ptr;
-    if (ty) {
-      swig_type_info *to = sobj->ty;
-      if (to == ty) {
-        /* no type cast needed */
-        if (ptr) *ptr = vptr;
-        break;
-      } else {
-        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
-        if (!tc) {
-          sobj = (SwigPyObject *)sobj->next;
-        } else {
-          if (ptr) {
-            int newmemory = 0;
-            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
-            if (newmemory == SWIG_CAST_NEW_MEMORY) {
-              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
-              if (own)
-                *own = *own | SWIG_CAST_NEW_MEMORY;
-            }
-          }
-          break;
-        }
-      }
-    } else {
-      if (ptr) *ptr = vptr;
-      break;
-    }
-  }
-  if (sobj) {
-    if (own)
-      *own = *own | sobj->own;
-    if (flags & SWIG_POINTER_DISOWN) {
-      sobj->own = 0;
-    }
-    res = SWIG_OK;
-  } else {
-    if (flags & SWIG_POINTER_IMPLICIT_CONV) {
-      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
-      if (data && !data->implicitconv) {
-        PyObject *klass = data->klass;
-        if (klass) {
-          PyObject *impconv;
-          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
-          impconv = SWIG_Python_CallFunctor(klass, obj);
-          data->implicitconv = 0;
-          if (PyErr_Occurred()) {
-            PyErr_Clear();
-            impconv = 0;
-          }
-          if (impconv) {
-            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
-            if (iobj) {
-              void *vptr;
-              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
-              if (SWIG_IsOK(res)) {
-                if (ptr) {
-                  *ptr = vptr;
-                  /* transfer the ownership to 'ptr' */
-                  iobj->own = 0;
-                  res = SWIG_AddCast(res);
-                  res = SWIG_AddNewMask(res);
-                } else {
-                  res = SWIG_AddCast(res);		    
-                }
-              }
-            }
-            Py_DECREF(impconv);
-          }
-        }
-      }
-    }
-  }
-  return res;
-}
-
-/* Convert a function ptr value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
-  if (!PyCFunction_Check(obj)) {
-    return SWIG_ConvertPtr(obj, ptr, ty, 0);
-  } else {
-    void *vptr = 0;
-    
-    /* here we get the method pointer for callbacks */
-    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
-    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
-    if (desc)
-      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
-    if (!desc) 
-      return SWIG_ERROR;
-    if (ty) {
-      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
-      if (tc) {
-        int newmemory = 0;
-        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
-        assert(!newmemory); /* newmemory handling not yet implemented */
-      } else {
-        return SWIG_ERROR;
-      }
-    } else {
-      *ptr = vptr;
-    }
-    return SWIG_OK;
-  }
-}
-
-/* Convert a packed value value */
-
-SWIGRUNTIME int
-SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
-  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
-  if (!to) return SWIG_ERROR;
-  if (ty) {
-    if (to != ty) {
-      /* check type cast? */
-      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
-      if (!tc) return SWIG_ERROR;
-    }
-  }
-  return SWIG_OK;
-}  
-
-/* -----------------------------------------------------------------------------
- * Create a new pointer object
- * ----------------------------------------------------------------------------- */
-
-/*
-  Create a new instance object, without calling __init__, and set the
-  'this' attribute.
-*/
-
-SWIGRUNTIME PyObject* 
-SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
-{
-#if (PY_VERSION_HEX >= 0x02020000)
-  PyObject *inst = 0;
-  PyObject *newraw = data->newraw;
-  if (newraw) {
-    inst = PyObject_Call(newraw, data->newargs, NULL);
-    if (inst) {
-#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
-      PyObject **dictptr = _PyObject_GetDictPtr(inst);
-      if (dictptr != NULL) {
-	PyObject *dict = *dictptr;
-	if (dict == NULL) {
-	  dict = PyDict_New();
-	  *dictptr = dict;
-	  PyDict_SetItem(dict, SWIG_This(), swig_this);
-	}
-      }
-#else
-      PyObject *key = SWIG_This();
-      PyObject_SetAttr(inst, key, swig_this);
-#endif
-    }
-  } else {
-#if PY_VERSION_HEX >= 0x03000000
-    inst = PyBaseObject_Type.tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
-    if (inst) {
-      PyObject_SetAttr(inst, SWIG_This(), swig_this);
-      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
-    }
-#else
-    PyObject *dict = PyDict_New();
-    if (dict) {
-      PyDict_SetItem(dict, SWIG_This(), swig_this);
-      inst = PyInstance_NewRaw(data->newargs, dict);
-      Py_DECREF(dict);
-    }
-#endif
-  }
-  return inst;
-#else
-#if (PY_VERSION_HEX >= 0x02010000)
-  PyObject *inst = 0;
-  PyObject *dict = PyDict_New();
-  if (dict) {
-    PyDict_SetItem(dict, SWIG_This(), swig_this);
-    inst = PyInstance_NewRaw(data->newargs, dict);
-    Py_DECREF(dict);
-  }
-  return (PyObject *) inst;
-#else
-  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
-  if (inst == NULL) {
-    return NULL;
-  }
-  inst->in_class = (PyClassObject *)data->newargs;
-  Py_INCREF(inst->in_class);
-  inst->in_dict = PyDict_New();
-  if (inst->in_dict == NULL) {
-    Py_DECREF(inst);
-    return NULL;
-  }
-#ifdef Py_TPFLAGS_HAVE_WEAKREFS
-  inst->in_weakreflist = NULL;
-#endif
-#ifdef Py_TPFLAGS_GC
-  PyObject_GC_Init(inst);
-#endif
-  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
-  return (PyObject *) inst;
-#endif
-#endif
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
-{
- PyObject *dict;
-#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
- PyObject **dictptr = _PyObject_GetDictPtr(inst);
- if (dictptr != NULL) {
-   dict = *dictptr;
-   if (dict == NULL) {
-     dict = PyDict_New();
-     *dictptr = dict;
-   }
-   PyDict_SetItem(dict, SWIG_This(), swig_this);
-   return;
- }
-#endif
- dict = PyObject_GetAttrString(inst, (char*)"__dict__");
- PyDict_SetItem(dict, SWIG_This(), swig_this);
- Py_DECREF(dict);
-} 
-
-
-SWIGINTERN PyObject *
-SWIG_Python_InitShadowInstance(PyObject *args) {
-  PyObject *obj[2];
-  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
-    return NULL;
-  } else {
-    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
-    if (sthis) {
-      SwigPyObject_append((PyObject*) sthis, obj[1]);
-    } else {
-      SWIG_Python_SetSwigThis(obj[0], obj[1]);
-    }
-    return SWIG_Py_Void();
-  }
-}
-
-/* Create a new pointer object */
-
-SWIGRUNTIME PyObject *
-SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
-  SwigPyClientData *clientdata;
-  PyObject * robj;
-  int own;
-
-  if (!ptr)
-    return SWIG_Py_Void();
-
-  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
-  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
-  if (clientdata && clientdata->pytype) {
-    SwigPyObject *newobj;
-    if (flags & SWIG_BUILTIN_TP_INIT) {
-      newobj = (SwigPyObject*) self;
-      if (newobj->ptr) {
-        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
-        while (newobj->next)
-	  newobj = (SwigPyObject *) newobj->next;
-        newobj->next = next_self;
-        newobj = (SwigPyObject *)next_self;
-      }
-    } else {
-      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
-    }
-    if (newobj) {
-      newobj->ptr = ptr;
-      newobj->ty = type;
-      newobj->own = own;
-      newobj->next = 0;
-#ifdef SWIGPYTHON_BUILTIN
-      newobj->dict = 0;
-#endif
-      return (PyObject*) newobj;
-    }
-    return SWIG_Py_Void();
-  }
-
-  assert(!(flags & SWIG_BUILTIN_TP_INIT));
-
-  robj = SwigPyObject_New(ptr, type, own);
-  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
-    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
-    Py_DECREF(robj);
-    robj = inst;
-  }
-  return robj;
-}
-
-/* Create a new packed object */
-
-SWIGRUNTIMEINLINE PyObject *
-SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
-  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
-}
-
-/* -----------------------------------------------------------------------------*
- *  Get type list 
- * -----------------------------------------------------------------------------*/
-
-#ifdef SWIG_LINK_RUNTIME
-void *SWIG_ReturnGlobalTypeList(void *);
-#endif
-
-SWIGRUNTIME swig_module_info *
-SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
-  static void *type_pointer = (void *)0;
-  /* first check if module already created */
-  if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
-    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
-#else
-# ifdef SWIGPY_USE_CAPSULE
-    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
-# else
-    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
-				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
-# endif
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-#endif
-  }
-  return (swig_module_info *) type_pointer;
-}
-
-#if PY_MAJOR_VERSION < 2
-/* PyModule_AddObject function was introduced in Python 2.0.  The following function
-   is copied out of Python/modsupport.c in python version 2.3.4 */
-SWIGINTERN int
-PyModule_AddObject(PyObject *m, char *name, PyObject *o)
-{
-  PyObject *dict;
-  if (!PyModule_Check(m)) {
-    PyErr_SetString(PyExc_TypeError,
-		    "PyModule_AddObject() needs module as first arg");
-    return SWIG_ERROR;
-  }
-  if (!o) {
-    PyErr_SetString(PyExc_TypeError,
-		    "PyModule_AddObject() needs non-NULL value");
-    return SWIG_ERROR;
-  }
-  
-  dict = PyModule_GetDict(m);
-  if (dict == NULL) {
-    /* Internal error -- modules must have a dict! */
-    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
-		 PyModule_GetName(m));
-    return SWIG_ERROR;
-  }
-  if (PyDict_SetItemString(dict, name, o))
-    return SWIG_ERROR;
-  Py_DECREF(o);
-  return SWIG_OK;
-}
-#endif
-
-SWIGRUNTIME void
-#ifdef SWIGPY_USE_CAPSULE
-SWIG_Python_DestroyModule(PyObject *obj)
-#else
-SWIG_Python_DestroyModule(void *vptr)
-#endif
-{
-#ifdef SWIGPY_USE_CAPSULE
-  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
-#else
-  swig_module_info *swig_module = (swig_module_info *) vptr;
-#endif
-  swig_type_info **types = swig_module->types;
-  size_t i;
-  for (i =0; i < swig_module->size; ++i) {
-    swig_type_info *ty = types[i];
-    if (ty->owndata) {
-      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
-      if (data) SwigPyClientData_Del(data);
-    }
-  }
-  Py_DECREF(SWIG_This());
-  swig_this = NULL;
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetModule(swig_module_info *swig_module) {
-#if PY_VERSION_HEX >= 0x03000000
- /* Add a dummy module object into sys.modules */
-  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
-#else
-  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
-  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
-#endif
-#ifdef SWIGPY_USE_CAPSULE
-  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
-  if (pointer && module) {
-    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
-  } else {
-    Py_XDECREF(pointer);
-  }
-#else
-  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
-  if (pointer && module) {
-    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
-  } else {
-    Py_XDECREF(pointer);
-  }
-#endif
-}
-
-/* The python cached type query */
-SWIGRUNTIME PyObject *
-SWIG_Python_TypeCache(void) {
-  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
-  return cache;
-}
-
-SWIGRUNTIME swig_type_info *
-SWIG_Python_TypeQuery(const char *type)
-{
-  PyObject *cache = SWIG_Python_TypeCache();
-  PyObject *key = SWIG_Python_str_FromChar(type); 
-  PyObject *obj = PyDict_GetItem(cache, key);
-  swig_type_info *descriptor;
-  if (obj) {
-#ifdef SWIGPY_USE_CAPSULE
-    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
-#else
-    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
-#endif
-  } else {
-    swig_module_info *swig_module = SWIG_GetModule(0);
-    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
-    if (descriptor) {
-#ifdef SWIGPY_USE_CAPSULE
-      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
-#else
-      obj = PyCObject_FromVoidPtr(descriptor, NULL);
-#endif
-      PyDict_SetItem(cache, key, obj);
-      Py_DECREF(obj);
-    }
-  }
-  Py_DECREF(key);
-  return descriptor;
-}
-
-/* 
-   For backward compatibility only
-*/
-#define SWIG_POINTER_EXCEPTION  0
-#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
-#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
-
-SWIGRUNTIME int
-SWIG_Python_AddErrMesg(const char* mesg, int infront)
-{  
-  if (PyErr_Occurred()) {
-    PyObject *type = 0;
-    PyObject *value = 0;
-    PyObject *traceback = 0;
-    PyErr_Fetch(&type, &value, &traceback);
-    if (value) {
-      char *tmp;
-      PyObject *old_str = PyObject_Str(value);
-      Py_XINCREF(type);
-      PyErr_Clear();
-      if (infront) {
-	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
-      } else {
-	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
-      }
-      SWIG_Python_str_DelForPy3(tmp);
-      Py_DECREF(old_str);
-    }
-    return 1;
-  } else {
-    return 0;
-  }
-}
-  
-SWIGRUNTIME int
-SWIG_Python_ArgFail(int argnum)
-{
-  if (PyErr_Occurred()) {
-    /* add information about failing argument */
-    char mesg[256];
-    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
-    return SWIG_Python_AddErrMesg(mesg, 1);
-  } else {
-    return 0;
-  }
-}
-
-SWIGRUNTIMEINLINE const char *
-SwigPyObject_GetDesc(PyObject *self)
-{
-  SwigPyObject *v = (SwigPyObject *)self;
-  swig_type_info *ty = v ? v->ty : 0;
-  return ty ? ty->str : "";
-}
-
-SWIGRUNTIME void
-SWIG_Python_TypeError(const char *type, PyObject *obj)
-{
-  if (type) {
-#if defined(SWIG_COBJECT_TYPES)
-    if (obj && SwigPyObject_Check(obj)) {
-      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
-      if (otype) {
-	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
-		     type, otype);
-	return;
-      }
-    } else 
-#endif      
-    {
-      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
-      if (otype) {
-	PyObject *str = PyObject_Str(obj);
-	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
-	if (cstr) {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
-		       type, otype, cstr);
-          SWIG_Python_str_DelForPy3(cstr);
-	} else {
-	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
-		       type, otype);
-	}
-	Py_XDECREF(str);
-	return;
-      }
-    }   
-    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
-  } else {
-    PyErr_Format(PyExc_TypeError, "unexpected type is received");
-  }
-}
-
-
-/* Convert a pointer value, signal an exception on a type mismatch */
-SWIGRUNTIME void *
-SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
-  void *result;
-  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
-    PyErr_Clear();
-#if SWIG_POINTER_EXCEPTION
-    if (flags) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-#endif
-  }
-  return result;
-}
-
-#ifdef SWIGPYTHON_BUILTIN
-SWIGRUNTIME int
-SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
-  PyTypeObject *tp = obj->ob_type;
-  PyObject *descr;
-  PyObject *encoded_name;
-  descrsetfunc f;
-  int res;
-
-# ifdef Py_USING_UNICODE
-  if (PyString_Check(name)) {
-    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
-    if (!name)
-      return -1;
-  } else if (!PyUnicode_Check(name))
-# else
-  if (!PyString_Check(name))
-# endif
-  {
-    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
-    return -1;
-  } else {
-    Py_INCREF(name);
-  }
-
-  if (!tp->tp_dict) {
-    if (PyType_Ready(tp) < 0)
-      goto done;
-  }
-
-  res = -1;
-  descr = _PyType_Lookup(tp, name);
-  f = NULL;
-  if (descr != NULL)
-    f = descr->ob_type->tp_descr_set;
-  if (!f) {
-    if (PyString_Check(name)) {
-      encoded_name = name;
-      Py_INCREF(name);
-    } else {
-      encoded_name = PyUnicode_AsUTF8String(name);
-    }
-    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
-    Py_DECREF(encoded_name);
-  } else {
-    res = f(descr, obj, value);
-  }
-  
-  done:
-  Py_DECREF(name);
-  return res;
-}
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-
-#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
-
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
-
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define SWIGTYPE_p__private_detail__MASKUNION swig_types[0]
-#define SWIGTYPE_p__private_detail__VPMask__VMaskType swig_types[1]
-#define SWIGTYPE_p_allocator_type swig_types[2]
-#define SWIGTYPE_p_char swig_types[3]
-#define SWIGTYPE_p_difference_type swig_types[4]
-#define SWIGTYPE_p_double swig_types[5]
-#define SWIGTYPE_p_im__DOUBLEMASK swig_types[6]
-#define SWIGTYPE_p_im__INTMASK swig_types[7]
-#define SWIGTYPE_p_int swig_types[8]
-#define SWIGTYPE_p_matrix swig_types[9]
-#define SWIGTYPE_p_size_type swig_types[10]
-#define SWIGTYPE_p_std__ostream swig_types[11]
-#define SWIGTYPE_p_value_type swig_types[12]
-#define SWIGTYPE_p_vips__VDMask swig_types[13]
-#define SWIGTYPE_p_vips__VError swig_types[14]
-#define SWIGTYPE_p_vips__VIMask swig_types[15]
-#define SWIGTYPE_p_vips__VMask swig_types[16]
-static swig_type_info *swig_types[18];
-static swig_module_info swig_module = {swig_types, 17, 0, 0, 0, 0};
-#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
-#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
-
-/* -------- TYPES TABLE (END) -------- */
-
-#if (PY_VERSION_HEX <= 0x02000000)
-# if !defined(SWIG_PYTHON_CLASSIC)
-#  error "This python version requires swig to be run with the '-classic' option"
-# endif
-#endif
-
-/*-----------------------------------------------
-              @(target):= vmaskmodule.so
-  ------------------------------------------------*/
-#if PY_VERSION_HEX >= 0x03000000
-#  define SWIG_init    PyInit_vmaskmodule
-
-#else
-#  define SWIG_init    initvmaskmodule
-
-#endif
-#define SWIG_name    "vmaskmodule"
-
-#define SWIGVERSION 0x020010 
-#define SWIG_VERSION SWIGVERSION
-
-
-#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
-#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 
-
-
-#include <stdexcept>
-
-
-namespace swig {
-  class SwigPtr_PyObject {
-  protected:
-    PyObject *_obj;
-
-  public:
-    SwigPtr_PyObject() :_obj(0)
-    {
-    }
-
-    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
-    {
-      Py_XINCREF(_obj);      
-    }
-    
-    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
-    {
-      if (initial_ref) {
-        Py_XINCREF(_obj);
-      }
-    }
-    
-    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
-    {
-      Py_XINCREF(item._obj);
-      Py_XDECREF(_obj);
-      _obj = item._obj;
-      return *this;      
-    }
-    
-    ~SwigPtr_PyObject() 
-    {
-      Py_XDECREF(_obj);
-    }
-    
-    operator PyObject *() const
-    {
-      return _obj;
-    }
-
-    PyObject *operator->() const
-    {
-      return _obj;
-    }
-  };
-}
-
-
-namespace swig {
-  struct SwigVar_PyObject : SwigPtr_PyObject {
-    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
-    
-    SwigVar_PyObject & operator = (PyObject* obj)
-    {
-      Py_XDECREF(_obj);
-      _obj = obj;
-      return *this;      
-    }
-  };
-}
-
-
-#include <stdexcept>
-#include <vips/vipscpp.h>
-
-
-  #include <stddef.h>
-
-
-namespace swig {
-  struct stop_iteration {
-  };
-
-  struct SwigPyIterator {
-  private:
-    SwigPtr_PyObject _seq;
-
-  protected:
-    SwigPyIterator(PyObject *seq) : _seq(seq)
-    {
-    }
-      
-  public:
-    virtual ~SwigPyIterator() {}
-
-    // Access iterator method, required by Python
-    virtual PyObject *value() const = 0;
-
-    // Forward iterator method, required by Python
-    virtual SwigPyIterator *incr(size_t n = 1) = 0;
-    
-    // Backward iterator method, very common in C++, but not required in Python
-    virtual SwigPyIterator *decr(size_t /*n*/ = 1)
-    {
-      throw stop_iteration();
-    }
-
-    // Random access iterator methods, but not required in Python
-    virtual ptrdiff_t distance(const SwigPyIterator &/*x*/) const
-    {
-      throw std::invalid_argument("operation not supported");
-    }
-
-    virtual bool equal (const SwigPyIterator &/*x*/) const
-    {
-      throw std::invalid_argument("operation not supported");
-    }
-    
-    // C++ common/needed methods
-    virtual SwigPyIterator *copy() const = 0;
-
-    PyObject *next()     
-    {
-      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
-      PyObject *obj = value();
-      incr();       
-      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads
-      return obj;     
-    }
-
-    /* Make an alias for Python 3.x */
-    PyObject *__next__()
-    {
-      return next();
-    }
-
-    PyObject *previous()
-    {
-      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
-      decr();
-      PyObject *obj = value();
-      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads       
-      return obj;
-    }
-
-    SwigPyIterator *advance(ptrdiff_t n)
-    {
-      return  (n > 0) ?  incr(n) : decr(-n);
-    }
-      
-    bool operator == (const SwigPyIterator& x)  const
-    {
-      return equal(x);
-    }
-      
-    bool operator != (const SwigPyIterator& x) const
-    {
-      return ! operator==(x);
-    }
-      
-    SwigPyIterator& operator += (ptrdiff_t n)
-    {
-      return *advance(n);
-    }
-
-    SwigPyIterator& operator -= (ptrdiff_t n)
-    {
-      return *advance(-n);
-    }
-      
-    SwigPyIterator* operator + (ptrdiff_t n) const
-    {
-      return copy()->advance(n);
-    }
-
-    SwigPyIterator* operator - (ptrdiff_t n) const
-    {
-      return copy()->advance(-n);
-    }
-      
-    ptrdiff_t operator - (const SwigPyIterator& x) const
-    {
-      return x.distance(*this);
-    }
-      
-    static swig_type_info* descriptor() {
-      static int init = 0;
-      static swig_type_info* desc = 0;
-      if (!init) {
-	desc = SWIG_TypeQuery("swig::SwigPyIterator *");
-	init = 1;
-      }	
-      return desc;
-    }    
-  };
-
-#if defined(SWIGPYTHON_BUILTIN)
-  inline PyObject* make_output_iterator_builtin (PyObject *pyself)
-  {
-    Py_INCREF(pyself);
-    return pyself;
-  }
-#endif
-}
-
-
-namespace swig {  
-  template <class Type>
-  struct noconst_traits {
-    typedef Type noconst_type;
-  };
-
-  template <class Type>
-  struct noconst_traits<const Type> {
-    typedef Type noconst_type;
-  };
-
-  /*
-    type categories
-  */
-  struct pointer_category { };  
-  struct value_category { };
-
-  /*
-    General traits that provides type_name and type_info
-  */
-  template <class Type> struct traits { };
-
-  template <class Type>
-  inline const char* type_name() {
-    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
-  }
-
-  template <class Type> 
-  struct traits_info {
-    static swig_type_info *type_query(std::string name) {
-      name += " *";
-      return SWIG_TypeQuery(name.c_str());
-    }    
-    static swig_type_info *type_info() {
-      static swig_type_info *info = type_query(type_name<Type>());
-      return info;
-    }
-  };
-
-  template <class Type>
-  inline swig_type_info *type_info() {
-    return traits_info<Type>::type_info();
-  }
-
-  /*
-    Partial specialization for pointers
-  */
-  template <class Type> struct traits <Type *> {
-    typedef pointer_category category;
-    static std::string make_ptr_name(const char* name) {
-      std::string ptrname = name;
-      ptrname += " *";
-      return ptrname;
-    }    
-    static const char* type_name() {
-      static std::string name = make_ptr_name(swig::type_name<Type>());
-      return name.c_str();
-    }
-  };
-
-  template <class Type, class Category> 
-  struct traits_as { };
- 
-  template <class Type, class Category> 
-  struct traits_check { };
-
-}
-
-
-namespace swig {  
-  /*
-    Traits that provides the from method
-  */
-  template <class Type> struct traits_from_ptr {
-    static PyObject *from(Type *val, int owner = 0) {
-      return SWIG_InternalNewPointerObj(val, type_info<Type>(), owner);
-    }
-  };
-
-  template <class Type> struct traits_from {
-    static PyObject *from(const Type& val) {
-      return traits_from_ptr<Type>::from(new Type(val), 1);
-    }
-  };
-
-  template <class Type> struct traits_from<Type *> {
-    static PyObject *from(Type* val) {
-      return traits_from_ptr<Type>::from(val, 0);
-    }
-  };
-
-  template <class Type> struct traits_from<const Type *> {
-    static PyObject *from(const Type* val) {
-      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
-    }
-  };
-
-
-  template <class Type>
-  inline PyObject *from(const Type& val) {
-    return traits_from<Type>::from(val);
-  }
-
-  template <class Type>
-  inline PyObject *from_ptr(Type* val, int owner) {
-    return traits_from_ptr<Type>::from(val, owner);
-  }
-
-  /*
-    Traits that provides the asval/as/check method
-  */
-  template <class Type>
-  struct traits_asptr {   
-    static int asptr(PyObject *obj, Type **val) {
-      Type *p;
-      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
-      if (SWIG_IsOK(res)) {
-	if (val) *val = p;
-      }
-      return res;
-    }
-  }; 
-
-  template <class Type>
-  inline int asptr(PyObject *obj, Type **vptr) {
-    return traits_asptr<Type>::asptr(obj, vptr);
-  }
-
-  template <class Type> 
-  struct traits_asval {
-    static int asval(PyObject *obj, Type *val) {
-      if (val) {
-	Type *p = 0;
-	int res = traits_asptr<Type>::asptr(obj, &p);
-	if (!SWIG_IsOK(res)) return res;	
-	if (p) {
-	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
-	  *(const_cast<noconst_type*>(val)) = *p;
-	  if (SWIG_IsNewObj(res)){
-	    delete p;
-	    res = SWIG_DelNewMask(res);
-	  }
-	  return res;
-	} else {
-	  return SWIG_ERROR;
-	}
-      } else {
-	return traits_asptr<Type>::asptr(obj, (Type **)(0));
-      }
-    }
-  };
-
-  template <class Type> struct traits_asval<Type*> {
-    static int asval(PyObject *obj, Type **val) {
-      if (val) {
-        typedef typename noconst_traits<Type>::noconst_type noconst_type;
-        noconst_type *p = 0;
-        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
-        if (SWIG_IsOK(res)) {
-          *(const_cast<noconst_type**>(val)) = p;
-	}
-	return res;
-      } else {
-	return traits_asptr<Type>::asptr(obj, (Type **)(0));
-      }
-    }
-  };
-  
-  template <class Type>
-  inline int asval(PyObject *obj, Type *val) {
-    return traits_asval<Type>::asval(obj, val);
-  }
-
-  template <class Type> 
-  struct traits_as<Type, value_category> {
-    static Type as(PyObject *obj, bool throw_error) {
-      Type v;
-      int res = asval(obj, &v);
-      if (!obj || !SWIG_IsOK(res)) {
-	if (!PyErr_Occurred()) {
-	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
-	}
-	if (throw_error) throw std::invalid_argument("bad type");
-      }
-      return v;
-    }
-  };
-
-  template <class Type> 
-  struct traits_as<Type, pointer_category> {
-    static Type as(PyObject *obj, bool throw_error) {
-      Type *v = 0;      
-      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
-      if (SWIG_IsOK(res) && v) {
-	if (SWIG_IsNewObj(res)) {
-	  Type r(*v);
-	  delete v;
-	  return r;
-	} else {
-	  return *v;
-	}
-      } else {
-	// Uninitialized return value, no Type() constructor required.
-	static Type *v_def = (Type*) malloc(sizeof(Type));
-	if (!PyErr_Occurred()) {
-	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
-	}
-	if (throw_error) throw std::invalid_argument("bad type");
-	memset(v_def,0,sizeof(Type));
-	return *v_def;
-      }
-    }
-  };
-
-  template <class Type> 
-  struct traits_as<Type*, pointer_category> {
-    static Type* as(PyObject *obj, bool throw_error) {
-      Type *v = 0;      
-      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
-      if (SWIG_IsOK(res)) {
-	return v;
-      } else {
-	if (!PyErr_Occurred()) {
-	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
-	}
-	if (throw_error) throw std::invalid_argument("bad type");
-	return 0;
-      }
-    }
-  };
-    
-  template <class Type>
-  inline Type as(PyObject *obj, bool te = false) {
-    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
-  }
-
-  template <class Type> 
-  struct traits_check<Type, value_category> {
-    static bool check(PyObject *obj) {
-      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
-      return SWIG_IsOK(res) ? true : false;
-    }
-  };
-
-  template <class Type> 
-  struct traits_check<Type, pointer_category> {
-    static bool check(PyObject *obj) {
-      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
-      return SWIG_IsOK(res) ? true : false;
-    }
-  };
-
-  template <class Type>
-  inline bool check(PyObject *obj) {
-    return traits_check<Type, typename traits<Type>::category>::check(obj);
-  }
-}
-
-
-#include <functional>
-
-namespace std {
-  template <>
-  struct less <PyObject *>: public binary_function<PyObject *, PyObject *, bool>
-  {
-    bool
-    operator()(PyObject * v, PyObject *w) const
-    { 
-      bool res;
-      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
-      res = PyObject_RichCompareBool(v, w, Py_LT) ? true : false;
-      /* This may fall into a case of inconsistent
-               eg. ObjA > ObjX > ObjB
-               but ObjA < ObjB
-      */
-      if( PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError) )
-      {
-        /* Objects can't be compared, this mostly occurred in Python 3.0 */
-        /* Compare their ptr directly for a workaround */
-        res = (v < w);
-        PyErr_Clear();
-      }
-      SWIG_PYTHON_THREAD_END_BLOCK;
-      return res;
-    }
-  };
-
-  template <>
-  struct less <swig::SwigPtr_PyObject>: public binary_function<swig::SwigPtr_PyObject, swig::SwigPtr_PyObject, bool>
-  {
-    bool
-    operator()(const swig::SwigPtr_PyObject& v, const swig::SwigPtr_PyObject& w) const
-    {
-      return std::less<PyObject *>()(v, w);
-    }
-  };
-
-  template <>
-  struct less <swig::SwigVar_PyObject>: public binary_function<swig::SwigVar_PyObject, swig::SwigVar_PyObject, bool>
-  {
-    bool
-    operator()(const swig::SwigVar_PyObject& v, const swig::SwigVar_PyObject& w) const
-    {
-      return std::less<PyObject *>()(v, w);
-    }
-  };
-
-}
-
-namespace swig {
-  template <> struct traits<PyObject *> {
-    typedef value_category category;
-    static const char* type_name() { return "PyObject *"; }
-  };  
-
-  template <>  struct traits_asval<PyObject * > {   
-    typedef PyObject * value_type;
-    static int asval(PyObject *obj, value_type *val) {
-      if (val) *val = obj;
-      return SWIG_OK;
-    }
-  };
-
-  template <> 
-  struct traits_check<PyObject *, value_category> {
-    static bool check(PyObject *) {
-      return true;
-    }
-  };
-
-  template <>  struct traits_from<PyObject *> {
-    typedef PyObject * value_type;
-    static PyObject *from(const value_type& val) {
-      Py_XINCREF(val);
-      return val;
-    }
-  };
-  
-}
-
-namespace swig {
-  template <class Difference>
-  inline size_t
-  check_index(Difference i, size_t size, bool insert = false) {
-    if ( i < 0 ) {
-      if ((size_t) (-i) <= size)
-	return (size_t) (i + size);
-    } else if ( (size_t) i < size ) {
-      return (size_t) i;
-    } else if (insert && ((size_t) i == size)) {
-      return size;
-    }
-    throw std::out_of_range("index out of range");
-  }
-
-  template <class Difference>
-  void
-  slice_adjust(Difference i, Difference j, Py_ssize_t step, size_t size, Difference &ii, Difference &jj, bool insert = false) {
-    if (step == 0) {
-      throw std::invalid_argument("slice step cannot be zero");
-    } else if (step > 0) {
-      // Required range: 0 <= i < size, 0 <= j < size
-      if (i < 0) {
-        ii = 0;
-      } else if (i < (Difference)size) {
-        ii = i;
-      } else if (insert && (i >= (Difference)size)) {
-        ii = (Difference)size;
-      }
-      if ( j < 0 ) {
-        jj = 0;
-      } else {
-        jj = (j < (Difference)size) ? j : (Difference)size;
-      }
-    } else {
-      // Required range: -1 <= i < size-1, -1 <= j < size-1
-      if (i < -1) {
-        ii = -1;
-      } else if (i < (Difference) size) {
-        ii = i;
-      } else if (i >= (Difference)(size-1)) {
-        ii = (Difference)(size-1);
-      }
-      if (j < -1) {
-        jj = -1;
-      } else {
-        jj = (j < (Difference)size ) ? j : (Difference)(size-1);
-      }
-    }
-  }
-
-  template <class Sequence, class Difference>
-  inline typename Sequence::iterator
-  getpos(Sequence* self, Difference i)  {
-    typename Sequence::iterator pos = self->begin();
-    std::advance(pos, check_index(i,self->size()));
-    return pos;
-  }
-
-  template <class Sequence, class Difference>
-  inline typename Sequence::const_iterator
-  cgetpos(const Sequence* self, Difference i)  {
-    typename Sequence::const_iterator pos = self->begin();
-    std::advance(pos, check_index(i,self->size()));
-    return pos;
-  }
-
-  template <class Sequence, class Difference>
-  inline Sequence*
-  getslice(const Sequence* self, Difference i, Difference j, Py_ssize_t step) {
-    typename Sequence::size_type size = self->size();
-    Difference ii = 0;
-    Difference jj = 0;
-    swig::slice_adjust(i, j, step, size, ii, jj);
-
-    if (step > 0) {
-      typename Sequence::const_iterator sb = self->begin();
-      typename Sequence::const_iterator se = self->begin();
-      std::advance(sb,ii);
-      std::advance(se,jj);
-      if (step == 1) {
-        return new Sequence(sb, se);
-      } else {
-        Sequence *sequence = new Sequence();
-        typename Sequence::const_iterator it = sb;
-        while (it!=se) {
-          sequence->push_back(*it);
-          for (Py_ssize_t c=0; c<step && it!=se; ++c)
-            it++;
-        }
-        return sequence;
-      } 
-    } else {
-      Sequence *sequence = new Sequence();
-      if (ii > jj) {
-        typename Sequence::const_reverse_iterator sb = self->rbegin();
-        typename Sequence::const_reverse_iterator se = self->rbegin();
-        std::advance(sb,size-ii-1);
-        std::advance(se,size-jj-1);
-        typename Sequence::const_reverse_iterator it = sb;
-        while (it!=se) {
-          sequence->push_back(*it);
-          for (Py_ssize_t c=0; c<-step && it!=se; ++c)
-            it++;
-        }
-      }
-      return sequence;
-    }
-  }
-
-  template <class Sequence, class Difference, class InputSeq>
-  inline void
-  setslice(Sequence* self, Difference i, Difference j, Py_ssize_t step, const InputSeq& is = InputSeq()) {
-    typename Sequence::size_type size = self->size();
-    Difference ii = 0;
-    Difference jj = 0;
-    swig::slice_adjust(i, j, step, size, ii, jj, true);
-    if (step > 0) {
-      if (jj < ii)
-        jj = ii;
-      if (step == 1) {
-        size_t ssize = jj - ii;
-        if (ssize <= is.size()) {
-          // expanding/staying the same size
-          typename Sequence::iterator sb = self->begin();
-          typename InputSeq::const_iterator isit = is.begin();
-          std::advance(sb,ii);
-          std::advance(isit, jj - ii);
-          self->insert(std::copy(is.begin(), isit, sb), isit, is.end());
-        } else {
-          // shrinking
-          typename Sequence::iterator sb = self->begin();
-          typename Sequence::iterator se = self->begin();
-          std::advance(sb,ii);
-          std::advance(se,jj);
-          self->erase(sb,se);
-          sb = self->begin();
-          std::advance(sb,ii);
-          self->insert(sb, is.begin(), is.end());
-        }
-      } else {
-        size_t replacecount = (jj - ii + step - 1) / step;
-        if (is.size() != replacecount) {
-          char msg[1024];
-          sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
-          throw std::invalid_argument(msg);
-        }
-        typename Sequence::const_iterator isit = is.begin();
-        typename Sequence::iterator it = self->begin();
-        std::advance(it,ii);
-        for (size_t rc=0; rc<replacecount; ++rc) {
-          *it++ = *isit++;
-          for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
-            it++;
-        }
-      }
-    } else {
-      if (jj > ii)
-        jj = ii;
-      size_t replacecount = (ii - jj - step - 1) / -step;
-      if (is.size() != replacecount) {
-        char msg[1024];
-        sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
-        throw std::invalid_argument(msg);
-      }
-      typename Sequence::const_iterator isit = is.begin();
-      typename Sequence::reverse_iterator it = self->rbegin();
-      std::advance(it,size-ii-1);
-      for (size_t rc=0; rc<replacecount; ++rc) {
-        *it++ = *isit++;
-        for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
-          it++;
-      }
-    }
-  }
-
-  template <class Sequence, class Difference>
-  inline void
-  delslice(Sequence* self, Difference i, Difference j, Py_ssize_t step) {
-    typename Sequence::size_type size = self->size();
-    Difference ii = 0;
-    Difference jj = 0;
-    swig::slice_adjust(i, j, step, size, ii, jj, true);
-    if (step > 0) {
-      if (jj > ii) {
-        typename Sequence::iterator sb = self->begin();
-        std::advance(sb,ii);
-        if (step == 1) {
-          typename Sequence::iterator se = self->begin();
-          std::advance(se,jj);
-          self->erase(sb,se);
-        } else {
-          typename Sequence::iterator it = sb;
-          size_t delcount = (jj - ii + step - 1) / step;
-          while (delcount) {
-            it = self->erase(it);
-            for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
-              it++;
-            delcount--;
-          }
-        }
-      }
-    } else {
-      if (ii > jj) {
-        typename Sequence::reverse_iterator sb = self->rbegin();
-        std::advance(sb,size-ii-1);
-        typename Sequence::reverse_iterator it = sb;
-        size_t delcount = (ii - jj - step - 1) / -step;
-        while (delcount) {
-          it = typename Sequence::reverse_iterator(self->erase((++it).base()));
-          for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
-            it++;
-          delcount--;
-        }
-      }
-    }
-  }
-}
-
-
-#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
-#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
-#    define SWIG_STD_NOITERATOR_TRAITS_STL
-#  endif
-#endif
-
-#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
-#include <iterator>
-#else
-namespace std {
-  template <class Iterator>
-  struct iterator_traits {
-    typedef ptrdiff_t difference_type;
-    typedef typename Iterator::value_type value_type;
-  };
-
-  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
-  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
-    typedef Distance difference_type;
-    typedef T value_type;
-  };
-
-  template <class T>
-  struct iterator_traits<T*> {
-    typedef T value_type;
-    typedef ptrdiff_t difference_type;
-  };
-
-  template<typename _InputIterator>
-  inline typename iterator_traits<_InputIterator>::difference_type
-  distance(_InputIterator __first, _InputIterator __last)
-  {
-    typename iterator_traits<_InputIterator>::difference_type __n = 0;
-    while (__first != __last) {
-      ++__first; ++__n;
-    }
-    return __n;
-  }
-}
-#endif
-
-
-namespace swig {
-  template<typename OutIterator>
-  class SwigPyIterator_T :  public SwigPyIterator
-  {
-  public:
-    typedef OutIterator out_iterator;
-    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
-    typedef SwigPyIterator_T<out_iterator> self_type;
-
-    SwigPyIterator_T(out_iterator curr, PyObject *seq)
-      : SwigPyIterator(seq), current(curr)
-    {
-    }
-
-    const out_iterator& get_current() const
-    {
-      return current;
-    }
-
-    
-    bool equal (const SwigPyIterator &iter) const
-    {
-      const self_type *iters = dynamic_cast<const self_type *>(&iter);
-      if (iters) {
-	return (current == iters->get_current());
-      } else {
-	throw std::invalid_argument("bad iterator type");
-      }
-    }
-    
-    ptrdiff_t distance(const SwigPyIterator &iter) const
-    {
-      const self_type *iters = dynamic_cast<const self_type *>(&iter);
-      if (iters) {
-	return std::distance(current, iters->get_current());
-      } else {
-	throw std::invalid_argument("bad iterator type");
-      }
-    }    
-    
-  protected:
-    out_iterator current;
-  };
-  
-  template <class ValueType>
-  struct from_oper 
-  {
-    typedef const ValueType& argument_type;
-    typedef PyObject *result_type;
-    result_type operator()(argument_type v) const
-    {
-      return swig::from(v);
-    }
-  };
-
-  template<typename OutIterator, 
-	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
-	   typename FromOper = from_oper<ValueType> >
-  class SwigPyIteratorOpen_T :  public SwigPyIterator_T<OutIterator>
-  {
-  public:
-    FromOper from;
-    typedef OutIterator out_iterator;
-    typedef ValueType value_type;
-    typedef SwigPyIterator_T<out_iterator>  base;
-    typedef SwigPyIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
-    
-    SwigPyIteratorOpen_T(out_iterator curr, PyObject *seq)
-      : SwigPyIterator_T<OutIterator>(curr, seq)
-    {
-    }
-    
-    PyObject *value() const {
-      return from(static_cast<const value_type&>(*(base::current)));
-    }
-    
-    SwigPyIterator *copy() const
-    {
-      return new self_type(*this);
-    }
-
-    SwigPyIterator *incr(size_t n = 1)
-    {
-      while (n--) {
-	++base::current;
-      }
-      return this;
-    }
-
-    SwigPyIterator *decr(size_t n = 1)
-    {
-      while (n--) {
-	--base::current;
-      }
-      return this;
-    }
-  };
-
-  template<typename OutIterator, 
-	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
-	   typename FromOper = from_oper<ValueType> >
-  class SwigPyIteratorClosed_T :  public SwigPyIterator_T<OutIterator>
-  {
-  public:
-    FromOper from;
-    typedef OutIterator out_iterator;
-    typedef ValueType value_type;
-    typedef SwigPyIterator_T<out_iterator>  base;    
-    typedef SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
-    
-    SwigPyIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
-      : SwigPyIterator_T<OutIterator>(curr, seq), begin(first), end(last)
-    {
-    }
-    
-    PyObject *value() const {
-      if (base::current == end) {
-	throw stop_iteration();
-      } else {
-	return from(static_cast<const value_type&>(*(base::current)));
-      }
-    }
-    
-    SwigPyIterator *copy() const
-    {
-      return new self_type(*this);
-    }
-
-    SwigPyIterator *incr(size_t n = 1)
-    {
-      while (n--) {
-	if (base::current == end) {
-	  throw stop_iteration();
-	} else {
-	  ++base::current;
-	}
-      }
-      return this;
-    }
-
-    SwigPyIterator *decr(size_t n = 1)
-    {
-      while (n--) {
-	if (base::current == begin) {
-	  throw stop_iteration();
-	} else {
-	  --base::current;
-	}
-      }
-      return this;
-    }
-
-  private:
-    out_iterator begin;
-    out_iterator end;
-  };
-
-  template<typename OutIter>
-  inline SwigPyIterator*
-  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
-  {
-    return new SwigPyIteratorClosed_T<OutIter>(current, begin, end, seq);
-  }
-
-  template<typename OutIter>
-  inline SwigPyIterator*
-  make_output_iterator(const OutIter& current, PyObject *seq = 0)
-  {
-    return new SwigPyIteratorOpen_T<OutIter>(current, seq);
-  }
-
-}
-
-
-namespace swig
-{
-  template <class T>
-  struct SwigPySequence_Ref
-  {
-    SwigPySequence_Ref(PyObject* seq, int index)
-      : _seq(seq), _index(index)
-    {
-    }
-    
-    operator T () const
-    {
-      swig::SwigVar_PyObject item = PySequence_GetItem(_seq, _index);
-      try {
-	return swig::as<T>(item, true);
-      } catch (std::exception& e) {
-	char msg[1024];
-	sprintf(msg, "in sequence element %d ", _index);
-	if (!PyErr_Occurred()) {
-	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
-	}
-	SWIG_Python_AddErrorMsg(msg);
-	SWIG_Python_AddErrorMsg(e.what());
-	throw;
-      }
-    }
-
-    SwigPySequence_Ref& operator=(const T& v)
-    {
-      PySequence_SetItem(_seq, _index, swig::from<T>(v));
-      return *this;
-    }
-
-  private:
-    PyObject* _seq;
-    int _index;
-  };
-
-  template <class T>
-  struct SwigPySequence_ArrowProxy
-  {
-    SwigPySequence_ArrowProxy(const T& x): m_value(x) {}
-    const T* operator->() const { return &m_value; }
-    operator const T*() const { return &m_value; }
-    T m_value;
-  };
-
-  template <class T, class Reference >
-  struct SwigPySequence_InputIterator
-  {
-    typedef SwigPySequence_InputIterator<T, Reference > self;
-
-    typedef std::random_access_iterator_tag iterator_category;
-    typedef Reference reference;
-    typedef T value_type;
-    typedef T* pointer;
-    typedef int difference_type;
-
-    SwigPySequence_InputIterator()
-    {
-    }
-
-    SwigPySequence_InputIterator(PyObject* seq, int index)
-      : _seq(seq), _index(index)
-    {
-    }
-
-    reference operator*() const
-    {
-      return reference(_seq, _index);
-    }
-
-    SwigPySequence_ArrowProxy<T>
-    operator->() const {
-      return SwigPySequence_ArrowProxy<T>(operator*());
-    }
-
-    bool operator==(const self& ri) const
-    {
-      return (_index == ri._index) && (_seq == ri._seq);
-    }
-
-    bool operator!=(const self& ri) const
-    {
-      return !(operator==(ri));
-    }
-
-    self& operator ++ ()
-    {
-      ++_index;
-      return *this;
-    }
-
-    self& operator -- ()
-    {
-      --_index;
-      return *this;
-    }
-
-    self& operator += (difference_type n)
-    {
-      _index += n;
-      return *this;
-    }
-
-    self operator +(difference_type n) const
-    {
-      return self(_seq, _index + n);
-    }
-
-    self& operator -= (difference_type n)
-    {
-      _index -= n;
-      return *this;
-    }
-
-    self operator -(difference_type n) const
-    {
-      return self(_seq, _index - n);
-    }
-
-    difference_type operator - (const self& ri) const
-    {
-      return _index - ri._index;
-    }
-
-    bool operator < (const self& ri) const
-    {
-      return _index < ri._index;
-    }
-
-    reference
-    operator[](difference_type n) const
-    {
-      return reference(_seq, _index + n);
-    }
-
-  private:
-    PyObject* _seq;
-    difference_type _index;
-  };
-
-  template <class T>
-  struct SwigPySequence_Cont
-  {
-    typedef SwigPySequence_Ref<T> reference;
-    typedef const SwigPySequence_Ref<T> const_reference;
-    typedef T value_type;
-    typedef T* pointer;
-    typedef int difference_type;
-    typedef int size_type;
-    typedef const pointer const_pointer;
-    typedef SwigPySequence_InputIterator<T, reference> iterator;
-    typedef SwigPySequence_InputIterator<T, const_reference> const_iterator;
-
-    SwigPySequence_Cont(PyObject* seq) : _seq(0)
-    {
-      if (!PySequence_Check(seq)) {
-	throw std::invalid_argument("a sequence is expected");
-      }
-      _seq = seq;
-      Py_INCREF(_seq);
-    }
-
-    ~SwigPySequence_Cont()
-    {
-      Py_XDECREF(_seq);
-    }
-
-    size_type size() const
-    {
-      return static_cast<size_type>(PySequence_Size(_seq));
-    }
-
-    bool empty() const
-    {
-      return size() == 0;
-    }
-
-    iterator begin()
-    {
-      return iterator(_seq, 0);
-    }
-
-    const_iterator begin() const
-    {
-      return const_iterator(_seq, 0);
-    }
-
-    iterator end()
-    {
-      return iterator(_seq, size());
-    }
-
-    const_iterator end() const
-    {
-      return const_iterator(_seq, size());
-    }
-
-    reference operator[](difference_type n)
-    {
-      return reference(_seq, n);
-    }
-
-    const_reference operator[](difference_type n)  const
-    {
-      return const_reference(_seq, n);
-    }
-
-    bool check(bool set_err = true) const
-    {
-      int s = size();
-      for (int i = 0; i < s; ++i) {
-	swig::SwigVar_PyObject item = PySequence_GetItem(_seq, i);
-	if (!swig::check<value_type>(item)) {
-	  if (set_err) {
-	    char msg[1024];
-	    sprintf(msg, "in sequence element %d", i);
-	    SWIG_Error(SWIG_RuntimeError, msg);
-	  }
-	  return false;
-	}
-      }
-      return true;
-    }
-
-  private:
-    PyObject* _seq;
-  };
-
-}
-
-
-SWIGINTERNINLINE PyObject*
-  SWIG_From_int  (int value)
-{
-  return PyInt_FromLong((long) value);
-}
-
-
-SWIGINTERN swig_type_info*
-SWIG_pchar_descriptor(void)
-{
-  static int init = 0;
-  static swig_type_info* info = 0;
-  if (!init) {
-    info = SWIG_TypeQuery("_p_char");
-    init = 1;
-  }
-  return info;
-}
-
-
-SWIGINTERNINLINE PyObject *
-SWIG_FromCharPtrAndSize(const char* carray, size_t size)
-{
-  if (carray) {
-    if (size > INT_MAX) {
-      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
-      return pchar_descriptor ? 
-	SWIG_InternalNewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
-    } else {
-#if PY_VERSION_HEX >= 0x03000000
-      return PyUnicode_FromStringAndSize(carray, static_cast< int >(size));
-#else
-      return PyString_FromStringAndSize(carray, static_cast< int >(size));
-#endif
-    }
-  } else {
-    return SWIG_Py_Void();
-  }
-}
-
-
-SWIGINTERNINLINE PyObject * 
-SWIG_FromCharPtr(const char *cptr)
-{ 
-  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
-}
-
-
-#include <limits.h>
-#if !defined(SWIG_NO_LLONG_MAX)
-# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
-#   define LLONG_MAX __LONG_LONG_MAX__
-#   define LLONG_MIN (-LLONG_MAX - 1LL)
-#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
-# endif
-#endif
-
-
-SWIGINTERN int
-SWIG_AsVal_double (PyObject *obj, double *val)
-{
-  int res = SWIG_TypeError;
-  if (PyFloat_Check(obj)) {
-    if (val) *val = PyFloat_AsDouble(obj);
-    return SWIG_OK;
-  } else if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AsLong(obj);
-    return SWIG_OK;
-  } else if (PyLong_Check(obj)) {
-    double v = PyLong_AsDouble(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_OK;
-    } else {
-      PyErr_Clear();
-    }
-  }
-#ifdef SWIG_PYTHON_CAST_MODE
-  {
-    int dispatch = 0;
-    double d = PyFloat_AsDouble(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = d;
-      return SWIG_AddCast(SWIG_OK);
-    } else {
-      PyErr_Clear();
-    }
-    if (!dispatch) {
-      long v = PyLong_AsLong(obj);
-      if (!PyErr_Occurred()) {
-	if (val) *val = v;
-	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
-      } else {
-	PyErr_Clear();
-      }
-    }
-  }
-#endif
-  return res;
-}
-
-
-#include <float.h>
-
-
-#include <math.h>
-
-
-SWIGINTERNINLINE int
-SWIG_CanCastAsInteger(double *d, double min, double max) {
-  double x = *d;
-  if ((min <= x && x <= max)) {
-   double fx = floor(x);
-   double cx = ceil(x);
-   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
-   if ((errno == EDOM) || (errno == ERANGE)) {
-     errno = 0;
-   } else {
-     double summ, reps, diff;
-     if (rd < x) {
-       diff = x - rd;
-     } else if (rd > x) {
-       diff = rd - x;
-     } else {
-       return 1;
-     }
-     summ = rd + x;
-     reps = diff/summ;
-     if (reps < 8*DBL_EPSILON) {
-       *d = rd;
-       return 1;
-     }
-   }
-  }
-  return 0;
-}
-
-
-SWIGINTERN int
-SWIG_AsVal_long (PyObject *obj, long* val)
-{
-  if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AsLong(obj);
-    return SWIG_OK;
-  } else if (PyLong_Check(obj)) {
-    long v = PyLong_AsLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_OK;
-    } else {
-      PyErr_Clear();
-    }
-  }
-#ifdef SWIG_PYTHON_CAST_MODE
-  {
-    int dispatch = 0;
-    long v = PyInt_AsLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return SWIG_AddCast(SWIG_OK);
-    } else {
-      PyErr_Clear();
-    }
-    if (!dispatch) {
-      double d;
-      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
-      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
-	if (val) *val = (long)(d);
-	return res;
-      }
-    }
-  }
-#endif
-  return SWIG_TypeError;
-}
-
-
-SWIGINTERN int
-SWIG_AsVal_int (PyObject * obj, int *val)
-{
-  long v;
-  int res = SWIG_AsVal_long (obj, &v);
-  if (SWIG_IsOK(res)) {
-    if ((v < INT_MIN || v > INT_MAX)) {
-      return SWIG_OverflowError;
-    } else {
-      if (val) *val = static_cast< int >(v);
-    }
-  }  
-  return res;
-}
-
-
-namespace swig {
-  template <> struct traits<int > {
-    typedef value_category category;
-    static const char* type_name() { return"int"; }
-  };  
-  template <>  struct traits_asval<int > {   
-    typedef int value_type;
-    static int asval(PyObject *obj, value_type *val) { 
-      return SWIG_AsVal_int (obj, val);
-    }
-  };
-  template <>  struct traits_from<int > {
-    typedef int value_type;
-    static PyObject *from(const value_type& val) {
-      return SWIG_From_int  (val);
-    }
-  };
-}
-
-
-namespace swig {
-  template <class SwigPySeq, class Seq>
-  inline void
-  assign(const SwigPySeq& swigpyseq, Seq* seq) {
-    // seq->assign(swigpyseq.begin(), swigpyseq.end()); // not used as not always implemented
-    typedef typename SwigPySeq::value_type value_type;
-    typename SwigPySeq::const_iterator it = swigpyseq.begin();
-    for (;it != swigpyseq.end(); ++it) {
-      seq->insert(seq->end(),(value_type)(*it));
-    }
-  }
-
-  template <class Seq, class T = typename Seq::value_type >
-  struct traits_asptr_stdseq {
-    typedef Seq sequence;
-    typedef T value_type;
-
-    static int asptr(PyObject *obj, sequence **seq) {
-      if (obj == Py_None || SWIG_Python_GetSwigThis(obj)) {
-	sequence *p;
-	if (::SWIG_ConvertPtr(obj,(void**)&p,
-			      swig::type_info<sequence>(),0) == SWIG_OK) {
-	  if (seq) *seq = p;
-	  return SWIG_OLDOBJ;
-	}
-      } else if (PySequence_Check(obj)) {
-	try {
-	  SwigPySequence_Cont<value_type> swigpyseq(obj);
-	  if (seq) {
-	    sequence *pseq = new sequence();
-	    assign(swigpyseq, pseq);
-	    *seq = pseq;
-	    return SWIG_NEWOBJ;
-	  } else {
-	    return swigpyseq.check() ? SWIG_OK : SWIG_ERROR;
-	  }
-	} catch (std::exception& e) {
-	  if (seq) {
-	    if (!PyErr_Occurred()) {
-	      PyErr_SetString(PyExc_TypeError, e.what());
-	    }
-	  }
-	  return SWIG_ERROR;
-	}
-      }
-      return SWIG_ERROR;
-    }
-  };
-
-  template <class Seq, class T = typename Seq::value_type >
-  struct traits_from_stdseq {
-    typedef Seq sequence;
-    typedef T value_type;
-    typedef typename Seq::size_type size_type;
-    typedef typename sequence::const_iterator const_iterator;
-
-    static PyObject *from(const sequence& seq) {
-#ifdef SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
-      swig_type_info *desc = swig::type_info<sequence>();
-      if (desc && desc->clientdata) {
-	return SWIG_NewPointerObj(new sequence(seq), desc, SWIG_POINTER_OWN);
-      }
-#endif
-      size_type size = seq.size();
-      if (size <= (size_type)INT_MAX) {
-	PyObject *obj = PyTuple_New((int)size);
-	int i = 0;
-	for (const_iterator it = seq.begin();
-	     it != seq.end(); ++it, ++i) {
-	  PyTuple_SetItem(obj,i,swig::from<value_type>(*it));
-	}
-	return obj;
-      } else {
-	PyErr_SetString(PyExc_OverflowError,"sequence size not valid in python");
-	return NULL;
-      }
-    }
-  };
-}
-
-
-  namespace swig {
-    template <class T>
-    struct traits_asptr<std::vector<T> >  {
-      static int asptr(PyObject *obj, std::vector<T> **vec) {
-	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
-      }
-    };
-    
-    template <class T>
-    struct traits_from<std::vector<T> > {
-      static PyObject *from(const std::vector<T>& vec) {
-	return traits_from_stdseq<std::vector<T> >::from(vec);
-      }
-    };
-  }
-
-
-      namespace swig {
-	template <>  struct traits<std::vector<int, std::allocator< int > > > {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return "std::vector<" "int" "," "std::allocator< int >" " >";
-	  }
-	};
-      }
-    
-
-SWIGINTERN int
-SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
-{
-#if PY_VERSION_HEX>=0x03000000
-  if (PyUnicode_Check(obj))
-#else  
-  if (PyString_Check(obj))
-#endif
-  {
-    char *cstr; Py_ssize_t len;
-#if PY_VERSION_HEX>=0x03000000
-    if (!alloc && cptr) {
-        /* We can't allow converting without allocation, since the internal
-           representation of string in Python 3 is UCS-2/UCS-4 but we require
-           a UTF-8 representation.
-           TODO(bhy) More detailed explanation */
-        return SWIG_RuntimeError;
-    }
-    obj = PyUnicode_AsUTF8String(obj);
-    PyBytes_AsStringAndSize(obj, &cstr, &len);
-    if(alloc) *alloc = SWIG_NEWOBJ;
-#else
-    PyString_AsStringAndSize(obj, &cstr, &len);
-#endif
-    if (cptr) {
-      if (alloc) {
-	/* 
-	   In python the user should not be able to modify the inner
-	   string representation. To warranty that, if you define
-	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
-	   buffer is always returned.
-
-	   The default behavior is just to return the pointer value,
-	   so, be careful.
-	*/ 
-#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
-	if (*alloc != SWIG_OLDOBJ) 
-#else
-	if (*alloc == SWIG_NEWOBJ) 
-#endif
-	  {
-	    *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
-	    *alloc = SWIG_NEWOBJ;
-	  }
-	else {
-	  *cptr = cstr;
-	  *alloc = SWIG_OLDOBJ;
-	}
-      } else {
-        #if PY_VERSION_HEX>=0x03000000
-        assert(0); /* Should never reach here in Python 3 */
-        #endif
-	*cptr = SWIG_Python_str_AsChar(obj);
-      }
-    }
-    if (psize) *psize = len + 1;
-#if PY_VERSION_HEX>=0x03000000
-    Py_XDECREF(obj);
-#endif
-    return SWIG_OK;
-  } else {
-    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
-    if (pchar_descriptor) {
-      void* vptr = 0;
-      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
-	if (cptr) *cptr = (char *) vptr;
-	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
-	if (alloc) *alloc = SWIG_OLDOBJ;
-	return SWIG_OK;
-      }
-    }
-  }
-  return SWIG_TypeError;
-}
-
-
-
-
-
-  #define SWIG_From_double   PyFloat_FromDouble 
-
-
-namespace swig {
-  template <> struct traits<double > {
-    typedef value_category category;
-    static const char* type_name() { return"double"; }
-  };  
-  template <>  struct traits_asval<double > {   
-    typedef double value_type;
-    static int asval(PyObject *obj, value_type *val) { 
-      return SWIG_AsVal_double (obj, val);
-    }
-  };
-  template <>  struct traits_from<double > {
-    typedef double value_type;
-    static PyObject *from(const value_type& val) {
-      return SWIG_From_double  (val);
-    }
-  };
-}
-
-
-      namespace swig {
-	template <>  struct traits<std::vector<double, std::allocator< double > > > {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return "std::vector<" "double" "," "std::allocator< double >" " >";
-	  }
-	};
-      }
-    
-#ifdef __cplusplus
-extern "C" {
-#endif
-SWIGINTERN PyObject *_wrap_new_VMask__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)":new_VMask")) SWIG_fail;
-  result = (vips::VMask *)new vips::VMask();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VMask, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VMask__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_VMask",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_vips__VMask,  0  | 0);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VMask" "', argument " "1"" of type '" "vips::VMask const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VMask" "', argument " "1"" of type '" "vips::VMask const &""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  result = (vips::VMask *)new vips::VMask((vips::VMask const &)*arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VMask, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VMask(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[2];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 1) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_new_VMask__SWIG_0(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_vips__VMask, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VMask__SWIG_1(self, args);
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_VMask'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VMask::VMask()\n"
-    "    vips::VMask::VMask(vips::VMask const &)\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VMask___assign__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = (vips::VMask *) 0 ;
-  vips::VMask *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VMask___assign__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VMask___assign__" "', argument " "1"" of type '" "vips::VMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VMask,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VMask___assign__" "', argument " "2"" of type '" "vips::VMask const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VMask___assign__" "', argument " "2"" of type '" "vips::VMask const &""'"); 
-  }
-  arg2 = reinterpret_cast< vips::VMask * >(argp2);
-  result = (vips::VMask *) &(arg1)->operator =((vips::VMask const &)*arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VMask, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_VMask(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = (vips::VMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_VMask",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VMask, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VMask" "', argument " "1"" of type '" "vips::VMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VMask_xsize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = (vips::VMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VMask_xsize",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VMask_xsize" "', argument " "1"" of type '" "vips::VMask const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  try {
-    result = (int)((vips::VMask const *)arg1)->xsize();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VMask_ysize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = (vips::VMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VMask_ysize",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VMask_ysize" "', argument " "1"" of type '" "vips::VMask const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  try {
-    result = (int)((vips::VMask const *)arg1)->ysize();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VMask_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = (vips::VMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VMask_size",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VMask_size" "', argument " "1"" of type '" "vips::VMask const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  try {
-    result = (int)((vips::VMask const *)arg1)->size();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VMask_filename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = (vips::VMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  char *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VMask_filename",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VMask_filename" "', argument " "1"" of type '" "vips::VMask const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  try {
-    result = (char *)((vips::VMask const *)arg1)->filename();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_FromCharPtr((const char *)result);
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VMask_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = (vips::VMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  _private_detail::VPMask::VMaskType result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VMask_type",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VMask_type" "', argument " "1"" of type '" "vips::VMask const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  result = ((vips::VMask const *)arg1)->type();
-  resultobj = SWIG_NewPointerObj((new _private_detail::VPMask::VMaskType(static_cast< const _private_detail::VPMask::VMaskType& >(result))), SWIGTYPE_p__private_detail__VPMask__VMaskType, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VMask_mask(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = (vips::VMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  _private_detail::MASKUNION result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VMask_mask",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VMask_mask" "', argument " "1"" of type '" "vips::VMask const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  result = ((vips::VMask const *)arg1)->mask();
-  resultobj = SWIG_NewPointerObj((new _private_detail::MASKUNION(static_cast< const _private_detail::MASKUNION& >(result))), SWIGTYPE_p__private_detail__MASKUNION, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VMask_ostream_print(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VMask *arg1 = (vips::VMask *) 0 ;
-  std::ostream *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VMask_ostream_print",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VMask_ostream_print" "', argument " "1"" of type '" "vips::VMask const *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VMask * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__ostream,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VMask_ostream_print" "', argument " "2"" of type '" "std::ostream &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VMask_ostream_print" "', argument " "2"" of type '" "std::ostream &""'"); 
-  }
-  arg2 = reinterpret_cast< std::ostream * >(argp2);
-  ((vips::VMask const *)arg1)->ostream_print(*arg2);
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *VMask_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_vips__VMask, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject *_wrap___lshift____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  std::ostream *arg1 = 0 ;
-  vips::VMask *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  std::ostream *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:__lshift__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__ostream,  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__lshift__" "', argument " "1"" of type '" "std::ostream &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__lshift__" "', argument " "1"" of type '" "std::ostream &""'"); 
-  }
-  arg1 = reinterpret_cast< std::ostream * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VMask,  0  | 0);
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "__lshift__" "', argument " "2"" of type '" "vips::VMask const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__lshift__" "', argument " "2"" of type '" "vips::VMask const &""'"); 
-  }
-  arg2 = reinterpret_cast< vips::VMask * >(argp2);
-  result = (std::ostream *) &vips::operator <<(*arg1,(vips::VMask const &)*arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap___lshift__(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[3];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 2) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ostream, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_vips__VMask, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap___lshift____SWIG_1(self, args);
-      }
-    }
-  }
-  
-fail:
-  Py_INCREF(Py_NotImplemented);
-  return Py_NotImplemented;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VIMask__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VIMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:new_VIMask",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VIMask" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_VIMask" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  result = (vips::VIMask *)new vips::VIMask(arg1,arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VIMask__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int arg3 ;
-  int arg4 ;
-  std::vector< int,std::allocator< int > > arg5 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  int val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VIMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_VIMask",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VIMask" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_VIMask" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_VIMask" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  ecode4 = SWIG_AsVal_int(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_VIMask" "', argument " "4"" of type '" "int""'");
-  } 
-  arg4 = static_cast< int >(val4);
-  {
-    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
-    int res = swig::asptr(obj4, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_VIMask" "', argument " "5"" of type '" "std::vector< int,std::allocator< int > >""'"); 
-    }
-    arg5 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  result = (vips::VIMask *)new vips::VIMask(arg1,arg2,arg3,arg4,arg5);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VIMask__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VIMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_VIMask",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VIMask" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  result = (vips::VIMask *)new vips::VIMask((char const *)arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_NEW |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VIMask__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)":new_VIMask")) SWIG_fail;
-  result = (vips::VIMask *)new vips::VIMask();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VIMask(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[6];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 5) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_new_VIMask__SWIG_3(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VIMask__SWIG_2(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_int(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_new_VIMask__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 5) {
-    int _v;
-    {
-      int res = SWIG_AsVal_int(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_int(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            int res = swig::asptr(argv[4], (std::vector<int,std::allocator< int > >**)(0));
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              return _wrap_new_VIMask__SWIG_1(self, args);
-            }
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_VIMask'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VIMask::VIMask(int,int)\n"
-    "    vips::VIMask::VIMask(int,int,int,int,std::vector< int,std::allocator< int > >)\n"
-    "    vips::VIMask::VIMask(char const *)\n"
-    "    vips::VIMask::VIMask()\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_scale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VIMask_scale",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_scale" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  result = (int)(arg1)->scale();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_offset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VIMask_offset",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_offset" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  result = (int)(arg1)->offset();
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_embed(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  im__INTMASK *arg2 = (im__INTMASK *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VIMask_embed",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_embed" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_im__INTMASK, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VIMask_embed" "', argument " "2"" of type '" "im__INTMASK *""'"); 
-  }
-  arg2 = reinterpret_cast< im__INTMASK * >(argp2);
-  try {
-    (arg1)->embed(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask___index__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  int *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VIMask___index__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask___index__" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VIMask___index__" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (int *) &(arg1)->operator [](arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask___call__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  int *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VIMask___call__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask___call__" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VIMask___call__" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VIMask___call__" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (int *) &(arg1)->operator ()(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  int result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VIMask_get",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_get" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VIMask_get" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (int)(arg1)->get(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_int(static_cast< int >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_gauss(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  double arg1 ;
-  double arg2 ;
-  double val1 ;
-  int ecode1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VIMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VIMask_gauss",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_double(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VIMask_gauss" "', argument " "1"" of type '" "double""'");
-  } 
-  arg1 = static_cast< double >(val1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VIMask_gauss" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = vips::VIMask::gauss(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VIMask(static_cast< const vips::VIMask& >(result))), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_gauss_sep(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  double arg1 ;
-  double arg2 ;
-  double val1 ;
-  int ecode1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VIMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VIMask_gauss_sep",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_double(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VIMask_gauss_sep" "', argument " "1"" of type '" "double""'");
-  } 
-  arg1 = static_cast< double >(val1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VIMask_gauss_sep" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = vips::VIMask::gauss_sep(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VIMask(static_cast< const vips::VIMask& >(result))), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_log(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  double arg1 ;
-  double arg2 ;
-  double val1 ;
-  int ecode1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VIMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VIMask_log",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_double(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VIMask_log" "', argument " "1"" of type '" "double""'");
-  } 
-  arg1 = static_cast< double >(val1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VIMask_log" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = vips::VIMask::log(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VIMask(static_cast< const vips::VIMask& >(result))), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_rotate45(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VIMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VIMask_rotate45",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_rotate45" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  try {
-    result = (arg1)->rotate45();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VIMask(static_cast< const vips::VIMask& >(result))), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_rotate90(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VIMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VIMask_rotate90",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_rotate90" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  try {
-    result = (arg1)->rotate90();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VIMask(static_cast< const vips::VIMask& >(result))), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_trn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VIMask_trn",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_trn" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  try {
-    result = (arg1)->trn();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_inv(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VIMask_inv",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_inv" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  try {
-    result = (arg1)->inv();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_cat(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VIMask_cat",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_cat" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VIMask_cat" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VIMask_cat" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->cat(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VIMask_mul(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VIMask_mul",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VIMask_mul" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VIMask_mul" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VIMask_mul" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->mul(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_VIMask(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VIMask *arg1 = (vips::VIMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_VIMask",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VIMask, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VIMask" "', argument " "1"" of type '" "vips::VIMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VIMask * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *VIMask_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_vips__VIMask, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-SWIGINTERN PyObject *_wrap_new_VDMask__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VDMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:new_VDMask",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VDMask" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_VDMask" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  result = (vips::VDMask *)new vips::VDMask(arg1,arg2);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VDMask__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  int arg1 ;
-  int arg2 ;
-  double arg3 ;
-  double arg4 ;
-  std::vector< double,std::allocator< double > > arg5 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  PyObject * obj3 = 0 ;
-  PyObject * obj4 = 0 ;
-  vips::VDMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_VDMask",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
-  ecode1 = SWIG_AsVal_int(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VDMask" "', argument " "1"" of type '" "int""'");
-  } 
-  arg1 = static_cast< int >(val1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_VDMask" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_double(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_VDMask" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(obj3, &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_VDMask" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  {
-    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
-    int res = swig::asptr(obj4, &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_VDMask" "', argument " "5"" of type '" "std::vector< double,std::allocator< double > >""'"); 
-    }
-    arg5 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  result = (vips::VDMask *)new vips::VDMask(arg1,arg2,arg3,arg4,arg5);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VDMask__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  char *arg1 = (char *) 0 ;
-  int res1 ;
-  char *buf1 = 0 ;
-  int alloc1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:new_VDMask",&obj0)) SWIG_fail;
-  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VDMask" "', argument " "1"" of type '" "char const *""'");
-  }
-  arg1 = reinterpret_cast< char * >(buf1);
-  result = (vips::VDMask *)new vips::VDMask((char const *)arg1);
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_NEW |  0 );
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return resultobj;
-fail:
-  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VDMask__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)":new_VDMask")) SWIG_fail;
-  result = (vips::VDMask *)new vips::VDMask();
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_NEW |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_new_VDMask(PyObject *self, PyObject *args) {
-  int argc;
-  PyObject *argv[6];
-  int ii;
-  
-  if (!PyTuple_Check(args)) SWIG_fail;
-  argc = args ? (int)PyObject_Length(args) : 0;
-  for (ii = 0; (ii < 5) && (ii < argc); ii++) {
-    argv[ii] = PyTuple_GET_ITEM(args,ii);
-  }
-  if (argc == 0) {
-    return _wrap_new_VDMask__SWIG_3(self, args);
-  }
-  if (argc == 1) {
-    int _v;
-    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VDMask__SWIG_2(self, args);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_int(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_new_VDMask__SWIG_0(self, args);
-      }
-    }
-  }
-  if (argc == 5) {
-    int _v;
-    {
-      int res = SWIG_AsVal_int(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_double(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_double(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            int res = swig::asptr(argv[4], (std::vector<double,std::allocator< double > >**)(0));
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              return _wrap_new_VDMask__SWIG_1(self, args);
-            }
-          }
-        }
-      }
-    }
-  }
-  
-fail:
-  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_VDMask'.\n"
-    "  Possible C/C++ prototypes are:\n"
-    "    vips::VDMask::VDMask(int,int)\n"
-    "    vips::VDMask::VDMask(int,int,double,double,std::vector< double,std::allocator< double > >)\n"
-    "    vips::VDMask::VDMask(char const *)\n"
-    "    vips::VDMask::VDMask()\n");
-  return 0;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_embed(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  im__DOUBLEMASK *arg2 = (im__DOUBLEMASK *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VDMask_embed",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_embed" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_im__DOUBLEMASK, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VDMask_embed" "', argument " "2"" of type '" "im__DOUBLEMASK *""'"); 
-  }
-  arg2 = reinterpret_cast< im__DOUBLEMASK * >(argp2);
-  try {
-    (arg1)->embed(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_scale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VDMask_scale",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_scale" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  try {
-    result = (double)(arg1)->scale();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_offset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VDMask_offset",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_offset" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  try {
-    result = (double)(arg1)->offset();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask___index__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  double *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VDMask___index__",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask___index__" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VDMask___index__" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (double *) &(arg1)->operator [](arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask___call__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  int val3 ;
-  int ecode3 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  PyObject * obj2 = 0 ;
-  double *result = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OOO:VDMask___call__",&obj0,&obj1,&obj2)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask___call__" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VDMask___call__" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  ecode3 = SWIG_AsVal_int(obj2, &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VDMask___call__" "', argument " "3"" of type '" "int""'");
-  } 
-  arg3 = static_cast< int >(val3);
-  try {
-    result = (double *) &(arg1)->operator ()(arg2,arg3);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  double result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VDMask_get",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_get" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  ecode2 = SWIG_AsVal_int(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VDMask_get" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  try {
-    result = (double)(arg1)->get(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_From_double(static_cast< double >(result));
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_gauss(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  double arg1 ;
-  double arg2 ;
-  double val1 ;
-  int ecode1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VDMask_gauss",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_double(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VDMask_gauss" "', argument " "1"" of type '" "double""'");
-  } 
-  arg1 = static_cast< double >(val1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VDMask_gauss" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = vips::VDMask::gauss(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_log(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  double arg1 ;
-  double arg2 ;
-  double val1 ;
-  int ecode1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VDMask_log",&obj0,&obj1)) SWIG_fail;
-  ecode1 = SWIG_AsVal_double(obj0, &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "VDMask_log" "', argument " "1"" of type '" "double""'");
-  } 
-  arg1 = static_cast< double >(val1);
-  ecode2 = SWIG_AsVal_double(obj1, &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VDMask_log" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  try {
-    result = vips::VDMask::log(arg1,arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_rotate45(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VDMask_rotate45",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_rotate45" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  try {
-    result = (arg1)->rotate45();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_rotate90(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VDMask_rotate90",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_rotate90" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  try {
-    result = (arg1)->rotate90();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_scalei(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VIMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VDMask_scalei",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_scalei" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  try {
-    result = (arg1)->scalei();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VIMask(static_cast< const vips::VIMask& >(result))), SWIGTYPE_p_vips__VIMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_trn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VDMask_trn",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_trn" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  try {
-    result = (arg1)->trn();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_inv(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:VDMask_inv",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_inv" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  try {
-    result = (arg1)->inv();
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_cat(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VDMask_cat",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_cat" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VDMask_cat" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VDMask_cat" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->cat(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_VDMask_mul(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  vips::VDMask arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  PyObject * obj0 = 0 ;
-  PyObject * obj1 = 0 ;
-  vips::VDMask result;
-  
-  if (!PyArg_ParseTuple(args,(char *)"OO:VDMask_mul",&obj0,&obj1)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VDMask_mul" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vips__VDMask,  0  | 0);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VDMask_mul" "', argument " "2"" of type '" "vips::VDMask""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VDMask_mul" "', argument " "2"" of type '" "vips::VDMask""'");
-    } else {
-      vips::VDMask * temp = reinterpret_cast< vips::VDMask * >(argp2);
-      arg2 = *temp;
-      if (SWIG_IsNewObj(res2)) delete temp;
-    }
-  }
-  try {
-    result = (arg1)->mul(arg2);
-  }
-  catch(vips::VError &_e) {
-    SWIG_Python_Raise(SWIG_NewPointerObj((new vips::VError(static_cast< const vips::VError& >(_e))),SWIGTYPE_p_vips__VError,SWIG_POINTER_OWN), "vips::VError", SWIGTYPE_p_vips__VError); SWIG_fail;
-  }
-  
-  resultobj = SWIG_NewPointerObj((new vips::VDMask(static_cast< const vips::VDMask& >(result))), SWIGTYPE_p_vips__VDMask, SWIG_POINTER_OWN |  0 );
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *_wrap_delete_VDMask(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *resultobj = 0;
-  vips::VDMask *arg1 = (vips::VDMask *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  PyObject * obj0 = 0 ;
-  
-  if (!PyArg_ParseTuple(args,(char *)"O:delete_VDMask",&obj0)) SWIG_fail;
-  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_vips__VDMask, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VDMask" "', argument " "1"" of type '" "vips::VDMask *""'"); 
-  }
-  arg1 = reinterpret_cast< vips::VDMask * >(argp1);
-  delete arg1;
-  resultobj = SWIG_Py_Void();
-  return resultobj;
-fail:
-  return NULL;
-}
-
-
-SWIGINTERN PyObject *VDMask_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
-  PyObject *obj;
-  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
-  SWIG_TypeNewClientData(SWIGTYPE_p_vips__VDMask, SWIG_NewClientData(obj));
-  return SWIG_Py_Void();
-}
-
-static PyMethodDef SwigMethods[] = {
-	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
-	 { (char *)"new_VMask", _wrap_new_VMask, METH_VARARGS, NULL},
-	 { (char *)"VMask___assign__", _wrap_VMask___assign__, METH_VARARGS, NULL},
-	 { (char *)"delete_VMask", _wrap_delete_VMask, METH_VARARGS, NULL},
-	 { (char *)"VMask_xsize", _wrap_VMask_xsize, METH_VARARGS, NULL},
-	 { (char *)"VMask_ysize", _wrap_VMask_ysize, METH_VARARGS, NULL},
-	 { (char *)"VMask_size", _wrap_VMask_size, METH_VARARGS, NULL},
-	 { (char *)"VMask_filename", _wrap_VMask_filename, METH_VARARGS, NULL},
-	 { (char *)"VMask_type", _wrap_VMask_type, METH_VARARGS, NULL},
-	 { (char *)"VMask_mask", _wrap_VMask_mask, METH_VARARGS, NULL},
-	 { (char *)"VMask_ostream_print", _wrap_VMask_ostream_print, METH_VARARGS, NULL},
-	 { (char *)"VMask_swigregister", VMask_swigregister, METH_VARARGS, NULL},
-	 { (char *)"__lshift__", _wrap___lshift__, METH_VARARGS, NULL},
-	 { (char *)"new_VIMask", _wrap_new_VIMask, METH_VARARGS, NULL},
-	 { (char *)"VIMask_scale", _wrap_VIMask_scale, METH_VARARGS, NULL},
-	 { (char *)"VIMask_offset", _wrap_VIMask_offset, METH_VARARGS, NULL},
-	 { (char *)"VIMask_embed", _wrap_VIMask_embed, METH_VARARGS, NULL},
-	 { (char *)"VIMask___index__", _wrap_VIMask___index__, METH_VARARGS, NULL},
-	 { (char *)"VIMask___call__", _wrap_VIMask___call__, METH_VARARGS, NULL},
-	 { (char *)"VIMask_get", _wrap_VIMask_get, METH_VARARGS, NULL},
-	 { (char *)"VIMask_gauss", _wrap_VIMask_gauss, METH_VARARGS, NULL},
-	 { (char *)"VIMask_gauss_sep", _wrap_VIMask_gauss_sep, METH_VARARGS, NULL},
-	 { (char *)"VIMask_log", _wrap_VIMask_log, METH_VARARGS, NULL},
-	 { (char *)"VIMask_rotate45", _wrap_VIMask_rotate45, METH_VARARGS, NULL},
-	 { (char *)"VIMask_rotate90", _wrap_VIMask_rotate90, METH_VARARGS, NULL},
-	 { (char *)"VIMask_trn", _wrap_VIMask_trn, METH_VARARGS, NULL},
-	 { (char *)"VIMask_inv", _wrap_VIMask_inv, METH_VARARGS, NULL},
-	 { (char *)"VIMask_cat", _wrap_VIMask_cat, METH_VARARGS, NULL},
-	 { (char *)"VIMask_mul", _wrap_VIMask_mul, METH_VARARGS, NULL},
-	 { (char *)"delete_VIMask", _wrap_delete_VIMask, METH_VARARGS, NULL},
-	 { (char *)"VIMask_swigregister", VIMask_swigregister, METH_VARARGS, NULL},
-	 { (char *)"new_VDMask", _wrap_new_VDMask, METH_VARARGS, NULL},
-	 { (char *)"VDMask_embed", _wrap_VDMask_embed, METH_VARARGS, NULL},
-	 { (char *)"VDMask_scale", _wrap_VDMask_scale, METH_VARARGS, NULL},
-	 { (char *)"VDMask_offset", _wrap_VDMask_offset, METH_VARARGS, NULL},
-	 { (char *)"VDMask___index__", _wrap_VDMask___index__, METH_VARARGS, NULL},
-	 { (char *)"VDMask___call__", _wrap_VDMask___call__, METH_VARARGS, NULL},
-	 { (char *)"VDMask_get", _wrap_VDMask_get, METH_VARARGS, NULL},
-	 { (char *)"VDMask_gauss", _wrap_VDMask_gauss, METH_VARARGS, NULL},
-	 { (char *)"VDMask_log", _wrap_VDMask_log, METH_VARARGS, NULL},
-	 { (char *)"VDMask_rotate45", _wrap_VDMask_rotate45, METH_VARARGS, NULL},
-	 { (char *)"VDMask_rotate90", _wrap_VDMask_rotate90, METH_VARARGS, NULL},
-	 { (char *)"VDMask_scalei", _wrap_VDMask_scalei, METH_VARARGS, NULL},
-	 { (char *)"VDMask_trn", _wrap_VDMask_trn, METH_VARARGS, NULL},
-	 { (char *)"VDMask_inv", _wrap_VDMask_inv, METH_VARARGS, NULL},
-	 { (char *)"VDMask_cat", _wrap_VDMask_cat, METH_VARARGS, NULL},
-	 { (char *)"VDMask_mul", _wrap_VDMask_mul, METH_VARARGS, NULL},
-	 { (char *)"delete_VDMask", _wrap_delete_VDMask, METH_VARARGS, NULL},
-	 { (char *)"VDMask_swigregister", VDMask_swigregister, METH_VARARGS, NULL},
-	 { NULL, NULL, 0, NULL }
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static void *_p_vips__VIMaskTo_p_vips__VMask(void *x, int *SWIGUNUSEDPARM(newmemory)) {
-    return (void *)((vips::VMask *)  ((vips::VIMask *) x));
-}
-static void *_p_vips__VDMaskTo_p_vips__VMask(void *x, int *SWIGUNUSEDPARM(newmemory)) {
-    return (void *)((vips::VMask *)  ((vips::VDMask *) x));
-}
-static swig_type_info _swigt__p__private_detail__MASKUNION = {"_p__private_detail__MASKUNION", "_private_detail::MASKUNION *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p__private_detail__VPMask__VMaskType = {"_p__private_detail__VPMask__VMaskType", "_private_detail::VPMask::VMaskType *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_im__DOUBLEMASK = {"_p_im__DOUBLEMASK", "im__DOUBLEMASK *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_im__INTMASK = {"_p_im__INTMASK", "im__INTMASK *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_matrix = {"_p_matrix", "matrix *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VDMask = {"_p_vips__VDMask", "vips::VDMask *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VError = {"_p_vips__VError", "vips::VError *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VIMask = {"_p_vips__VIMask", "vips::VIMask *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_vips__VMask = {"_p_vips__VMask", "vips::VMask *", 0, 0, (void*)0, 0};
-
-static swig_type_info *swig_type_initial[] = {
-  &_swigt__p__private_detail__MASKUNION,
-  &_swigt__p__private_detail__VPMask__VMaskType,
-  &_swigt__p_allocator_type,
-  &_swigt__p_char,
-  &_swigt__p_difference_type,
-  &_swigt__p_double,
-  &_swigt__p_im__DOUBLEMASK,
-  &_swigt__p_im__INTMASK,
-  &_swigt__p_int,
-  &_swigt__p_matrix,
-  &_swigt__p_size_type,
-  &_swigt__p_std__ostream,
-  &_swigt__p_value_type,
-  &_swigt__p_vips__VDMask,
-  &_swigt__p_vips__VError,
-  &_swigt__p_vips__VIMask,
-  &_swigt__p_vips__VMask,
-};
-
-static swig_cast_info _swigc__p__private_detail__MASKUNION[] = {  {&_swigt__p__private_detail__MASKUNION, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p__private_detail__VPMask__VMaskType[] = {  {&_swigt__p__private_detail__VPMask__VMaskType, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_im__DOUBLEMASK[] = {  {&_swigt__p_im__DOUBLEMASK, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_im__INTMASK[] = {  {&_swigt__p_im__INTMASK, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_matrix[] = {  {&_swigt__p_matrix, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VDMask[] = {  {&_swigt__p_vips__VDMask, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VError[] = {  {&_swigt__p_vips__VError, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VIMask[] = {  {&_swigt__p_vips__VIMask, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_vips__VMask[] = {  {&_swigt__p_vips__VDMask, _p_vips__VDMaskTo_p_vips__VMask, 0, 0},  {&_swigt__p_vips__VMask, 0, 0, 0},  {&_swigt__p_vips__VIMask, _p_vips__VIMaskTo_p_vips__VMask, 0, 0},{0, 0, 0, 0}};
-
-static swig_cast_info *swig_cast_initial[] = {
-  _swigc__p__private_detail__MASKUNION,
-  _swigc__p__private_detail__VPMask__VMaskType,
-  _swigc__p_allocator_type,
-  _swigc__p_char,
-  _swigc__p_difference_type,
-  _swigc__p_double,
-  _swigc__p_im__DOUBLEMASK,
-  _swigc__p_im__INTMASK,
-  _swigc__p_int,
-  _swigc__p_matrix,
-  _swigc__p_size_type,
-  _swigc__p_std__ostream,
-  _swigc__p_value_type,
-  _swigc__p_vips__VDMask,
-  _swigc__p_vips__VError,
-  _swigc__p_vips__VIMask,
-  _swigc__p_vips__VMask,
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-static swig_const_info swig_const_table[] = {
-{0, 0, 0, 0.0, 0, 0}};
-
-#ifdef __cplusplus
-}
-#endif
-/* -----------------------------------------------------------------------------
- * Type initialization:
- * This problem is tough by the requirement that no dynamic 
- * memory is used. Also, since swig_type_info structures store pointers to 
- * swig_cast_info structures and swig_cast_info structures store pointers back
- * to swig_type_info structures, we need some lookup code at initialization. 
- * The idea is that swig generates all the structures that are needed. 
- * The runtime then collects these partially filled structures. 
- * The SWIG_InitializeModule function takes these initial arrays out of 
- * swig_module, and does all the lookup, filling in the swig_module.types
- * array with the correct data and linking the correct swig_cast_info
- * structures together.
- *
- * The generated swig_type_info structures are assigned staticly to an initial 
- * array. We just loop through that array, and handle each type individually.
- * First we lookup if this type has been already loaded, and if so, use the
- * loaded structure instead of the generated one. Then we have to fill in the
- * cast linked list. The cast data is initially stored in something like a
- * two-dimensional array. Each row corresponds to a type (there are the same
- * number of rows as there are in the swig_type_initial array). Each entry in
- * a column is one of the swig_cast_info structures for that type.
- * The cast_initial array is actually an array of arrays, because each row has
- * a variable number of columns. So to actually build the cast linked list,
- * we find the array of casts associated with the type, and loop through it 
- * adding the casts to the list. The one last trick we need to do is making
- * sure the type pointer in the swig_cast_info struct is correct.
- *
- * First off, we lookup the cast->type name to see if it is already loaded. 
- * There are three cases to handle:
- *  1) If the cast->type has already been loaded AND the type we are adding
- *     casting info to has not been loaded (it is in this module), THEN we
- *     replace the cast->type pointer with the type pointer that has already
- *     been loaded.
- *  2) If BOTH types (the one we are adding casting info to, and the 
- *     cast->type) are loaded, THEN the cast info has already been loaded by
- *     the previous module so we just ignore it.
- *  3) Finally, if cast->type has not already been loaded, then we add that
- *     swig_cast_info to the linked list (because the cast->type) pointer will
- *     be correct.
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern "C" {
-#if 0
-} /* c-mode */
-#endif
-#endif
-
-#if 0
-#define SWIGRUNTIME_DEBUG
-#endif
-
-
-SWIGRUNTIME void
-SWIG_InitializeModule(void *clientdata) {
-  size_t i;
-  swig_module_info *module_head, *iter;
-  int found, init;
-  
-  /* check to see if the circular list has been setup, if not, set it up */
-  if (swig_module.next==0) {
-    /* Initialize the swig_module */
-    swig_module.type_initial = swig_type_initial;
-    swig_module.cast_initial = swig_cast_initial;
-    swig_module.next = &swig_module;
-    init = 1;
-  } else {
-    init = 0;
-  }
-  
-  /* Try and load any already created modules */
-  module_head = SWIG_GetModule(clientdata);
-  if (!module_head) {
-    /* This is the first module loaded for this interpreter */
-    /* so set the swig module into the interpreter */
-    SWIG_SetModule(clientdata, &swig_module);
-    module_head = &swig_module;
-  } else {
-    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
-    found=0;
-    iter=module_head;
-    do {
-      if (iter==&swig_module) {
-        found=1;
-        break;
-      }
-      iter=iter->next;
-    } while (iter!= module_head);
-    
-    /* if the is found in the list, then all is done and we may leave */
-    if (found) return;
-    /* otherwise we must add out module into the list */
-    swig_module.next = module_head->next;
-    module_head->next = &swig_module;
-  }
-  
-  /* When multiple interpeters are used, a module could have already been initialized in
-       a different interpreter, but not yet have a pointer in this interpreter.
-       In this case, we do not want to continue adding types... everything should be
-       set up already */
-  if (init == 0) return;
-  
-  /* Now work on filling in swig_module.types */
-#ifdef SWIGRUNTIME_DEBUG
-  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
-#endif
-  for (i = 0; i < swig_module.size; ++i) {
-    swig_type_info *type = 0;
-    swig_type_info *ret;
-    swig_cast_info *cast;
-    
-#ifdef SWIGRUNTIME_DEBUG
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-#endif
-    
-    /* if there is another module already loaded */
-    if (swig_module.next != &swig_module) {
-      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
-    }
-    if (type) {
-      /* Overwrite clientdata field */
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: found type %s\n", type->name);
-#endif
-      if (swig_module.type_initial[i]->clientdata) {
-        type->clientdata = swig_module.type_initial[i]->clientdata;
-#ifdef SWIGRUNTIME_DEBUG
-        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
-#endif
-      }
-    } else {
-      type = swig_module.type_initial[i];
-    }
-    
-    /* Insert casting types */
-    cast = swig_module.cast_initial[i];
-    while (cast->type) {
-      /* Don't need to add information already in the list */
-      ret = 0;
-#ifdef SWIGRUNTIME_DEBUG
-      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
-#endif
-      if (swig_module.next != &swig_module) {
-        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
-#ifdef SWIGRUNTIME_DEBUG
-        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
-#endif
-      }
-      if (ret) {
-        if (type == swig_module.type_initial[i]) {
-#ifdef SWIGRUNTIME_DEBUG
-          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
-#endif
-          cast->type = ret;
-          ret = 0;
-        } else {
-          /* Check for casting already in the list */
-          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
-#ifdef SWIGRUNTIME_DEBUG
-          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
-#endif
-          if (!ocast) ret = 0;
-        }
-      }
-      
-      if (!ret) {
-#ifdef SWIGRUNTIME_DEBUG
-        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
-#endif
-        if (type->cast) {
-          type->cast->prev = cast;
-          cast->next = type->cast;
-        }
-        type->cast = cast;
-      }
-      cast++;
-    }
-    /* Set entry in modules->types array equal to the type */
-    swig_module.types[i] = type;
-  }
-  swig_module.types[i] = 0;
-  
-#ifdef SWIGRUNTIME_DEBUG
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-  for (i = 0; i < swig_module.size; ++i) {
-    int j = 0;
-    swig_cast_info *cast = swig_module.cast_initial[i];
-    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
-    while (cast->type) {
-      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
-      cast++;
-      ++j;
-    }
-    printf("---- Total casts: %d\n",j);
-  }
-  printf("**** SWIG_InitializeModule: Cast List ******\n");
-#endif
-}
-
-/* This function will propagate the clientdata field of type to
-* any new swig_type_info structures that have been added into the list
-* of equivalent types.  It is like calling
-* SWIG_TypeClientData(type, clientdata) a second time.
-*/
-SWIGRUNTIME void
-SWIG_PropagateClientData(void) {
-  size_t i;
-  swig_cast_info *equiv;
-  static int init_run = 0;
-  
-  if (init_run) return;
-  init_run = 1;
-  
-  for (i = 0; i < swig_module.size; i++) {
-    if (swig_module.types[i]->clientdata) {
-      equiv = swig_module.types[i]->cast;
-      while (equiv) {
-        if (!equiv->converter) {
-          if (equiv->type && !equiv->type->clientdata)
-          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
-        }
-        equiv = equiv->next;
-      }
-    }
-  }
-}
-
-#ifdef __cplusplus
-#if 0
-{
-  /* c-mode */
-#endif
-}
-#endif
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-  
-  /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-  
-  /* -----------------------------------------------------------------------------
-   * global variable support code.
-   * ----------------------------------------------------------------------------- */
-  
-  typedef struct swig_globalvar {
-    char       *name;                  /* Name of global variable */
-    PyObject *(*get_attr)(void);       /* Return the current value */
-    int       (*set_attr)(PyObject *); /* Set the value */
-    struct swig_globalvar *next;
-  } swig_globalvar;
-  
-  typedef struct swig_varlinkobject {
-    PyObject_HEAD
-    swig_globalvar *vars;
-  } swig_varlinkobject;
-  
-  SWIGINTERN PyObject *
-  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
-#if PY_VERSION_HEX >= 0x03000000
-    return PyUnicode_InternFromString("<Swig global variables>");
-#else
-    return PyString_FromString("<Swig global variables>");
-#endif
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_str(swig_varlinkobject *v) {
-#if PY_VERSION_HEX >= 0x03000000
-    PyObject *str = PyUnicode_InternFromString("(");
-    PyObject *tail;
-    PyObject *joined;
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      tail = PyUnicode_FromString(var->name);
-      joined = PyUnicode_Concat(str, tail);
-      Py_DecRef(str);
-      Py_DecRef(tail);
-      str = joined;
-      if (var->next) {
-        tail = PyUnicode_InternFromString(", ");
-        joined = PyUnicode_Concat(str, tail);
-        Py_DecRef(str);
-        Py_DecRef(tail);
-        str = joined;
-      }
-    }
-    tail = PyUnicode_InternFromString(")");
-    joined = PyUnicode_Concat(str, tail);
-    Py_DecRef(str);
-    Py_DecRef(tail);
-    str = joined;
-#else
-    PyObject *str = PyString_FromString("(");
-    swig_globalvar *var;
-    for (var = v->vars; var; var=var->next) {
-      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
-      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
-    }
-    PyString_ConcatAndDel(&str,PyString_FromString(")"));
-#endif
-    return str;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
-    char *tmp;
-    PyObject *str = swig_varlink_str(v);
-    fprintf(fp,"Swig global variables ");
-    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
-    SWIG_Python_str_DelForPy3(tmp);
-    Py_DECREF(str);
-    return 0;
-  }
-  
-  SWIGINTERN void
-  swig_varlink_dealloc(swig_varlinkobject *v) {
-    swig_globalvar *var = v->vars;
-    while (var) {
-      swig_globalvar *n = var->next;
-      free(var->name);
-      free(var);
-      var = n;
-    }
-  }
-  
-  SWIGINTERN PyObject *
-  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-    PyObject *res = NULL;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->get_attr)();
-        break;
-      }
-      var = var->next;
-    }
-    if (res == NULL && !PyErr_Occurred()) {
-      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-    }
-    return res;
-  }
-  
-  SWIGINTERN int
-  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-    int res = 1;
-    swig_globalvar *var = v->vars;
-    while (var) {
-      if (strcmp(var->name,n) == 0) {
-        res = (*var->set_attr)(p);
-        break;
-      }
-      var = var->next;
-    }
-    if (res == 1 && !PyErr_Occurred()) {
-      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
-    }
-    return res;
-  }
-  
-  SWIGINTERN PyTypeObject*
-  swig_varlink_type(void) {
-    static char varlink__doc__[] = "Swig var link object";
-    static PyTypeObject varlink_type;
-    static int type_init = 0;
-    if (!type_init) {
-      const PyTypeObject tmp = {
-        /* PyObject header changed in Python 3 */
-#if PY_VERSION_HEX >= 0x03000000
-        PyVarObject_HEAD_INIT(NULL, 0)
-#else
-        PyObject_HEAD_INIT(NULL)
-        0,                                  /* ob_size */
-#endif
-        (char *)"swigvarlink",              /* tp_name */
-        sizeof(swig_varlinkobject),         /* tp_basicsize */
-        0,                                  /* tp_itemsize */
-        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
-        (printfunc) swig_varlink_print,     /* tp_print */
-        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
-        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
-        0,                                  /* tp_compare */
-        (reprfunc) swig_varlink_repr,       /* tp_repr */
-        0,                                  /* tp_as_number */
-        0,                                  /* tp_as_sequence */
-        0,                                  /* tp_as_mapping */
-        0,                                  /* tp_hash */
-        0,                                  /* tp_call */
-        (reprfunc) swig_varlink_str,        /* tp_str */
-        0,                                  /* tp_getattro */
-        0,                                  /* tp_setattro */
-        0,                                  /* tp_as_buffer */
-        0,                                  /* tp_flags */
-        varlink__doc__,                     /* tp_doc */
-        0,                                  /* tp_traverse */
-        0,                                  /* tp_clear */
-        0,                                  /* tp_richcompare */
-        0,                                  /* tp_weaklistoffset */
-#if PY_VERSION_HEX >= 0x02020000
-        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
-#endif
-#if PY_VERSION_HEX >= 0x02030000
-        0,                                  /* tp_del */
-#endif
-#if PY_VERSION_HEX >= 0x02060000
-        0,                                  /* tp_version */
-#endif
-#ifdef COUNT_ALLOCS
-        0,0,0,0                             /* tp_alloc -> tp_next */
-#endif
-      };
-      varlink_type = tmp;
-      type_init = 1;
-#if PY_VERSION_HEX < 0x02020000
-      varlink_type.ob_type = &PyType_Type;
-#else
-      if (PyType_Ready(&varlink_type) < 0)
-      return NULL;
-#endif
-    }
-    return &varlink_type;
-  }
-  
-  /* Create a variable linking object for use later */
-  SWIGINTERN PyObject *
-  SWIG_Python_newvarlink(void) {
-    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-    if (result) {
-      result->vars = 0;
-    }
-    return ((PyObject*) result);
-  }
-  
-  SWIGINTERN void 
-  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-    swig_varlinkobject *v = (swig_varlinkobject *) p;
-    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-    if (gv) {
-      size_t size = strlen(name)+1;
-      gv->name = (char *)malloc(size);
-      if (gv->name) {
-        strncpy(gv->name,name,size);
-        gv->get_attr = get_attr;
-        gv->set_attr = set_attr;
-        gv->next = v->vars;
-      }
-    }
-    v->vars = gv;
-  }
-  
-  SWIGINTERN PyObject *
-  SWIG_globals(void) {
-    static PyObject *_SWIG_globals = 0; 
-    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
-    return _SWIG_globals;
-  }
-  
-  /* -----------------------------------------------------------------------------
-   * constants/methods manipulation
-   * ----------------------------------------------------------------------------- */
-  
-  /* Install Constants */
-  SWIGINTERN void
-  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
-    PyObject *obj = 0;
-    size_t i;
-    for (i = 0; constants[i].type; ++i) {
-      switch(constants[i].type) {
-      case SWIG_PY_POINTER:
-        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
-        break;
-      case SWIG_PY_BINARY:
-        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
-        break;
-      default:
-        obj = 0;
-        break;
-      }
-      if (obj) {
-        PyDict_SetItemString(d, constants[i].name, obj);
-        Py_DECREF(obj);
-      }
-    }
-  }
-  
-  /* -----------------------------------------------------------------------------*/
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  /* -----------------------------------------------------------------------------*/
-  
-  SWIGINTERN void
-  SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
-    size_t i;
-    for (i = 0; methods[i].ml_name; ++i) {
-      const char *c = methods[i].ml_doc;
-      if (c && (c = strstr(c, "swig_ptr: "))) {
-        int j;
-        swig_const_info *ci = 0;
-        const char *name = c + 10;
-        for (j = 0; const_table[j].type; ++j) {
-          if (strncmp(const_table[j].name, name, 
-              strlen(const_table[j].name)) == 0) {
-            ci = &(const_table[j]);
-            break;
-          }
-        }
-        if (ci) {
-          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
-          if (ptr) {
-            size_t shift = (ci->ptype) - types;
-            swig_type_info *ty = types_initial[shift];
-            size_t ldoc = (c - methods[i].ml_doc);
-            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
-            char *ndoc = (char*)malloc(ldoc + lptr + 10);
-            if (ndoc) {
-              char *buff = ndoc;
-              strncpy(buff, methods[i].ml_doc, ldoc);
-              buff += ldoc;
-              strncpy(buff, "swig_ptr: ", 10);
-              buff += 10;
-              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
-              methods[i].ml_doc = ndoc;
-            }
-          }
-        }
-      }
-    }
-  } 
-  
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------*
- *  Partial Init method
- * -----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern "C"
-#endif
-
-SWIGEXPORT 
-#if PY_VERSION_HEX >= 0x03000000
-PyObject*
-#else
-void
-#endif
-SWIG_init(void) {
-  PyObject *m, *d, *md;
-#if PY_VERSION_HEX >= 0x03000000
-  static struct PyModuleDef SWIG_module = {
-# if PY_VERSION_HEX >= 0x03020000
-    PyModuleDef_HEAD_INIT,
-# else
-    {
-      PyObject_HEAD_INIT(NULL)
-      NULL, /* m_init */
-      0,    /* m_index */
-      NULL, /* m_copy */
-    },
-# endif
-    (char *) SWIG_name,
-    NULL,
-    -1,
-    SwigMethods,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-  };
-#endif
-  
-#if defined(SWIGPYTHON_BUILTIN)
-  static SwigPyClientData SwigPyObject_clientdata = {
-    0, 0, 0, 0, 0, 0, 0
-  };
-  static PyGetSetDef this_getset_def = {
-    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
-  };
-  static SwigPyGetSet thisown_getset_closure = {
-    (PyCFunction) SwigPyObject_own,
-    (PyCFunction) SwigPyObject_own
-  };
-  static PyGetSetDef thisown_getset_def = {
-    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
-  };
-  PyObject *metatype_args;
-  PyTypeObject *builtin_pytype;
-  int builtin_base_count;
-  swig_type_info *builtin_basetype;
-  PyObject *tuple;
-  PyGetSetDescrObject *static_getset;
-  PyTypeObject *metatype;
-  SwigPyClientData *cd;
-  PyObject *public_interface, *public_symbol;
-  PyObject *this_descr;
-  PyObject *thisown_descr;
-  int i;
-  
-  (void)builtin_pytype;
-  (void)builtin_base_count;
-  (void)builtin_basetype;
-  (void)tuple;
-  (void)static_getset;
-  
-  /* metatype is used to implement static member variables. */
-  metatype_args = Py_BuildValue("(s(O){})", "SwigPyObjectType", &PyType_Type);
-  assert(metatype_args);
-  metatype = (PyTypeObject *) PyType_Type.tp_call((PyObject *) &PyType_Type, metatype_args, NULL);
-  assert(metatype);
-  Py_DECREF(metatype_args);
-  metatype->tp_setattro = (setattrofunc) &SwigPyObjectType_setattro;
-  assert(PyType_Ready(metatype) >= 0);
-#endif
-  
-  /* Fix SwigMethods to carry the callback ptrs when needed */
-  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
-  
-#if PY_VERSION_HEX >= 0x03000000
-  m = PyModule_Create(&SWIG_module);
-#else
-  m = Py_InitModule((char *) SWIG_name, SwigMethods);
-#endif
-  md = d = PyModule_GetDict(m);
-  (void)md;
-  
-  SWIG_InitializeModule(0);
-  
-#ifdef SWIGPYTHON_BUILTIN
-  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
-  assert(SwigPyObject_stype);
-  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
-  if (!cd) {
-    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
-    SwigPyObject_clientdata.pytype = SwigPyObject_TypeOnce();
-  } else if (SwigPyObject_TypeOnce()->tp_basicsize != cd->pytype->tp_basicsize) {
-    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
-# if PY_VERSION_HEX >= 0x03000000
-    return NULL;
-# else
-    return;
-# endif
-  }
-  
-  /* All objects have a 'this' attribute */
-  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
-  (void)this_descr;
-  
-  /* All objects have a 'thisown' attribute */
-  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
-  (void)thisown_descr;
-  
-  public_interface = PyList_New(0);
-  public_symbol = 0;
-  (void)public_symbol;
-  
-  PyDict_SetItemString(md, "__all__", public_interface);
-  Py_DECREF(public_interface);
-  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
-  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
-  for (i = 0; swig_const_table[i].name != 0; ++i)
-  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
-#endif
-  
-  SWIG_InstallConstants(d,swig_const_table);
-  
-#if PY_VERSION_HEX >= 0x03000000
-  return m;
-#else
-  return;
-#endif
-}
-
diff -u --recursive --new-file vips-7.38.5-vanilla/swig/vipsCC/VMask.py vips-7.38.5/swig/vipsCC/VMask.py
--- vips-7.38.5-vanilla/swig/vipsCC/VMask.py	2014-07-17 23:48:36.208794473 -0400
+++ vips-7.38.5/swig/vipsCC/VMask.py	1969-12-31 19:00:00.000000000 -0500
@@ -1,191 +0,0 @@
-# This file was automatically generated by SWIG (http://www.swig.org).
-# Version 2.0.10
-#
-# Do not make changes to this file unless you know what you are doing--modify
-# the SWIG interface file instead.
-
-
-
-from sys import version_info
-if version_info >= (2,6,0):
-    def swig_import_helper():
-        from os.path import dirname
-        import imp
-        fp = None
-        try:
-            fp, pathname, description = imp.find_module('vmaskmodule', [dirname(__file__)])
-        except ImportError:
-            import vmaskmodule
-            return vmaskmodule
-        if fp is not None:
-            try:
-                _mod = imp.load_module('vmaskmodule', fp, pathname, description)
-            finally:
-                fp.close()
-            return _mod
-    vmaskmodule = swig_import_helper()
-    del swig_import_helper
-else:
-    import vmaskmodule
-del version_info
-try:
-    _swig_property = property
-except NameError:
-    pass # Python < 2.2 doesn't have 'property'.
-def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
-    if (name == "thisown"): return self.this.own(value)
-    if (name == "this"):
-        if type(value).__name__ == 'SwigPyObject':
-            self.__dict__[name] = value
-            return
-    method = class_type.__swig_setmethods__.get(name,None)
-    if method: return method(self,value)
-    if (not static):
-        self.__dict__[name] = value
-    else:
-        raise AttributeError("You cannot add attributes to %s" % self)
-
-def _swig_setattr(self,class_type,name,value):
-    return _swig_setattr_nondynamic(self,class_type,name,value,0)
-
-def _swig_getattr(self,class_type,name):
-    if (name == "thisown"): return self.this.own()
-    method = class_type.__swig_getmethods__.get(name,None)
-    if method: return method(self)
-    raise AttributeError(name)
-
-def _swig_repr(self):
-    try: strthis = "proxy of " + self.this.__repr__()
-    except: strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-try:
-    _object = object
-    _newclass = 1
-except AttributeError:
-    class _object : pass
-    _newclass = 0
-
-
-import VError
-import VImage
-import VDisplay
-class VMask(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, VMask, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, VMask, name)
-    __repr__ = _swig_repr
-    def __init__(self, *args): 
-        this = vmaskmodule.new_VMask(*args)
-        try: self.this.append(this)
-        except: self.this = this
-    def __assign__(self, *args): return vmaskmodule.VMask___assign__(self, *args)
-    __swig_destroy__ = vmaskmodule.delete_VMask
-    __del__ = lambda self : None;
-    def xsize(self): return vmaskmodule.VMask_xsize(self)
-    def ysize(self): return vmaskmodule.VMask_ysize(self)
-    def size(self): return vmaskmodule.VMask_size(self)
-    def filename(self): return vmaskmodule.VMask_filename(self)
-    def type(self): return vmaskmodule.VMask_type(self)
-    def mask(self): return vmaskmodule.VMask_mask(self)
-    def ostream_print(self, *args): return vmaskmodule.VMask_ostream_print(self, *args)
-VMask_swigregister = vmaskmodule.VMask_swigregister
-VMask_swigregister(VMask)
-
-
-def __lshift__(*args):
-  return vmaskmodule.__lshift__(*args)
-__lshift__ = vmaskmodule.__lshift__
-class VIMask(VMask):
-    __swig_setmethods__ = {}
-    for _s in [VMask]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
-    __setattr__ = lambda self, name, value: _swig_setattr(self, VIMask, name, value)
-    __swig_getmethods__ = {}
-    for _s in [VMask]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
-    __getattr__ = lambda self, name: _swig_getattr(self, VIMask, name)
-    __repr__ = _swig_repr
-    def __init__(self, *args): 
-        this = vmaskmodule.new_VIMask(*args)
-        try: self.this.append(this)
-        except: self.this = this
-    def scale(self): return vmaskmodule.VIMask_scale(self)
-    def offset(self): return vmaskmodule.VIMask_offset(self)
-    def embed(self, *args): return vmaskmodule.VIMask_embed(self, *args)
-    def __index__(self, *args): return vmaskmodule.VIMask___index__(self, *args)
-    def __call__(self, *args): return vmaskmodule.VIMask___call__(self, *args)
-    def get(self, *args): return vmaskmodule.VIMask_get(self, *args)
-    __swig_getmethods__["gauss"] = lambda x: vmaskmodule.VIMask_gauss
-    if _newclass:gauss = staticmethod(vmaskmodule.VIMask_gauss)
-    __swig_getmethods__["gauss_sep"] = lambda x: vmaskmodule.VIMask_gauss_sep
-    if _newclass:gauss_sep = staticmethod(vmaskmodule.VIMask_gauss_sep)
-    __swig_getmethods__["log"] = lambda x: vmaskmodule.VIMask_log
-    if _newclass:log = staticmethod(vmaskmodule.VIMask_log)
-    def rotate45(self): return vmaskmodule.VIMask_rotate45(self)
-    def rotate90(self): return vmaskmodule.VIMask_rotate90(self)
-    def trn(self): return vmaskmodule.VIMask_trn(self)
-    def inv(self): return vmaskmodule.VIMask_inv(self)
-    def cat(self, *args): return vmaskmodule.VIMask_cat(self, *args)
-    def mul(self, *args): return vmaskmodule.VIMask_mul(self, *args)
-    __swig_destroy__ = vmaskmodule.delete_VIMask
-    __del__ = lambda self : None;
-VIMask_swigregister = vmaskmodule.VIMask_swigregister
-VIMask_swigregister(VIMask)
-
-def VIMask_gauss(*args):
-  return vmaskmodule.VIMask_gauss(*args)
-VIMask_gauss = vmaskmodule.VIMask_gauss
-
-def VIMask_gauss_sep(*args):
-  return vmaskmodule.VIMask_gauss_sep(*args)
-VIMask_gauss_sep = vmaskmodule.VIMask_gauss_sep
-
-def VIMask_log(*args):
-  return vmaskmodule.VIMask_log(*args)
-VIMask_log = vmaskmodule.VIMask_log
-
-class VDMask(VMask):
-    __swig_setmethods__ = {}
-    for _s in [VMask]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
-    __setattr__ = lambda self, name, value: _swig_setattr(self, VDMask, name, value)
-    __swig_getmethods__ = {}
-    for _s in [VMask]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
-    __getattr__ = lambda self, name: _swig_getattr(self, VDMask, name)
-    __repr__ = _swig_repr
-    def __init__(self, *args): 
-        this = vmaskmodule.new_VDMask(*args)
-        try: self.this.append(this)
-        except: self.this = this
-    def embed(self, *args): return vmaskmodule.VDMask_embed(self, *args)
-    def scale(self): return vmaskmodule.VDMask_scale(self)
-    def offset(self): return vmaskmodule.VDMask_offset(self)
-    def __index__(self, *args): return vmaskmodule.VDMask___index__(self, *args)
-    def __call__(self, *args): return vmaskmodule.VDMask___call__(self, *args)
-    def get(self, *args): return vmaskmodule.VDMask_get(self, *args)
-    __swig_getmethods__["gauss"] = lambda x: vmaskmodule.VDMask_gauss
-    if _newclass:gauss = staticmethod(vmaskmodule.VDMask_gauss)
-    __swig_getmethods__["log"] = lambda x: vmaskmodule.VDMask_log
-    if _newclass:log = staticmethod(vmaskmodule.VDMask_log)
-    def rotate45(self): return vmaskmodule.VDMask_rotate45(self)
-    def rotate90(self): return vmaskmodule.VDMask_rotate90(self)
-    def scalei(self): return vmaskmodule.VDMask_scalei(self)
-    def trn(self): return vmaskmodule.VDMask_trn(self)
-    def inv(self): return vmaskmodule.VDMask_inv(self)
-    def cat(self, *args): return vmaskmodule.VDMask_cat(self, *args)
-    def mul(self, *args): return vmaskmodule.VDMask_mul(self, *args)
-    __swig_destroy__ = vmaskmodule.delete_VDMask
-    __del__ = lambda self : None;
-VDMask_swigregister = vmaskmodule.VDMask_swigregister
-VDMask_swigregister(VDMask)
-
-def VDMask_gauss(*args):
-  return vmaskmodule.VDMask_gauss(*args)
-VDMask_gauss = vmaskmodule.VDMask_gauss
-
-def VDMask_log(*args):
-  return vmaskmodule.VDMask_log(*args)
-VDMask_log = vmaskmodule.VDMask_log
-
-# This file is compatible with both classic and new-style classes.
-
-
diff -u --recursive --new-file vips-7.38.5-vanilla/vips.pc.in vips-7.38.5/vips.pc.in
--- vips-7.38.5-vanilla/vips.pc.in	2014-07-17 23:48:36.236794473 -0400
+++ vips-7.38.5/vips.pc.in	2014-07-17 23:48:52.069794148 -0400
@@ -7,5 +7,5 @@
 Description: Image processing library
 Version: @VERSION@
 Requires: @PACKAGES_USED@
-Libs: -L${libdir} -lvips @VIPS_LIBS@ @VIPS_CXX_LIBS@
+Libs: -L${libdir} -lvips @VIPS_LIBS@
 Cflags: -I${includedir} 
