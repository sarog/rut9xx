#!/bin/bash

# Arguements:
#   fw type: master, sfmode, image
#      image - generated MASTER image from WebUI file. Usage: ./fwFinalization.sh image <WebUI file>
# Return values:
#   0 : Success
#   1 : Error indicating that either the bootrom image OR the firmware file,
#       that is supposed to be generated by the openWrt BUILD proccess, were not found
#   2 : Firmware image is too large

#Defines
# the name of the bootrom file
BOOTROM_FILE="../../scripts/uboot_for_tlt_rut9xx_3.2.5.bin"
ART_FILE="../../scripts/art_tlt_rut900.bin"
CONFIG_FILE="../../scripts/config_tlt_rut900.bin"
# The exact size that the firmware is supposed to be
FIRMWARE_SIZE=16777216 # 0x1000000
# ammount of space that is to be left free
# text file containing the version of the firmware (does it require sanitization?)
VERSION_FILE="../../build_dir/target-mips_34kc_uClibc-0.9.33.2/root-ar71xx/etc/version"
# firmware file generated by openwrt
GENERATED_FW_FILE="openwrt-ar71xx-generic-tlt-rut900-squashfs-sysupgrade.bin"
# temporary md5 file
MD5_FILE="image_md5.tmp"
SEADRIVE_PATH_1="/Firmwares/0_Testavimui/RUT9XX/"
SEADRIVE_PATH_2="/Shared with groups${SEADRIVE_PATH_1}"

BOOTLOADER_NAME="$(tail --byte 10 $BOOTROM_FILE | head --byte 5)"

fw_name="${1:-master}"
upload_fw=0
upload_dir=""

while [ $# -ne 0 ]; do
	case "$1" in
		--upload_dir)
			if [ -e "${2}${SEADRIVE_PATH_1}" ]; then
				upload_fw=1
				upload_dir="${2}${SEADRIVE_PATH_1}"
			elif [ -e "${2}${SEADRIVE_PATH_2}" ]; then
				upload_fw=1
				upload_dir="${2}${SEADRIVE_PATH_2}"
			else
				echo "SEADRIVE UPLOAD PATH DOESN'T EXIST, NOT UPLOADING FIRMWARE TO SEADRIVE!"
			fi
			shift
			shift
		;;
		*)
			shift
		;;
	esac
done

if [ "$fw_name" != "image" ]; then
	#create tltFws dir if it already does not exist
	[ -d tltFws ] || mkdir tltFws

	if [ ! -f "$GENERATED_FW_FILE" ]; then
		echo "WebuiFW image $GENERATED_FW_FILE not found!"
	fi

	#copy checksum to the end of last erase block
	dd if="$GENERATED_FW_FILE" of="$MD5_FILE" bs=1 count=16 skip=76
	md5_offset=`stat -c %s "$GENERATED_FW_FILE"`
	#md5 should be just before magic 0xDEADCODE
	md5_offset=`expr "$md5_offset" - 16 - 4`
	dd if="$MD5_FILE" of="$GENERATED_FW_FILE" bs=1 count=16 seek="$md5_offset" conv=notrunc
	rm -f "$MD5_FILE"

	#add fw name
	printf '%.6s' "$fw_name" >> "$GENERATED_FW_FILE"
	if [ "$?" != 0 ];
	then
		echo "Adding fw name to WebuiFW image $GENERATED_FW_FILE failed!"
		exit 1
	fi

	#add whole file checksum
	md5sum "$GENERATED_FW_FILE" | awk '{print $1}' | xxd -r -p >> "$GENERATED_FW_FILE"
	if [ "$?" != 0 ];
	then
		echo "Adding checksum to WebuiFW image $GENERATED_FW_FILE failed!"
		exit 1
	fi
else
	GENERATED_FW_FILE="$2"
	if [ ! -f "$GENERATED_FW_FILE" ]; then
		echo "WebuiFW image $GENERATED_FW_FILE not found!"
		exit 1
	fi
	echo "Generating MASTER image from WebUI file"
fi

# if we have the required files (bootrom image + generated firmware image + art image)
if [ -f $BOOTROM_FILE -a -f "$ART_FILE" -a -f "$CONFIG_FILE" ]; then
	# remove any intermediate files left from the previous finalisation
	if [ -f master_nopad.img ]; then
		rm master_nopad.img
	fi
	if [ -f pad.img ]; then
		rm pad.img
	fi
	if [ -f master_stendui.img ]; then
		rm master_stendui.img
	fi
	# create an unpaded image by first layering the bootrom, config, art images immediately
	# followed by the firmware image created by the build proccess
	cat $BOOTROM_FILE $CONFIG_FILE $ART_FILE $GENERATED_FW_FILE > master_nopad.img
	# grab the size of unpaded master image
	masterSize=`stat -c %s master_nopad.img`
	if [ $masterSize -gt $FIRMWARE_SIZE ]; then
		overboard=$(( $masterSize - $FIRMWARE_SIZE ))
		echo "Firmware size is too large by $overboard bytes!"
		exit 2
	fi
	# calculate the ammount of padding we will need
	padSize=$(( $FIRMWARE_SIZE - $masterSize ))
	# create the padding (just the padding) that we will use to top of the finalisation
	# master image
	tr "\000" "\377" < /dev/zero | dd ibs=1 count=$padSize of=pad.img
	# create the master image
	cat master_nopad.img pad.img > master_stendui.img

	# extract the version from the specified version file
	version=$(cat ${VERSION_FILE})
	prefix=${version%%_*}
	client_id=${version##*_}
	client_id=${client_id%%.*}
	client_folder="${prefix}_R_${client_id}/"
	upload_dir="${upload_dir}${client_folder}${version}"

	if [ "$fw_name" != "image" ]; then

		# if a file with the specified version exists...
		if [ -f tltFws/${version}_WEBUI.bin ]; then
			# we will now try and create a firmware tuple with the name
			# ${version}_[0..$MAX_FWS_OF_SAME_VER]_WEBUI/MASTER_STENDUI
			# to do this we will first loop through numbers 1 to $MAX_FWS_OF_SAME_VER
			# TODO: transport 999 to defines
			for ii in {0..999}; do
				# for a fixed length and so that sorting in the file
				# explorer works fine we will pad the number out with zeros in the front
				if [ $ii -lt 10 ]; then
					int3l="00$ii"
				elif [ $ii -lt 100 ]; then
					int3l="0$ii"
				else
					int3l="$ii"
				fi

				# check wether the modified file name exists, if it does not...
				testfile="tltFws/${version}_${int3l}_WEBUI.bin"
				if [ ! -f $testfile ]; then
					# create it by simply first copying the generated fw image with the new name
					cp $GENERATED_FW_FILE ${testfile}
					# and by copying the master image created previously with a slightly different name (same numbering)
					cp master_stendui.img tltFws/${version}_${int3l}_UBOOT_${BOOTLOADER_NAME}_MASTER_STENDUI.bin
					# since we achieved our goal we'll break the 0..$MAX_FWS_OF_SAME_VER loop here
					break
				fi
			done
		else
			# .. otherwise .. we'll simply copy in the tuple with new names
			cp $GENERATED_FW_FILE tltFws/${version}_WEBUI.bin
			cp master_stendui.img tltFws/${version}_UBOOT_${BOOTLOADER_NAME}_MASTER_STENDUI.bin
		fi

		if [ $upload_fw -eq 1 ] && [ ! -e "${upload_dir}" ]; then
			echo "SEADRIVE UPLOAD PATH: '${upload_dir}'"
			mkdir -p "${upload_dir}"
			cp $GENERATED_FW_FILE "${upload_dir}/${version}_WEBUI.bin"

			if [ -n "$CI_COMMIT_REF_NAME" ]; then
				branch_name="$CI_COMMIT_REF_NAME"
			else
				branch_name=$(git rev-parse --abbrev-ref HEAD)
			fi

			case "$branch_name" in
				master*)
					cp master_stendui.img "${upload_dir}/${version}_UBOOT_${BOOTLOADER_NAME}_MASTER_STENDUI.bin"
					cp ../../changelog "${upload_dir}/changelog.txt"
				;;
				hotfix*|release*)
					cp ../../changelog "${upload_dir}/changelog.txt"
				;;
				*)
				;;
			esac

			echo "Waiting for Seafile to sync files"
			sync
			sleep 60
		fi
	else
		#get MASTER image name from WebUI file
		cp master_stendui.img ${GENERATED_FW_FILE%_WEBUI.bin*}_UBOOT_${BOOTLOADER_NAME}_MASTER_STENDUI.bin
	fi

	# return 0 for success
	exit 0
else
	if [ ! -f $BOOTROM_FILE ]; then
		echo "Bootrom image $BOOTROM_FILE not found!"
	fi
	if [ ! -f "$ART_FILE" ]; then
		echo "ART image $ART_FILE not found!"
	fi
	if [ ! -f "$CONFIG_FILE" ]; then
		echo "Config image $CONFIG_FILE not found!"
	fi
	# return 1 for an indication of error
	exit 1
fi
