Fixes out-of-bounds read and segmentation violation

Fixes: CVE-2022-29458

link: https://salsa.debian.org/debian/ncurses/-/blob/479e1dff6bd8ef26d768b9de4957ee2262b90728/ncurses/tinfo/read_entry.c
--- a/ncurses/tinfo/read_entry.c
+++ b/ncurses/tinfo/read_entry.c
@@ -1,5 +1,5 @@
 /****************************************************************************
- * Copyright 2018-2019,2020 Thomas E. Dickey                                *
+ * Copyright 2018-2021,2022 Thomas E. Dickey                                *
  * Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *
  *                                                                          *
  * Permission is hereby granted, free of charge, to any person obtaining a  *
@@ -42,12 +42,14 @@
 
 #include <tic.h>
 
-MODULE_ID("$Id: read_entry.c,v 1.157 2020/02/02 23:34:34 tom Exp $")
+MODULE_ID("$Id: read_entry.c,v 1.162 2022/04/16 21:00:00 tom Exp $")
 
 #define TYPE_CALLOC(type,elts) typeCalloc(type, (unsigned)(elts))
 
 #define MyNumber(n) (short) LOW_MSB(n)
 
+#define safe_fopen(name,mode) fopen(name,mode)
+
 #define SIZEOF_32BITS 4
 
 #if NCURSES_USE_DATABASE
@@ -145,6 +147,7 @@ convert_strings(char *buf, char **String
 {
     int i;
     char *p;
+    bool corrupt = FALSE;
 
     for (i = 0; i < count; i++) {
 	if (IS_NEG1(buf + 2 * i)) {
@@ -154,17 +157,29 @@ convert_strings(char *buf, char **String
 	} else if (MyNumber(buf + 2 * i) > size) {
 	    Strings[i] = ABSENT_STRING;
 	} else {
-	    Strings[i] = (MyNumber(buf + 2 * i) + table);
-	    TR(TRACE_DATABASE, ("Strings[%d] = %s", i, _nc_visbuf(Strings[i])));
+	    int nn = MyNumber(buf + 2 * i);
+	    if (nn >= 0 && nn < size) {
+	       Strings[i] = (nn + table);
+	       TR(TRACE_DATABASE, ("Strings[%d] = %s", i,
+	                           _nc_visbuf(Strings[i])));
+	   } else {
+	       if (!corrupt) {
+	           corrupt = TRUE;
+	           TR(TRACE_DATABASE,
+	              ("ignore out-of-range index %d to Strings[]", nn));
+	           _nc_warning("corrupt data found in convert_strings");
+	       }
+	       Strings[i] = ABSENT_STRING;
+	   }
 	}
 
 	/* make sure all strings are NUL terminated */
 	if (VALID_STRING(Strings[i])) {
-	    for (p = Strings[i]; p <= table + size; p++)
+	    for (p = Strings[i]; p < table + size; p++)
 		if (*p == '\0')
 		    break;
 	    /* if there is no NUL, ignore the string */
-	    if (p > table + size)
+	    if (p >= table + size)
 		Strings[i] = ABSENT_STRING;
 	}
     }
@@ -257,7 +272,6 @@ _nc_read_termtype(TERMTYPE2 *ptr, char *
     char buf[MAX_ENTRY_SIZE + 2];
     char *string_table;
     unsigned want, have;
-    bool need_ints;
     size_t (*convert_numbers) (char *, NCURSES_INT2 *, int);
     int size_of_numbers;
     int max_entry_size = MAX_ENTRY_SIZE;
@@ -276,7 +290,7 @@ _nc_read_termtype(TERMTYPE2 *ptr, char *
 	returnDB(TGETENT_NO);
     }
 #if NCURSES_EXT_NUMBERS
-    if ((need_ints = (LOW_MSB(buf) == MAGIC2))) {
+    if (LOW_MSB(buf) == MAGIC2) {
 	convert_numbers = convert_32bits;
 	size_of_numbers = SIZEOF_INT2;
     } else {
@@ -285,7 +299,7 @@ _nc_read_termtype(TERMTYPE2 *ptr, char *
 	size_of_numbers = SIZEOF_SHORT;
     }
 #else
-    if ((need_ints = (LOW_MSB(buf) == MAGIC2))) {
+    if (LOW_MSB(buf) == MAGIC2) {
 	convert_numbers = convert_32bits;
 	size_of_numbers = SIZEOF_32BITS;
     } else {
@@ -553,7 +567,7 @@ _nc_read_file_entry(const char *const fi
     int code;
 
     if (_nc_access(filename, R_OK) < 0
-	|| (fp = fopen(filename, BIN_R)) == 0) {
+	|| (fp = safe_fopen(filename, BIN_R)) == 0) {
 	TR(TRACE_DATABASE, ("cannot open terminfo %s (errno=%d)", filename, errno));
 	code = TGETENT_NO;
     } else {
@@ -666,11 +680,10 @@ decode_hex(const char **source)
 {
     int result = 0;
     int nibble;
-    int ch;
 
     for (nibble = 0; nibble < 2; ++nibble) {
+	int ch = UChar(**source);
 	result <<= 4;
-	ch = UChar(**source);
 	*source += 1;
 	if (ch >= '0' && ch <= '9') {
 	    ch -= '0';
@@ -776,7 +789,7 @@ _nc_read_tic_entry(char *filename,
 	 * looking for compiled (binary) terminfo data.
 	 *
 	 * cgetent uses a two-level lookup.  On the first it uses the given
-	 * name to return a record containing only the aliases for an entry. 
+	 * name to return a record containing only the aliases for an entry.
 	 * On the second (using that list of aliases as a key), it returns the
 	 * content of the terminal description.  We expect second lookup to
 	 * return data beginning with the same set of aliases.
@@ -833,7 +846,7 @@ _nc_read_tic_entry(char *filename,
 #endif /* NCURSES_USE_DATABASE */
 
 /*
- * Find and read the compiled entry for a given terminal type, if it exists. 
+ * Find and read the compiled entry for a given terminal type, if it exists.
  * We take pains here to make sure no combination of environment variables and
  * terminal type name can be used to overrun the file buffer.
  */
